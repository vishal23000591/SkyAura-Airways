(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target2, all) => {
    for (var name13 in all)
      __defProp(target2, name13, { get: all[name13], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target2) => (target2 = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target2, "default", { value: mod3, enumerable: true }) : target2,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../../node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../../node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut4;
      module.exports.default = earcut4;
      function earcut4(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x3, y3, invSize;
        if (hasHoles)
          outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i5 = dim; i5 < outerLen; i5 += dim) {
            x3 = data[i5];
            y3 = data[i5 + 1];
            if (x3 < minX)
              minX = x3;
            if (y3 < minY)
              minY = y3;
            if (x3 > maxX)
              maxX = x3;
            if (y3 > maxY)
              maxY = y3;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList2(data, start, end, dim, clockwise) {
        var i5, last;
        if (clockwise === signedArea2(data, start, end, dim) > 0) {
          for (i5 = start; i5 < end; i5 += dim)
            last = insertNode2(i5, data[i5], data[i5 + 1], last);
        } else {
          for (i5 = end - dim; i5 >= start; i5 -= dim)
            last = insertNode2(i5, data[i5], data[i5 + 1], last);
        }
        if (last && equals16(last, last.next)) {
          removeNode2(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints2(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p3 = start, again;
        do {
          again = false;
          if (!p3.steiner && (equals16(p3, p3.next) || area2(p3.prev, p3, p3.next) === 0)) {
            removeNode2(p3);
            p3 = end = p3.prev;
            if (p3 === p3.next)
              break;
            again = true;
          } else {
            p3 = p3.next;
          }
        } while (again || p3 !== end);
        return end;
      }
      function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve2(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode2(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
              earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut2(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar2(ear) {
        var a3 = ear.prev, b2 = ear, c2 = ear.next;
        if (area2(a3, b2, c2) >= 0)
          return false;
        var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p3 = c2.next;
        while (p3 !== a3) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.next;
        }
        return true;
      }
      function isEarHashed2(ear, minX, minY, invSize) {
        var a3 = ear.prev, b2 = ear, c2 = ear.next;
        if (area2(a3, b2, c2) >= 0)
          return false;
        var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
        var p3 = ear.prevZ, n3 = ear.nextZ;
        while (p3 && p3.z >= minZ && n3 && n3.z <= maxZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
          if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area2(n3.prev, n3, n3.next) >= 0)
            return false;
          n3 = n3.nextZ;
        }
        while (p3 && p3.z >= minZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
        }
        while (n3 && n3.z <= maxZ) {
          if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area2(n3.prev, n3, n3.next) >= 0)
            return false;
          n3 = n3.nextZ;
        }
        return true;
      }
      function cureLocalIntersections2(start, triangles, dim) {
        var p3 = start;
        do {
          var a3 = p3.prev, b2 = p3.next.next;
          if (!equals16(a3, b2) && intersects2(a3, p3, p3.next, b2) && locallyInside2(a3, b2) && locallyInside2(b2, a3)) {
            triangles.push(a3.i / dim | 0);
            triangles.push(p3.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode2(p3);
            removeNode2(p3.next);
            p3 = start = b2;
          }
          p3 = p3.next;
        } while (p3 !== start);
        return filterPoints2(p3);
      }
      function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
        var a3 = start;
        do {
          var b2 = a3.next.next;
          while (b2 !== a3.prev) {
            if (a3.i !== b2.i && isValidDiagonal2(a3, b2)) {
              var c2 = splitPolygon2(a3, b2);
              a3 = filterPoints2(a3, a3.next);
              c2 = filterPoints2(c2, c2.next);
              earcutLinked2(a3, triangles, dim, minX, minY, invSize, 0);
              earcutLinked2(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a3 = a3.next;
        } while (a3 !== start);
      }
      function eliminateHoles2(data, holeIndices, outerNode, dim) {
        var queue = [], i5, len8, start, end, list;
        for (i5 = 0, len8 = holeIndices.length; i5 < len8; i5++) {
          start = holeIndices[i5] * dim;
          end = i5 < len8 - 1 ? holeIndices[i5 + 1] * dim : data.length;
          list = linkedList2(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost2(list));
        }
        queue.sort(compareX2);
        for (i5 = 0; i5 < queue.length; i5++) {
          outerNode = eliminateHole2(queue[i5], outerNode);
        }
        return outerNode;
      }
      function compareX2(a3, b2) {
        return a3.x - b2.x;
      }
      function eliminateHole2(hole, outerNode) {
        var bridge = findHoleBridge2(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon2(bridge, hole);
        filterPoints2(bridgeReverse, bridgeReverse.next);
        return filterPoints2(bridge, bridge.next);
      }
      function findHoleBridge2(hole, outerNode) {
        var p3 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
            var x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
            if (x3 <= hx && x3 > qx) {
              qx = x3;
              m = p3.x < p3.next.x ? p3 : p3.next;
              if (x3 === hx)
                return m;
            }
          }
          p3 = p3.next;
        } while (p3 !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan6;
        p3 = m;
        do {
          if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
            tan6 = Math.abs(hy - p3.y) / (hx - p3.x);
            if (locallyInside2(p3, hole) && (tan6 < tanMin || tan6 === tanMin && (p3.x > m.x || p3.x === m.x && sectorContainsSector2(m, p3)))) {
              m = p3;
              tanMin = tan6;
            }
          }
          p3 = p3.next;
        } while (p3 !== stop);
        return m;
      }
      function sectorContainsSector2(m, p3) {
        return area2(m.prev, m, p3.prev) < 0 && area2(p3.next, m, m.next) < 0;
      }
      function indexCurve2(start, minX, minY, invSize) {
        var p3 = start;
        do {
          if (p3.z === 0)
            p3.z = zOrder2(p3.x, p3.y, minX, minY, invSize);
          p3.prevZ = p3.prev;
          p3.nextZ = p3.next;
          p3 = p3.next;
        } while (p3 !== start);
        p3.prevZ.nextZ = null;
        p3.prevZ = null;
        sortLinked2(p3);
      }
      function sortLinked2(list) {
        var i5, p3, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p3 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p3) {
            numMerges++;
            q2 = p3;
            pSize = 0;
            for (i5 = 0; i5 < inSize; i5++) {
              pSize++;
              q2 = q2.nextZ;
              if (!q2)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q2) {
              if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
                e3 = p3;
                p3 = p3.nextZ;
                pSize--;
              } else {
                e3 = q2;
                q2 = q2.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e3;
              else
                list = e3;
              e3.prevZ = tail;
              tail = e3;
            }
            p3 = q2;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder2(x3, y3, minX, minY, invSize) {
        x3 = (x3 - minX) * invSize | 0;
        y3 = (y3 - minY) * invSize | 0;
        x3 = (x3 | x3 << 8) & 16711935;
        x3 = (x3 | x3 << 4) & 252645135;
        x3 = (x3 | x3 << 2) & 858993459;
        x3 = (x3 | x3 << 1) & 1431655765;
        y3 = (y3 | y3 << 8) & 16711935;
        y3 = (y3 | y3 << 4) & 252645135;
        y3 = (y3 | y3 << 2) & 858993459;
        y3 = (y3 | y3 << 1) & 1431655765;
        return x3 | y3 << 1;
      }
      function getLeftmost2(start) {
        var p3 = start, leftmost = start;
        do {
          if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
            leftmost = p3;
          p3 = p3.next;
        } while (p3 !== start);
        return leftmost;
      }
      function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal2(a3, b2) {
        return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon2(a3, b2) && // dones't intersect other edges
        (locallyInside2(a3, b2) && locallyInside2(b2, a3) && middleInside2(a3, b2) && // locally visible
        (area2(a3.prev, a3, b2.prev) || area2(a3, b2.prev, b2)) || // does not create opposite-facing sectors
        equals16(a3, b2) && area2(a3.prev, a3, a3.next) > 0 && area2(b2.prev, b2, b2.next) > 0);
      }
      function area2(p3, q2, r3) {
        return (q2.y - p3.y) * (r3.x - q2.x) - (q2.x - p3.x) * (r3.y - q2.y);
      }
      function equals16(p1, p22) {
        return p1.x === p22.x && p1.y === p22.y;
      }
      function intersects2(p1, q1, p22, q2) {
        var o1 = sign2(area2(p1, q1, p22));
        var o22 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p22, q2, p1));
        var o4 = sign2(area2(p22, q2, q1));
        if (o1 !== o22 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment2(p1, p22, q1))
          return true;
        if (o22 === 0 && onSegment2(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment2(p22, p1, q2))
          return true;
        if (o4 === 0 && onSegment2(p22, q1, q2))
          return true;
        return false;
      }
      function onSegment2(p3, q2, r3) {
        return q2.x <= Math.max(p3.x, r3.x) && q2.x >= Math.min(p3.x, r3.x) && q2.y <= Math.max(p3.y, r3.y) && q2.y >= Math.min(p3.y, r3.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon2(a3, b2) {
        var p3 = a3;
        do {
          if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects2(p3, p3.next, a3, b2))
            return true;
          p3 = p3.next;
        } while (p3 !== a3);
        return false;
      }
      function locallyInside2(a3, b2) {
        return area2(a3.prev, a3, a3.next) < 0 ? area2(a3, b2, a3.next) >= 0 && area2(a3, a3.prev, b2) >= 0 : area2(a3, b2, a3.prev) < 0 || area2(a3, a3.next, b2) < 0;
      }
      function middleInside2(a3, b2) {
        var p3 = a3, inside = false, px = (a3.x + b2.x) / 2, py = (a3.y + b2.y) / 2;
        do {
          if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
            inside = !inside;
          p3 = p3.next;
        } while (p3 !== a3);
        return inside;
      }
      function splitPolygon2(a3, b2) {
        var a22 = new Node2(a3.i, a3.x, a3.y), b22 = new Node2(b2.i, b2.x, b2.y), an = a3.next, bp = b2.prev;
        a3.next = b2;
        b2.prev = a3;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode2(i5, x3, y3, last) {
        var p3 = new Node2(i5, x3, y3);
        if (!last) {
          p3.prev = p3;
          p3.next = p3;
        } else {
          p3.next = last.next;
          p3.prev = last;
          last.next.prev = p3;
          last.next = p3;
        }
        return p3;
      }
      function removeNode2(p3) {
        p3.next.prev = p3.prev;
        p3.prev.next = p3.next;
        if (p3.prevZ)
          p3.prevZ.nextZ = p3.nextZ;
        if (p3.nextZ)
          p3.nextZ.prevZ = p3.prevZ;
      }
      function Node2(i5, x3, y3) {
        this.i = i5;
        this.x = x3;
        this.y = y3;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut4.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i5 = 0, len8 = holeIndices.length; i5 < len8; i5++) {
            var start = holeIndices[i5] * dim;
            var end = i5 < len8 - 1 ? holeIndices[i5 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea2(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i5 = 0; i5 < triangles.length; i5 += 3) {
          var a3 = triangles[i5] * dim;
          var b2 = triangles[i5 + 1] * dim;
          var c2 = triangles[i5 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a3] - data[c2]) * (data[b2 + 1] - data[a3 + 1]) - (data[a3] - data[b2]) * (data[c2 + 1] - data[a3 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea2(data, start, end, dim) {
        var sum2 = 0;
        for (var i5 = start, j2 = end - dim; i5 < end; i5 += dim) {
          sum2 += (data[j2] - data[i5]) * (data[i5 + 1] + data[j2 + 1]);
          j2 = i5;
        }
        return sum2;
      }
      earcut4.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i5 = 0; i5 < data.length; i5++) {
          for (var j2 = 0; j2 < data[i5].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i5][j2][d2]);
          }
          if (i5 > 0) {
            holeIndex += data[i5 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../../node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../../node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches3 = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len8 = match.length;
          for (let index = 0; index < len8; index++) {
            allmatches.push(match[index]);
          }
          matches3.push(allmatches);
          match = regex.exec(string);
        }
        return matches3;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v2) {
        return typeof v2 !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target2, a3, arrayMode) {
        if (a3) {
          const keys = Object.keys(a3);
          const len8 = keys.length;
          for (let i5 = 0; i5 < len8; i5++) {
            if (arrayMode === "strict") {
              target2[keys[i5]] = [a3[keys[i5]]];
            } else {
              target2[keys[i5]] = a3[keys[i5]];
            }
          }
        }
      };
      exports.getValue = function(v2) {
        if (exports.isExist(v2)) {
          return v2;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../../node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions3 = {
        allowBooleanAttributes: false,
        //A tag can have attributes without any value
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions3, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i5 = 0; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === "<" && xmlData[i5 + 1] === "?") {
            i5 += 2;
            i5 = readPI(xmlData, i5);
            if (i5.err)
              return i5;
          } else if (xmlData[i5] === "<") {
            let tagStartPos = i5;
            i5++;
            if (xmlData[i5] === "!") {
              i5 = readCommentAndCDATA(xmlData, i5);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i5] === "/") {
                closingTag = true;
                i5++;
              }
              let tagName = "";
              for (; i5 < xmlData.length && xmlData[i5] !== ">" && xmlData[i5] !== " " && xmlData[i5] !== "	" && xmlData[i5] !== "\n" && xmlData[i5] !== "\r"; i5++) {
                tagName += xmlData[i5];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i5--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i5));
              }
              const result = readAttributeStr(xmlData, i5);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i5));
              }
              let attrStr = result.value;
              i5 = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i5 - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i5));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else if (tags.length === 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject(
                      "InvalidTag",
                      "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                      getLineNumberForPosition(xmlData, tagStartPos)
                    );
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i5 - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i5));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i5++; i5 < xmlData.length; i5++) {
                if (xmlData[i5] === "<") {
                  if (xmlData[i5 + 1] === "!") {
                    i5++;
                    i5 = readCommentAndCDATA(xmlData, i5);
                    continue;
                  } else if (xmlData[i5 + 1] === "?") {
                    i5 = readPI(xmlData, ++i5);
                    if (i5.err)
                      return i5;
                  } else {
                    break;
                  }
                } else if (xmlData[i5] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i5);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i5));
                  i5 = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i5])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i5));
                  }
                }
              }
              if (xmlData[i5] === "<") {
                i5--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i5])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i5] + "' is not expected.", getLineNumberForPosition(xmlData, i5));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i5) {
        const start = i5;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] == "?" || xmlData[i5] == " ") {
            const tagname = xmlData.substr(start, i5 - start);
            if (i5 > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i5));
            } else if (xmlData[i5] == "?" && xmlData[i5 + 1] == ">") {
              i5++;
              break;
            } else {
              continue;
            }
          }
        }
        return i5;
      }
      function readCommentAndCDATA(xmlData, i5) {
        if (xmlData.length > i5 + 5 && xmlData[i5 + 1] === "-" && xmlData[i5 + 2] === "-") {
          for (i5 += 3; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "-" && xmlData[i5 + 1] === "-" && xmlData[i5 + 2] === ">") {
              i5 += 2;
              break;
            }
          }
        } else if (xmlData.length > i5 + 8 && xmlData[i5 + 1] === "D" && xmlData[i5 + 2] === "O" && xmlData[i5 + 3] === "C" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "Y" && xmlData[i5 + 6] === "P" && xmlData[i5 + 7] === "E") {
          let angleBracketsCount = 1;
          for (i5 += 8; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i5] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i5 + 9 && xmlData[i5 + 1] === "[" && xmlData[i5 + 2] === "C" && xmlData[i5 + 3] === "D" && xmlData[i5 + 4] === "A" && xmlData[i5 + 5] === "T" && xmlData[i5 + 6] === "A" && xmlData[i5 + 7] === "[") {
          for (i5 += 8; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "]" && xmlData[i5 + 1] === "]" && xmlData[i5 + 2] === ">") {
              i5 += 2;
              break;
            }
          }
        }
        return i5;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i5) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === doubleQuote || xmlData[i5] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i5];
            } else if (startChar !== xmlData[i5]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i5] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i5];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i5,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches3 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i5 = 0; i5 < matches3.length; i5++) {
          if (matches3[i5][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i5][2] + "' has no space in starting.", getPositionFromMatch(matches3[i5]));
          } else if (matches3[i5][3] !== void 0 && matches3[i5][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i5][2] + "' is without value.", getPositionFromMatch(matches3[i5]));
          } else if (matches3[i5][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches3[i5][2] + "' is not allowed.", getPositionFromMatch(matches3[i5]));
          }
          const attrName = matches3[i5][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches3[i5]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches3[i5]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i5) {
        let re = /\d/;
        if (xmlData[i5] === "x") {
          i5++;
          re = /[\da-fA-F]/;
        }
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === ";")
            return i5;
          if (!xmlData[i5].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i5) {
        i5++;
        if (xmlData[i5] === ";")
          return -1;
        if (xmlData[i5] === "#") {
          i5++;
          return validateNumberAmpersand(xmlData, i5);
        }
        let count3 = 0;
        for (; i5 < xmlData.length; i5++, count3++) {
          if (xmlData[i5].match(/\w/) && count3 < 20)
            continue;
          if (xmlData[i5] === ";")
            break;
          return -1;
        }
        return i5;
      }
      function getErrorObject(code, message2, lineNumber) {
        return {
          err: {
            code,
            msg: message2,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          // column number is last line's length + 1, because column numbering starts at 1:
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions3 = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        // remove NS from tag name or attribute name if true
        allowBooleanAttributes: false,
        //a tag can have attributes without any value
        //ignoreRootElement : false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        //Trim string values of tag and attributes
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        //nested tags will not be parsed even for errors
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
        // skipEmptyListItem: false
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions3, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions3;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node) {
          if (node.tagname === "__proto__")
            node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
        }
      };
      module.exports = XmlNode;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
      var util = require_util();
      function readDocType(xmlData, i5) {
        const entities = {};
        if (xmlData[i5 + 3] === "O" && xmlData[i5 + 4] === "C" && xmlData[i5 + 5] === "T" && xmlData[i5 + 6] === "Y" && xmlData[i5 + 7] === "P" && xmlData[i5 + 8] === "E") {
          i5 = i5 + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i5)) {
                i5 += 7;
                [entityName, val, i5] = readEntityExp(xmlData, i5 + 1);
                if (val.indexOf("&") === -1)
                  entities[validateEntityName(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i5))
                i5 += 8;
              else if (hasBody && isAttlist(xmlData, i5))
                i5 += 8;
              else if (hasBody && isNotation(xmlData, i5))
                i5 += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i5] === ">") {
              if (comment) {
                if (xmlData[i5 - 1] === "-" && xmlData[i5 - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i5] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i5];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i: i5 };
      }
      function readEntityExp(xmlData, i5) {
        let entityName2 = "";
        for (; i5 < xmlData.length && (xmlData[i5] !== "'" && xmlData[i5] !== '"'); i5++) {
          entityName2 += xmlData[i5];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i5++];
        let val2 = "";
        for (; i5 < xmlData.length && xmlData[i5] !== startChar; i5++) {
          val2 += xmlData[i5];
        }
        return [entityName2, val2, i5];
      }
      function isComment(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "-" && xmlData[i5 + 3] === "-")
          return true;
        return false;
      }
      function isEntity(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "E" && xmlData[i5 + 3] === "N" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "I" && xmlData[i5 + 6] === "T" && xmlData[i5 + 7] === "Y")
          return true;
        return false;
      }
      function isElement(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "E" && xmlData[i5 + 3] === "L" && xmlData[i5 + 4] === "E" && xmlData[i5 + 5] === "M" && xmlData[i5 + 6] === "E" && xmlData[i5 + 7] === "N" && xmlData[i5 + 8] === "T")
          return true;
        return false;
      }
      function isAttlist(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "A" && xmlData[i5 + 3] === "T" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "L" && xmlData[i5 + 6] === "I" && xmlData[i5 + 7] === "S" && xmlData[i5 + 8] === "T")
          return true;
        return false;
      }
      function isNotation(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "N" && xmlData[i5 + 3] === "O" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "A" && xmlData[i5 + 6] === "T" && xmlData[i5 + 7] === "I" && xmlData[i5 + 8] === "O" && xmlData[i5 + 9] === "N")
          return true;
        return false;
      }
      function validateEntityName(name13) {
        if (util.isName(name13))
          return name13;
        else
          throw new Error(`Invalid entity name ${name13}`);
      }
      module.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
        //skipLike: /regex/
      };
      function toNumber2(str7, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str7 || typeof str7 !== "string")
          return str7;
        let trimmedStr = str7.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str7;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign2 = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
              return str7;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
              return str7;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str7;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str7;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign2 && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str7;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign2 + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str7;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign2 + numStr)
                return num;
              return str7;
            }
          } else {
            return str7;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module.exports = toNumber2;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber2 = require_strnum();
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            // "lt" : { regex: /&(lt|#60);/g, val: "<" },
            // "gt" : { regex: /&(gt|#62);/g, val: ">" },
            // "amp" : { regex: /&(amp|#38);/g, val: "&" },
            // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
            // "apos" : { regex: /&(apos|#39);/g, val: "'" },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
            "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_2, str7) => String.fromCharCode(Number.parseInt(str7, 10)) },
            "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_2, str7) => String.fromCharCode(Number.parseInt(str7, 16)) }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i5 = 0; i5 < entKeys.length; i5++) {
          const ent = entKeys[i5];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches3 = util.getAllMatches(attrStr, attrsRegx);
          const len8 = matches3.length;
          const attrs = {};
          for (let i5 = 0; i5 < len8; i5++) {
            const attrName = this.resolveNameSpace(matches3[i5][1]);
            let oldVal = matches3[i5][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(
                    oldVal,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions
                  );
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i5 = 0; i5 < xmlData.length; i5++) {
          const ch = xmlData[i5];
          if (ch === "<") {
            if (xmlData[i5 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i5, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i5 + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i5 = closeIndex;
            } else if (xmlData[i5 + 1] === "?") {
              let tagData = readTagExp(xmlData, i5, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i5 = tagData.closeIndex + 1;
            } else if (xmlData.substr(i5 + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i5 + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i5 + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i5 = endIndex;
            } else if (xmlData.substr(i5 + 1, 2) === "!D") {
              const result = readDocType(xmlData, i5);
              this.docTypeEntities = result.entities;
              i5 = result.i;
            } else if (xmlData.substr(i5 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i5, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i5 + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
              if (val2 == void 0)
                val2 = "";
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                currentNode.add(this.options.textNodeName, val2);
              }
              i5 = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i5, this.options.removeNSPrefix);
              let tagName = result.tagName;
              const rawTagName = result.rawTagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  i5 = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i5 = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${rawTagName}`);
                  i5 = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i5 = closeIndex;
              }
            }
          } else {
            textData += xmlData[i5];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(
            textData,
            currentNode.tagname,
            jPath,
            false,
            currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
            isLeafNode
          );
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i5, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i5; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str7, i5, errMsg) {
        const closingIndex = xmlData.indexOf(str7, i5);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str7.length - 1;
        }
      }
      function readTagExp(xmlData, i5, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i5 + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substring(0, separatorIndex);
          tagExp = tagExp.substring(separatorIndex + 1).trimStart();
        }
        const rawTagName = tagName;
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent,
          rawTagName
        };
      }
      function readStopNodeData(xmlData, tagName, i5) {
        const startIndex = i5;
        let openTagCount = 1;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === "<") {
            if (xmlData[i5 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i5, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i5 + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i5),
                    i: closeIndex
                  };
                }
              }
              i5 = closeIndex;
            } else if (xmlData[i5 + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i5 + 1, "StopNode is not closed.");
              i5 = closeIndex;
            } else if (xmlData.substr(i5 + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i5 + 3, "StopNode is not closed.");
              i5 = closeIndex;
            } else if (xmlData.substr(i5 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i5, "StopNode is not closed.") - 2;
              i5 = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i5, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i5 = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber2(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module.exports = OrderedObjParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node, options) {
        return compress(node, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i5 = 0; i5 < arr.length; i5++) {
          const tagObj = arr[i5];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i5 = 0; i5 < keys.length; i5++) {
          const key = keys[i5];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len8 = keys.length;
          for (let i5 = 0; i5 < len8; i5++) {
            const atrrName = keys[i5];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        /**
         * Parse XML dats to JS object 
         * @param {string|Buffer} xmlData 
         * @param {boolean|Object} validationOption 
         */
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        /**
         * Add Entity which is not by default supported by this library
         * @param {string} key 
         * @param {string} value 
         */
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module.exports = XMLParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i5 = 0; i5 < arr.length; i5++) {
          const tagObj = arr[i5];
          const tagName = propName(tagObj);
          if (tagName === void 0)
            continue;
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i5 = 0; i5 < keys.length; i5++) {
          const key = keys[i5];
          if (!obj.hasOwnProperty(key))
            continue;
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            if (!attrMap.hasOwnProperty(attr))
              continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i5 = 0; i5 < options.entities.length; i5++) {
            const entity = options.entities[i5];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module.exports = toXml;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions3 = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a3) {
          return a3;
        },
        attributeValueProcessor: function(attrName, a3) {
          return a3;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          //it must be on top
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        // transformTagName: false,
        // transformAttributeName: false,
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions3, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (!Object.prototype.hasOwnProperty.call(jObj, key))
            continue;
          if (typeof jObj[key] === "undefined") {
            if (this.isAttribute(key)) {
              val2 += "";
            }
          } else if (jObj[key] === null) {
            if (this.isAttribute(key)) {
              val2 += "";
            } else if (key[0] === "?") {
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            } else {
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            }
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            let listTagAttr = "";
            for (let j2 = 0; j2 < arrLen; j2++) {
              const item = jObj[key][j2];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  const result = this.j2x(item, level + 1);
                  listTagVal += result.val;
                  if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                    listTagAttr += result.attrStr;
                  }
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                if (this.options.oneListGroup) {
                  let textValue = this.options.tagValueProcessor(key, item);
                  textValue = this.replaceEntitiesValue(textValue);
                  listTagVal += textValue;
                } else {
                  listTagVal += this.buildTextValNode(item, key, "", level);
                }
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L2 = Ks.length;
              for (let j2 = 0; j2 < L2; j2++) {
                attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i5 = 0; i5 < this.options.entities.length; i5++) {
            const entity = this.options.entities[i5];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name13) {
        if (name13.startsWith(this.options.attributeNamePrefix) && name13 !== this.options.textNodeName) {
          return name13.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module.exports = Builder;
    }
  });

  // ../../node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // ../../node_modules/long/dist/long.js
  var require_long = __commonJS({
    "../../node_modules/long/dist/long.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define["amd"])
          define([], factory);
        else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
          module["exports"] = factory();
        else
          (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
      })(exports, function() {
        "use strict";
        function Long4(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long4.prototype.__isLong__;
        Object.defineProperty(Long4.prototype, "__isLong__", {
          value: true,
          enumerable: false,
          configurable: false
        });
        function isLong2(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        Long4.isLong = isLong2;
        var INT_CACHE2 = {};
        var UINT_CACHE2 = {};
        function fromInt2(value, unsigned) {
          var obj, cachedObj, cache3;
          if (unsigned) {
            value >>>= 0;
            if (cache3 = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache3)
              UINT_CACHE2[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache3 = -128 <= value && value < 128) {
              cachedObj = INT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, value < 0 ? -1 : 0, false);
            if (cache3)
              INT_CACHE2[value] = obj;
            return obj;
          }
        }
        Long4.fromInt = fromInt2;
        function fromNumber2(value, unsigned) {
          if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO2 : ZERO17;
          if (unsigned) {
            if (value < 0)
              return UZERO2;
            if (value >= TWO_PWR_64_DBL2)
              return MAX_UNSIGNED_VALUE2;
          } else {
            if (value <= -TWO_PWR_63_DBL2)
              return MIN_VALUE2;
            if (value + 1 >= TWO_PWR_63_DBL2)
              return MAX_VALUE2;
          }
          if (value < 0)
            return fromNumber2(-value, unsigned).neg();
          return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
        }
        Long4.fromNumber = fromNumber2;
        function fromBits2(lowBits, highBits, unsigned) {
          return new Long4(lowBits, highBits, unsigned);
        }
        Long4.fromBits = fromBits2;
        var pow_dbl2 = Math.pow;
        function fromString2(str7, unsigned, radix) {
          if (str7.length === 0)
            throw Error("empty string");
          if (str7 === "NaN" || str7 === "Infinity" || str7 === "+Infinity" || str7 === "-Infinity")
            return ZERO17;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p3;
          if ((p3 = str7.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p3 === 0) {
            return fromString2(str7.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 8));
          var result = ZERO17;
          for (var i5 = 0; i5 < str7.length; i5 += 8) {
            var size = Math.min(8, str7.length - i5), value = parseInt(str7.substring(i5, i5 + size), radix);
            if (size < 8) {
              var power = fromNumber2(pow_dbl2(radix, size));
              result = result.mul(power).add(fromNumber2(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber2(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long4.fromString = fromString2;
        function fromValue2(val2) {
          if (val2 instanceof Long4)
            return val2;
          if (typeof val2 === "number")
            return fromNumber2(val2);
          if (typeof val2 === "string")
            return fromString2(val2);
          return fromBits2(val2.low, val2.high, val2.unsigned);
        }
        Long4.fromValue = fromValue2;
        var TWO_PWR_16_DBL2 = 1 << 16;
        var TWO_PWR_24_DBL2 = 1 << 24;
        var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
        var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
        var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
        var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
        var ZERO17 = fromInt2(0);
        Long4.ZERO = ZERO17;
        var UZERO2 = fromInt2(0, true);
        Long4.UZERO = UZERO2;
        var ONE2 = fromInt2(1);
        Long4.ONE = ONE2;
        var UONE2 = fromInt2(1, true);
        Long4.UONE = UONE2;
        var NEG_ONE2 = fromInt2(-1);
        Long4.NEG_ONE = NEG_ONE2;
        var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
        Long4.MAX_VALUE = MAX_VALUE2;
        var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
        Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
        var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
        Long4.MIN_VALUE = MIN_VALUE2;
        var LongPrototype2 = Long4.prototype;
        LongPrototype2.toInt = function toInt2() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype2.toNumber = function toNumber2() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
        };
        LongPrototype2.toString = function toString2(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE2)) {
              var radixLong = fromNumber2(radix), div5 = this.div(radixLong), rem1 = div5.mul(radixLong).sub(this);
              return div5.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
              return digits + result;
            else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype2.getHighBits = function getHighBits2() {
          return this.high;
        };
        LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
          return this.high >>> 0;
        };
        LongPrototype2.getLowBits = function getLowBits2() {
          return this.low;
        };
        LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
          return this.low >>> 0;
        };
        LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
          if (this.isNegative())
            return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
          var val2 = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--)
            if ((val2 & 1 << bit) != 0)
              break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype2.isZero = function isZero2() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype2.isNegative = function isNegative2() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype2.isPositive = function isPositive2() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype2.isOdd = function isOdd2() {
          return (this.low & 1) === 1;
        };
        LongPrototype2.isEven = function isEven2() {
          return (this.low & 1) === 0;
        };
        LongPrototype2.equals = function equals16(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype2.eq = LongPrototype2.equals;
        LongPrototype2.notEquals = function notEquals2(other) {
          return !this.eq(
            /* validates */
            other
          );
        };
        LongPrototype2.neq = LongPrototype2.notEquals;
        LongPrototype2.lessThan = function lessThan2(other) {
          return this.comp(
            /* validates */
            other
          ) < 0;
        };
        LongPrototype2.lt = LongPrototype2.lessThan;
        LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
          return this.comp(
            /* validates */
            other
          ) <= 0;
        };
        LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
        LongPrototype2.greaterThan = function greaterThan2(other) {
          return this.comp(
            /* validates */
            other
          ) > 0;
        };
        LongPrototype2.gt = LongPrototype2.greaterThan;
        LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
          return this.comp(
            /* validates */
            other
          ) >= 0;
        };
        LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
        LongPrototype2.compare = function compare2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype2.comp = LongPrototype2.compare;
        LongPrototype2.negate = function negate6() {
          if (!this.unsigned && this.eq(MIN_VALUE2))
            return MIN_VALUE2;
          return this.not().add(ONE2);
        };
        LongPrototype2.neg = LongPrototype2.negate;
        LongPrototype2.add = function add16(addend) {
          if (!isLong2(addend))
            addend = fromValue2(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.subtract = function subtract8(subtrahend) {
          if (!isLong2(subtrahend))
            subtrahend = fromValue2(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype2.sub = LongPrototype2.subtract;
        LongPrototype2.multiply = function multiply20(multiplier) {
          if (this.isZero())
            return ZERO17;
          if (!isLong2(multiplier))
            multiplier = fromValue2(multiplier);
          if (multiplier.isZero())
            return ZERO17;
          if (this.eq(MIN_VALUE2))
            return multiplier.isOdd() ? MIN_VALUE2 : ZERO17;
          if (multiplier.eq(MIN_VALUE2))
            return this.isOdd() ? MIN_VALUE2 : ZERO17;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
            return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.mul = LongPrototype2.multiply;
        LongPrototype2.divide = function divide6(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (this.isZero())
            return this.unsigned ? UZERO2 : ZERO17;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE2)) {
              if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
                return MIN_VALUE2;
              else if (divisor.eq(MIN_VALUE2))
                return ONE2;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO17)) {
                  return divisor.isNegative() ? ONE2 : NEG_ONE2;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE2))
              return this.unsigned ? UZERO2 : ZERO17;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = ZERO17;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return UZERO2;
            if (divisor.gt(this.shru(1)))
              return UONE2;
            res = UZERO2;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl2(2, log23 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber2(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = ONE2;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype2.div = LongPrototype2.divide;
        LongPrototype2.modulo = function modulo2(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype2.mod = LongPrototype2.modulo;
        LongPrototype2.not = function not2() {
          return fromBits2(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype2.and = function and2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
        };
        LongPrototype2.or = function or2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
        };
        LongPrototype2.xor = function xor2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return fromBits2(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype2.shl = LongPrototype2.shiftLeft;
        LongPrototype2.shiftRight = function shiftRight2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        LongPrototype2.shr = LongPrototype2.shiftRight;
        LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return fromBits2(high, 0, this.unsigned);
            else
              return fromBits2(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
        LongPrototype2.toSigned = function toSigned2() {
          if (!this.unsigned)
            return this;
          return fromBits2(this.low, this.high, false);
        };
        LongPrototype2.toUnsigned = function toUnsigned2() {
          if (this.unsigned)
            return this;
          return fromBits2(this.low, this.high, true);
        };
        LongPrototype2.toBytes = function(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype2.toBytesLE = function() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24 & 255,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24 & 255
          ];
        };
        LongPrototype2.toBytesBE = function() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24 & 255,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24 & 255,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        return Long4;
      });
    }
  });

  // external-global-plugin:h3-js
  var require_h3_js = __commonJS({
    "external-global-plugin:h3-js"(exports, module) {
      module.exports = globalThis.h3 || {};
    }
  });

  // ../../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e3, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i5 = isLE ? nBytes - 1 : 0;
        var d2 = isLE ? -1 : 1;
        var s3 = buffer[offset + i5];
        i5 += d2;
        e3 = s3 & (1 << -nBits) - 1;
        s3 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i5], i5 += d2, nBits -= 8) {
        }
        m = e3 & (1 << -nBits) - 1;
        e3 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i5], i5 += d2, nBits -= 8) {
        }
        if (e3 === 0) {
          e3 = 1 - eBias;
        } else if (e3 === eMax) {
          return m ? NaN : (s3 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e3 = e3 - eBias;
        }
        return (s3 ? -1 : 1) * m * Math.pow(2, e3 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e3, m, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i5 = isLE ? 0 : nBytes - 1;
        var d2 = isLE ? 1 : -1;
        var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e3 = eMax;
        } else {
          e3 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e3)) < 1) {
            e3--;
            c2 *= 2;
          }
          if (e3 + eBias >= 1) {
            value += rt / c2;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e3++;
            c2 /= 2;
          }
          if (e3 + eBias >= eMax) {
            m = 0;
            e3 = eMax;
          } else if (e3 + eBias >= 1) {
            m = (value * c2 - 1) * Math.pow(2, mLen);
            e3 = e3 + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e3 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i5] = m & 255, i5 += d2, m /= 256, mLen -= 8) {
        }
        e3 = e3 << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i5] = e3 & 255, i5 += d2, e3 /= 256, eLen -= 8) {
        }
        buffer[offset + i5 - d2] |= s3 * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        // === READING =================================================================
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
            this.type = val2 & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val2);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val2 = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        readSFixed32: function() {
          var val2 = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
        readFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readSFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readFloat: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val2;
        },
        readDouble: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val2;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val2, b2;
          b2 = buf[this.pos++];
          val2 = b2 & 127;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 7;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 14;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 21;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos];
          val2 |= (b2 & 15) << 28;
          return readVarintRemainder(val2, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        // verbose for performance reasons; doesn't affect gzipped size
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val2) {
          var type = val2 & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        // === WRITING =================================================================
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min6) {
          var length16 = this.length || 16;
          while (length16 < this.pos + min6)
            length16 *= 2;
          if (length16 !== this.length) {
            var buf = new Uint8Array(length16);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length16;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val2) {
          val2 = +val2 || 0;
          if (val2 > 268435455 || val2 < 0) {
            writeBigVarint(val2, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = val2 >>> 7 & 127;
        },
        writeSVarint: function(val2) {
          this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
        },
        writeBoolean: function(val2) {
          this.writeVarint(Boolean(val2));
        },
        writeString: function(str7) {
          str7 = String(str7);
          this.realloc(str7.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str7, this.pos);
          var len8 = this.pos - startPos;
          if (len8 >= 128)
            makeRoomForExtraLength(startPos, len8, this);
          this.pos = startPos - 1;
          this.writeVarint(len8);
          this.pos += len8;
        },
        writeFloat: function(val2) {
          this.realloc(4);
          ieee754.write(this.buf, val2, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val2) {
          this.realloc(8);
          ieee754.write(this.buf, val2, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len8 = buffer.length;
          this.writeVarint(len8);
          this.realloc(len8);
          for (var i5 = 0; i5 < len8; i5++)
            this.buf[this.pos++] = buffer[i5];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len8 = this.pos - startPos;
          if (len8 >= 128)
            makeRoomForExtraLength(startPos, len8, this);
          this.pos = startPos - 1;
          this.writeVarint(len8);
          this.pos += len8;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val2);
        },
        writeSFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val2);
        },
        writeFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val2);
        },
        writeSFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val2);
        },
        writeVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val2);
        },
        writeSVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val2);
        },
        writeStringField: function(tag, str7) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str7);
        },
        writeFloatField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val2);
        },
        writeDoubleField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val2);
        },
        writeBooleanField: function(tag, val2) {
          this.writeVarintField(tag, Boolean(val2));
        }
      };
      function readVarintRemainder(l3, s3, p3) {
        var buf = p3.buf, h4, b2;
        b2 = buf[p3.pos++];
        h4 = (b2 & 112) >> 4;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        b2 = buf[p3.pos++];
        h4 |= (b2 & 127) << 3;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        b2 = buf[p3.pos++];
        h4 |= (b2 & 127) << 10;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        b2 = buf[p3.pos++];
        h4 |= (b2 & 127) << 17;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        b2 = buf[p3.pos++];
        h4 |= (b2 & 127) << 24;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        b2 = buf[p3.pos++];
        h4 |= (b2 & 1) << 31;
        if (b2 < 128)
          return toNum(l3, h4, s3);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val2, pbf) {
        var low, high;
        if (val2 >= 0) {
          low = val2 % 4294967296 | 0;
          high = val2 / 4294967296 | 0;
        } else {
          low = ~(-val2 % 4294967296);
          high = ~(-val2 / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb2 = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb2 | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len8, pbf) {
        var extraLen = len8 <= 16383 ? 1 : len8 <= 2097151 ? 2 : len8 <= 268435455 ? 3 : Math.floor(Math.log(len8) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i5 = pbf.pos - 1; i5 >= startPos; i5--)
          pbf.buf[i5 + extraLen] = pbf.buf[i5];
      }
      function writePackedVarint(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeVarint(arr[i5]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSVarint(arr[i5]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFloat(arr[i5]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeDouble(arr[i5]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeBoolean(arr[i5]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFixed32(arr[i5]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSFixed32(arr[i5]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFixed64(arr[i5]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSFixed64(arr[i5]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val2, pos) {
        buf[pos] = val2;
        buf[pos + 1] = val2 >>> 8;
        buf[pos + 2] = val2 >>> 16;
        buf[pos + 3] = val2 >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str7 = "";
        var i5 = pos;
        while (i5 < end) {
          var b0 = buf[i5];
          var c2 = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i5 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c2 = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i5 + 1];
            if ((b1 & 192) === 128) {
              c2 = (b0 & 31) << 6 | b1 & 63;
              if (c2 <= 127) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i5 + 1];
            b2 = buf[i5 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i5 + 1];
            b2 = buf[i5 + 2];
            b3 = buf[i5 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c2 <= 65535 || c2 >= 1114112) {
                c2 = null;
              }
            }
          }
          if (c2 === null) {
            c2 = 65533;
            bytesPerSequence = 1;
          } else if (c2 > 65535) {
            c2 -= 65536;
            str7 += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
            c2 = 56320 | c2 & 1023;
          }
          str7 += String.fromCharCode(c2);
          i5 += bytesPerSequence;
        }
        return str7;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str7, pos) {
        for (var i5 = 0, c2, lead; i5 < str7.length; i5++) {
          c2 = str7.charCodeAt(i5);
          if (c2 > 55295 && c2 < 57344) {
            if (lead) {
              if (c2 < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c2;
                continue;
              } else {
                c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c2 > 56319 || i5 + 1 === str7.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c2;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c2 < 128) {
            buf[pos++] = c2;
          } else {
            if (c2 < 2048) {
              buf[pos++] = c2 >> 6 | 192;
            } else {
              if (c2 < 65536) {
                buf[pos++] = c2 >> 12 | 224;
              } else {
                buf[pos++] = c2 >> 18 | 240;
                buf[pos++] = c2 >> 12 & 63 | 128;
              }
              buf[pos++] = c2 >> 6 & 63 | 128;
            }
            buf[pos++] = c2 & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    AmbientLight: () => AmbientLight,
    ArcLayer: () => ArcLayer,
    Attribute: () => Attribute2,
    AttributeManager: () => AttributeManager,
    BitmapLayer: () => BitmapLayer,
    BrushingExtension: () => BrushingExtension,
    COORDINATE_SYSTEM: () => COORDINATE_SYSTEM,
    CPUAggregator: () => CPUAggregator,
    ClipExtension: () => ClipExtension,
    CollisionFilterExtension: () => CollisionFilterExtension,
    ColumnLayer: () => ColumnLayer,
    CompassWidget: () => CompassWidget,
    CompositeLayer: () => CompositeLayer,
    ContourLayer: () => GridLayer,
    Controller: () => Controller,
    DarkGlassTheme: () => DarkGlassTheme,
    DarkTheme: () => DarkTheme,
    DataFilterExtension: () => DataFilterExtension,
    Deck: () => Deck,
    DeckGL: () => DeckGL,
    DeckRenderer: () => DeckRenderer,
    DirectionalLight: () => DirectionalLight,
    FillStyleExtension: () => FillStyleExtension,
    FirstPersonController: () => FirstPersonController,
    FirstPersonView: () => FirstPersonView,
    FirstPersonViewport: () => FirstPersonViewport,
    FlyToInterpolator: () => FlyToInterpolator,
    Fp64Extension: () => Fp64Extension,
    FullscreenWidget: () => FullscreenWidget,
    GeoJsonLayer: () => GeoJsonLayer,
    GeohashLayer: () => GeohashLayer,
    GoogleMapsOverlay: () => GoogleMapsOverlay,
    GreatCircleLayer: () => GreatCircleLayer,
    GridCellLayer: () => GridCellLayer,
    GridLayer: () => GridLayer2,
    H3ClusterLayer: () => H3ClusterLayer,
    H3HexagonLayer: () => H3HexagonLayer,
    HeatmapLayer: () => HeatmapLayer,
    HexagonLayer: () => HexagonLayer,
    IconLayer: () => IconLayer,
    Layer: () => Layer,
    LayerExtension: () => LayerExtension,
    LayerManager: () => LayerManager,
    LightGlassTheme: () => LightGlassTheme,
    LightTheme: () => LightTheme,
    LightingEffect: () => LightingEffect,
    LineLayer: () => LineLayer,
    LinearInterpolator: () => LinearInterpolator,
    MVTLayer: () => MVTLayer,
    MapController: () => MapController,
    MapView: () => MapView,
    MapboxOverlay: () => MapboxOverlay,
    MaskExtension: () => MaskExtension,
    OPERATION: () => OPERATION,
    OrbitController: () => OrbitController,
    OrbitView: () => OrbitView,
    OrbitViewport: () => OrbitViewport,
    OrthographicController: () => OrthographicController,
    OrthographicView: () => OrthographicView,
    OrthographicViewport: () => OrthographicViewport,
    PathLayer: () => PathLayer,
    PathStyleExtension: () => PathStyleExtension,
    PointCloudLayer: () => PointCloudLayer,
    PointLight: () => PointLight,
    PolygonLayer: () => PolygonLayer,
    PostProcessEffect: () => PostProcessEffect,
    QuadkeyLayer: () => QuadkeyLayer,
    ResetViewWidget: () => ResetViewWidget,
    S2Layer: () => S2Layer,
    ScatterplotLayer: () => ScatterplotLayer,
    ScenegraphLayer: () => ScenegraphLayer,
    ScreenGridLayer: () => ScreenGridLayer,
    ScreenshotWidget: () => ScreenshotWidget,
    SimpleMeshLayer: () => SimpleMeshLayer,
    SolidPolygonLayer: () => SolidPolygonLayer,
    TRANSITION_EVENTS: () => TRANSITION_EVENTS,
    TerrainLayer: () => TerrainLayer,
    Tesselator: () => Tesselator,
    TextLayer: () => TextLayer,
    Tile3DLayer: () => Tile3DLayer,
    TileLayer: () => TileLayer,
    TransitionInterpolator: () => TransitionInterpolator,
    TripsLayer: () => TripsLayer,
    UNIT: () => UNIT,
    VERSION: () => VERSION4,
    View: () => View,
    Viewport: () => Viewport,
    WebGLAggregator: () => WebGLAggregator,
    WebMercatorViewport: () => WebMercatorViewport2,
    ZoomWidget: () => ZoomWidget,
    _AggregationLayer: () => AggregationLayer,
    _CameraLight: () => CameraLight,
    _Component: () => Component,
    _ComponentState: () => ComponentState,
    _GeoCellLayer: () => GeoCellLayer,
    _GlobeController: () => GlobeController,
    _GlobeView: () => GlobeView,
    _GlobeViewport: () => GlobeViewport,
    _LayersPass: () => LayersPass,
    _MultiIconLayer: () => MultiIconLayer,
    _PickLayersPass: () => PickLayersPass,
    _SunLight: () => SunLight,
    _TerrainExtension: () => TerrainExtension,
    _TextBackgroundLayer: () => TextBackgroundLayer,
    _Tile2DHeader: () => Tile2DHeader,
    _Tileset2D: () => Tileset2D,
    _WMSLayer: () => WMSLayer,
    _WidgetImpl: () => WidgetImpl,
    _applyStyles: () => applyStyles,
    _compareProps: () => compareProps,
    _components: () => components_exports,
    _count: () => count,
    _deepEqual: () => deepEqual2,
    _fillArray: () => fillArray,
    _flatten: () => flatten,
    _getURLFromTemplate: () => getURLFromTemplate,
    _memoize: () => memoize,
    _mergeShaders: () => mergeShaders,
    _registerLoggers: () => register,
    _removeStyles: () => removeStyles,
    assert: () => assert8,
    createIterable: () => createIterable,
    fp64LowPart: () => fp64LowPart2,
    getShaderAssembler: () => getShaderAssembler,
    gouraudLighting: () => gouraudLighting,
    log: () => log_default,
    phongLighting: () => phongLighting,
    picking: () => picking_default,
    project: () => project_default,
    project32: () => project32_default,
    project64: () => project64_default,
    shadow: () => shadow_default
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/loader-types.js
  async function parseFromContext(data, loaders, options, context) {
    return context._parse(data, loaders, options, context);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
  function assert2(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = (
    // @ts-ignore process does not exist on browser
    Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
  );
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var window_2 = globalThis;
  var document_2 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && window.process?.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    return Boolean(userAgent2 && userAgent2.indexOf("Electron") >= 0);
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser2() {
    const isNode = (
      // @ts-expect-error
      typeof process === "object" && String(process) === "[object process]" && !process?.browser
    );
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/get-browser.js
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser2()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const userAgent2 = mockUserAgent || navigator_.userAgent || "";
    if (userAgent2.indexOf("Edge") > -1) {
      return "Edge";
    }
    if (globalThis.chrome) {
      return "Chrome";
    }
    if (globalThis.safari) {
      return "Safari";
    }
    if (globalThis.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // ../../node_modules/@probe.gl/env/dist/index.js
  var VERSION = true ? "4.1.0" : "untranspiled source";

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x3 = "__storage_test__";
      storage.setItem(x3, x3);
      storage.removeItem(x3);
      return storage;
    } catch (e3) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig, type = "sessionStorage") {
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
      formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1e3) {
      formatted = `${ms.toFixed(0)}ms`;
    } else {
      formatted = `${(ms / 1e3).toFixed(2)}s`;
    }
    return formatted;
  }
  function leftPad(string, length16 = 8) {
    const padLength = Math.max(length16 - string.length, 0);
    return `${" ".repeat(padLength)}${string}`;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser2 && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = `\x1B[${colorCode}m${string}\x1B[39m`;
      }
      if (background) {
        const colorCode = getColor(background);
        string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj, predefined = ["constructor"]) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name13) => key === name13)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert3(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser2() && window_2.performance) {
      timestamp = window_2?.performance?.now?.();
    } else if ("hrtime" in process_) {
      const timeParts = process_?.hrtime?.();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser2() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = { once: true };
  var Log = class {
    constructor({ id } = { id: "" }) {
      this.VERSION = VERSION;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
      this.timeStamp(`${this.id} started`);
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */
    set priority(newPriority) {
      this.level = newPriority;
    }
    /** @deprecated use logLevel */
    get priority() {
      return this.level;
    }
    /** @deprecated use logLevel */
    getPriority() {
      return this.level;
    }
    // Configure
    enable(enabled = true) {
      this._storage.setConfiguration({ enabled });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({ level });
      return this;
    }
    /** return the current status of the setting */
    get(setting) {
      return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
      this._storage.setConfiguration({ [setting]: value });
    }
    /** Logs the current settings as a table */
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    // Unconditional logging
    assert(condition, message2) {
      if (!condition) {
        throw new Error(message2 || "Assertion failed");
      }
    }
    warn(message2) {
      return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
    }
    error(message2) {
      return this._getLogFunction(0, message2, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */
    deprecated(oldUsage, newUsage) {
      return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */
    removed(oldUsage, newUsage) {
      return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
    }
    info(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.info, arguments);
    }
    once(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    time(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
    }
    group(logLevel, message2, opts = { collapsed: false }) {
      const options = normalizeArguments({ logLevel, message: message2, opts });
      const { collapsed } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message2, opts = {}) {
      return this.group(logLevel, message2, Object.assign({}, opts, { collapsed: true }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message2, func) {
      this.group(logLevel, message2)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message2, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({ logLevel, message: message2, args, opts });
        method = method || opts.method;
        assert3(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message2 = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message2, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert3(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const { logLevel, message: message2 } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message2) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message2 !== void 0) {
          args.unshift(message2);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert3(messageType === "string" || messageType === "object");
    return Object.assign(opts, { args }, opts.opts);
  }
  function decorateMessage(id, message2, opts) {
    if (typeof message2 === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message2 = opts.time ? `${id}: ${time}  ${message2}` : `${id}: ${message2}`;
      message2 = addColor(message2, opts.color, opts.background);
    }
    return message2;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/init.js
  globalThis.probe = {};

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({ id: "@probe.gl/log" });

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
  function mergeLoaderOptions(baseOptions, newOptions) {
    return mergeOptionsRecursively(baseOptions || {}, newOptions);
  }
  function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
    if (level > 3) {
      return newOptions;
    }
    const options = { ...baseOptions };
    for (const [key, newValue] of Object.entries(newOptions)) {
      if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
        options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
      } else {
        options[key] = newOptions[key];
      }
    }
    return options;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js
  function registerJSModules(modules) {
    globalThis.loaders ||= {};
    globalThis.loaders.modules ||= {};
    Object.assign(globalThis.loaders.modules, modules);
  }
  function getJSModuleOrNull(name13) {
    const module = globalThis.loaders?.modules?.[name13];
    return module || null;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
  var NPM_TAG = "latest";
  function getVersion() {
    if (!globalThis._loadersgl_?.version) {
      globalThis._loadersgl_ = globalThis._loadersgl_ || {};
      if (false) {
        console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
        globalThis._loadersgl_.version = NPM_TAG;
      } else {
        globalThis._loadersgl_.version = "4.2.1";
      }
    }
    return globalThis._loadersgl_.version;
  }
  var VERSION2 = getVersion();

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
  function assert4(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loaders.gl assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_3 = globals2.window || globals2.self || globals2.global || {};
  var global_3 = globals2.global || globals2.self || globals2.window || {};
  var document_3 = globals2.document || {};
  var isBrowser3 = (
    // @ts-ignore process.browser
    typeof process !== "object" || String(process) !== "[object process]" || process.browser
  );
  var isWorker = typeof importScripts === "function";
  var isMobile2 = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
  var WorkerJob = class {
    name;
    workerThread;
    isRunning = true;
    /** Promise that resolves when Job is done */
    result;
    _resolve = () => {
    };
    _reject = () => {
    };
    constructor(jobName, workerThread) {
      this.name = jobName;
      this.workerThread = workerThread;
      this.result = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    /**
     * Send a message to the job's worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     */
    postMessage(type, payload) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        // Lets worker ignore unrelated messages
        type,
        payload
      });
    }
    /**
     * Call to resolve the `result` Promise with the supplied value
     */
    done(value) {
      assert4(this.isRunning);
      this.isRunning = false;
      this._resolve(value);
    }
    /**
     * Call to reject the `result` Promise with the supplied error
     */
    error(error) {
      assert4(this.isRunning);
      this.isRunning = false;
      this._reject(error);
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
  var NodeWorker = class {
    terminate() {
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
  var workerURLCache = /* @__PURE__ */ new Map();
  function getLoadableWorkerURL(props) {
    assert4(props.source && !props.url || !props.source && props.url);
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
      if (props.url) {
        workerURL = getLoadableWorkerURLFromURL(props.url);
        workerURLCache.set(props.url, workerURL);
      }
      if (props.source) {
        workerURL = getLoadableWorkerURLFromSource(props.source);
        workerURLCache.set(props.source, workerURL);
      }
    }
    assert4(workerURL);
    return workerURL;
  }
  function getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) {
      return url;
    }
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
  }
  function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([workerSource], { type: "application/javascript" });
    return URL.createObjectURL(blob);
  }
  function buildScriptSource(workerUrl) {
    return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
  function getTransferList(object, recursive = true, transfers) {
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
  var NOOP = () => {
  };
  var WorkerThread = class {
    name;
    source;
    url;
    terminated = false;
    worker;
    onMessage;
    onError;
    _loadableURL = "";
    /** Checks if workers are supported on this platform */
    static isSupported() {
      return typeof Worker !== "undefined" && isBrowser3 || typeof NodeWorker !== "undefined" && !isBrowser3;
    }
    constructor(props) {
      const { name: name13, source: source3, url } = props;
      assert4(source3 || url);
      this.name = name13;
      this.source = source3;
      this.url = url;
      this.onMessage = NOOP;
      this.onError = (error) => console.log(error);
      this.worker = isBrowser3 ? this._createBrowserWorker() : this._createNodeWorker();
    }
    /**
     * Terminate this worker thread
     * @note Can free up significant memory
     */
    destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    /**
     * Send a message to this worker thread
     * @param data any data structure, ideally consisting mostly of transferrable objects
     * @param transferList If not supplied, calculated automatically by traversing data
     */
    postMessage(data, transferList) {
      transferList = transferList || getTransferList(data);
      this.worker.postMessage(data, transferList);
    }
    // PRIVATE
    /**
     * Generate a standard Error from an ErrorEvent
     * @param event
     */
    _getErrorFromErrorEvent(event) {
      let message2 = "Failed to load ";
      message2 += `worker ${this.name} from ${this.url}. `;
      if (event.message) {
        message2 += `${event.message} in `;
      }
      if (event.lineno) {
        message2 += `:${event.lineno}:${event.colno}`;
      }
      return new Error(message2);
    }
    /**
     * Creates a worker thread on the browser
     */
    _createBrowserWorker() {
      this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
      const worker = new Worker(this._loadableURL, { name: this.name });
      worker.onmessage = (event) => {
        if (!event.data) {
          this.onError(new Error("No data received"));
        } else {
          this.onMessage(event.data);
        }
      };
      worker.onerror = (error) => {
        this.onError(this._getErrorFromErrorEvent(error));
        this.terminated = true;
      };
      worker.onmessageerror = (event) => console.error(event);
      return worker;
    }
    /**
     * Creates a worker thread in node.js
     * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
     */
    _createNodeWorker() {
      let worker;
      if (this.url) {
        const absolute = this.url.includes(":/") || this.url.startsWith("/");
        const url = absolute ? this.url : `./${this.url}`;
        worker = new NodeWorker(url, { eval: false });
      } else if (this.source) {
        worker = new NodeWorker(this.source, { eval: true });
      } else {
        throw new Error("no worker");
      }
      worker.on("message", (data) => {
        this.onMessage(data);
      });
      worker.on("error", (error) => {
        this.onError(error);
      });
      worker.on("exit", (code) => {
      });
      return worker;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
  var WorkerPool = class {
    name = "unnamed";
    source;
    // | Function;
    url;
    maxConcurrency = 1;
    maxMobileConcurrency = 1;
    onDebug = () => {
    };
    reuseWorkers = true;
    props = {};
    jobQueue = [];
    idleQueue = [];
    count = 0;
    isDestroyed = false;
    /** Checks if workers are supported on this platform */
    static isSupported() {
      return WorkerThread.isSupported();
    }
    /**
     * @param processor - worker function
     * @param maxConcurrency - max count of workers
     */
    constructor(props) {
      this.source = props.source;
      this.url = props.url;
      this.setProps(props);
    }
    /**
     * Terminates all workers in the pool
     * @note Can free up significant memory
     */
    destroy() {
      this.idleQueue.forEach((worker) => worker.destroy());
      this.isDestroyed = true;
    }
    setProps(props) {
      this.props = { ...this.props, ...props };
      if (props.name !== void 0) {
        this.name = props.name;
      }
      if (props.maxConcurrency !== void 0) {
        this.maxConcurrency = props.maxConcurrency;
      }
      if (props.maxMobileConcurrency !== void 0) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }
      if (props.reuseWorkers !== void 0) {
        this.reuseWorkers = props.reuseWorkers;
      }
      if (props.onDebug !== void 0) {
        this.onDebug = props.onDebug;
      }
    }
    async startJob(name13, onMessage2 = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
      const startPromise = new Promise((onStart) => {
        this.jobQueue.push({ name: name13, onMessage: onMessage2, onError, onStart });
        return this;
      });
      this._startQueuedJob();
      return await startPromise;
    }
    // PRIVATE
    /**
     * Starts first queued job if worker is available or can be created
     * Called when job is started and whenever a worker returns to the idleQueue
     */
    async _startQueuedJob() {
      if (!this.jobQueue.length) {
        return;
      }
      const workerThread = this._getAvailableWorker();
      if (!workerThread) {
        return;
      }
      const queuedJob = this.jobQueue.shift();
      if (queuedJob) {
        this.onDebug({
          message: "Starting job",
          name: queuedJob.name,
          workerThread,
          backlog: this.jobQueue.length
        });
        const job = new WorkerJob(queuedJob.name, workerThread);
        workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
        workerThread.onError = (error) => queuedJob.onError(job, error);
        queuedJob.onStart(job);
        try {
          await job.result;
        } catch (error) {
          console.error(`Worker exception: ${error}`);
        } finally {
          this.returnWorkerToQueue(workerThread);
        }
      }
    }
    /**
     * Returns a worker to the idle queue
     * Destroys the worker if
     *  - pool is destroyed
     *  - if this pool doesn't reuse workers
     *  - if maxConcurrency has been lowered
     * @param worker
     */
    returnWorkerToQueue(worker) {
      const shouldDestroyWorker = (
        // Workers on Node.js prevent the process from exiting.
        // Until we figure out how to close them before exit, we always destroy them
        !isBrowser3 || // If the pool is destroyed, there is no reason to keep the worker around
        this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
        !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
        this.count > this._getMaxConcurrency()
      );
      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }
      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
    /**
     * Returns idle worker or creates new worker if maxConcurrency has not been reached
     */
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const name13 = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
        return new WorkerThread({ name: name13, source: this.source, url: this.url });
      }
      return null;
    }
    _getMaxConcurrency() {
      return isMobile2 ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
  var DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  var _WorkerFarm = class {
    props;
    workerPools = /* @__PURE__ */ new Map();
    /** Checks if workers are supported on this platform */
    static isSupported() {
      return WorkerThread.isSupported();
    }
    /** Get the singleton instance of the global worker farm */
    static getWorkerFarm(props = {}) {
      _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
      _WorkerFarm._workerFarm.setProps(props);
      return _WorkerFarm._workerFarm;
    }
    /** get global instance with WorkerFarm.getWorkerFarm() */
    constructor(props) {
      this.props = { ...DEFAULT_PROPS };
      this.setProps(props);
      this.workerPools = /* @__PURE__ */ new Map();
    }
    /**
     * Terminate all workers in the farm
     * @note Can free up significant memory
     */
    destroy() {
      for (const workerPool of this.workerPools.values()) {
        workerPool.destroy();
      }
      this.workerPools = /* @__PURE__ */ new Map();
    }
    /**
     * Set props used when initializing worker pools
     * @param props
     */
    setProps(props) {
      this.props = { ...this.props, ...props };
      for (const workerPool of this.workerPools.values()) {
        workerPool.setProps(this._getWorkerPoolProps());
      }
    }
    /**
     * Returns a worker pool for the specified worker
     * @param options - only used first time for a specific worker name
     * @param options.name - the name of the worker - used to identify worker pool
     * @param options.url -
     * @param options.source -
     * @example
     *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
     */
    getWorkerPool(options) {
      const { name: name13, source: source3, url } = options;
      let workerPool = this.workerPools.get(name13);
      if (!workerPool) {
        workerPool = new WorkerPool({
          name: name13,
          source: source3,
          url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name13, workerPool);
      }
      return workerPool;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  var WorkerFarm = _WorkerFarm;
  // singleton
  __publicField(WorkerFarm, "_workerFarm");

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
  function getWorkerURL(worker, options = {}) {
    const workerOptions = options[worker.id] || {};
    const workerFile = isBrowser3 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") {
      url = options.workerUrl;
    }
    if (options._workerType === "test") {
      if (isBrowser3) {
        url = `modules/${worker.module}/dist/${workerFile}`;
      } else {
        url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
      }
    }
    if (!url) {
      let version = worker.version;
      if (version === "latest") {
        version = NPM_TAG;
      }
      const versionTag = version ? `@${version}` : "";
      url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
    }
    assert4(url);
    return url;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
  function validateWorkerVersion(worker, coreVersion = VERSION2) {
    assert4(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js
  var loadLibraryPromises = {};
  async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {
    if (moduleName) {
      libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);
    }
    loadLibraryPromises[libraryUrl] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
  }
  function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {
    if (!options.useLocalLibraries && library.startsWith("http")) {
      return library;
    }
    libraryName = libraryName || library;
    const modules = options.modules || {};
    if (modules[libraryName]) {
      return modules[libraryName];
    }
    if (!isBrowser3) {
      return `modules/${moduleName}/dist/libs/${libraryName}`;
    }
    if (options.CDN) {
      assert4(options.CDN.startsWith("http"));
      return `${options.CDN}/${moduleName}@${VERSION2}/dist/libs/${libraryName}`;
    }
    if (isWorker) {
      return `../src/libs/${libraryName}`;
    }
    return `modules/${moduleName}/src/libs/${libraryName}`;
  }
  async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith("wasm")) {
      return await loadAsArrayBuffer(libraryUrl);
    }
    if (!isBrowser3) {
      try {
        const { requireFromFile } = globalThis.loaders || {};
        return await requireFromFile?.(libraryUrl);
      } catch (error) {
        console.error(error);
        return null;
      }
    }
    if (isWorker) {
      return importScripts(libraryUrl);
    }
    const scriptSource = await loadAsText(libraryUrl);
    return loadLibraryFromString(scriptSource, libraryUrl);
  }
  function loadLibraryFromString(scriptSource, id) {
    if (!isBrowser3) {
      const { requireFromString } = globalThis.loaders || {};
      return requireFromString?.(scriptSource, id);
    }
    if (isWorker) {
      eval.call(globalThis, scriptSource);
      return null;
    }
    const script = document.createElement("script");
    script.id = id;
    try {
      script.appendChild(document.createTextNode(scriptSource));
    } catch (e3) {
      script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
  }
  async function loadAsArrayBuffer(url) {
    const { readFileAsArrayBuffer } = globalThis.loaders || {};
    if (isBrowser3 || !readFileAsArrayBuffer || url.startsWith("http")) {
      const response = await fetch(url);
      return await response.arrayBuffer();
    }
    return await readFileAsArrayBuffer(url);
  }
  async function loadAsText(url) {
    const { readFileAsText } = globalThis.loaders || {};
    if (isBrowser3 || !readFileAsText || url.startsWith("http")) {
      const response = await fetch(url);
      return await response.text();
    }
    return await readFileAsText(url);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
  function canParseWithWorker(loader, options) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    if (!isBrowser3 && !options?._nodeWorkers) {
      return false;
    }
    return loader.worker && options?.worker;
  }
  async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name13 = loader.id;
    const url = getWorkerURL(loader, options);
    const workerFarm = WorkerFarm.getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({ name: name13, url });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob(
      "process-on-worker",
      // @ts-expect-error
      onMessage.bind(null, parseOnMainThread)
      // eslint-disable-line @typescript-eslint/no-misused-promises
    );
    job.postMessage("process", {
      // @ts-ignore
      input: data,
      options,
      context
    });
    const result = await job.result;
    return await result.result;
  }
  async function onMessage(parseOnMainThread, job, type, payload) {
    switch (type) {
      case "done":
        job.done(payload);
        break;
      case "error":
        job.error(new Error(payload.error));
        break;
      case "process":
        const { id, input, options } = payload;
        try {
          const result = await parseOnMainThread(input, options);
          job.postMessage("done", { id, result });
        } catch (error) {
          const message2 = error instanceof Error ? error.message : "unknown error";
          job.postMessage("error", { id, error: message2 });
        }
        break;
      default:
        console.warn(`parse-with-worker unknown message ${type}`);
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js
  function getFirstCharacters(data, length16 = 5) {
    if (typeof data === "string") {
      return data.slice(0, length16);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length16);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length16);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length16) {
    if (arrayBuffer2.byteLength <= byteOffset + length16) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i5 = 0; i5 < length16; i5++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i5));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/parser-utils/parse-json.js
  function parseJSON(string) {
    try {
      return JSON.parse(string);
    } catch (_2) {
      throw new Error(`Failed to parse JSON from data starting with "${getFirstCharacters(string)}"`);
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for (let i5 = 0; i5 < array1.length; ++i5) {
      if (array1[i5] !== array2[i5]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers(...sources) {
    return concatenateArrayBuffersFromArray(sources);
  }
  function concatenateArrayBuffersFromArray(sources) {
    const sourceArrays = sources.map((source22) => source22 instanceof ArrayBuffer ? new Uint8Array(source22) : source22);
    const byteLength = sourceArrays.reduce((length16, typedArray) => length16 + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }
  function concatenateTypedArrays(...typedArrays) {
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
      throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays) {
      result.set(array, offset);
      offset += array.length;
    }
    return result;
  }
  function sliceArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer2).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer2).subarray(byteOffset);
    const arrayCopy2 = new Uint8Array(subArray);
    return arrayCopy2.buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js
  function padToNBytes(byteLength, padding) {
    assert2(byteLength >= 0);
    assert2(padding > 0);
    return byteLength + (padding - 1) & ~(padding - 1);
  }
  function copyToArray(source3, target2, targetOffset) {
    let sourceArray;
    if (source3 instanceof ArrayBuffer) {
      sourceArray = new Uint8Array(source3);
    } else {
      const srcByteOffset = source3.byteOffset;
      const srcByteLength = source3.byteLength;
      sourceArray = new Uint8Array(source3.buffer || source3.arrayBuffer, srcByteOffset, srcByteLength);
    }
    target2.set(sourceArray, targetOffset);
    return targetOffset + padToNBytes(sourceArray.byteLength, 4);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // ../../node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name13, type) {
      this.sampleSize = 1;
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      this.name = name13;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    /** Call to increment count (+1) */
    incrementCount() {
      this.addCount(1);
      return this;
    }
    /** Call to decrement count (-1) */
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    /** Increase count */
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    /** Decrease count */
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    /** Add an arbitrary timing and bump the count */
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    /** Start a timer */
    timeStart() {
      this._startTime = getHiResTimestamp2();
      this._timerPending = true;
      return this;
    }
    /** End a timer. Adds to time and bumps the timing count. */
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp2() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    /** Calculate average time / count for the previous window */
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    /** Calculate counts per second for the previous window */
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    /** Calculate average time / count */
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    /** Calculate counts per second */
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      this.stats = {};
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    /** Acquire a stat. Create if it doesn't exist. */
    get(name13, type = "count") {
      return this._getOrCreate({ name: name13, type });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    /** Reset all stats */
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats(stats2 = []) {
      stats2.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const { name: name13, type } = stat;
      let result = this.stats[name13];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name13, type);
        }
        this.stats[name13] = result;
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js
  var STAT_QUEUED_REQUESTS = "Queued Requests";
  var STAT_ACTIVE_REQUESTS = "Active Requests";
  var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
  var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
  var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
  var DEFAULT_PROPS2 = {
    id: "request-scheduler",
    /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
    throttleRequests: true,
    /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
    maxRequests: 6,
    /**
     * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
     * been added to the queue for this amount of time.
     */
    debounceTime: 0
  };
  var RequestScheduler = class {
    props;
    stats;
    activeRequestCount = 0;
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    requestQueue = [];
    requestMap = /* @__PURE__ */ new Map();
    updateTimer = null;
    constructor(props = {}) {
      this.props = { ...DEFAULT_PROPS2, ...props };
      this.stats = new Stats({ id: this.props.id });
      this.stats.get(STAT_QUEUED_REQUESTS);
      this.stats.get(STAT_ACTIVE_REQUESTS);
      this.stats.get(STAT_CANCELLED_REQUESTS);
      this.stats.get(STAT_QUEUED_REQUESTS_EVER);
      this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    /**
     * Called by an application that wants to issue a request, without having it deeply queued by the browser
     *
     * When the returned promise resolved, it is OK for the application to issue a request.
     * The promise resolves to an object that contains a `done` method.
     * When the application's request has completed (or failed), the application must call the `done` function
     *
     * @param handle
     * @param getPriority will be called when request "slots" open up,
     *    allowing the caller to update priority or cancel the request
     *    Highest priority executes first, priority < 0 cancels the request
     * @returns a promise
     *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
     *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
     *     In this case the application should not issue the request
     */
    scheduleRequest(handle, getPriority = () => 0) {
      if (!this.props.throttleRequests) {
        return Promise.resolve({ done: () => {
        } });
      }
      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }
      const request = { handle, priority: 0, getPriority };
      const promise = new Promise((resolve2) => {
        request.resolve = resolve2;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);
      this._issueNewRequests();
      return promise;
    }
    // PRIVATE
    _issueRequest(request) {
      const { handle, resolve: resolve2 } = request;
      let isDone = false;
      const done = () => {
        if (!isDone) {
          isDone = true;
          this.requestMap.delete(handle);
          this.activeRequestCount--;
          this._issueNewRequests();
        }
      };
      this.activeRequestCount++;
      return resolve2 ? resolve2({ done }) : Promise.resolve({ done });
    }
    /** We check requests asynchronously, to prevent multiple updates */
    _issueNewRequests() {
      if (this.updateTimer !== null) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
    }
    /** Refresh all requests  */
    _issueNewRequestsAsync() {
      if (this.updateTimer !== null) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = null;
      const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
      if (freeSlots === 0) {
        return;
      }
      this._updateAllRequests();
      for (let i5 = 0; i5 < freeSlots; ++i5) {
        const request = this.requestQueue.shift();
        if (request) {
          this._issueRequest(request);
        }
      }
    }
    /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
    _updateAllRequests() {
      const requestQueue = this.requestQueue;
      for (let i5 = 0; i5 < requestQueue.length; ++i5) {
        const request = requestQueue[i5];
        if (!this._updateRequest(request)) {
          requestQueue.splice(i5, 1);
          this.requestMap.delete(request.handle);
          i5--;
        }
      }
      requestQueue.sort((a3, b2) => a3.priority - b2.priority);
    }
    /** Update a single request by calling the callback */
    _updateRequest(request) {
      request.priority = request.getPriority(request.handle);
      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }
      return true;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename2) {
    for (const alias in fileAliases) {
      if (filename2.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename2 = filename2.replace(alias, replacement);
      }
    }
    if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
      filename2 = `${pathPrefix}${filename2}`;
    }
    return filename2;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value) {
    return value && typeof value === "object" && value.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text = data;
      const uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join,
    resolve: () => resolve
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
  function getCWD() {
    if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
      return process.cwd();
    }
    const pathname = window.location?.pathname;
    return pathname?.slice(0, pathname.lastIndexOf("/") + 1) || "";
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
  function filename(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join(...parts) {
    const separator = "/";
    parts = parts.map((part, index) => {
      if (index) {
        part = part.replace(new RegExp(`^${separator}`), "");
      }
      if (index !== parts.length - 1) {
        part = part.replace(new RegExp(`${separator}$`), "");
      }
      return part;
    });
    return parts.join(separator);
  }
  function resolve(...components) {
    const paths = [];
    for (let _i = 0; _i < components.length; _i++) {
      paths[_i] = components[_i];
    }
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i5 = paths.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
      let path;
      if (i5 >= 0) {
        path = paths[i5];
      } else {
        if (cwd === void 0) {
          cwd = getCWD();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    }
    return ".";
  }
  var SLASH = 47;
  var DOT = 46;
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for (let i5 = 0; i5 <= path.length; ++i5) {
      if (i5 < path.length) {
        code = path.charCodeAt(i5);
      } else if (code === SLASH) {
        break;
      } else {
        code = SLASH;
      }
      if (code === SLASH) {
        if (lastSlash === i5 - 1 || dots === 1) {
        } else if (lastSlash !== i5 - 1 && dots === 2) {
          if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
            if (res.length > 2) {
              const start = res.length - 1;
              let j2 = start;
              for (; j2 >= 0; --j2) {
                if (res.charCodeAt(j2) === SLASH) {
                  break;
                }
              }
              if (j2 !== start) {
                res = j2 === -1 ? "" : res.slice(0, j2);
                lastSlash = i5;
                dots = 0;
                isAboveRoot = false;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSlash = i5;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            isAboveRoot = true;
          }
        } else {
          const slice = path.slice(lastSlash + 1, i5);
          if (res.length > 0) {
            res += `/${slice}`;
          } else {
            res = slice;
          }
          isAboveRoot = false;
        }
        lastSlash = i5;
        dots = 0;
      } else if (code === DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/sources/data-source.js
  var DataSource = class {
    /** A resolved fetch function extracted from loadOptions prop */
    fetch;
    /** The actual load options, if calling a loaders.gl loader */
    loadOptions;
    _needsRefresh = true;
    props;
    constructor(props) {
      this.props = { ...props };
      this.loadOptions = { ...props.loadOptions };
      this.fetch = getFetchFunction(this.loadOptions);
    }
    setProps(props) {
      this.props = Object.assign(this.props, props);
      this.setNeedsRefresh();
    }
    /** Mark this data source as needing a refresh (redraw) */
    setNeedsRefresh() {
      this._needsRefresh = true;
    }
    /**
     * Does this data source need refreshing?
     * @note The specifics of the refresh mechanism depends on type of data source
     */
    getNeedsRefresh(clear = true) {
      const needsRefresh = this._needsRefresh;
      if (clear) {
        this._needsRefresh = false;
      }
      return needsRefresh;
    }
  };
  function getFetchFunction(options) {
    const fetchFunction = options?.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options?.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/sources/image-source.js
  var ImageSource = class extends DataSource {
  };
  __publicField(ImageSource, "type", "template");
  __publicField(ImageSource, "testURL", (url) => false);

  // ../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
  var isBoolean = (x3) => typeof x3 === "boolean";
  var isFunction = (x3) => typeof x3 === "function";
  var isObject = (x3) => x3 !== null && typeof x3 === "object";
  var isPureObject = (x3) => isObject(x3) && x3.constructor === {}.constructor;
  var isIterable = (x3) => Boolean(x3) && typeof x3[Symbol.iterator] === "function";
  var isAsyncIterable = (x3) => x3 && typeof x3[Symbol.asyncIterator] === "function";
  var isResponse = (x3) => typeof Response !== "undefined" && x3 instanceof Response || x3 && x3.arrayBuffer && x3.text && x3.json;
  var isBlob = (x3) => typeof Blob !== "undefined" && x3 instanceof Blob;
  var isBuffer2 = (x3) => x3 && typeof x3 === "object" && x3.isBuffer;
  var isReadableDOMStream = (x3) => typeof ReadableStream !== "undefined" && x3 instanceof ReadableStream || isObject(x3) && isFunction(x3.tee) && isFunction(x3.cancel) && isFunction(x3.getReader);
  var isReadableNodeStream = (x3) => isObject(x3) && isFunction(x3.read) && isFunction(x3.pipe) && isBoolean(x3.readable);
  var isReadableStream = (x3) => isReadableDOMStream(x3) || isReadableNodeStream(x3);

  // ../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
  var FetchError = class extends Error {
    constructor(message2, info) {
      super(message2);
      this.reason = info.reason;
      this.url = info.url;
      this.response = info.response;
    }
    /** A best effort reason for why the fetch failed */
    reason;
    /** The URL that failed to load. Empty string if not available. */
    url;
    /** The Response object, if any. */
    response;
  };

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function compareMIMETypes(mimeType1, mimeType2) {
    if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
      return true;
    }
    return false;
  }
  function parseMIMEType(mimeString) {
    const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(url) {
    const matches3 = DATA_URL_PATTERN.exec(url);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function extractQueryString(url) {
    const matches3 = url.match(QUERY_STRING_PATTERN);
    return matches3 && matches3[0];
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }
  function shortenUrlForDisplay(url) {
    if (url.length < 50) {
      return url;
    }
    const urlEnd = url.slice(url.length - 15);
    const urlStart = url.substr(0, 32);
    return `${urlStart}...${urlEnd}`;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
  function getResourceUrl(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.url;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.name || "";
    }
    if (typeof resource === "string") {
      return resource;
    }
    return "";
  }
  function getResourceMIMEType(resource) {
    if (isResponse(resource)) {
      const response = resource;
      const contentTypeHeader = response.headers.get("content-type") || "";
      const noQueryUrl = stripQueryString(response.url);
      return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.type || "";
    }
    if (typeof resource === "string") {
      return parseMIMETypeFromURL(resource);
    }
    return "";
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
  async function makeResponse(resource) {
    if (isResponse(resource)) {
      return resource;
    }
    const headers = {};
    const contentLength = getResourceContentLength(resource);
    if (contentLength >= 0) {
      headers["content-length"] = String(contentLength);
    }
    const url = getResourceUrl(resource);
    const type = getResourceMIMEType(resource);
    if (type) {
      headers["content-type"] = type;
    }
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
      headers["x-first-bytes"] = initialDataUrl;
    }
    if (typeof resource === "string") {
      resource = new TextEncoder().encode(resource);
    }
    const response = new Response(resource, { headers });
    Object.defineProperty(response, "url", { value: url });
    return response;
  }
  async function checkResponse(response) {
    if (!response.ok) {
      const error = await getResponseError(response);
      throw error;
    }
  }
  async function getResponseError(response) {
    const shortUrl = shortenUrlForDisplay(response.url);
    let message2 = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
    message2 = message2.length > 100 ? `${message2.slice(0, 100)}...` : message2;
    const info = {
      reason: response.statusText,
      url: response.url,
      response
    };
    try {
      const contentType = response.headers.get("Content-Type");
      info.reason = contentType?.includes("application/json") ? await response.json() : response.text();
    } catch (error) {
    }
    return new FetchError(message2, info);
  }
  async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") {
      return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
    }
    if (resource instanceof Blob) {
      const blobSlice = resource.slice(0, 5);
      return await new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onload = (event) => resolve2(event?.target?.result);
        reader.readAsDataURL(blobSlice);
      });
    }
    if (resource instanceof ArrayBuffer) {
      const slice = resource.slice(0, INITIAL_DATA_LENGTH);
      const base64 = arrayBufferToBase64(slice);
      return `data:base64,${base64}`;
    }
    return null;
  }
  function arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i5 = 0; i5 < bytes.byteLength; i5++) {
      binary += String.fromCharCode(bytes[i5]);
    }
    return btoa(binary);
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
  function isNodePath(url) {
    return !isRequestURL(url) && !isDataURL(url);
  }
  function isRequestURL(url) {
    return url.startsWith("http:") || url.startsWith("https:");
  }
  function isDataURL(url) {
    return url.startsWith("data:");
  }
  async function fetchFile(urlOrData, fetchOptions) {
    if (typeof urlOrData === "string") {
      const url = resolvePath(urlOrData);
      if (isNodePath(url)) {
        if (globalThis.loaders?.fetchNode) {
          return globalThis.loaders?.fetchNode(url, fetchOptions);
        }
      }
      return await fetch(url, fetchOptions);
    }
    return await makeResponse(urlOrData);
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
  var probeLog = new Log({ id: "loaders.gl" });
  var NullLog = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var ConsoleLog = class {
    console;
    constructor() {
      this.console = console;
    }
    log(...args) {
      return this.console.log.bind(this.console, ...args);
    }
    info(...args) {
      return this.console.info.bind(this.console, ...args);
    }
    warn(...args) {
      return this.console.warn.bind(this.console, ...args);
    }
    error(...args) {
      return this.console.error.bind(this.console, ...args);
    }
  };

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
  var DEFAULT_LOADER_OPTIONS = {
    // baseUri
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new ConsoleLog(),
    // A probe.gl compatible (`log.log()()` syntax) that just logs to console
    useLocalLibraries: false,
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    // By default, use worker if provided by loader.
    maxConcurrency: 3,
    // How many worker instances should be created for each loader.
    maxMobileConcurrency: 1,
    // How many worker instances should be created for each loader on mobile devices.
    reuseWorkers: isBrowser,
    // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
    _nodeWorkers: false,
    // By default do not support node workers
    _workerType: "",
    // 'test' to use locally generated workers
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
    transforms: []
  };
  var REMOVED_LOADER_OPTIONS = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    // Warn if fetch options are used on top-level
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
  function getGlobalLoaderState() {
    globalThis.loaders = globalThis.loaders || {};
    const { loaders } = globalThis;
    if (!loaders._state) {
      loaders._state = {};
    }
    return loaders._state;
  }
  function getGlobalLoaderOptions() {
    const state = getGlobalLoaderState();
    state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
    return state.globalOptions;
  }
  function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
  }
  function validateOptions(options, loaders) {
    validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
    for (const loader of loaders) {
      const idOptions = options && options[loader.id] || {};
      const loaderOptions = loader.options && loader.options[loader.id] || {};
      const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  }
  function validateOptionsObject(options, id, defaultOptions3, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? `${id}.` : "";
    for (const key in options) {
      const isSubOptions = !id && isObject(options[key]);
      const isBaseUriOption = key === "baseUri" && !id;
      const isWorkerUrlOption = key === "workerUrl" && id;
      if (!(key in defaultOptions3) && !isBaseUriOption && !isWorkerUrlOption) {
        if (key in deprecatedOptions) {
          probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
        } else if (!isSubOptions) {
          const suggestion = findSimilarOption(key, loaders);
          probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders) {
      for (const key in loader.options) {
        if (optionKey === key) {
          return `Did you mean '${loader.id}.${key}'?`;
        }
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
        }
      }
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = { ...loaderDefaultOptions };
    addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options) {
    for (const key in options) {
      if (key in options) {
        const value = options[key];
        if (isPureObject(value) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
          };
        } else {
          mergedOptions[key] = options[key];
        }
      }
    }
  }
  function addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) {
      options.baseUri = url;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
  function isLoaderObject(loader) {
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const hasExtensions = Array.isArray(loader?.extensions);
    return hasExtensions;
  }
  function normalizeLoader(loader) {
    assert2(loader, "null loader");
    assert2(isLoaderObject(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
      options = loader[1];
      loader = loader[0];
      loader = {
        ...loader,
        options: { ...loader.options, ...options }
      };
    }
    if (loader?.parseTextSync || loader?.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
  var getGlobalLoaderRegistry = () => {
    const state = getGlobalLoaderState();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
  };
  function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    for (const loader of loaders) {
      const normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
        loaderRegistry.unshift(normalizedLoader);
      }
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/log.js
  var log = new Log({ id: "loaders.gl" });

  // ../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
  var EXT_PATTERN = /\.([^.]+)$/;
  async function selectLoader(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
      return null;
    }
    let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
    if (loader) {
      return loader;
    }
    if (isBlob(data)) {
      data = await data.slice(0, 10).arrayBuffer();
      loader = selectLoaderSync(data, loaders, options, context);
    }
    if (!loader && !options?.nothrow) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderSync(data, loaders = [], options, context) {
    if (!validHTTPResponse(data)) {
      return null;
    }
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    let candidateLoaders = [];
    if (loaders) {
      candidateLoaders = candidateLoaders.concat(loaders);
    }
    if (!options?.ignoreRegisteredLoaders) {
      candidateLoaders.push(...getRegisteredLoaders());
    }
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !options?.nothrow) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderInternal(data, loaders, options, context) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    const testUrl = stripQueryString(url) || context?.url;
    let loader = null;
    let reason = "";
    if (options?.mimeType) {
      loader = findLoaderByMIMEType(loaders, options?.mimeType);
      reason = `match forced by supplied MIME type ${options?.mimeType}`;
    }
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? `matched url ${testUrl}` : "");
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? `matched MIME type ${type}` : "");
    loader = loader || findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? `matched initial data ${getFirstCharacters2(data)}` : "");
    if (options?.fallbackMimeType) {
      loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
      reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
    }
    if (reason) {
      log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
    }
    return loader;
  }
  function validHTTPResponse(data) {
    if (data instanceof Response) {
      if (data.status === 204) {
        return false;
      }
    }
    return true;
  }
  function getNoValidLoaderMessage(data) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    let message2 = "No valid loader found (";
    message2 += url ? `${path_exports.filename(url)}, ` : "no url provided, ";
    message2 += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
    const firstCharacters = data ? getFirstCharacters2(data) : "";
    message2 += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
    message2 += ")";
    return message2;
  }
  function normalizeLoaders(loaders) {
    for (const loader of loaders) {
      normalizeLoader(loader);
    }
  }
  function findLoaderByUrl(loaders, url) {
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders) {
      for (const loaderExtension of loader.extensions) {
        if (loaderExtension.toLowerCase() === extension) {
          return loader;
        }
      }
    }
    return null;
  }
  function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders) {
      if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
        return loader;
      }
      if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
        return loader;
      }
    }
    return null;
  }
  function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
      return null;
    }
    for (const loader of loaders) {
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    if (loader.testText) {
      return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => data.startsWith(test));
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => testBinary(data, byteOffset, loader, test));
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (typeof test) {
      case "function":
        return test(data);
      case "string":
        const magic = getMagicString2(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters2(data, length16 = 5) {
    if (typeof data === "string") {
      return data.slice(0, length16);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString2(data.buffer, data.byteOffset, length16);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString2(data, byteOffset, length16);
    }
    return "";
  }
  function getMagicString2(arrayBuffer2, byteOffset, length16) {
    if (arrayBuffer2.byteLength < byteOffset + length16) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i5 = 0; i5 < length16; i5++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i5));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
  var DEFAULT_CHUNK_SIZE = 256 * 1024;
  function* makeStringIterator(string, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while (offset < string.length) {
      const chunkLength = Math.min(string.length - offset, chunkSize);
      const chunk = string.slice(offset, offset + chunkLength);
      offset += chunkLength;
      yield textEncoder.encode(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
  var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  function* makeArrayBufferIterator(arrayBuffer2, options = {}) {
    const { chunkSize = DEFAULT_CHUNK_SIZE2 } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer2.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
  var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  async function* makeBlobIterator(blob, options) {
    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE3;
    let offset = 0;
    while (offset < blob.size) {
      const end = offset + chunkSize;
      const chunk = await blob.slice(offset, end).arrayBuffer();
      offset = end;
      yield chunk;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
  function makeStreamIterator(stream, options) {
    return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
  }
  async function* makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
      while (true) {
        const currentBatchPromise = nextBatchPromise || reader.read();
        if (options?._streamReadAhead) {
          nextBatchPromise = reader.read();
        }
        const { done, value } = await currentBatchPromise;
        if (done) {
          return;
        }
        yield toArrayBuffer2(value);
      }
    } catch (error) {
      reader.releaseLock();
    }
  }
  async function* makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream) {
      yield toArrayBuffer2(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
  function makeIterator(data, options) {
    if (typeof data === "string") {
      return makeStringIterator(data, options);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data, options);
    }
    if (isResponse(data)) {
      const response = data;
      return makeStreamIterator(response.body, options);
    }
    throw new Error("makeIterator");
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (isBuffer2(data)) {
      data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
      const arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data)) {
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(data);
      }
      let arrayBuffer2 = data.buffer;
      const byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
        arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return arrayBuffer2;
    }
    throw new Error(ERR_DATA);
  }
  async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) {
      return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    if (isBlob(data)) {
      data = await makeResponse(data);
    }
    if (isResponse(data)) {
      const response = data;
      await checkResponse(response);
      return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if (isReadableStream(data)) {
      data = makeIterator(data, options);
    }
    if (isIterable(data) || isAsyncIterable(data)) {
      return concatenateArrayBuffersAsync(data);
    }
    throw new Error(ERR_DATA);
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
  function getFetchFunction2(options, context) {
    const globalOptions = getGlobalLoaderOptions();
    const loaderOptions = options || globalOptions;
    if (typeof loaderOptions.fetch === "function") {
      return loaderOptions.fetch;
    }
    if (isObject(loaderOptions.fetch)) {
      return (url) => fetchFile(url, loaderOptions.fetch);
    }
    if (context?.fetch) {
      return context?.fetch;
    }
    return fetchFile;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
  function getLoaderContext(context, options, parentContext) {
    if (parentContext) {
      return parentContext;
    }
    const newContext = {
      fetch: getFetchFunction2(options, context),
      ...context
    };
    if (newContext.url) {
      const baseUrl = stripQueryString(newContext.url);
      newContext.baseUrl = baseUrl;
      newContext.queryString = extractQueryString(newContext.url);
      newContext.filename = path_exports.filename(baseUrl);
      newContext.baseUrl = path_exports.dirname(baseUrl);
    }
    if (!Array.isArray(newContext.loaders)) {
      newContext.loaders = null;
    }
    return newContext;
  }
  function getLoadersFromContext(loaders, context) {
    if (loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    let candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/parse.js
  async function parse(data, loaders, options, context) {
    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    data = await data;
    options = options || {};
    const url = getResourceUrl(data);
    const typedLoaders = loaders;
    const candidateLoaders = getLoadersFromContext(typedLoaders, context);
    const loader = await selectLoader(data, candidateLoaders, options);
    if (!loader) {
      return null;
    }
    options = normalizeOptions(options, loader, candidateLoaders, url);
    context = getLoaderContext(
      // @ts-expect-error
      { url, _parse: parse, loaders: candidateLoaders },
      options,
      context || null
    );
    return await parseWithLoader(loader, data, options, context);
  }
  async function parseWithLoader(loader, data, options, context) {
    validateWorkerVersion(loader);
    options = mergeLoaderOptions(loader.options, options);
    if (isResponse(data)) {
      const response = data;
      const { ok, redirected, status, statusText, type, url } = response;
      const headers = Object.fromEntries(response.headers.entries());
      context.response = { headers, ok, redirected, status, statusText, type, url };
    }
    data = await getArrayBufferOrStringFromData(data, loader, options);
    const loaderWithParser = loader;
    if (loaderWithParser.parseTextSync && typeof data === "string") {
      return loaderWithParser.parseTextSync(data, options, context);
    }
    if (canParseWithWorker(loader, options)) {
      return await parseWithWorker(loader, data, options, context, parse);
    }
    if (loaderWithParser.parseText && typeof data === "string") {
      return await loaderWithParser.parseText(data, options, context);
    }
    if (loaderWithParser.parse) {
      return await loaderWithParser.parse(data, options, context);
    }
    assert4(!loaderWithParser.parseSync);
    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
  function getDataTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return "int8";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int16Array:
        return "int16";
      case Uint16Array:
        return "uint16";
      case Int32Array:
        return "int32";
      case Uint32Array:
        return "uint32";
      case Float32Array:
        return "float32";
      case Float64Array:
        return "float64";
      default:
        return "null";
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/mesh/mesh-utils.js
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len8 = positions && positions.length;
    for (let i5 = 0; i5 < len8; i5 += 3) {
      const x3 = positions[i5];
      const y3 = positions[i5 + 1];
      const z2 = positions[i5 + 2];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      minZ = z2 < minZ ? z2 : minZ;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      maxZ = z2 > maxZ ? z2 : maxZ;
    }
    return [
      [minX, minY, minZ],
      [maxX, maxY, maxZ]
    ];
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js
  function deduceMeshField(name13, attribute, optionalMetadata) {
    const type = getDataTypeFromTypedArray(attribute.value);
    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
    return {
      name: name13,
      type: { type: "fixed-size-list", listSize: attribute.size, children: [{ name: "value", type }] },
      nullable: false,
      metadata
    };
  }
  function makeMeshAttributeMetadata(attribute) {
    const result = {};
    if ("byteOffset" in attribute) {
      result.byteOffset = attribute.byteOffset.toString(10);
    }
    if ("byteStride" in attribute) {
      result.byteStride = attribute.byteStride.toString(10);
    }
    if ("normalized" in attribute) {
      result.normalized = attribute.normalized.toString();
    }
    return result;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/load.js
  async function load(url, loaders, options, context) {
    let resolvedLoaders;
    let resolvedOptions;
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      resolvedLoaders = [];
      resolvedOptions = loaders;
      context = void 0;
    } else {
      resolvedLoaders = loaders;
      resolvedOptions = options;
    }
    const fetch2 = getFetchFunction2(resolvedOptions);
    let data = url;
    if (typeof url === "string") {
      data = await fetch2(url);
    }
    if (isBlob(url)) {
      data = await fetch2(url);
    }
    return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/utils/version.js
  var VERSION3 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
  var parseImageNode = globalThis.loaders?.parseImageNode;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas2 = document.createElement("canvas");
        const context = canvas2.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas2.width = image.width;
        canvas2.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error) {
        throw new Error(error.message);
      }
      const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve2, reject) => {
      try {
        image.onload = () => resolve2(image);
        image.onerror = (error) => {
          const message2 = error instanceof Error ? error.message : "error";
          reject(new Error(message2));
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error) {
        console.warn(error);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return { extension: "avif", mimeType: "image/avif" };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header, offset = 0) {
    const headerBytes = stringToBytes(header);
    for (let i5 = 0; i5 < headerBytes.length; ++i5) {
      if (headerBytes[i5] !== buffer[i5 + offset]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      // TODO - decode width and height
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const { tableMarkers, sofMarkers } = getJpegMarkers();
    let i5 = 2;
    while (i5 + 9 < dataView.byteLength) {
      const marker2 = dataView.getUint16(i5, BIG_ENDIAN);
      if (sofMarkers.has(marker2)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i5 + 5, BIG_ENDIAN),
          // Number of lines
          width: dataView.getUint16(i5 + 7, BIG_ENDIAN)
          // Number of pixels per line
        };
      }
      if (!tableMarkers.has(marker2)) {
        return null;
      }
      i5 += 2;
      i5 += dataView.getUint16(i5, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i5 = 65504; i5 < 65520; ++i5) {
      tableMarkers.add(i5);
    }
    const sofMarkers = /* @__PURE__ */ new Set([
      65472,
      65473,
      65474,
      65475,
      65477,
      65478,
      65479,
      65481,
      65482,
      65483,
      65485,
      65486,
      65487,
      65502
    ]);
    return { tableMarkers, sofMarkers };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options) {
    const { mimeType } = getBinaryImageMetadata(arrayBuffer2) || {};
    const parseImageNode2 = globalThis.loaders?.parseImageNode;
    assert2(parseImageNode2);
    return await parseImageNode2(arrayBuffer2, mimeType);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const { url } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options);
        break;
      default:
        assert2(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../../node_modules/@loaders.gl/images/dist/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = [
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
    "image/avif",
    "image/bmp",
    "image/vnd.microsoft.icon",
    "image/svg+xml"
  ];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
      // if format is HTML
    }
    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
  };
  var ImageLoader = {
    dataType: null,
    batchType: null,
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    // TODO: byteOffset, byteLength;
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/image-format.js
  var mimeTypeSupportedSync = {};
  function isImageFormatSupported(mimeType) {
    if (mimeTypeSupportedSync[mimeType] === void 0) {
      const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
      mimeTypeSupportedSync[mimeType] = supported;
    }
    return mimeTypeSupportedSync[mimeType];
  }
  function checkNodeImageFormatSupport(mimeType) {
    const NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
    const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;
    const parseImageNode2 = globalThis.loaders?.parseImageNode;
    return Boolean(parseImageNode2) && imageFormatsNode.includes(mimeType);
  }
  function checkBrowserImageFormatSupport(mimeType) {
    switch (mimeType) {
      case "image/avif":
      case "image/webp":
        return testBrowserImageFormatSupport(mimeType);
      default:
        return true;
    }
  }
  function testBrowserImageFormatSupport(mimeType) {
    try {
      const element = document.createElement("canvas");
      const dataURL = element.toDataURL(mimeType);
      return dataURL.indexOf(`data:${mimeType}`) === 0;
    } catch {
      return false;
    }
  }

  // ../core/src/utils/log.ts
  var defaultLogger = new Log({ id: "deck" });
  var log_default = defaultLogger;

  // ../core/src/debug/loggers.ts
  var logState = {
    attributeUpdateStart: -1,
    attributeManagerUpdateStart: -1,
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = (log3) => ({
    /* Layer events */
    "layer.changeFlag": (layer, key, flags) => {
      log3.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
    },
    "layer.initialize": (layer) => {
      log3.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
    },
    "layer.update": (layer, needsUpdate) => {
      if (needsUpdate) {
        const flags = layer.getChangeFlags();
        log3.log(
          LOG_LEVEL_MINOR_UPDATE,
          `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`
        )();
      } else {
        log3.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
      }
    },
    "layer.matched": (layer, changed) => {
      if (changed) {
        log3.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
      }
    },
    "layer.finalize": (layer) => {
      log3.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
    },
    /* CompositeLayer events */
    "compositeLayer.renderLayers": (layer, updated, subLayers) => {
      if (updated) {
        log3.log(
          LOG_LEVEL_MINOR_UPDATE,
          `Composite layer rendered new subLayers ${layer}`,
          subLayers
        )();
      } else {
        log3.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
      }
    },
    /* LayerManager events */
    "layerManager.setLayers": (layerManager, updated, layers) => {
      if (updated) {
        log3.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
      }
    },
    "layerManager.activateViewport": (layerManager, viewport) => {
      log3.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
    },
    /* AttributeManager events */
    "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
      log3.log(
        LOG_LEVEL_MAJOR_UPDATE,
        attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`
      )();
    },
    "attributeManager.updateStart": (attributeManager) => {
      logState.attributeUpdateMessages.length = 0;
      logState.attributeManagerUpdateStart = Date.now();
    },
    "attributeManager.updateEnd": (attributeManager, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
      log3.groupCollapsed(
        LOG_LEVEL_MINOR_UPDATE,
        `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`
      )();
      for (const updateMessage of logState.attributeUpdateMessages) {
        log3.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
      }
      log3.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
    },
    /* Attribute events */
    "attribute.updateStart": (attribute) => {
      logState.attributeUpdateStart = Date.now();
    },
    "attribute.allocate": (attribute, numInstances) => {
      const message2 = `${attribute.id} allocated ${numInstances}`;
      logState.attributeUpdateMessages.push(message2);
    },
    "attribute.updateEnd": (attribute, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
      const message2 = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
      logState.attributeUpdateMessages.push(message2);
    },
    /* Render events */
    "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
      const { pass, redrawReason, stats: stats2 } = opts;
      for (const status of renderStats) {
        const { totalCount, visibleCount, compositeCount, pickableCount } = status;
        const primitiveCount = totalCount - compositeCount;
        const hiddenCount = primitiveCount - visibleCount;
        log3.log(
          LOG_LEVEL_DRAW,
          `RENDER #${deckRenderer.renderCount}   ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason}   (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`
        )();
        if (stats2) {
          stats2.get("Redraw Layers").add(visibleCount);
        }
      }
    }
  });

  // ../core/src/debug/index.ts
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType, arg1, arg2, arg3) {
    if (log_default.level > 0 && loggers[eventType]) {
      loggers[eventType].call(null, arg1, arg2, arg3);
    }
  }

  // ../core/src/utils/json-loader.ts
  function isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    dataType: null,
    batchType: null,
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // ../core/src/lib/init.ts
  function checkVersion() {
    const version = typeof __VERSION__ !== "undefined" ? __VERSION__ : globalThis.DECK_VERSION || "untranspiled source";
    const existingVersion = globalThis.deck && globalThis.deck.VERSION;
    if (existingVersion && existingVersion !== version) {
      throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version}`);
    }
    if (!existingVersion) {
      log_default.log(1, `deck.gl ${version}`)();
      globalThis.deck = {
        ...globalThis.deck,
        VERSION: version,
        version,
        log: log_default,
        // experimental
        _registerLoggers: register
      };
      registerLoaders([
        json_loader_default,
        // @ts-expect-error non-standard Loader format
        [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]
      ]);
    }
    return version;
  }
  var VERSION4 = checkVersion();

  // ../../node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
  function assert5(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "shadertools: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
  var DEFAULT_PROP_VALIDATORS = {
    number: {
      type: "number",
      validate(value, propType) {
        return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
      }
    },
    array: {
      type: "array",
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function makePropValidators(propTypes) {
    const propValidators = {};
    for (const [name13, propType] of Object.entries(propTypes)) {
      propValidators[name13] = makePropValidator(propType);
    }
    return propValidators;
  }
  function makePropValidator(propType) {
    let type = getTypeOf(propType);
    if (type !== "object") {
      return { value: propType, ...DEFAULT_PROP_VALIDATORS[type], type };
    }
    if (typeof propType === "object") {
      if (!propType) {
        return { type: "object", value: null };
      }
      if (propType.type !== void 0) {
        return { ...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type };
      }
      if (propType.value === void 0) {
        return { type: "object", value: propType };
      }
      type = getTypeOf(propType.value);
      return { ...propType, ...DEFAULT_PROP_VALIDATORS[type], type };
    }
    throw new Error("props");
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/module-injectors.js
  var MODULE_INJECTORS_VS = (
    /* glsl */
    `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
  );
  var MODULE_INJECTORS_FS = (
    /* glsl */
    `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
  var MODULE_INJECTORS = {
    vertex: MODULE_INJECTORS_VS,
    fragment: MODULE_INJECTORS_FS
  };
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  function normalizeInjections(injections) {
    const result = { vertex: {}, fragment: {} };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = getHookStage(hook);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }
  function getHookStage(hook) {
    const type = hook.slice(0, 2);
    switch (type) {
      case "vs":
        return "vertex";
      case "fs":
        return "fragment";
      default:
        throw new Error(type);
    }
  }
  function injectShader(source3, stage, inject6, injectStandardStubs = false) {
    const isVertex = stage === "vertex";
    for (const key in inject6) {
      const fragmentData = inject6[key];
      fragmentData.sort((a3, b2) => a3.order - b2.order);
      fragments.length = fragmentData.length;
      for (let i5 = 0, len8 = fragmentData.length; i5 < len8; ++i5) {
        fragments[i5] = fragmentData[i5].injection;
      }
      const fragmentString = `${fragments.join("\n")}
`;
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source3 = source3.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source3 = source3.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source3 = source3.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source3 = source3.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source3 = source3.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source3 = source3.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source3 = source3.replace(key, (match) => match + fragmentString);
      }
    }
    source3 = source3.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source3 = source3.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
    }
    return source3;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module.js
  function initializeShaderModules(modules) {
    modules.map((module) => initializeShaderModule(module));
  }
  function initializeShaderModule(module) {
    if (module.instance) {
      return;
    }
    initializeShaderModules(module.dependencies || []);
    const {
      propTypes = {},
      deprecations = [],
      // defines = {},
      inject: inject6 = {}
    } = module;
    const instance = {
      normalizedInjections: normalizeInjections(inject6),
      parsedDeprecations: parseDeprecationDefinitions(deprecations)
    };
    if (propTypes) {
      instance.propValidators = makePropValidators(propTypes);
    }
    module.instance = instance;
    let defaultProps48 = {};
    if (propTypes) {
      defaultProps48 = Object.entries(propTypes).reduce((obj, [key, propType]) => {
        const value = propType?.value;
        if (value) {
          obj[key] = value;
        }
        return obj;
      }, {});
    }
    module.defaultUniforms = { ...module.defaultUniforms, ...defaultProps48 };
  }
  function checkShaderModuleDeprecations(shaderModule, shaderSource, log3) {
    shaderModule.deprecations?.forEach((def) => {
      if (def.regex?.test(shaderSource)) {
        if (def.deprecated) {
          log3.deprecated(def.old, def.new)();
        } else {
          log3.removed(def.old, def.new)();
        }
      }
    });
  }
  function parseDeprecationDefinitions(deprecations) {
    deprecations.forEach((def) => {
      switch (def.type) {
        case "function":
          def.regex = new RegExp(`\\b${def.old}\\(`);
          break;
        default:
          def.regex = new RegExp(`${def.type} ${def.old};`);
      }
    });
    return deprecations;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-dependencies.js
  function getShaderModuleDependencies(modules) {
    initializeShaderModules(modules);
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({ modules, level: 0, moduleMap, moduleDepth });
    const dependencies = Object.keys(moduleDepth).sort((a3, b2) => moduleDepth[b2] - moduleDepth[a3]).map((name13) => moduleMap[name13]);
    initializeShaderModules(dependencies);
    return dependencies;
  }
  function getDependencyGraph(options) {
    const { modules, level, moduleMap, moduleDepth } = options;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module of modules) {
      moduleMap[module.name] = module;
      if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
    for (const module of modules) {
      if (module.dependencies) {
        getDependencyGraph({ modules: module.dependencies, level: level + 1, moduleMap, moduleDepth });
      }
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
  function getPlatformShaderDefines(platformInfo) {
    switch (platformInfo?.gpu.toLowerCase()) {
      case "apple":
        return (
          /* glsl */
          `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
        );
      case "nvidia":
        return (
          /* glsl */
          `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
        );
      case "intel":
        return (
          /* glsl */
          `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
        );
      case "amd":
        return (
          /* glsl */
          `#define AMD_GPU
`
        );
      default:
        return (
          /* glsl */
          `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
        );
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
  function transpileGLSLShader(source3, stage) {
    const sourceGLSLVersion = Number(source3.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
    if (sourceGLSLVersion !== 300) {
      throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
    }
    switch (stage) {
      case "vertex":
        source3 = convertShader(source3, ES300_VERTEX_REPLACEMENTS);
        return source3;
      case "fragment":
        source3 = convertShader(source3, ES300_FRAGMENT_REPLACEMENTS);
        return source3;
      default:
        throw new Error(stage);
    }
  }
  var ES300_REPLACEMENTS = [
    // Fix poorly formatted version directive
    [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
    // The individual `texture...()` functions were replaced with `texture()` overloads
    [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
    [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
  ];
  var ES300_VERTEX_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `attribute` keyword replaced with `in`
    [makeVariableTextRegExp("attribute"), "in $1"],
    // `varying` keyword replaced with `out`
    [makeVariableTextRegExp("varying"), "out $1"]
  ];
  var ES300_FRAGMENT_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    // `varying` keyword replaced with `in`
    [makeVariableTextRegExp("varying"), "in $1"]
  ];
  function convertShader(source3, replacements) {
    for (const [pattern, replacement] of replacements) {
      source3 = source3.replace(pattern, replacement);
    }
    return source3;
  }
  function makeVariableTextRegExp(qualifier) {
    return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
  function getShaderHooks(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += `void ${hookFunction.signature} {
`;
      if (hookFunction.header) {
        result += `  ${hookFunction.header}`;
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a3, b2) => a3.order - b2.order);
        for (const injection of injections) {
          result += `  ${injection.injection}
`;
        }
      }
      if (hookFunction.footer) {
        result += `  ${hookFunction.footer}`;
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeShaderHooks(hookFunctions) {
    const result = { vertex: {}, fragment: {} };
    for (const hookFunction of hookFunctions) {
      let opts;
      let hook;
      if (typeof hookFunction !== "string") {
        opts = hookFunction;
        hook = opts.hook;
      } else {
        opts = {};
        hook = hookFunction;
      }
      hook = hook.trim();
      const [shaderStage, signature] = hook.split(":");
      const name13 = hook.replace(/\(.+/, "");
      const normalizedHook = Object.assign(opts, { signature });
      switch (shaderStage) {
        case "vs":
          result.vertex[name13] = normalizedHook;
          break;
        case "fs":
          result.fragment[name13] = normalizedHook;
          break;
        default:
          throw new Error(shaderStage);
      }
    }
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
  function getShaderInfo(source3, defaultName) {
    return {
      name: getShaderName(source3, defaultName),
      language: "glsl",
      version: getShaderVersion(source3)
    };
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion(source3) {
    let version = 100;
    const words = source3.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const parsedVersion = parseInt(words[1], 10);
      if (Number.isFinite(parsedVersion)) {
        version = parsedVersion;
      }
    }
    if (version !== 100 && version !== 300) {
      throw new Error(`Invalid GLSL version ${version}`);
    }
    return version;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
  var FRAGMENT_SHADER_PROLOGUE = (
    /* glsl */
    `precision highp float;
`
  );
  function assembleWGSLShader(options) {
    const modules = getShaderModuleDependencies(options.modules || []);
    return {
      source: assembleShaderWGSL(options.platformInfo, {
        ...options,
        source: options.source,
        stage: "vertex",
        modules
      }),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleGLSLShaderPair(options) {
    const { vs: vs14, fs: fs11 } = options;
    const modules = getShaderModuleDependencies(options.modules || []);
    return {
      vs: assembleShaderGLSL(options.platformInfo, {
        ...options,
        source: vs14,
        stage: "vertex",
        modules
      }),
      fs: assembleShaderGLSL(options.platformInfo, {
        ...options,
        // @ts-expect-error
        source: fs11,
        stage: "fragment",
        modules
      }),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShaderWGSL(platformInfo, options) {
    const {
      // id,
      source: source3,
      stage,
      modules,
      // defines = {},
      hookFunctions = [],
      inject: inject6 = {},
      log: log3
    } = options;
    assert5(typeof source3 === "string", "shader source must be a string");
    const coreSource = source3;
    let assembledSource = "";
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject6) {
      const injection = typeof inject6[key] === "string" ? { injection: inject6[key], order: 0 } : inject6[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name13 = match[3];
        if (hash) {
          if (name13 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    const modulesToInject = modules;
    for (const module of modulesToInject) {
      if (log3) {
        checkShaderModuleDeprecations(module, coreSource, log3);
      }
      const moduleSource = getShaderModuleSource(module, "wgsl");
      assembledSource += moduleSource;
      const injections = module.injections?.[stage] || {};
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name13 = match[2];
          const injectionType = name13 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    return assembledSource;
  }
  function assembleShaderGLSL(platformInfo, options) {
    const { id, source: source3, stage, language = "glsl", modules, defines: defines2 = {}, hookFunctions = [], inject: inject6 = {}, prologue = true, log: log3 } = options;
    assert5(typeof source3 === "string", "shader source must be a string");
    const sourceVersion = language === "glsl" ? getShaderInfo(source3).version : -1;
    const targetVersion = platformInfo.shaderLanguageVersion;
    const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
    const sourceLines = source3.split("\n");
    const coreSource = sourceLines.slice(1).join("\n");
    const allDefines = {};
    modules.forEach((module) => {
      Object.assign(allDefines, module.defines);
    });
    Object.assign(allDefines, defines2);
    let assembledSource = "";
    switch (language) {
      case "wgsl":
        break;
      case "glsl":
        assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({ id, source: source3, stage })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}

${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
        break;
    }
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject6) {
      const injection = typeof inject6[key] === "string" ? { injection: inject6[key], order: 0 } : inject6[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name13 = match[3];
        if (hash) {
          if (name13 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module of modules) {
      if (log3) {
        checkShaderModuleDeprecations(module, coreSource, log3);
      }
      const moduleSource = getShaderModuleSource(module, stage);
      assembledSource += moduleSource;
      const injections = module.instance?.normalizedInjections[stage] || {};
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name13 = match[2];
          const injectionType = name13 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    if (language === "glsl" && sourceVersion !== targetVersion) {
      assembledSource = transpileGLSLShader(assembledSource, stage);
    }
    return assembledSource.trim();
  }
  function assembleGetUniforms(modules) {
    return function getUniforms8(opts) {
      const uniforms = {};
      for (const module of modules) {
        const moduleUniforms = module.getUniforms?.(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderNameDefine(options) {
    const { id, source: source3, stage } = options;
    const injectShaderName = id && source3.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}` : "";
  }
  function getApplicationDefines(defines2 = {}) {
    let sourceText = "";
    for (const define2 in defines2) {
      const value = defines2[define2];
      if (value || Number.isFinite(value)) {
        sourceText += `#define ${define2.toUpperCase()} ${defines2[define2]}
`;
      }
    }
    return sourceText;
  }
  function getShaderModuleSource(module, stage) {
    let moduleSource;
    switch (stage) {
      case "vertex":
        moduleSource = module.vs || "";
        break;
      case "fragment":
        moduleSource = module.fs || "";
        break;
      case "wgsl":
        moduleSource = module.source || "";
        break;
      default:
        assert5(false);
    }
    if (!module.name) {
      throw new Error("Shader module must have a name");
    }
    const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    let source3 = `// ----- MODULE ${module.name} ---------------

`;
    if (stage !== "wgsl") {
      source3 += `#define MODULE_${moduleName}
`;
    }
    source3 += `${moduleSource}
`;
    return source3;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js
  var IFDEF_REGEXP = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/;
  var ENDIF_REGEXP = /^\s*\#\s*endif\s*$/;
  function preprocess(source3, options) {
    const lines = source3.split("\n");
    const output = [];
    let conditional = true;
    let currentDefine = null;
    for (const line of lines) {
      const matchIf = line.match(IFDEF_REGEXP);
      const matchEnd = line.match(ENDIF_REGEXP);
      if (matchIf) {
        currentDefine = matchIf[1];
        conditional = Boolean(options?.defines?.[currentDefine]);
      } else if (matchEnd) {
        conditional = true;
      } else if (conditional) {
        output.push(line);
      }
    }
    return output.join("\n");
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
  var _ShaderAssembler = class {
    /** Hook functions */
    _hookFunctions = [];
    /** Shader modules */
    _defaultModules = [];
    /**
     * A default shader assembler instance - the natural place to register default modules and hooks
     * @returns
     */
    static getDefaultShaderAssembler() {
      _ShaderAssembler.defaultShaderAssembler = _ShaderAssembler.defaultShaderAssembler || new _ShaderAssembler();
      return _ShaderAssembler.defaultShaderAssembler;
    }
    /**
     * Add a default module that does not have to be provided with every call to assembleShaders()
     */
    addDefaultModule(module) {
      if (!this._defaultModules.find((m) => m.name === (typeof module === "string" ? module : module.name))) {
        this._defaultModules.push(module);
      }
    }
    /**
     * Remove a default module
     */
    removeDefaultModule(module) {
      const moduleName = typeof module === "string" ? module : module.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
    }
    /**
     * Register a shader hook
     * @param hook
     * @param opts
     */
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, { hook });
      }
      this._hookFunctions.push(hook);
    }
    /**
     * Assemble a WGSL unified shader
     * @param platformInfo
     * @param props
     * @returns
     */
    assembleWGSLShader(props) {
      const modules = this._getModuleList(props.modules);
      const hookFunctions = this._hookFunctions;
      const { source: source3, getUniforms: getUniforms8 } = assembleWGSLShader({
        ...props,
        // @ts-expect-error
        source: props.source,
        modules,
        hookFunctions
      });
      const preprocessedSource = props.platformInfo.shaderLanguage === "wgsl" ? preprocess(source3) : source3;
      return { source: preprocessedSource, getUniforms: getUniforms8, modules };
    }
    /**
     * Assemble a pair of shaders into a single shader program
     * @param platformInfo
     * @param props
     * @returns
     */
    assembleGLSLShaderPair(props) {
      const modules = this._getModuleList(props.modules);
      const hookFunctions = this._hookFunctions;
      const assembled = assembleGLSLShaderPair({
        ...props,
        // @ts-expect-error
        vs: props.vs,
        // @ts-expect-error
        fs: props.fs,
        modules,
        hookFunctions
      });
      return { ...assembled, modules };
    }
    /**
     * Dedupe and combine with default modules
     */
    _getModuleList(appModules = []) {
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count3 = 0;
      for (let i5 = 0, len8 = this._defaultModules.length; i5 < len8; ++i5) {
        const module = this._defaultModules[i5];
        const name13 = module.name;
        modules[count3++] = module;
        seen[name13] = true;
      }
      for (let i5 = 0, len8 = appModules.length; i5 < len8; ++i5) {
        const module = appModules[i5];
        const name13 = module.name;
        if (!seen[name13]) {
          modules[count3++] = module;
          seen[name13] = true;
        }
      }
      modules.length = count3;
      initializeShaderModules(modules);
      return modules;
    }
  };
  var ShaderAssembler = _ShaderAssembler;
  /** Default ShaderAssembler instance */
  __publicField(ShaderAssembler, "defaultShaderAssembler");

  // ../../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
  var FS_GLES = (
    /* glsl */
    `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
  );
  var FS300 = `#version 300 es
${FS_GLES}`;
  function getPassthroughFS(options) {
    const { input, inputChannels, output } = options || {};
    if (!input) {
      return FS300;
    }
    if (!inputChannels) {
      throw new Error("inputChannels");
    }
    const inputType = channelCountToType(inputChannels);
    const outputValue = convertToVec4(input, inputChannels);
    return `#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
  }
  function channelCountToType(channels) {
    switch (channels) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }
  function convertToVec4(variable, channels) {
    switch (channels) {
      case 1:
        return `vec4(${variable}, 0.0, 0.0, 1.0)`;
      case 2:
        return `vec4(${variable}, 0.0, 1.0)`;
      case 3:
        return `vec4(${variable}, 1.0)`;
      case 4:
        return variable;
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }

  // ../../node_modules/@luma.gl/core/dist/utils/stats-manager.js
  var StatsManager = class {
    stats = /* @__PURE__ */ new Map();
    getStats(name13) {
      return this.get(name13);
    }
    get(name13) {
      if (!this.stats.has(name13)) {
        this.stats.set(name13, new Stats({ id: name13 }));
      }
      return this.stats.get(name13);
    }
  };
  var lumaStats = new StatsManager();

  // ../../node_modules/@luma.gl/core/dist/utils/log.js
  var log2 = new Log({ id: "luma.gl" });

  // ../../node_modules/@luma.gl/core/dist/utils/uid.js
  var uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count3 = uidCounters[id]++;
    return `${id}-${count3}`;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/resource.js
  var Resource = class {
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
    }
    /** props.id, for debugging. */
    id;
    props;
    userData = {};
    _device;
    /** Whether this resource has been destroyed */
    destroyed = false;
    /** For resources that allocate GPU memory */
    allocatedBytes = 0;
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    _attachedResources = /* @__PURE__ */ new Set();
    /**
     * Create a new Resource. Called from Subclass
     */
    constructor(device, props, defaultProps48) {
      if (!device) {
        throw new Error("no device");
      }
      this._device = device;
      this.props = selectivelyMerge(props, defaultProps48);
      const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
      this.props.id = id;
      this.id = id;
      this.userData = this.props.userData || {};
      this.addStats();
    }
    /**
     * destroy can be called on any resource to release it before it is garbage collected.
     */
    destroy() {
      this.destroyResource();
    }
    /** @deprecated Use destroy() */
    delete() {
      this.destroy();
      return this;
    }
    /**
     * Combines a map of user props and default props, only including props from defaultProps
     * @returns returns a map of overridden default props
     */
    getProps() {
      return this.props;
    }
    // ATTACHED RESOURCES
    /**
     * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
     * Called automatically when sub resources are auto created but can be called by application
     */
    attachResource(resource) {
      this._attachedResources.add(resource);
    }
    /**
     * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
     */
    detachResource(resource) {
      this._attachedResources.delete(resource);
    }
    /**
     * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
     */
    destroyAttachedResource(resource) {
      if (this._attachedResources.delete(resource)) {
        resource.destroy();
      }
    }
    /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
    destroyAttachedResources() {
      for (const resource of Object.values(this._attachedResources)) {
        resource.destroy();
      }
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    // PROTECTED METHODS
    /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
    destroyResource() {
      this.destroyAttachedResources();
      this.removeStats();
      this.destroyed = true;
    }
    /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
    removeStats() {
      const stats2 = this._device.statsManager.getStats("Resource Counts");
      const name13 = this[Symbol.toStringTag];
      stats2.get(`${name13}s Active`).decrementCount();
    }
    /** Called by subclass to track memory allocations */
    trackAllocatedMemory(bytes, name13 = this[Symbol.toStringTag]) {
      const stats2 = this._device.statsManager.getStats("Resource Counts");
      stats2.get("GPU Memory").addCount(bytes);
      stats2.get(`${name13} Memory`).addCount(bytes);
      this.allocatedBytes = bytes;
    }
    /** Called by subclass to track memory deallocations */
    trackDeallocatedMemory(name13 = this[Symbol.toStringTag]) {
      const stats2 = this._device.statsManager.getStats("Resource Counts");
      stats2.get("GPU Memory").subtractCount(this.allocatedBytes);
      stats2.get(`${name13} Memory`).subtractCount(this.allocatedBytes);
      this.allocatedBytes = 0;
    }
    /** Called by resource constructor to track object creation */
    addStats() {
      const stats2 = this._device.statsManager.getStats("Resource Counts");
      const name13 = this[Symbol.toStringTag];
      stats2.get("Resources Created").incrementCount();
      stats2.get(`${name13}s Created`).incrementCount();
      stats2.get(`${name13}s Active`).incrementCount();
    }
  };
  /** Default properties for resource */
  __publicField(Resource, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  });
  function selectivelyMerge(props, defaultProps48) {
    const mergedProps = { ...defaultProps48 };
    for (const key in props) {
      if (props[key] !== void 0) {
        mergedProps[key] = props[key];
      }
    }
    return mergedProps;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/buffer.js
  var _Buffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    /** The usage with which this buffer was created */
    usage;
    /** For index buffers, whether indices are 16 or 32 bit */
    indexType;
    /** "Time" of last update, can be used to check if redraw is needed */
    updateTimestamp;
    constructor(device, props) {
      const deducedProps = { ...props };
      if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          deducedProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          deducedProps.indexType = "uint16";
        }
      }
      delete deducedProps.data;
      super(device, deducedProps, _Buffer.defaultProps);
      this.usage = deducedProps.usage || 0;
      this.indexType = deducedProps.indexType;
      this.updateTimestamp = device.incrementTimestamp();
    }
    /**
     * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
     * @note Does not copy contents of the cloned Buffer.
     */
    clone(props) {
      return this.device.createBuffer({ ...this.props, ...props });
    }
    /** Read data synchronously. @note WebGL2 only */
    readSyncWebGL(byteOffset, byteLength) {
      throw new Error("not implemented");
    }
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    debugData = new ArrayBuffer(0);
    /** This doesn't handle partial non-zero offset updates correctly */
    _setDebugData(data, byteOffset, byteLength) {
      const arrayBuffer2 = ArrayBuffer.isView(data) ? data.buffer : data;
      const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
      if (arrayBuffer2 === null) {
        this.debugData = new ArrayBuffer(debugDataLength);
      } else if (byteOffset === 0 && byteLength === arrayBuffer2.byteLength) {
        this.debugData = arrayBuffer2.slice(0, debugDataLength);
      } else {
        this.debugData = arrayBuffer2.slice(byteOffset, byteOffset + debugDataLength);
      }
    }
  };
  var Buffer2 = _Buffer;
  __publicField(Buffer2, "defaultProps", {
    ...Resource.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  // Usage Flags
  __publicField(Buffer2, "MAP_READ", 1);
  __publicField(Buffer2, "MAP_WRITE", 2);
  __publicField(Buffer2, "COPY_SRC", 4);
  __publicField(Buffer2, "COPY_DST", 8);
  /** Index buffer */
  __publicField(Buffer2, "INDEX", 16);
  /** Vertex buffer */
  __publicField(Buffer2, "VERTEX", 32);
  /** Uniform buffer */
  __publicField(Buffer2, "UNIFORM", 64);
  /** Storage buffer */
  __publicField(Buffer2, "STORAGE", 128);
  __publicField(Buffer2, "INDIRECT", 256);
  __publicField(Buffer2, "QUERY_RESOLVE", 512);
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  __publicField(Buffer2, "DEBUG_DATA_MAX_LENGTH", 32);

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/decode-data-type.js
  function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes("norm");
    const integer = !normalized && !type.startsWith("float");
    const signed = type.startsWith("s");
    return {
      dataType: TYPE_MAP[type],
      byteLength: bytes,
      integer,
      signed,
      normalized
    };
  }
  function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES[type];
    return bytes;
  }
  var TYPE_MAP = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  };
  var TYPE_SIZES = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  };

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-table.js
  var texture_compression_bc = "texture-compression-bc";
  var texture_compression_astc = "texture-compression-astc";
  var texture_compression_etc2 = "texture-compression-etc2";
  var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
  var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
  var texture_compression_atc_webgl = "texture-compression-atc-webgl";
  var float32_renderable = "float32-renderable-webgl";
  var float16_renderable = "float16-renderable-webgl";
  var rgb9e5ufloat_renderable = "rgb9e5ufloat-renderable-webgl";
  var snorm8_renderable = "snorm8-renderable-webgl";
  var norm16_renderable = "norm16-renderable-webgl";
  var snorm16_renderable = "snorm16-renderable-webgl";
  var float32_filterable = "float32-filterable";
  var float16_filterable = "float16-filterable-webgl";
  function getTextureFormatDefinition(format) {
    const info = TEXTURE_FORMAT_TABLE[format];
    if (!info) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return info;
  }
  var TEXTURE_FORMAT_TABLE = {
    // 8-bit formats
    "r8unorm": {},
    "r8snorm": { render: snorm8_renderable },
    "r8uint": {},
    "r8sint": {},
    // 16-bit formats
    "rg8unorm": {},
    "rg8snorm": { render: snorm8_renderable },
    "rg8uint": {},
    "rg8sint": {},
    "r16uint": {},
    "r16sint": {},
    "r16float": { render: float16_renderable, filter: "float16-filterable-webgl" },
    "r16unorm-webgl": { f: norm16_renderable },
    "r16snorm-webgl": { f: snorm16_renderable },
    // Packed 16-bit formats
    "rgba4unorm-webgl": { channels: "rgba", bitsPerChannel: [4, 4, 4, 4], packed: true },
    "rgb565unorm-webgl": { channels: "rgb", bitsPerChannel: [5, 6, 5, 0], packed: true },
    "rgb5a1unorm-webgl": { channels: "rgba", bitsPerChannel: [5, 5, 5, 1], packed: true },
    // 24-bit formats
    "rgb8unorm-webgl": {},
    "rgb8snorm-webgl": {},
    // 32-bit formats  
    "rgba8unorm": {},
    "rgba8unorm-srgb": {},
    "rgba8snorm": { render: snorm8_renderable },
    "rgba8uint": {},
    "rgba8sint": {},
    // 32-bit, reverse colors, webgpu only
    "bgra8unorm": {},
    "bgra8unorm-srgb": {},
    "rg16uint": {},
    "rg16sint": {},
    "rg16float": { render: float16_renderable, filter: float16_filterable },
    "rg16unorm-webgl": { render: norm16_renderable },
    "rg16snorm-webgl": { render: snorm16_renderable },
    "r32uint": {},
    "r32sint": {},
    "r32float": { render: float32_renderable, filter: float32_filterable },
    // Packed 32 bit formats
    "rgb9e5ufloat": { channels: "rgb", packed: true, render: rgb9e5ufloat_renderable },
    // , filter: true},
    "rg11b10ufloat": { channels: "rgb", bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1, render: float32_renderable },
    "rgb10a2unorm": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1 },
    "rgb10a2uint-webgl": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1, wgpu: false },
    // 48-bit formats
    "rgb16unorm-webgl": { f: norm16_renderable },
    // rgb not renderable
    "rgb16snorm-webgl": { f: norm16_renderable },
    // rgb not renderable
    // 64-bit formats
    "rg32uint": {},
    "rg32sint": {},
    "rg32float": { render: false, filter: float32_filterable },
    "rgba16uint": {},
    "rgba16sint": {},
    "rgba16float": { render: float16_renderable, filter: float16_filterable },
    "rgba16unorm-webgl": { render: norm16_renderable },
    "rgba16snorm-webgl": { render: snorm16_renderable },
    // 96-bit formats (deprecated!)
    "rgb32float-webgl": { render: float32_renderable, filter: float32_filterable },
    // 128-bit formats
    "rgba32uint": {},
    "rgba32sint": {},
    "rgba32float": { render: float32_renderable, filter: float32_filterable },
    // Depth/stencil
    // Depth and stencil formats
    stencil8: { attachment: "stencil", bitsPerChannel: [8, 0, 0, 0], dataType: "uint8" },
    "depth16unorm": { attachment: "depth", bitsPerChannel: [16, 0, 0, 0], dataType: "uint16" },
    "depth24plus": { attachment: "depth", bitsPerChannel: [24, 0, 0, 0], dataType: "uint32" },
    "depth32float": { attachment: "depth", bitsPerChannel: [32, 0, 0, 0], dataType: "float32" },
    // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
    "depth24plus-stencil8": { attachment: "depth-stencil", bitsPerChannel: [24, 8, 0, 0], packed: true },
    // "depth32float-stencil8" feature
    "depth32float-stencil8": { attachment: "depth-stencil", bitsPerChannel: [32, 8, 0, 0], packed: true },
    // BC compressed formats: check device.features.has("texture-compression-bc");
    "bc1-rgb-unorm-webgl": { f: texture_compression_bc },
    "bc1-rgb-unorm-srgb-webgl": { f: texture_compression_bc },
    "bc1-rgba-unorm": { f: texture_compression_bc },
    "bc1-rgba-unorm-srgb": { f: texture_compression_bc },
    "bc2-rgba-unorm": { f: texture_compression_bc },
    "bc2-rgba-unorm-srgb": { f: texture_compression_bc },
    "bc3-rgba-unorm": { f: texture_compression_bc },
    "bc3-rgba-unorm-srgb": { f: texture_compression_bc },
    "bc4-r-unorm": { f: texture_compression_bc },
    "bc4-r-snorm": { f: texture_compression_bc },
    "bc5-rg-unorm": { f: texture_compression_bc },
    "bc5-rg-snorm": { f: texture_compression_bc },
    "bc6h-rgb-ufloat": { f: texture_compression_bc },
    "bc6h-rgb-float": { f: texture_compression_bc },
    "bc7-rgba-unorm": { f: texture_compression_bc },
    "bc7-rgba-unorm-srgb": { f: texture_compression_bc },
    // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
    // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
    "etc2-rgb8unorm": { f: texture_compression_etc2 },
    "etc2-rgb8unorm-srgb": { f: texture_compression_etc2 },
    "etc2-rgb8a1unorm": { f: texture_compression_etc2 },
    "etc2-rgb8a1unorm-srgb": { f: texture_compression_etc2 },
    "etc2-rgba8unorm": { f: texture_compression_etc2 },
    "etc2-rgba8unorm-srgb": { f: texture_compression_etc2 },
    "eac-r11unorm": { f: texture_compression_etc2 },
    "eac-r11snorm": { f: texture_compression_etc2 },
    "eac-rg11unorm": { f: texture_compression_etc2 },
    "eac-rg11snorm": { f: texture_compression_etc2 },
    // X_ASTC compressed formats: device.features.has("texture-compression-astc")
    "astc-4x4-unorm": { f: texture_compression_astc },
    "astc-4x4-unorm-srgb": { f: texture_compression_astc },
    "astc-5x4-unorm": { f: texture_compression_astc },
    "astc-5x4-unorm-srgb": { f: texture_compression_astc },
    "astc-5x5-unorm": { f: texture_compression_astc },
    "astc-5x5-unorm-srgb": { f: texture_compression_astc },
    "astc-6x5-unorm": { f: texture_compression_astc },
    "astc-6x5-unorm-srgb": { f: texture_compression_astc },
    "astc-6x6-unorm": { f: texture_compression_astc },
    "astc-6x6-unorm-srgb": { f: texture_compression_astc },
    "astc-8x5-unorm": { f: texture_compression_astc },
    "astc-8x5-unorm-srgb": { f: texture_compression_astc },
    "astc-8x6-unorm": { f: texture_compression_astc },
    "astc-8x6-unorm-srgb": { f: texture_compression_astc },
    "astc-8x8-unorm": { f: texture_compression_astc },
    "astc-8x8-unorm-srgb": { f: texture_compression_astc },
    "astc-10x5-unorm": { f: texture_compression_astc },
    "astc-10x5-unorm-srgb": { f: texture_compression_astc },
    "astc-10x6-unorm": { f: texture_compression_astc },
    "astc-10x6-unorm-srgb": { f: texture_compression_astc },
    "astc-10x8-unorm": { f: texture_compression_astc },
    "astc-10x8-unorm-srgb": { f: texture_compression_astc },
    "astc-10x10-unorm": { f: texture_compression_astc },
    "astc-10x10-unorm-srgb": { f: texture_compression_astc },
    "astc-12x10-unorm": { f: texture_compression_astc },
    "astc-12x10-unorm-srgb": { f: texture_compression_astc },
    "astc-12x12-unorm": { f: texture_compression_astc },
    "astc-12x12-unorm-srgb": { f: texture_compression_astc },
    // WEBGL_compressed_texture_pvrtc
    "pvrtc-rgb4unorm-webgl": { f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba4unorm-webgl": { f: texture_compression_pvrtc_webgl },
    "pvrtc-rbg2unorm-webgl": { f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba2unorm-webgl": { f: texture_compression_pvrtc_webgl },
    // WEBGL_compressed_texture_etc1
    "etc1-rbg-unorm-webgl": { f: texture_compression_etc1_webgl },
    // WEBGL_compressed_texture_atc
    "atc-rgb-unorm-webgl": { f: texture_compression_atc_webgl },
    "atc-rgba-unorm-webgl": { f: texture_compression_atc_webgl },
    "atc-rgbai-unorm-webgl": { f: texture_compression_atc_webgl }
  };

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/decode-texture-format.js
  var COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
    "bc1",
    "bc2",
    "bc3",
    "bc4",
    "bc5",
    "bc6",
    "bc7",
    "etc1",
    "etc2",
    "eac",
    "atc",
    "astc",
    "pvrtc"
  ];
  var RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
  function isTextureFormatCompressed(format) {
    return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix) => format.startsWith(prefix));
  }
  function decodeTextureFormat(format) {
    let formatInfo = decodeTextureFormatUsingTable(format);
    if (isTextureFormatCompressed(format)) {
      formatInfo.channels = "rgb";
      formatInfo.components = 3;
      formatInfo.bytesPerPixel = 1;
      formatInfo.srgb = false;
      formatInfo.compressed = true;
      const blockSize = getCompressedTextureBlockSize(format);
      if (blockSize) {
        formatInfo.blockWidth = blockSize.blockWidth;
        formatInfo.blockHeight = blockSize.blockHeight;
      }
    }
    const matches3 = RGB_FORMAT_REGEX.exec(format);
    if (matches3) {
      const [, channels, length16, type, srgb, suffix] = matches3;
      const dataType = `${type}${length16}`;
      const decodedType = decodeVertexType(dataType);
      const bits = decodedType.byteLength * 8;
      const components = channels.length;
      const bitsPerChannel = [
        bits,
        components >= 2 ? bits : 0,
        components >= 3 ? bits : 0,
        components >= 4 ? bits : 0
      ];
      formatInfo = {
        format,
        attachment: formatInfo.attachment,
        dataType: decodedType.dataType,
        components,
        channels,
        integer: decodedType.integer,
        signed: decodedType.signed,
        normalized: decodedType.normalized,
        bitsPerChannel,
        bytesPerPixel: decodedType.byteLength * channels.length,
        packed: formatInfo.packed,
        srgb: formatInfo.srgb
      };
      if (suffix === "-webgl") {
        formatInfo.webgl = true;
      }
      if (srgb === "-srgb") {
        formatInfo.srgb = true;
      }
    }
    if (format.endsWith("-webgl")) {
      formatInfo.webgl = true;
    }
    if (format.endsWith("-srgb")) {
      formatInfo.srgb = true;
    }
    return formatInfo;
  }
  function decodeTextureFormatUsingTable(format) {
    const info = getTextureFormatDefinition(format);
    const bytesPerPixel = info.bytesPerPixel || 1;
    const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];
    delete info.bitsPerChannel;
    delete info.bytesPerPixel;
    delete info.f;
    delete info.render;
    delete info.filter;
    delete info.blend;
    delete info.store;
    const formatInfo = {
      ...info,
      format,
      attachment: info.attachment || "color",
      channels: info.channels || "r",
      components: info.components || info.channels?.length || 1,
      bytesPerPixel,
      bitsPerChannel,
      dataType: info.dataType || "uint8",
      srgb: info.srgb ?? false,
      packed: info.packed ?? false,
      webgl: info.webgl ?? false,
      integer: info.integer ?? false,
      signed: info.signed ?? false,
      normalized: info.normalized ?? false,
      compressed: info.compressed ?? false
    };
    return formatInfo;
  }
  function getCompressedTextureBlockSize(format) {
    const REGEX = /.*-(\d+)x(\d+)-.*/;
    const matches3 = REGEX.exec(format);
    if (matches3) {
      const [, blockWidth, blockHeight] = matches3;
      return { blockWidth: Number(blockWidth), blockHeight: Number(blockHeight) };
    }
    return null;
  }

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/texture-format-capabilities.js
  function getTextureFormatCapabilities(format) {
    const info = getTextureFormatDefinition(format);
    const formatCapabilities = {
      format,
      create: info.f ?? true,
      render: info.render ?? true,
      filter: info.filter ?? true,
      blend: info.blend ?? true,
      store: info.store ?? true
    };
    const formatInfo = decodeTextureFormat(format);
    const isDepthStencil = format.startsWith("depth") || format.startsWith("stencil");
    const isSigned = formatInfo?.signed;
    const isInteger = formatInfo?.integer;
    const isWebGLSpecific = formatInfo?.webgl;
    formatCapabilities.render &&= !isSigned;
    formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;
    return formatCapabilities;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/device.js
  var DeviceLimits = class {
  };
  var DeviceFeatures = class {
    features;
    disabledFeatures;
    constructor(features = [], disabledFeatures) {
      this.features = new Set(features);
      this.disabledFeatures = disabledFeatures || {};
    }
    *[Symbol.iterator]() {
      yield* this.features;
    }
    has(feature) {
      return !this.disabledFeatures?.[feature] && this.features.has(feature);
    }
  };
  var _Device = class {
    get [Symbol.toStringTag]() {
      return "Device";
    }
    constructor(props) {
      this.props = { ..._Device.defaultProps, ...props };
      this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    /** id of this device, primarily for debugging */
    id;
    /** A copy of the device props  */
    props;
    /** Available for the application to store data on the device */
    userData = {};
    /** stats */
    statsManager = lumaStats;
    /** An abstract timestamp used for change tracking */
    timestamp = 0;
    /** True if this device has been reused during device creation (app has multiple references) */
    _reused = false;
    /** Used by other luma.gl modules to store data on the device */
    _lumaData = {};
    /** Determines what operations are supported on a texture format, checking against supported device features */
    getTextureFormatCapabilities(format) {
      const genericCapabilities = getTextureFormatCapabilities(format);
      const checkFeature = (featureOrBoolean) => (typeof featureOrBoolean === "string" ? this.features.has(featureOrBoolean) : featureOrBoolean) ?? true;
      const supported = checkFeature(genericCapabilities.create);
      const deviceCapabilities = {
        format,
        create: supported,
        render: supported && checkFeature(genericCapabilities.render),
        filter: supported && checkFeature(genericCapabilities.filter),
        blend: supported && checkFeature(genericCapabilities.blend),
        store: supported && checkFeature(genericCapabilities.store)
      };
      return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);
    }
    /** Check if device supports a specific texture format (creation and `nearest` sampling) */
    isTextureFormatSupported(format, capabilities) {
      return this.getTextureFormatCapabilities(format).create;
    }
    /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
    isTextureFormatFilterable(format) {
      return this.getTextureFormatCapabilities(format).filter;
    }
    /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
    isTextureFormatRenderable(format) {
      return this.getTextureFormatCapabilities(format).render;
    }
    /** Check if a specific texture format is GPU compressed */
    isTextureFormatCompressed(format) {
      return isTextureFormatCompressed(format);
    }
    /**
     * Trigger device loss.
     * @returns `true` if context loss could actually be triggered.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice() {
      return false;
    }
    /** Report error (normally called for unhandled device errors) */
    reportError(error) {
      this.props.onError(error);
    }
    /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
    getDefaultCanvasContext() {
      if (!this.canvasContext) {
        throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
      }
      return this.canvasContext;
    }
    createCommandEncoder(props = {}) {
      throw new Error("not implemented");
    }
    /** A monotonic counter for tracking buffer and texture updates */
    incrementTimestamp() {
      return this.timestamp++;
    }
    // Error Handling
    /** Report unhandled device errors */
    onError(error) {
      this.props.onError(error);
    }
    // DEPRECATED METHODS
    /** @deprecated Use getDefaultCanvasContext() */
    getCanvasContext() {
      return this.getDefaultCanvasContext();
    }
    // WebGL specific HACKS - enables app to remove webgl import
    // Use until we have a better way to handle these
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToArrayWebGL(source3, options) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToBufferWebGL(source3, options) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    setParametersWebGL(parameters2) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    getParametersWebGL(parameters2) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    withParametersWebGL(parameters2, func) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use clear arguments in RenderPass */
    clearWebGL(options) {
      throw new Error("not implemented");
    }
    /** @deprecated - will be removed - should use for debugging only */
    resetWebGL() {
      throw new Error("not implemented");
    }
    // IMPLEMENTATION
    /** Helper to get the canvas context props */
    static _getCanvasContextProps(props) {
      return props.createCanvasContext === true ? {} : props.createCanvasContext;
    }
    /** Subclasses use this to support .createBuffer() overloads */
    _normalizeBufferProps(props) {
      if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
        props = { data: props };
      }
      const newProps = { ...props };
      if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else {
          log2.warn("indices buffer content must be of integer type")();
        }
      }
      return newProps;
    }
  };
  var Device = _Device;
  __publicField(Device, "defaultProps", {
    id: null,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: false,
    createCanvasContext: void 0,
    // Callbacks
    onError: (error) => log2.error(error.message)(),
    // Experimental
    _reuseDevices: false,
    _requestMaxLimits: true,
    _factoryDestroyPolicy: "unused",
    // TODO - Change these after confirming things work as expected
    _initializeFeatures: true,
    _disabledFeatures: {
      "compilation-status-async-webgl": true
    },
    _resourceDefaults: {},
    // WebGL specific
    webgl: {},
    debug: log2.get("debug") || void 0,
    debugShaders: log2.get("debug-shaders") || void 0,
    debugFramebuffers: Boolean(log2.get("debug-framebuffers")),
    debugWebGL: Boolean(log2.get("debug-webgl")),
    debugSpectorJS: void 0,
    // Note: log setting is queried by the spector.js code
    debugSpectorJSUrl: void 0,
    // INTERNAL
    _handle: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/luma.js
  var isPage = isBrowser2() && typeof document !== "undefined";
  var isPageLoaded = () => isPage && document.readyState === "complete";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var ERROR_MESSAGE = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
  var _Luma = class {
    /** Global stats for all devices */
    stats = lumaStats;
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    log = log2;
    /** Version of luma.gl */
    VERSION = (
      // Version detection using build plugin
      // @ts-expect-error no-undef
      true ? "9.1.5" : "running from source"
    );
    spector;
    preregisteredAdapters = /* @__PURE__ */ new Map();
    constructor() {
      if (globalThis.luma) {
        if (globalThis.luma.VERSION !== this.VERSION) {
          log2.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();
          log2.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();
          throw new Error(`luma.gl - multiple versions detected: see console log`);
        }
        log2.error("This version of luma.gl has already been initialized")();
      }
      log2.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();
      globalThis.luma = this;
    }
    registerAdapters(adapters) {
      for (const deviceClass of adapters) {
        this.preregisteredAdapters.set(deviceClass.type, deviceClass);
      }
    }
    /** Get type strings for supported Devices */
    getSupportedAdapters(adapters = []) {
      const adapterMap = this.getAdapterMap(adapters);
      return Array.from(adapterMap).map(([, adapter]) => adapter).filter((adapter) => adapter.isSupported?.()).map((adapter) => adapter.type);
    }
    /** Get type strings for best available Device */
    getBestAvailableAdapter(adapters = []) {
      const adapterMap = this.getAdapterMap(adapters);
      if (adapterMap.get("webgpu")?.isSupported?.()) {
        return "webgpu";
      }
      if (adapterMap.get("webgl")?.isSupported?.()) {
        return "webgl";
      }
      return null;
    }
    setDefaultDeviceProps(props) {
      Object.assign(_Luma.defaultProps, props);
    }
    /** Creates a device. Asynchronously. */
    async createDevice(props = {}) {
      props = { ..._Luma.defaultProps, ...props };
      if (props.waitForPageLoad) {
        await _Luma.pageLoaded;
      }
      const adapterMap = this.getAdapterMap(props.adapters);
      let type = props.type || "";
      if (type === "best-available") {
        type = this.getBestAvailableAdapter(props.adapters) || type;
      }
      const adapters = this.getAdapterMap(props.adapters) || adapterMap;
      const adapter = adapters.get(type);
      const device = await adapter?.create?.(props);
      if (device) {
        return device;
      }
      throw new Error(ERROR_MESSAGE);
    }
    /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
    async attachDevice(props) {
      const adapters = this.getAdapterMap(props.adapters);
      let type = "";
      if (props.handle instanceof WebGL2RenderingContext) {
        type = "webgl";
      }
      if (props.createCanvasContext) {
        await _Luma.pageLoaded;
      }
      if (props.handle === null) {
        type = "unknown";
      }
      const adapter = adapters.get(type);
      const device = await adapter?.attach?.(null);
      if (device) {
        return device;
      }
      throw new Error(ERROR_MESSAGE);
    }
    /**
     * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
     * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
     */
    enforceWebGL2(enforce = true, adapters = []) {
      const adapterMap = this.getAdapterMap(adapters);
      const webgl2Adapter2 = adapterMap.get("webgl");
      if (!webgl2Adapter2) {
        log2.warn("enforceWebGL2: webgl adapter not found")();
      }
      webgl2Adapter2?.enforceWebGL2?.(enforce);
    }
    /** Convert a list of adapters to a map */
    getAdapterMap(adapters = []) {
      const map6 = new Map(this.preregisteredAdapters);
      for (const adapter of adapters) {
        map6.set(adapter.type, adapter);
      }
      return map6;
    }
    // DEPRECATED
    /** @deprecated Use registerAdapters */
    registerDevices(deviceClasses) {
      log2.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
      for (const deviceClass of deviceClasses) {
        const adapter = deviceClass.adapter;
        if (adapter) {
          this.preregisteredAdapters.set(adapter.type, adapter);
        }
      }
    }
  };
  var Luma = _Luma;
  __publicField(Luma, "defaultProps", {
    ...Device.defaultProps,
    type: "best-available",
    adapters: void 0,
    waitForPageLoad: true
  });
  /**
   * Page load promise
   * Get a 'lazy' promise that resolves when the DOM is loaded.
   * @note Since there may be limitations on number of `load` event listeners,
   * it is recommended avoid calling this function until actually needed.
   * I.e. don't call it until you know that you will be looking up a string in the DOM.
   */
  __publicField(Luma, "pageLoaded", getPageLoadPromise().then(() => {
    log2.probe(2, "DOM is loaded")();
  }));
  var luma = new Luma();
  function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === "undefined") {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      window.addEventListener("load", () => resolve2());
    });
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/adapter.js
  var Adapter = class {
  };

  // ../../node_modules/@luma.gl/core/dist/adapter/canvas-context.js
  var _CanvasContext = class {
    id;
    props;
    canvas;
    htmlCanvas;
    offscreenCanvas;
    type;
    width = 1;
    height = 1;
    resizeObserver;
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
    toString() {
      return `${this[Symbol.toStringTag]}(${this.id})`;
    }
    constructor(props) {
      this.props = { ..._CanvasContext.defaultProps, ...props };
      props = this.props;
      if (!isBrowser2()) {
        this.id = "node-canvas-context";
        this.type = "node";
        this.width = this.props.width;
        this.height = this.props.height;
        this.canvas = null;
        return;
      }
      if (!props.canvas) {
        const canvas2 = createCanvas(props);
        const container = getContainer(props?.container || null);
        container.insertBefore(canvas2, container.firstChild);
        this.canvas = canvas2;
        if (!props?.visible) {
          this.canvas.style.visibility = "hidden";
        }
      } else if (typeof props.canvas === "string") {
        this.canvas = getCanvasFromDOM(props.canvas);
      } else {
        this.canvas = props.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement) {
        this.id = this.canvas.id;
        this.type = "html-canvas";
        this.htmlCanvas = this.canvas;
      } else {
        this.id = "offscreen-canvas";
        this.type = "offscreen-canvas";
        this.offscreenCanvas = this.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
        this.resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvas) {
              this.update();
            }
          }
        });
        this.resizeObserver.observe(this.canvas);
      }
    }
    /**
     * Returns the current DPR, if props.useDevicePixels is true
     * Device refers to physical
     */
    getDevicePixelRatio(useDevicePixels) {
      if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
        return 1;
      }
      useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
      if (!useDevicePixels || useDevicePixels <= 0) {
        return 1;
      }
      if (useDevicePixels === true) {
        const dpr = typeof window !== "undefined" && window.devicePixelRatio;
        return dpr || 1;
      }
      return useDevicePixels;
    }
    /**
     * Returns the size of drawing buffer in device pixels.
     * @note This can be different from the 'CSS' size of a canvas, and also from the
     * canvas' internal drawing buffer size (.width, .height).
     * This is the size required to cover the canvas, adjusted for DPR
     */
    getPixelSize() {
      switch (this.type) {
        case "node":
          return [this.width, this.height];
        case "offscreen-canvas":
          return [this.canvas.width, this.canvas.height];
        case "html-canvas":
          const dpr = this.getDevicePixelRatio();
          const canvas2 = this.canvas;
          return canvas2.parentElement ? [canvas2.clientWidth * dpr, canvas2.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
        default:
          throw new Error(this.type);
      }
    }
    getAspect() {
      const [width, height] = this.getPixelSize();
      return width / height;
    }
    /**
     * Returns multiplier need to convert CSS size to Device size
     */
    cssToDeviceRatio() {
      try {
        const [drawingBufferWidth] = this.getDrawingBufferSize();
        const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
        return clientWidth ? drawingBufferWidth / clientWidth : 1;
      } catch {
        return 1;
      }
    }
    /**
     * Maps CSS pixel position to device pixel position
     */
    cssToDevicePixels(cssPixel, yInvert = true) {
      const ratio = this.cssToDeviceRatio();
      const [width, height] = this.getDrawingBufferSize();
      return scalePixels(cssPixel, ratio, width, height, yInvert);
    }
    /**
     * Use devicePixelRatio to set canvas width and height
     * @note this is a raw port of luma.gl v8 code. Might be worth a review
     */
    setDevicePixelRatio(devicePixelRatio, options = {}) {
      if (!this.htmlCanvas) {
        return;
      }
      let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
      let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
      if (!clientWidth || !clientHeight) {
        log2.log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = this.htmlCanvas.width || 1;
        clientHeight = this.htmlCanvas.height || 1;
      }
      const cachedSize = this._canvasSizeInfo;
      if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        this.htmlCanvas.width = canvasWidth;
        this.htmlCanvas.height = canvasHeight;
        const gl = this.device.gl;
        if (gl) {
          const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
          if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
            clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
            this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
            this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
            log2.warn("Device pixel ratio clamped")();
          }
          this._canvasSizeInfo.clientWidth = clientWidth;
          this._canvasSizeInfo.clientHeight = clientHeight;
          this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
        }
      }
    }
    // PRIVATE
    /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
    getDrawingBufferSize() {
      const gl = this.device.gl;
      if (!gl) {
        return this.getPixelSize();
      }
      return [gl.drawingBufferWidth, gl.drawingBufferHeight];
    }
    /**
     * Allows subclass constructor to override the canvas id for auto created canvases.
     * This can really help when debugging DOM in apps that create multiple devices
     */
    _setAutoCreatedCanvasId(id) {
      if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
        this.htmlCanvas.id = id;
      }
    }
  };
  var CanvasContext = _CanvasContext;
  __publicField(CanvasContext, "defaultProps", {
    canvas: null,
    width: 800,
    // width are height are only used by headless gl
    height: 600,
    useDevicePixels: true,
    autoResize: true,
    container: null,
    visible: true,
    alphaMode: "opaque",
    colorSpace: "srgb"
  });
  function getContainer(container) {
    if (typeof container === "string") {
      const element = document.getElementById(container);
      if (!element) {
        throw new Error(`${container} is not an HTML element`);
      }
      return element;
    } else if (container) {
      return container;
    }
    return document.body;
  }
  function getCanvasFromDOM(canvasId) {
    const canvas2 = document.getElementById(canvasId);
    if (!(canvas2 instanceof HTMLCanvasElement)) {
      throw new Error("Object is not a canvas element");
    }
    return canvas2;
  }
  function createCanvas(props) {
    const { width, height } = props;
    const targetCanvas = document.createElement("canvas");
    targetCanvas.id = uid("lumagl-auto-created-canvas");
    targetCanvas.width = width || 1;
    targetCanvas.height = height || 1;
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
    return targetCanvas;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const point = pixel;
    const x3 = scaleX(point[0], ratio, width);
    let y3 = scaleY(point[1], ratio, height, yInvert);
    let t3 = scaleX(point[0] + 1, ratio, width);
    const xHigh = t3 === width - 1 ? t3 : t3 - 1;
    t3 = scaleY(point[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t3 = t3 === 0 ? t3 : t3 + 1;
      yHigh = y3;
      y3 = t3;
    } else {
      yHigh = t3 === height - 1 ? t3 : t3 - 1;
    }
    return {
      x: x3,
      y: y3,
      // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
      width: Math.max(xHigh - x3 + 1, 1),
      height: Math.max(yHigh - y3 + 1, 1)
    };
  }
  function scaleX(x3, ratio, width) {
    const r3 = Math.min(Math.round(x3 * ratio), width - 1);
    return r3;
  }
  function scaleY(y3, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y3 * ratio)) : Math.min(Math.round(y3 * ratio), height - 1);
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/texture.js
  var _Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    toString() {
      return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
    }
    /** dimension of this texture */
    dimension;
    /** format of this texture */
    format;
    /** width in pixels of this texture */
    width;
    /** height in pixels of this texture */
    height;
    /** depth of this texture */
    depth;
    /** mip levels in this texture */
    mipLevels;
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    updateTimestamp;
    /** Do not use directly. Create with device.createTexture() */
    constructor(device, props) {
      props = _Texture.normalizeProps(device, props);
      super(device, props, _Texture.defaultProps);
      this.dimension = this.props.dimension;
      this.format = this.props.format;
      this.width = this.props.width;
      this.height = this.props.height;
      this.depth = this.props.depth;
      if (this.props.width === void 0 || this.props.height === void 0) {
        const size = _Texture.getTextureDataSize(this.props.data);
        this.width = size?.width || 1;
        this.height = size?.height || 1;
      }
      if (this.props.mipmaps && this.props.mipLevels === void 0) {
        this.props.mipLevels = "pyramid";
      }
      this.mipLevels = this.props.mipLevels === "pyramid" ? _Texture.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1;
      this.updateTimestamp = device.incrementTimestamp();
    }
    /**
     * Create a new texture with the same parameters and optionally, a different size
     * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     */
    clone(size) {
      return this.device.createTexture({ ...this.props, ...size });
    }
    /** Check if data is an external image */
    static isExternalImage(data) {
      return typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement || typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement || typeof VideoFrame !== "undefined" && data instanceof VideoFrame || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas;
    }
    /** Determine size (width and height) of provided image data */
    static getExternalImageSize(data) {
      if (typeof ImageData !== "undefined" && data instanceof ImageData || typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && data instanceof OffscreenCanvas) {
        return { width: data.width, height: data.height };
      }
      if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        return { width: data.naturalWidth, height: data.naturalHeight };
      }
      if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        return { width: data.videoWidth, height: data.videoHeight };
      }
      if (typeof VideoFrame !== "undefined" && data instanceof VideoFrame) {
        return { width: data.displayWidth, height: data.displayHeight };
      }
      throw new Error("Unknown image type");
    }
    /** Check if texture data is a typed array */
    static isTextureLevelData(data) {
      const typedArray = data?.data;
      return ArrayBuffer.isView(typedArray);
    }
    /** Get the size of the texture described by the provided TextureData */
    static getTextureDataSize(data) {
      if (!data) {
        return null;
      }
      if (ArrayBuffer.isView(data)) {
        return null;
      }
      if (Array.isArray(data)) {
        return _Texture.getTextureDataSize(data[0]);
      }
      if (_Texture.isExternalImage(data)) {
        return _Texture.getExternalImageSize(data);
      }
      if (data && typeof data === "object" && data.constructor === Object) {
        const textureDataArray = Object.values(data);
        const untypedData = textureDataArray[0];
        return { width: untypedData.width, height: untypedData.height };
      }
      throw new Error("texture size deduction failed");
    }
    /**
     * Normalize TextureData to an array of TextureLevelData / ExternalImages
     * @param data
     * @param options
     * @returns array of TextureLevelData / ExternalImages
     */
    static normalizeTextureData(data, options) {
      let lodArray;
      if (ArrayBuffer.isView(data)) {
        lodArray = [
          {
            // ts-expect-error does data really need to be Uint8ClampedArray?
            data,
            width: options.width,
            height: options.height
            // depth: options.depth
          }
        ];
      } else if (!Array.isArray(data)) {
        lodArray = [data];
      } else {
        lodArray = data;
      }
      return lodArray;
    }
    /** Calculate the number of mip levels for a texture of width and height */
    static getMipLevelCount(width, height) {
      return Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    /** Convert luma.gl cubemap face constants to depth index */
    static getCubeFaceDepth(face) {
      switch (face) {
        case "+X":
          return 0;
        case "-X":
          return 1;
        case "+Y":
          return 2;
        case "-Y":
          return 3;
        case "+Z":
          return 4;
        case "-Z":
          return 5;
        default:
          throw new Error(face);
      }
    }
    /** Ensure we have integer coordinates */
    static normalizeProps(device, props) {
      const newProps = { ...props };
      const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};
      Object.assign(newProps, overriddenDefaultProps);
      const { width, height } = newProps;
      if (typeof width === "number") {
        newProps.width = Math.max(1, Math.ceil(width));
      }
      if (typeof height === "number") {
        newProps.height = Math.max(1, Math.ceil(height));
      }
      return newProps;
    }
  };
  var Texture = _Texture;
  __publicField(Texture, "COPY_SRC", 1);
  __publicField(Texture, "COPY_DST", 2);
  __publicField(Texture, "TEXTURE", 4);
  __publicField(Texture, "STORAGE", 8);
  __publicField(Texture, "RENDER_ATTACHMENT", 16);
  __publicField(Texture, "CubeFaces", ["+X", "-X", "+Y", "-Y", "+Z", "-Z"]);
  __publicField(Texture, "defaultProps", {
    ...Resource.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: false,
    compressed: false,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    sampler: {},
    view: void 0,
    flipY: void 0
  });
  /** Default options */
  __publicField(Texture, "defaultCopyExternalImageOptions", {
    image: void 0,
    sourceX: 0,
    sourceY: 0,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all",
    colorSpace: "srgb",
    premultipliedAlpha: false,
    flipY: false
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js
  var _TextureView = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TextureView";
    }
    /** Should not be constructed directly. Use `texture.createView(props)` */
    constructor(device, props) {
      super(device, props, _TextureView.defaultProps);
    }
  };
  var TextureView = _TextureView;
  __publicField(TextureView, "defaultProps", {
    ...Resource.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js
  function formatCompilerLog(shaderLog, source3, options) {
    let formattedLog = "";
    const lines = source3.split(/\r?\n/);
    const log3 = shaderLog.slice().sort((a3, b2) => a3.lineNum - b2.lineNum);
    switch (options?.showSourceCode || "no") {
      case "all":
        let currentMessage = 0;
        for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
          formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
          while (log3.length > currentMessage && log3[currentMessage].lineNum === lineNum) {
            const message2 = log3[currentMessage++];
            formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
              ...options,
              inlineSource: false
            });
          }
        }
        return formattedLog;
      case "issues":
      case "no":
        for (const message2 of shaderLog) {
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            inlineSource: options?.showSourceCode !== "no"
          });
        }
        return formattedLog;
    }
  }
  function formatCompilerMessage(message2, lines, lineNum, options) {
    if (options?.inlineSource) {
      const numberedLines = getNumberedLines(lines, lineNum);
      const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
      return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
    }
    const color = message2.type === "error" ? "red" : "#8B4000";
    return options?.html ? `<div class='luma-compiler-log-error' style="color:${color};"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
  }
  function getNumberedLines(lines, lineNum, options) {
    let numberedLines = "";
    for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
      const sourceLine = lines[lineIndex - 1];
      if (sourceLine !== void 0) {
        numberedLines += getNumberedLine(sourceLine, lineNum, options);
      }
    }
    return numberedLines;
  }
  function getNumberedLine(line, lineNum, options) {
    const escapedLine = options?.html ? escapeHTML(line) : line;
    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
  }
  function padLeft(string, paddedLength) {
    let result = "";
    for (let i5 = string.length; i5 < paddedLength; ++i5) {
      result += " ";
    }
    return result + string;
  }
  function escapeHTML(unsafe) {
    return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/shader.js
  var _Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    /** The stage of this shader */
    stage;
    /** The source code of this shader */
    source;
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    compilationStatus = "pending";
    /** Create a new Shader instance */
    constructor(device, props) {
      props = { ...props, debugShaders: props.debugShaders || device.props.debugShaders || "errors" };
      super(device, { id: getShaderIdFromProps(props), ...props }, _Shader.defaultProps);
      this.stage = this.props.stage;
      this.source = this.props.source;
    }
    /** Get compiler log synchronously (WebGL only) */
    getCompilationInfoSync() {
      return null;
    }
    /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
    getTranslatedSource() {
      return null;
    }
    // PORTABLE HELPERS
    /** In browser logging of errors */
    async debugShader() {
      const trigger = this.props.debugShaders;
      switch (trigger) {
        case "never":
          return;
        case "errors":
          if (this.compilationStatus === "success") {
            return;
          }
          break;
        case "warnings":
        case "always":
          break;
      }
      const messages = await this.getCompilationInfo();
      if (trigger === "warnings" && messages?.length === 0) {
        return;
      }
      this._displayShaderLog(messages);
    }
    // PRIVATE
    /**
     * In-browser UI logging of errors
     * TODO - this HTML formatting code should not be in Device, should be pluggable
     */
    _displayShaderLog(messages) {
      if (typeof document === "undefined" || !document?.createElement) {
        return;
      }
      const shaderName = getShaderName2(this.source);
      const shaderTitle = `${this.stage} ${shaderName}`;
      let htmlLog = formatCompilerLog(messages, this.source, { showSourceCode: "all", html: true });
      const translatedSource = this.getTranslatedSource();
      if (translatedSource) {
        htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
      }
      const button = document.createElement("Button");
      button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
      button.style.top = "10px";
      button.style.left = "10px";
      button.style.position = "absolute";
      button.style.zIndex = "9999";
      button.style.width = "100%";
      button.style.textAlign = "left";
      document.body.appendChild(button);
      const errors = document.getElementsByClassName("luma-compiler-log-error");
      errors[0]?.scrollIntoView();
      button.onclick = () => {
        const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
        navigator.clipboard.writeText(dataURI);
      };
    }
  };
  var Shader = _Shader;
  __publicField(Shader, "defaultProps", {
    ...Resource.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debugShaders: void 0
  });
  function getShaderIdFromProps(props) {
    return getShaderName2(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);
  }
  function getShaderName2(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/sampler.js
  var _Sampler = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Sampler";
    }
    constructor(device, props) {
      props = _Sampler.normalizeProps(device, props);
      super(device, props, _Sampler.defaultProps);
    }
    static normalizeProps(device, props) {
      const overriddenDefaultProps = device?.props?._resourceDefaults?.sampler || {};
      const newProps = { ...props, ...overriddenDefaultProps };
      return newProps;
    }
  };
  var Sampler = _Sampler;
  __publicField(Sampler, "defaultProps", {
    ...Resource.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "none",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js
  var _Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    /** Width of all attachments in this framebuffer */
    width;
    /** Height of all attachments in this framebuffer */
    height;
    constructor(device, props = {}) {
      super(device, props, _Framebuffer.defaultProps);
      this.width = this.props.width;
      this.height = this.props.height;
    }
    /**
     * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
     * @note Does not copy contents of the attached textures.
     */
    clone(size) {
      const colorAttachments = this.colorAttachments.map((colorAttachment) => colorAttachment.texture.clone(size));
      const depthStencilAttachment = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);
      return this.device.createFramebuffer({ ...this.props, colorAttachments, depthStencilAttachment });
    }
    resize(size) {
      let updateSize = !size;
      if (size) {
        const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
        updateSize = updateSize || height !== this.height || width !== this.width;
        this.width = width;
        this.height = height;
      }
      if (updateSize) {
        log2.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
        this.resizeAttachments(this.width, this.height);
      }
    }
    /** Auto creates any textures */
    autoCreateAttachmentTextures() {
      if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
        throw new Error("Framebuffer has noattachments");
      }
      this.colorAttachments = this.props.colorAttachments.map((attachment2, index) => {
        if (typeof attachment2 === "string") {
          const texture = this.createColorTexture(attachment2, index);
          this.attachResource(texture);
          return texture.view;
        }
        if (attachment2 instanceof Texture) {
          return attachment2.view;
        }
        return attachment2;
      });
      const attachment = this.props.depthStencilAttachment;
      if (attachment) {
        if (typeof attachment === "string") {
          const texture = this.createDepthStencilTexture(attachment);
          this.attachResource(texture);
          this.depthStencilAttachment = texture.view;
        } else if (attachment instanceof Texture) {
          this.depthStencilAttachment = attachment.view;
        } else {
          this.depthStencilAttachment = attachment;
        }
      }
    }
    /** Create a color texture */
    createColorTexture(format, index) {
      return this.device.createTexture({
        id: `${this.id}-color-attachment-${index}`,
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height,
        // TODO deprecated? - luma.gl v8 compatibility
        sampler: {
          magFilter: "linear",
          minFilter: "linear"
        }
      });
    }
    /** Create depth stencil texture */
    createDepthStencilTexture(format) {
      return this.device.createTexture({
        id: `${this.id}-depth-stencil-attachment`,
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height,
        mipmaps: false
      });
    }
    /**
     * Default implementation of resize
     * Creates new textures with correct size for all attachments.
     * and destroys existing textures if owned
     */
    resizeAttachments(width, height) {
      for (let i5 = 0; i5 < this.colorAttachments.length; ++i5) {
        if (this.colorAttachments[i5]) {
          const resizedTexture = this.colorAttachments[i5].texture.clone({
            width,
            height
          });
          this.destroyAttachedResource(this.colorAttachments[i5]);
          this.colorAttachments[i5] = resizedTexture.view;
          this.attachResource(resizedTexture.view);
        }
      }
      if (this.depthStencilAttachment) {
        const resizedTexture = this.depthStencilAttachment.texture.clone({
          width,
          height
        });
        this.destroyAttachedResource(this.depthStencilAttachment);
        this.depthStencilAttachment = resizedTexture.view;
        this.attachResource(resizedTexture);
      }
      this.updateAttachments();
    }
  };
  var Framebuffer = _Framebuffer;
  __publicField(Framebuffer, "defaultProps", {
    ...Resource.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js
  var _RenderPipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    /** The merged layout */
    shaderLayout;
    /** Buffer map describing buffer interleaving etc */
    bufferLayout;
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    linkStatus = "pending";
    /** The hash of the pipeline */
    hash = "";
    constructor(device, props) {
      super(device, props, _RenderPipeline.defaultProps);
      this.shaderLayout = this.props.shaderLayout;
      this.bufferLayout = this.props.bufferLayout || [];
    }
    // DEPRECATED METHODS
    /**
     * Uniforms
     * @deprecated Use uniforms buffers
     * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
     * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
     */
    setUniformsWebGL(uniforms) {
      throw new Error("Use uniform blocks");
    }
  };
  var RenderPipeline = _RenderPipeline;
  __publicField(RenderPipeline, "defaultProps", {
    ...Resource.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    // isInstanced: false,
    // instanceCount: 0,
    // vertexCount: 0,
    bindings: {},
    uniforms: {}
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js
  var _RenderPass = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPass";
    }
    constructor(device, props) {
      props = _RenderPass.normalizeProps(device, props);
      super(device, props, _RenderPass.defaultProps);
    }
    static normalizeProps(device, props) {
      const overriddenDefaultProps = device.props._resourceDefaults?.renderPass;
      const newProps = { ...overriddenDefaultProps, ...props };
      return newProps;
    }
  };
  var RenderPass = _RenderPass;
  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
  __publicField(RenderPass, "defaultClearColor", [0, 0, 0, 1]);
  /** Depth 1.0 represents the far plance */
  __publicField(RenderPass, "defaultClearDepth", 1);
  /** Clears all stencil bits */
  __publicField(RenderPass, "defaultClearStencil", 0);
  /** Default properties for RenderPass */
  __publicField(RenderPass, "defaultProps", {
    ...Resource.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: _RenderPass.defaultClearColor,
    clearColors: void 0,
    clearDepth: _RenderPass.defaultClearDepth,
    clearStencil: _RenderPass.defaultClearStencil,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
  var _ComputePipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "ComputePipeline";
    }
    hash = "";
    /** The merged shader layout */
    shaderLayout;
    constructor(device, props) {
      super(device, props, _ComputePipeline.defaultProps);
      this.shaderLayout = props.shaderLayout;
    }
  };
  var ComputePipeline = _ComputePipeline;
  __publicField(ComputePipeline, "defaultProps", {
    ...Resource.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js
  var _CommandEncoder = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandEncoder";
    }
    constructor(device, props) {
      super(device, props, _CommandEncoder.defaultProps);
    }
  };
  var CommandEncoder = _CommandEncoder;
  __publicField(CommandEncoder, "defaultProps", {
    ...Resource.defaultProps,
    measureExecutionTime: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js
  var _CommandBuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandBuffer";
    }
    constructor(device, props) {
      super(device, props, _CommandBuffer.defaultProps);
    }
  };
  var CommandBuffer = _CommandBuffer;
  __publicField(CommandBuffer, "defaultProps", {
    ...Resource.defaultProps
  });

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/decode-attribute-type.js
  function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === "i32" || dataType === "u32";
    const signed = dataType !== "u32";
    const byteLength = TYPE_SIZES2[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
      dataType,
      components,
      defaultVertexFormat,
      byteLength,
      integer,
      signed
    };
  }
  function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch (dataType) {
      case "f32":
        vertexType = "float32";
        break;
      case "i32":
        vertexType = "sint32";
        break;
      case "u32":
        vertexType = "uint32";
        break;
      case "f16":
        return components <= 2 ? "float16x2" : "float16x4";
    }
    if (components === 1) {
      return vertexType;
    }
    return `${vertexType}x${components}`;
  }
  var TYPE_INFO = {
    f32: ["f32", 1],
    "vec2<f32>": ["f32", 2],
    "vec3<f32>": ["f32", 3],
    "vec4<f32>": ["f32", 4],
    f16: ["f16", 1],
    "vec2<f16>": ["f16", 2],
    "vec3<f16>": ["f16", 3],
    "vec4<f16>": ["f16", 4],
    i32: ["i32", 1],
    "vec2<i32>": ["i32", 2],
    "vec3<i32>": ["i32", 3],
    "vec4<i32>": ["i32", 4],
    u32: ["u32", 1],
    "vec2<u32>": ["u32", 2],
    "vec3<u32>": ["u32", 3],
    "vec4<u32>": ["u32", 4]
  };
  var TYPE_SIZES2 = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
    // 'bool-webgl': 4,
  };

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/decode-vertex-format.js
  function decodeVertexFormat(format) {
    let webglOnly;
    if (format.endsWith("-webgl")) {
      format.replace("-webgl", "");
      webglOnly = true;
    }
    const [type_, count3] = format.split("x");
    const type = type_;
    const components = count3 ? parseInt(count3) : 1;
    const decodedType = decodeVertexType(type);
    const result = {
      type,
      components,
      byteLength: decodedType.byteLength * components,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized
    };
    if (webglOnly) {
      result.webglOnly = true;
    }
    return result;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter-utils/get-attribute-from-layouts.js
  function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes) {
      const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
      if (attributeInfo) {
        attributeInfos[attribute.name] = attributeInfo;
      }
    }
    return attributeInfos;
  }
  function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
    const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
    const locationInfos = new Array(maxVertexAttributes).fill(null);
    for (const attributeInfo of Object.values(attributeInfos)) {
      locationInfos[attributeInfo.location] = attributeInfo;
    }
    return locationInfos;
  }
  function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name13) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name13);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name13);
    if (!shaderDeclaration) {
      return null;
    }
    const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = decodeVertexFormat(vertexFormat);
    return {
      attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
      bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
      location: shaderDeclaration.location,
      shaderType: shaderDeclaration.type,
      shaderDataType: attributeTypeInfo.dataType,
      shaderComponents: attributeTypeInfo.components,
      vertexFormat,
      bufferDataType: vertexFormatInfo.type,
      bufferComponents: vertexFormatInfo.components,
      // normalized is a property of the buffer's vertex format
      normalized: vertexFormatInfo.normalized,
      // integer is a property of the shader declaration
      integer: attributeTypeInfo.integer,
      stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || "vertex",
      byteOffset: bufferMapping?.byteOffset || 0,
      byteStride: bufferMapping?.byteStride || 0
    };
  }
  function getAttributeFromShaderLayout(shaderLayout, name13) {
    const attribute = shaderLayout.attributes.find((attr) => attr.name === name13);
    if (!attribute) {
      log2.warn(`shader layout attribute "${name13}" not present in shader`);
    }
    return attribute || null;
  }
  function getAttributeFromBufferLayout(bufferLayouts, name13) {
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name13);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name13);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    log2.warn(`layout for attribute "${name13}" not present in buffer layout`);
    return null;
  }
  function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
        log2.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
      }
    }
  }
  function getAttributeFromShortHand(bufferLayouts, name13) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.format && bufferLayout.name === name13) {
        return {
          attributeName: bufferLayout.name,
          bufferName: name13,
          stepMode: bufferLayout.stepMode,
          vertexFormat: bufferLayout.format,
          // If offset is needed, use `attributes` field.
          byteOffset: 0,
          byteStride: bufferLayout.byteStride || 0
        };
      }
    }
    return null;
  }
  function getAttributeFromAttributesList(bufferLayouts, name13) {
    for (const bufferLayout of bufferLayouts) {
      let byteStride = bufferLayout.byteStride;
      if (typeof bufferLayout.byteStride !== "number") {
        for (const attributeMapping2 of bufferLayout.attributes || []) {
          const info = decodeVertexFormat(attributeMapping2.format);
          byteStride += info.byteLength;
        }
      }
      const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name13);
      if (attributeMapping) {
        return {
          attributeName: attributeMapping.attribute,
          bufferName: bufferLayout.name,
          stepMode: bufferLayout.stepMode,
          vertexFormat: attributeMapping.format,
          byteOffset: attributeMapping.byteOffset,
          // @ts-ignore
          byteStride
        };
      }
    }
    return null;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js
  var _VertexArray = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    /** Max number of vertex attributes */
    maxVertexAttributes;
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    attributeInfos;
    /** Index buffer */
    indexBuffer = null;
    /** Attributes indexed by buffer slot */
    attributes;
    constructor(device, props) {
      super(device, props, _VertexArray.defaultProps);
      this.maxVertexAttributes = device.limits.maxVertexAttributes;
      this.attributes = new Array(this.maxVertexAttributes).fill(null);
      const { shaderLayout, bufferLayout } = props.renderPipeline || {};
      if (!shaderLayout || !bufferLayout) {
        throw new Error("VertexArray");
      }
      this.attributeInfos = getAttributeInfosByLocation(shaderLayout, bufferLayout, this.maxVertexAttributes);
    }
    // DEPRECATED METHODS
    /** @deprecated Set constant attributes (WebGL only) */
    setConstantWebGL(location, value) {
      this.device.reportError(new Error("constant attributes not supported"));
    }
  };
  var VertexArray = _VertexArray;
  __publicField(VertexArray, "defaultProps", {
    ...Resource.defaultProps,
    renderPipeline: null
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js
  var _TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    constructor(device, props) {
      super(device, props, _TransformFeedback.defaultProps);
    }
  };
  var TransformFeedback = _TransformFeedback;
  __publicField(TransformFeedback, "defaultProps", {
    ...Resource.defaultProps,
    layout: void 0,
    buffers: {}
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/query-set.js
  var _QuerySet = class extends Resource {
    get [Symbol.toStringTag]() {
      return "QuerySet";
    }
    constructor(device, props) {
      super(device, props, _QuerySet.defaultProps);
    }
  };
  var QuerySet = _QuerySet;
  __publicField(QuerySet, "defaultProps", {
    ...Resource.defaultProps,
    type: void 0,
    count: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/decode-shader-types.js
  var UNIFORM_FORMATS = {
    f32: { type: "f32", components: 1 },
    i32: { type: "i32", components: 1 },
    u32: { type: "u32", components: 1 },
    // 'bool-webgl': {type: 'bool-webgl', components: 1},
    "vec2<f32>": { type: "f32", components: 2 },
    "vec3<f32>": { type: "f32", components: 3 },
    "vec4<f32>": { type: "f32", components: 4 },
    "vec2<i32>": { type: "i32", components: 2 },
    "vec3<i32>": { type: "i32", components: 3 },
    "vec4<i32>": { type: "i32", components: 4 },
    "vec2<u32>": { type: "u32", components: 2 },
    "vec3<u32>": { type: "u32", components: 3 },
    "vec4<u32>": { type: "u32", components: 4 },
    "mat2x2<f32>": { type: "f32", components: 4 },
    "mat2x3<f32>": { type: "f32", components: 6 },
    "mat2x4<f32>": { type: "f32", components: 8 },
    "mat3x2<f32>": { type: "f32", components: 6 },
    "mat3x3<f32>": { type: "f32", components: 9 },
    "mat3x4<f32>": { type: "f32", components: 12 },
    "mat4x2<f32>": { type: "f32", components: 8 },
    "mat4x3<f32>": { type: "f32", components: 12 },
    "mat4x4<f32>": { type: "f32", components: 16 }
  };
  function decodeShaderUniformType(format) {
    const decoded = UNIFORM_FORMATS[format];
    return decoded;
  }
  function alignTo(size, count3) {
    switch (count3) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }

  // ../../node_modules/@luma.gl/core/dist/utils/array-utils-flat.js
  var arrayBuffer;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type2, length16) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type2.BYTES_PER_ELEMENT * length16);
    return new Type2(scratchArrayBuffer, 0, length16);
  }

  // ../../node_modules/@luma.gl/core/dist/utils/is-array.js
  function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function isNumberArray(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number";
    }
    return isTypedArray(value);
  }

  // ../../node_modules/@luma.gl/core/dist/portable/uniform-buffer-layout.js
  var minBufferSize = 1024;
  var UniformBufferLayout = class {
    layout = {};
    /** number of bytes needed for buffer allocation */
    byteLength;
    /** Create a new UniformBufferLayout given a map of attributes. */
    constructor(uniformTypes) {
      let size = 0;
      for (const [key, uniformType] of Object.entries(uniformTypes)) {
        const typeAndComponents = decodeShaderUniformType(uniformType);
        const { type, components: count3 } = typeAndComponents;
        size = alignTo(size, count3);
        const offset = size;
        size += count3;
        this.layout[key] = { type, size: count3, offset };
      }
      size += (4 - size % 4) % 4;
      const actualByteLength = size * 4;
      this.byteLength = Math.max(actualByteLength, minBufferSize);
    }
    /** Get the data for the complete buffer */
    getData(uniformValues) {
      const bufferSize = Math.max(this.byteLength, minBufferSize);
      const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
      const typedArrays = {
        i32: new Int32Array(arrayBuffer2),
        u32: new Uint32Array(arrayBuffer2),
        f32: new Float32Array(arrayBuffer2),
        // TODO not implemented
        f16: new Uint16Array(arrayBuffer2)
      };
      for (const [name13, value] of Object.entries(uniformValues)) {
        const uniformLayout = this.layout[name13];
        if (!uniformLayout) {
          log2.warn(`Supplied uniform value ${name13} not present in uniform block layout`)();
          continue;
        }
        const { type, size, offset } = uniformLayout;
        const typedArray = typedArrays[type];
        if (size === 1) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            log2.warn(`Supplied value for single component uniform ${name13} is not a number: ${value}`)();
            continue;
          }
          typedArray[offset] = Number(value);
        } else {
          if (!isNumberArray(value)) {
            log2.warn(`Supplied value for multi component / array uniform ${name13} is not a numeric array: ${value}`)();
            continue;
          }
          typedArray.set(value, offset);
        }
      }
      return new Uint8Array(arrayBuffer2);
    }
    /** Does this layout have a field with specified name */
    has(name13) {
      return Boolean(this.layout[name13]);
    }
    /** Get offset and size for a field with specified name */
    get(name13) {
      const layout = this.layout[name13];
      return layout;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/utils/array-equal.js
  function arrayEqual(a3, b2, limit = 16) {
    if (a3 !== b2) {
      return false;
    }
    const arrayA = a3;
    const arrayB = b2;
    if (!isNumberArray(arrayA)) {
      return false;
    }
    if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {
      for (let i5 = 0; i5 < arrayA.length; ++i5) {
        if (arrayB[i5] !== arrayA[i5]) {
          return false;
        }
      }
    }
    return true;
  }
  function arrayCopy(a3) {
    if (isNumberArray(a3)) {
      return a3.slice();
    }
    return a3;
  }

  // ../../node_modules/@luma.gl/core/dist/portable/uniform-block.js
  var UniformBlock = class {
    name;
    uniforms = {};
    modifiedUniforms = {};
    modified = true;
    bindingLayout = {};
    needsRedraw = "initialized";
    constructor(props) {
      this.name = props?.name || "unnamed";
      if (props?.name && props?.shaderLayout) {
        const binding = props?.shaderLayout.bindings?.find((binding_) => binding_.type === "uniform" && binding_.name === props?.name);
        if (!binding) {
          throw new Error(props?.name);
        }
        const uniformBlock36 = binding;
        for (const uniform of uniformBlock36.uniforms || []) {
          this.bindingLayout[uniform.name] = uniform;
        }
      }
    }
    /** Set a map of uniforms */
    setUniforms(uniforms) {
      for (const [key, value] of Object.entries(uniforms)) {
        this._setUniform(key, value);
        if (!this.needsRedraw) {
          this.setNeedsRedraw(`${this.name}.${key}=${value}`);
        }
      }
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
    }
    /** Returns all uniforms */
    getAllUniforms() {
      this.modifiedUniforms = {};
      this.needsRedraw = false;
      return this.uniforms || {};
    }
    /** Set a single uniform */
    _setUniform(key, value) {
      if (arrayEqual(this.uniforms[key], value)) {
        return;
      }
      this.uniforms[key] = arrayCopy(value);
      this.modifiedUniforms[key] = true;
      this.modified = true;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/portable/uniform-store.js
  var UniformStore = class {
    /** Stores the uniform values for each uniform block */
    uniformBlocks = /* @__PURE__ */ new Map();
    /** Can generate data for a uniform buffer for each block from data */
    uniformBufferLayouts = /* @__PURE__ */ new Map();
    /** Actual buffer for the blocks */
    uniformBuffers = /* @__PURE__ */ new Map();
    /**
     * Create a new UniformStore instance
     * @param blocks
     */
    constructor(blocks) {
      for (const [bufferName, block] of Object.entries(blocks)) {
        const uniformBufferName = bufferName;
        const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
        this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
        const uniformBlock36 = new UniformBlock({ name: bufferName });
        uniformBlock36.setUniforms(block.defaultUniforms || {});
        this.uniformBlocks.set(uniformBufferName, uniformBlock36);
      }
    }
    /** Destroy any managed uniform buffers */
    destroy() {
      for (const uniformBuffer of this.uniformBuffers.values()) {
        uniformBuffer.destroy();
      }
    }
    /**
     * Set uniforms
     * Makes all properties partial
     */
    setUniforms(uniforms) {
      for (const [blockName, uniformValues] of Object.entries(uniforms)) {
        this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);
      }
      this.updateUniformBuffers();
    }
    /** Get the required minimum length of the uniform buffer */
    getUniformBufferByteLength(uniformBufferName) {
      return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;
    }
    /** Get formatted binary memory that can be uploaded to a buffer */
    getUniformBufferData(uniformBufferName) {
      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};
      return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);
    }
    /**
     * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
     * The new buffer is initialized with current / supplied values
     */
    createUniformBuffer(device, uniformBufferName, uniforms) {
      if (uniforms) {
        this.setUniforms(uniforms);
      }
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
        byteLength
      });
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer.write(uniformBufferData);
      return uniformBuffer;
    }
    /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
    getManagedUniformBuffer(device, uniformBufferName) {
      if (!this.uniformBuffers.get(uniformBufferName)) {
        const byteLength = this.getUniformBufferByteLength(uniformBufferName);
        const uniformBuffer = device.createBuffer({
          usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
          byteLength
        });
        this.uniformBuffers.set(uniformBufferName, uniformBuffer);
      }
      return this.uniformBuffers.get(uniformBufferName);
    }
    /** Updates all uniform buffers where values have changed */
    updateUniformBuffers() {
      let reason = false;
      for (const uniformBufferName of this.uniformBlocks.keys()) {
        const bufferReason = this.updateUniformBuffer(uniformBufferName);
        reason ||= bufferReason;
      }
      if (reason) {
        log2.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
      }
      return reason;
    }
    /** Update one uniform buffer. Only updates if values have changed */
    updateUniformBuffer(uniformBufferName) {
      const uniformBlock36 = this.uniformBlocks.get(uniformBufferName);
      let uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      let reason = false;
      if (uniformBuffer && uniformBlock36?.needsRedraw) {
        reason ||= uniformBlock36.needsRedraw;
        const uniformBufferData = this.getUniformBufferData(uniformBufferName);
        uniformBuffer = this.uniformBuffers.get(uniformBufferName);
        uniformBuffer?.write(uniformBufferData);
        const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();
        log2.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
      }
      return reason;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/gpu-type-utils/vertex-format-from-attribute.js
  function getDataTypeFromTypedArray2(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return "float32";
      case Uint16Array:
        return "uint16";
      case Uint32Array:
        return "uint32";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int8Array:
        return "sint8";
      case Int16Array:
        return "sint16";
      case Int32Array:
        return "sint32";
      default:
        throw new Error(type.constructor.name);
    }
  }
  function getTypedArrayFromDataType(dataType) {
    switch (dataType) {
      case "float32":
        return Float32Array;
      case "uint32":
        return Uint32Array;
      case "sint32":
        return Int32Array;
      case "uint16":
      case "unorm16":
        return Uint16Array;
      case "sint16":
      case "snorm16":
        return Int16Array;
      case "uint8":
      case "unorm8":
        return Uint8Array;
      case "sint8":
      case "snorm8":
        return Int8Array;
      default:
        throw new Error(dataType);
    }
  }
  function getVertexFormatFromAttribute(typedArray, size, normalized) {
    if (!size || size > 4) {
      throw new Error(`size ${size}`);
    }
    const components = size;
    let dataType = getDataTypeFromTypedArray2(typedArray);
    if (dataType === "uint8" && normalized && components === 1) {
      return "unorm8-webgl";
    }
    if (dataType === "uint8" && normalized && components === 3) {
      return "unorm8x3-webgl";
    }
    if (dataType === "uint8" || dataType === "sint8") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (dataType === "uint16" || dataType === "sint16") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (components === 1) {
      return dataType;
    }
    return `${dataType}x${components}`;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter-utils/buffer-layout-helper.js
  var BufferLayoutHelper = class {
    bufferLayouts;
    constructor(bufferLayouts) {
      this.bufferLayouts = bufferLayouts;
    }
    getBufferLayout(name13) {
      return this.bufferLayouts.find((layout) => layout.name === name13) || null;
    }
    /** Get attribute names from a BufferLayout */
    getAttributeNamesForBuffer(bufferLayout) {
      return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
    }
    mergeBufferLayouts(bufferLayouts1, bufferLayouts2) {
      const mergedLayouts = [...bufferLayouts1];
      for (const attribute of bufferLayouts2) {
        const index = mergedLayouts.findIndex((attribute2) => attribute2.name === attribute.name);
        if (index < 0) {
          mergedLayouts.push(attribute);
        } else {
          mergedLayouts[index] = attribute;
        }
      }
      return mergedLayouts;
    }
  };

  // ../../node_modules/wgsl_reflect/wgsl_reflect.module.js
  var ParseContext = class {
    constructor() {
      this.constants = /* @__PURE__ */ new Map();
      this.aliases = /* @__PURE__ */ new Map();
      this.structs = /* @__PURE__ */ new Map();
    }
  };
  var Node = class {
    constructor() {
    }
    get isAstNode() {
      return true;
    }
    get astNodeType() {
      return "";
    }
    evaluate(context) {
      throw new Error("Cannot evaluate node");
    }
    evaluateString(context) {
      return this.evaluate(context).toString();
    }
    search(callback) {
    }
    searchBlock(block, callback) {
      if (block) {
        callback(_BlockStart.instance);
        for (const node of block) {
          if (node instanceof Array) {
            this.searchBlock(node, callback);
          } else {
            node.search(callback);
          }
        }
        callback(_BlockEnd.instance);
      }
    }
  };
  var _BlockStart = class extends Node {
  };
  _BlockStart.instance = new _BlockStart();
  var _BlockEnd = class extends Node {
  };
  _BlockEnd.instance = new _BlockEnd();
  var Statement = class extends Node {
    constructor() {
      super();
    }
  };
  var Function = class extends Statement {
    constructor(name13, args, returnType, body, startLine, endLine) {
      super();
      this.calls = /* @__PURE__ */ new Set();
      this.name = name13;
      this.args = args;
      this.returnType = returnType;
      this.body = body;
      this.startLine = startLine;
      this.endLine = endLine;
    }
    get astNodeType() {
      return "function";
    }
    search(callback) {
      this.searchBlock(this.body, callback);
    }
  };
  var StaticAssert = class extends Statement {
    constructor(expression) {
      super();
      this.expression = expression;
    }
    get astNodeType() {
      return "staticAssert";
    }
    search(callback) {
      this.expression.search(callback);
    }
  };
  var While = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "while";
    }
    search(callback) {
      this.condition.search(callback);
      this.searchBlock(this.body, callback);
    }
  };
  var Continuing = class extends Statement {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "continuing";
    }
    search(callback) {
      this.searchBlock(this.body, callback);
    }
  };
  var For = class extends Statement {
    constructor(init, condition, increment, body) {
      super();
      this.init = init;
      this.condition = condition;
      this.increment = increment;
      this.body = body;
    }
    get astNodeType() {
      return "for";
    }
    search(callback) {
      var _a2, _b, _c;
      (_a2 = this.init) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
      (_b = this.condition) === null || _b === void 0 ? void 0 : _b.search(callback);
      (_c = this.increment) === null || _c === void 0 ? void 0 : _c.search(callback);
      this.searchBlock(this.body, callback);
    }
  };
  var Var = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "var";
    }
    search(callback) {
      var _a2;
      callback(this);
      (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    }
  };
  var Override = class extends Statement {
    constructor(name13, type, value) {
      super();
      this.name = name13;
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "override";
    }
    search(callback) {
      var _a2;
      (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    }
  };
  var Let = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "let";
    }
    search(callback) {
      var _a2;
      callback(this);
      (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    }
  };
  var Const = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "const";
    }
    evaluate(context) {
      return this.value.evaluate(context);
    }
    search(callback) {
      var _a2;
      callback(this);
      (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    }
  };
  var IncrementOperator;
  (function(IncrementOperator2) {
    IncrementOperator2["increment"] = "++";
    IncrementOperator2["decrement"] = "--";
  })(IncrementOperator || (IncrementOperator = {}));
  (function(IncrementOperator2) {
    function parse5(val2) {
      const key = val2;
      if (key == "parse")
        throw new Error("Invalid value for IncrementOperator");
      return IncrementOperator2[key];
    }
    IncrementOperator2.parse = parse5;
  })(IncrementOperator || (IncrementOperator = {}));
  var Increment = class extends Statement {
    constructor(operator, variable) {
      super();
      this.operator = operator;
      this.variable = variable;
    }
    get astNodeType() {
      return "increment";
    }
    search(callback) {
      this.variable.search(callback);
    }
  };
  var AssignOperator;
  (function(AssignOperator2) {
    AssignOperator2["assign"] = "=";
    AssignOperator2["addAssign"] = "+=";
    AssignOperator2["subtractAssin"] = "-=";
    AssignOperator2["multiplyAssign"] = "*=";
    AssignOperator2["divideAssign"] = "/=";
    AssignOperator2["moduloAssign"] = "%=";
    AssignOperator2["andAssign"] = "&=";
    AssignOperator2["orAssign"] = "|=";
    AssignOperator2["xorAssign"] = "^=";
    AssignOperator2["shiftLeftAssign"] = "<<=";
    AssignOperator2["shiftRightAssign"] = ">>=";
  })(AssignOperator || (AssignOperator = {}));
  (function(AssignOperator2) {
    function parse5(val2) {
      const key = val2;
      if (key == "parse") {
        throw new Error("Invalid value for AssignOperator");
      }
      return key;
    }
    AssignOperator2.parse = parse5;
  })(AssignOperator || (AssignOperator = {}));
  var Assign = class extends Statement {
    constructor(operator, variable, value) {
      super();
      this.operator = operator;
      this.variable = variable;
      this.value = value;
    }
    get astNodeType() {
      return "assign";
    }
    search(callback) {
      this.variable.search(callback);
      this.value.search(callback);
    }
  };
  var Call = class extends Statement {
    constructor(name13, args) {
      super();
      this.name = name13;
      this.args = args;
    }
    get astNodeType() {
      return "call";
    }
    search(callback) {
      for (const node of this.args) {
        node.search(callback);
      }
      callback(this);
    }
  };
  var Loop = class extends Statement {
    constructor(body, continuing) {
      super();
      this.body = body;
      this.continuing = continuing;
    }
    get astNodeType() {
      return "loop";
    }
  };
  var Switch = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "body";
    }
  };
  var If = class extends Statement {
    constructor(condition, body, elseif, _else) {
      super();
      this.condition = condition;
      this.body = body;
      this.elseif = elseif;
      this.else = _else;
    }
    get astNodeType() {
      return "if";
    }
    search(callback) {
      this.condition.search(callback);
      this.searchBlock(this.body, callback);
      this.searchBlock(this.elseif, callback);
      this.searchBlock(this.else, callback);
    }
  };
  var Return = class extends Statement {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "return";
    }
    search(callback) {
      var _a2;
      (_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.search(callback);
    }
  };
  var Enable = class extends Statement {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "enable";
    }
  };
  var Requires = class extends Statement {
    constructor(extensions) {
      super();
      this.extensions = extensions;
    }
    get astNodeType() {
      return "requires";
    }
  };
  var Diagnostic = class extends Statement {
    constructor(severity, rule) {
      super();
      this.severity = severity;
      this.rule = rule;
    }
    get astNodeType() {
      return "diagnostic";
    }
  };
  var Alias = class extends Statement {
    constructor(name13, type) {
      super();
      this.name = name13;
      this.type = type;
    }
    get astNodeType() {
      return "alias";
    }
  };
  var Discard = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "discard";
    }
  };
  var Break = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "break";
    }
  };
  var Continue = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "continue";
    }
  };
  var Type = class extends Statement {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "type";
    }
    get isStruct() {
      return false;
    }
    get isArray() {
      return false;
    }
  };
  var Struct = class extends Type {
    constructor(name13, members, startLine, endLine) {
      super(name13);
      this.members = members;
      this.startLine = startLine;
      this.endLine = endLine;
    }
    get astNodeType() {
      return "struct";
    }
    get isStruct() {
      return true;
    }
    /// Return the index of the member with the given name, or -1 if not found.
    getMemberIndex(name13) {
      for (let i5 = 0; i5 < this.members.length; i5++) {
        if (this.members[i5].name == name13)
          return i5;
      }
      return -1;
    }
  };
  var TemplateType = class extends Type {
    constructor(name13, format, access) {
      super(name13);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "template";
    }
  };
  var PointerType = class extends Type {
    constructor(name13, storage, type, access) {
      super(name13);
      this.storage = storage;
      this.type = type;
      this.access = access;
    }
    get astNodeType() {
      return "pointer";
    }
  };
  var ArrayType = class extends Type {
    constructor(name13, attributes, format, count3) {
      super(name13);
      this.attributes = attributes;
      this.format = format;
      this.count = count3;
    }
    get astNodeType() {
      return "array";
    }
    get isArray() {
      return true;
    }
  };
  var SamplerType = class extends Type {
    constructor(name13, format, access) {
      super(name13);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "sampler";
    }
  };
  var Expression = class extends Node {
    constructor() {
      super();
    }
  };
  var StringExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "stringExpr";
    }
    toString() {
      return this.value;
    }
    evaluateString() {
      return this.value;
    }
  };
  var CreateExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "createExpr";
    }
    search(callback) {
      callback(this);
      for (const node of this.args) {
        node.search(callback);
      }
    }
  };
  var CallExpr = class extends Expression {
    constructor(name13, args) {
      super();
      this.name = name13;
      this.args = args;
    }
    get astNodeType() {
      return "callExpr";
    }
    evaluate(context) {
      switch (this.name) {
        case "abs":
          return Math.abs(this.args[0].evaluate(context));
        case "acos":
          return Math.acos(this.args[0].evaluate(context));
        case "acosh":
          return Math.acosh(this.args[0].evaluate(context));
        case "asin":
          return Math.asin(this.args[0].evaluate(context));
        case "asinh":
          return Math.asinh(this.args[0].evaluate(context));
        case "atan":
          return Math.atan(this.args[0].evaluate(context));
        case "atan2":
          return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "atanh":
          return Math.atanh(this.args[0].evaluate(context));
        case "ceil":
          return Math.ceil(this.args[0].evaluate(context));
        case "clamp":
          return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));
        case "cos":
          return Math.cos(this.args[0].evaluate(context));
        case "degrees":
          return this.args[0].evaluate(context) * 180 / Math.PI;
        case "distance":
          return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));
        case "dot":
        case "exp":
          return Math.exp(this.args[0].evaluate(context));
        case "exp2":
          return Math.pow(2, this.args[0].evaluate(context));
        case "floor":
          return Math.floor(this.args[0].evaluate(context));
        case "fma":
          return this.args[0].evaluate(context) * this.args[1].evaluate(context) + this.args[2].evaluate(context);
        case "fract":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "inverseSqrt":
          return 1 / Math.sqrt(this.args[0].evaluate(context));
        case "log":
          return Math.log(this.args[0].evaluate(context));
        case "log2":
          return Math.log2(this.args[0].evaluate(context));
        case "max":
          return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "min":
          return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "mix":
          return this.args[0].evaluate(context) * (1 - this.args[2].evaluate(context)) + this.args[1].evaluate(context) * this.args[2].evaluate(context);
        case "modf":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "pow":
          return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "radians":
          return this.args[0].evaluate(context) * Math.PI / 180;
        case "round":
          return Math.round(this.args[0].evaluate(context));
        case "sign":
          return Math.sign(this.args[0].evaluate(context));
        case "sin":
          return Math.sin(this.args[0].evaluate(context));
        case "sinh":
          return Math.sinh(this.args[0].evaluate(context));
        case "saturate":
          return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);
        case "smoothstep":
          return this.args[0].evaluate(context) * this.args[0].evaluate(context) * (3 - 2 * this.args[0].evaluate(context));
        case "sqrt":
          return Math.sqrt(this.args[0].evaluate(context));
        case "step":
          return this.args[0].evaluate(context) < this.args[1].evaluate(context) ? 0 : 1;
        case "tan":
          return Math.tan(this.args[0].evaluate(context));
        case "tanh":
          return Math.tanh(this.args[0].evaluate(context));
        case "trunc":
          return Math.trunc(this.args[0].evaluate(context));
        default:
          throw new Error("Non const function: " + this.name);
      }
    }
    search(callback) {
      for (const node of this.args) {
        node.search(callback);
      }
      callback(this);
    }
  };
  var VariableExpr = class extends Expression {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "varExpr";
    }
    search(callback) {
      callback(this);
      if (this.postfix) {
        this.postfix.search(callback);
      }
    }
    evaluate(context) {
      const constant = context.constants.get(this.name);
      if (!constant) {
        throw new Error("Cannot evaluate node");
      }
      return constant.evaluate(context);
    }
  };
  var ConstExpr = class extends Expression {
    constructor(name13, initializer) {
      super();
      this.name = name13;
      this.initializer = initializer;
    }
    get astNodeType() {
      return "constExpr";
    }
    evaluate(context) {
      var _a2, _b;
      if (this.initializer instanceof CreateExpr) {
        const property = (_a2 = this.postfix) === null || _a2 === void 0 ? void 0 : _a2.evaluateString(context);
        const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;
        const struct = context.structs.get(type);
        const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);
        if (memberIndex != -1) {
          const value = this.initializer.args[memberIndex].evaluate(context);
          return value;
        }
        console.log(memberIndex);
      }
      return this.initializer.evaluate(context);
    }
    search(callback) {
      this.initializer.search(callback);
    }
  };
  var LiteralExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "literalExpr";
    }
    evaluate() {
      return this.value;
    }
  };
  var BitcastExpr = class extends Expression {
    constructor(type, value) {
      super();
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "bitcastExpr";
    }
    search(callback) {
      this.value.search(callback);
    }
  };
  var TypecastExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "typecastExpr";
    }
    evaluate(context) {
      return this.args[0].evaluate(context);
    }
    search(callback) {
      this.searchBlock(this.args, callback);
    }
  };
  var GroupingExpr = class extends Expression {
    constructor(contents) {
      super();
      this.contents = contents;
    }
    get astNodeType() {
      return "groupExpr";
    }
    evaluate(context) {
      return this.contents[0].evaluate(context);
    }
    search(callback) {
      this.searchBlock(this.contents, callback);
    }
  };
  var ArrayIndex = class extends Expression {
    constructor(index) {
      super();
      this.index = index;
    }
    search(callback) {
      this.index.search(callback);
    }
  };
  var Operator = class extends Expression {
    constructor() {
      super();
    }
  };
  var UnaryOperator = class extends Operator {
    constructor(operator, right) {
      super();
      this.operator = operator;
      this.right = right;
    }
    get astNodeType() {
      return "unaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.right.evaluate(context);
        case "-":
          return -this.right.evaluate(context);
        case "!":
          return this.right.evaluate(context) ? 0 : 1;
        case "~":
          return ~this.right.evaluate(context);
        default:
          throw new Error("Unknown unary operator: " + this.operator);
      }
    }
    search(callback) {
      this.right.search(callback);
    }
  };
  var BinaryOperator = class extends Operator {
    constructor(operator, left, right) {
      super();
      this.operator = operator;
      this.left = left;
      this.right = right;
    }
    get astNodeType() {
      return "binaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.left.evaluate(context) + this.right.evaluate(context);
        case "-":
          return this.left.evaluate(context) - this.right.evaluate(context);
        case "*":
          return this.left.evaluate(context) * this.right.evaluate(context);
        case "/":
          return this.left.evaluate(context) / this.right.evaluate(context);
        case "%":
          return this.left.evaluate(context) % this.right.evaluate(context);
        case "==":
          return this.left.evaluate(context) == this.right.evaluate(context) ? 1 : 0;
        case "!=":
          return this.left.evaluate(context) != this.right.evaluate(context) ? 1 : 0;
        case "<":
          return this.left.evaluate(context) < this.right.evaluate(context) ? 1 : 0;
        case ">":
          return this.left.evaluate(context) > this.right.evaluate(context) ? 1 : 0;
        case "<=":
          return this.left.evaluate(context) <= this.right.evaluate(context) ? 1 : 0;
        case ">=":
          return this.left.evaluate(context) >= this.right.evaluate(context) ? 1 : 0;
        case "&&":
          return this.left.evaluate(context) && this.right.evaluate(context) ? 1 : 0;
        case "||":
          return this.left.evaluate(context) || this.right.evaluate(context) ? 1 : 0;
        default:
          throw new Error(`Unknown operator ${this.operator}`);
      }
    }
    search(callback) {
      this.left.search(callback);
      this.right.search(callback);
    }
  };
  var SwitchCase = class extends Node {
    constructor() {
      super();
    }
  };
  var Case = class extends SwitchCase {
    constructor(selector, body) {
      super();
      this.selector = selector;
      this.body = body;
    }
    get astNodeType() {
      return "case";
    }
    search(callback) {
      this.searchBlock(this.body, callback);
    }
  };
  var Default = class extends SwitchCase {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "default";
    }
    search(callback) {
      this.searchBlock(this.body, callback);
    }
  };
  var Argument = class extends Node {
    constructor(name13, type, attributes) {
      super();
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "argument";
    }
  };
  var ElseIf = class extends Node {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "elseif";
    }
    search(callback) {
      this.condition.search(callback);
      this.searchBlock(this.body, callback);
    }
  };
  var Member = class extends Node {
    constructor(name13, type, attributes) {
      super();
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "member";
    }
  };
  var Attribute = class extends Node {
    constructor(name13, value) {
      super();
      this.name = name13;
      this.value = value;
    }
    get astNodeType() {
      return "attribute";
    }
  };
  var _a;
  var TokenClass;
  (function(TokenClass2) {
    TokenClass2[TokenClass2["token"] = 0] = "token";
    TokenClass2[TokenClass2["keyword"] = 1] = "keyword";
    TokenClass2[TokenClass2["reserved"] = 2] = "reserved";
  })(TokenClass || (TokenClass = {}));
  var TokenType = class {
    constructor(name13, type, rule) {
      this.name = name13;
      this.type = type;
      this.rule = rule;
    }
    toString() {
      return this.name;
    }
  };
  var TokenTypes = class {
  };
  _a = TokenTypes;
  TokenTypes.none = new TokenType("", TokenClass.reserved, "");
  TokenTypes.eof = new TokenType("EOF", TokenClass.token, "");
  TokenTypes.reserved = {
    asm: new TokenType("asm", TokenClass.reserved, "asm"),
    bf16: new TokenType("bf16", TokenClass.reserved, "bf16"),
    do: new TokenType("do", TokenClass.reserved, "do"),
    enum: new TokenType("enum", TokenClass.reserved, "enum"),
    f16: new TokenType("f16", TokenClass.reserved, "f16"),
    f64: new TokenType("f64", TokenClass.reserved, "f64"),
    handle: new TokenType("handle", TokenClass.reserved, "handle"),
    i8: new TokenType("i8", TokenClass.reserved, "i8"),
    i16: new TokenType("i16", TokenClass.reserved, "i16"),
    i64: new TokenType("i64", TokenClass.reserved, "i64"),
    mat: new TokenType("mat", TokenClass.reserved, "mat"),
    premerge: new TokenType("premerge", TokenClass.reserved, "premerge"),
    regardless: new TokenType("regardless", TokenClass.reserved, "regardless"),
    typedef: new TokenType("typedef", TokenClass.reserved, "typedef"),
    u8: new TokenType("u8", TokenClass.reserved, "u8"),
    u16: new TokenType("u16", TokenClass.reserved, "u16"),
    u64: new TokenType("u64", TokenClass.reserved, "u64"),
    unless: new TokenType("unless", TokenClass.reserved, "unless"),
    using: new TokenType("using", TokenClass.reserved, "using"),
    vec: new TokenType("vec", TokenClass.reserved, "vec"),
    void: new TokenType("void", TokenClass.reserved, "void")
  };
  TokenTypes.keywords = {
    array: new TokenType("array", TokenClass.keyword, "array"),
    atomic: new TokenType("atomic", TokenClass.keyword, "atomic"),
    bool: new TokenType("bool", TokenClass.keyword, "bool"),
    f32: new TokenType("f32", TokenClass.keyword, "f32"),
    i32: new TokenType("i32", TokenClass.keyword, "i32"),
    mat2x2: new TokenType("mat2x2", TokenClass.keyword, "mat2x2"),
    mat2x3: new TokenType("mat2x3", TokenClass.keyword, "mat2x3"),
    mat2x4: new TokenType("mat2x4", TokenClass.keyword, "mat2x4"),
    mat3x2: new TokenType("mat3x2", TokenClass.keyword, "mat3x2"),
    mat3x3: new TokenType("mat3x3", TokenClass.keyword, "mat3x3"),
    mat3x4: new TokenType("mat3x4", TokenClass.keyword, "mat3x4"),
    mat4x2: new TokenType("mat4x2", TokenClass.keyword, "mat4x2"),
    mat4x3: new TokenType("mat4x3", TokenClass.keyword, "mat4x3"),
    mat4x4: new TokenType("mat4x4", TokenClass.keyword, "mat4x4"),
    ptr: new TokenType("ptr", TokenClass.keyword, "ptr"),
    sampler: new TokenType("sampler", TokenClass.keyword, "sampler"),
    sampler_comparison: new TokenType("sampler_comparison", TokenClass.keyword, "sampler_comparison"),
    struct: new TokenType("struct", TokenClass.keyword, "struct"),
    texture_1d: new TokenType("texture_1d", TokenClass.keyword, "texture_1d"),
    texture_2d: new TokenType("texture_2d", TokenClass.keyword, "texture_2d"),
    texture_2d_array: new TokenType("texture_2d_array", TokenClass.keyword, "texture_2d_array"),
    texture_3d: new TokenType("texture_3d", TokenClass.keyword, "texture_3d"),
    texture_cube: new TokenType("texture_cube", TokenClass.keyword, "texture_cube"),
    texture_cube_array: new TokenType("texture_cube_array", TokenClass.keyword, "texture_cube_array"),
    texture_multisampled_2d: new TokenType("texture_multisampled_2d", TokenClass.keyword, "texture_multisampled_2d"),
    texture_storage_1d: new TokenType("texture_storage_1d", TokenClass.keyword, "texture_storage_1d"),
    texture_storage_2d: new TokenType("texture_storage_2d", TokenClass.keyword, "texture_storage_2d"),
    texture_storage_2d_array: new TokenType("texture_storage_2d_array", TokenClass.keyword, "texture_storage_2d_array"),
    texture_storage_3d: new TokenType("texture_storage_3d", TokenClass.keyword, "texture_storage_3d"),
    texture_depth_2d: new TokenType("texture_depth_2d", TokenClass.keyword, "texture_depth_2d"),
    texture_depth_2d_array: new TokenType("texture_depth_2d_array", TokenClass.keyword, "texture_depth_2d_array"),
    texture_depth_cube: new TokenType("texture_depth_cube", TokenClass.keyword, "texture_depth_cube"),
    texture_depth_cube_array: new TokenType("texture_depth_cube_array", TokenClass.keyword, "texture_depth_cube_array"),
    texture_depth_multisampled_2d: new TokenType("texture_depth_multisampled_2d", TokenClass.keyword, "texture_depth_multisampled_2d"),
    texture_external: new TokenType("texture_external", TokenClass.keyword, "texture_external"),
    u32: new TokenType("u32", TokenClass.keyword, "u32"),
    vec2: new TokenType("vec2", TokenClass.keyword, "vec2"),
    vec3: new TokenType("vec3", TokenClass.keyword, "vec3"),
    vec4: new TokenType("vec4", TokenClass.keyword, "vec4"),
    bitcast: new TokenType("bitcast", TokenClass.keyword, "bitcast"),
    block: new TokenType("block", TokenClass.keyword, "block"),
    break: new TokenType("break", TokenClass.keyword, "break"),
    case: new TokenType("case", TokenClass.keyword, "case"),
    continue: new TokenType("continue", TokenClass.keyword, "continue"),
    continuing: new TokenType("continuing", TokenClass.keyword, "continuing"),
    default: new TokenType("default", TokenClass.keyword, "default"),
    diagnostic: new TokenType("diagnostic", TokenClass.keyword, "diagnostic"),
    discard: new TokenType("discard", TokenClass.keyword, "discard"),
    else: new TokenType("else", TokenClass.keyword, "else"),
    enable: new TokenType("enable", TokenClass.keyword, "enable"),
    fallthrough: new TokenType("fallthrough", TokenClass.keyword, "fallthrough"),
    false: new TokenType("false", TokenClass.keyword, "false"),
    fn: new TokenType("fn", TokenClass.keyword, "fn"),
    for: new TokenType("for", TokenClass.keyword, "for"),
    function: new TokenType("function", TokenClass.keyword, "function"),
    if: new TokenType("if", TokenClass.keyword, "if"),
    let: new TokenType("let", TokenClass.keyword, "let"),
    const: new TokenType("const", TokenClass.keyword, "const"),
    loop: new TokenType("loop", TokenClass.keyword, "loop"),
    while: new TokenType("while", TokenClass.keyword, "while"),
    private: new TokenType("private", TokenClass.keyword, "private"),
    read: new TokenType("read", TokenClass.keyword, "read"),
    read_write: new TokenType("read_write", TokenClass.keyword, "read_write"),
    return: new TokenType("return", TokenClass.keyword, "return"),
    requires: new TokenType("requires", TokenClass.keyword, "requires"),
    storage: new TokenType("storage", TokenClass.keyword, "storage"),
    switch: new TokenType("switch", TokenClass.keyword, "switch"),
    true: new TokenType("true", TokenClass.keyword, "true"),
    alias: new TokenType("alias", TokenClass.keyword, "alias"),
    type: new TokenType("type", TokenClass.keyword, "type"),
    uniform: new TokenType("uniform", TokenClass.keyword, "uniform"),
    var: new TokenType("var", TokenClass.keyword, "var"),
    override: new TokenType("override", TokenClass.keyword, "override"),
    workgroup: new TokenType("workgroup", TokenClass.keyword, "workgroup"),
    write: new TokenType("write", TokenClass.keyword, "write"),
    r8unorm: new TokenType("r8unorm", TokenClass.keyword, "r8unorm"),
    r8snorm: new TokenType("r8snorm", TokenClass.keyword, "r8snorm"),
    r8uint: new TokenType("r8uint", TokenClass.keyword, "r8uint"),
    r8sint: new TokenType("r8sint", TokenClass.keyword, "r8sint"),
    r16uint: new TokenType("r16uint", TokenClass.keyword, "r16uint"),
    r16sint: new TokenType("r16sint", TokenClass.keyword, "r16sint"),
    r16float: new TokenType("r16float", TokenClass.keyword, "r16float"),
    rg8unorm: new TokenType("rg8unorm", TokenClass.keyword, "rg8unorm"),
    rg8snorm: new TokenType("rg8snorm", TokenClass.keyword, "rg8snorm"),
    rg8uint: new TokenType("rg8uint", TokenClass.keyword, "rg8uint"),
    rg8sint: new TokenType("rg8sint", TokenClass.keyword, "rg8sint"),
    r32uint: new TokenType("r32uint", TokenClass.keyword, "r32uint"),
    r32sint: new TokenType("r32sint", TokenClass.keyword, "r32sint"),
    r32float: new TokenType("r32float", TokenClass.keyword, "r32float"),
    rg16uint: new TokenType("rg16uint", TokenClass.keyword, "rg16uint"),
    rg16sint: new TokenType("rg16sint", TokenClass.keyword, "rg16sint"),
    rg16float: new TokenType("rg16float", TokenClass.keyword, "rg16float"),
    rgba8unorm: new TokenType("rgba8unorm", TokenClass.keyword, "rgba8unorm"),
    rgba8unorm_srgb: new TokenType("rgba8unorm_srgb", TokenClass.keyword, "rgba8unorm_srgb"),
    rgba8snorm: new TokenType("rgba8snorm", TokenClass.keyword, "rgba8snorm"),
    rgba8uint: new TokenType("rgba8uint", TokenClass.keyword, "rgba8uint"),
    rgba8sint: new TokenType("rgba8sint", TokenClass.keyword, "rgba8sint"),
    bgra8unorm: new TokenType("bgra8unorm", TokenClass.keyword, "bgra8unorm"),
    bgra8unorm_srgb: new TokenType("bgra8unorm_srgb", TokenClass.keyword, "bgra8unorm_srgb"),
    rgb10a2unorm: new TokenType("rgb10a2unorm", TokenClass.keyword, "rgb10a2unorm"),
    rg11b10float: new TokenType("rg11b10float", TokenClass.keyword, "rg11b10float"),
    rg32uint: new TokenType("rg32uint", TokenClass.keyword, "rg32uint"),
    rg32sint: new TokenType("rg32sint", TokenClass.keyword, "rg32sint"),
    rg32float: new TokenType("rg32float", TokenClass.keyword, "rg32float"),
    rgba16uint: new TokenType("rgba16uint", TokenClass.keyword, "rgba16uint"),
    rgba16sint: new TokenType("rgba16sint", TokenClass.keyword, "rgba16sint"),
    rgba16float: new TokenType("rgba16float", TokenClass.keyword, "rgba16float"),
    rgba32uint: new TokenType("rgba32uint", TokenClass.keyword, "rgba32uint"),
    rgba32sint: new TokenType("rgba32sint", TokenClass.keyword, "rgba32sint"),
    rgba32float: new TokenType("rgba32float", TokenClass.keyword, "rgba32float"),
    static_assert: new TokenType("static_assert", TokenClass.keyword, "static_assert")
    // WGSL grammar has a few keywords that have different token names than the strings they
    // represent. Aliasing them here.
    /*int32: new TokenType("i32", TokenClass.keyword, "i32"),
        uint32: new TokenType("u32", TokenClass.keyword, "u32"),
        float32: new TokenType("f32", TokenClass.keyword, "f32"),
        pointer: new TokenType("ptr", TokenClass.keyword, "ptr"),*/
  };
  TokenTypes.tokens = {
    decimal_float_literal: new TokenType("decimal_float_literal", TokenClass.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
    hex_float_literal: new TokenType("hex_float_literal", TokenClass.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
    int_literal: new TokenType("int_literal", TokenClass.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
    uint_literal: new TokenType("uint_literal", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
    ident: new TokenType("ident", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
    and: new TokenType("and", TokenClass.token, "&"),
    and_and: new TokenType("and_and", TokenClass.token, "&&"),
    arrow: new TokenType("arrow ", TokenClass.token, "->"),
    attr: new TokenType("attr", TokenClass.token, "@"),
    forward_slash: new TokenType("forward_slash", TokenClass.token, "/"),
    bang: new TokenType("bang", TokenClass.token, "!"),
    bracket_left: new TokenType("bracket_left", TokenClass.token, "["),
    bracket_right: new TokenType("bracket_right", TokenClass.token, "]"),
    brace_left: new TokenType("brace_left", TokenClass.token, "{"),
    brace_right: new TokenType("brace_right", TokenClass.token, "}"),
    colon: new TokenType("colon", TokenClass.token, ":"),
    comma: new TokenType("comma", TokenClass.token, ","),
    equal: new TokenType("equal", TokenClass.token, "="),
    equal_equal: new TokenType("equal_equal", TokenClass.token, "=="),
    not_equal: new TokenType("not_equal", TokenClass.token, "!="),
    greater_than: new TokenType("greater_than", TokenClass.token, ">"),
    greater_than_equal: new TokenType("greater_than_equal", TokenClass.token, ">="),
    shift_right: new TokenType("shift_right", TokenClass.token, ">>"),
    less_than: new TokenType("less_than", TokenClass.token, "<"),
    less_than_equal: new TokenType("less_than_equal", TokenClass.token, "<="),
    shift_left: new TokenType("shift_left", TokenClass.token, "<<"),
    modulo: new TokenType("modulo", TokenClass.token, "%"),
    minus: new TokenType("minus", TokenClass.token, "-"),
    minus_minus: new TokenType("minus_minus", TokenClass.token, "--"),
    period: new TokenType("period", TokenClass.token, "."),
    plus: new TokenType("plus", TokenClass.token, "+"),
    plus_plus: new TokenType("plus_plus", TokenClass.token, "++"),
    or: new TokenType("or", TokenClass.token, "|"),
    or_or: new TokenType("or_or", TokenClass.token, "||"),
    paren_left: new TokenType("paren_left", TokenClass.token, "("),
    paren_right: new TokenType("paren_right", TokenClass.token, ")"),
    semicolon: new TokenType("semicolon", TokenClass.token, ";"),
    star: new TokenType("star", TokenClass.token, "*"),
    tilde: new TokenType("tilde", TokenClass.token, "~"),
    underscore: new TokenType("underscore", TokenClass.token, "_"),
    xor: new TokenType("xor", TokenClass.token, "^"),
    plus_equal: new TokenType("plus_equal", TokenClass.token, "+="),
    minus_equal: new TokenType("minus_equal", TokenClass.token, "-="),
    times_equal: new TokenType("times_equal", TokenClass.token, "*="),
    division_equal: new TokenType("division_equal", TokenClass.token, "/="),
    modulo_equal: new TokenType("modulo_equal", TokenClass.token, "%="),
    and_equal: new TokenType("and_equal", TokenClass.token, "&="),
    or_equal: new TokenType("or_equal", TokenClass.token, "|="),
    xor_equal: new TokenType("xor_equal", TokenClass.token, "^="),
    shift_right_equal: new TokenType("shift_right_equal", TokenClass.token, ">>="),
    shift_left_equal: new TokenType("shift_left_equal", TokenClass.token, "<<=")
  };
  TokenTypes.simpleTokens = {
    "@": _a.tokens.attr,
    "{": _a.tokens.brace_left,
    "}": _a.tokens.brace_right,
    ":": _a.tokens.colon,
    ",": _a.tokens.comma,
    "(": _a.tokens.paren_left,
    ")": _a.tokens.paren_right,
    ";": _a.tokens.semicolon
  };
  TokenTypes.literalTokens = {
    "&": _a.tokens.and,
    "&&": _a.tokens.and_and,
    "->": _a.tokens.arrow,
    "/": _a.tokens.forward_slash,
    "!": _a.tokens.bang,
    "[": _a.tokens.bracket_left,
    "]": _a.tokens.bracket_right,
    "=": _a.tokens.equal,
    "==": _a.tokens.equal_equal,
    "!=": _a.tokens.not_equal,
    ">": _a.tokens.greater_than,
    ">=": _a.tokens.greater_than_equal,
    ">>": _a.tokens.shift_right,
    "<": _a.tokens.less_than,
    "<=": _a.tokens.less_than_equal,
    "<<": _a.tokens.shift_left,
    "%": _a.tokens.modulo,
    "-": _a.tokens.minus,
    "--": _a.tokens.minus_minus,
    ".": _a.tokens.period,
    "+": _a.tokens.plus,
    "++": _a.tokens.plus_plus,
    "|": _a.tokens.or,
    "||": _a.tokens.or_or,
    "*": _a.tokens.star,
    "~": _a.tokens.tilde,
    "_": _a.tokens.underscore,
    "^": _a.tokens.xor,
    "+=": _a.tokens.plus_equal,
    "-=": _a.tokens.minus_equal,
    "*=": _a.tokens.times_equal,
    "/=": _a.tokens.division_equal,
    "%=": _a.tokens.modulo_equal,
    "&=": _a.tokens.and_equal,
    "|=": _a.tokens.or_equal,
    "^=": _a.tokens.xor_equal,
    ">>=": _a.tokens.shift_right_equal,
    "<<=": _a.tokens.shift_left_equal
  };
  TokenTypes.regexTokens = {
    decimal_float_literal: _a.tokens.decimal_float_literal,
    hex_float_literal: _a.tokens.hex_float_literal,
    int_literal: _a.tokens.int_literal,
    uint_literal: _a.tokens.uint_literal,
    ident: _a.tokens.ident
  };
  TokenTypes.storage_class = [
    _a.keywords.function,
    _a.keywords.private,
    _a.keywords.workgroup,
    _a.keywords.uniform,
    _a.keywords.storage
  ];
  TokenTypes.access_mode = [
    _a.keywords.read,
    _a.keywords.write,
    _a.keywords.read_write
  ];
  TokenTypes.sampler_type = [
    _a.keywords.sampler,
    _a.keywords.sampler_comparison
  ];
  TokenTypes.sampled_texture_type = [
    _a.keywords.texture_1d,
    _a.keywords.texture_2d,
    _a.keywords.texture_2d_array,
    _a.keywords.texture_3d,
    _a.keywords.texture_cube,
    _a.keywords.texture_cube_array
  ];
  TokenTypes.multisampled_texture_type = [
    _a.keywords.texture_multisampled_2d
  ];
  TokenTypes.storage_texture_type = [
    _a.keywords.texture_storage_1d,
    _a.keywords.texture_storage_2d,
    _a.keywords.texture_storage_2d_array,
    _a.keywords.texture_storage_3d
  ];
  TokenTypes.depth_texture_type = [
    _a.keywords.texture_depth_2d,
    _a.keywords.texture_depth_2d_array,
    _a.keywords.texture_depth_cube,
    _a.keywords.texture_depth_cube_array,
    _a.keywords.texture_depth_multisampled_2d
  ];
  TokenTypes.texture_external_type = [_a.keywords.texture_external];
  TokenTypes.any_texture_type = [
    ..._a.sampled_texture_type,
    ..._a.multisampled_texture_type,
    ..._a.storage_texture_type,
    ..._a.depth_texture_type,
    ..._a.texture_external_type
  ];
  TokenTypes.texel_format = [
    _a.keywords.r8unorm,
    _a.keywords.r8snorm,
    _a.keywords.r8uint,
    _a.keywords.r8sint,
    _a.keywords.r16uint,
    _a.keywords.r16sint,
    _a.keywords.r16float,
    _a.keywords.rg8unorm,
    _a.keywords.rg8snorm,
    _a.keywords.rg8uint,
    _a.keywords.rg8sint,
    _a.keywords.r32uint,
    _a.keywords.r32sint,
    _a.keywords.r32float,
    _a.keywords.rg16uint,
    _a.keywords.rg16sint,
    _a.keywords.rg16float,
    _a.keywords.rgba8unorm,
    _a.keywords.rgba8unorm_srgb,
    _a.keywords.rgba8snorm,
    _a.keywords.rgba8uint,
    _a.keywords.rgba8sint,
    _a.keywords.bgra8unorm,
    _a.keywords.bgra8unorm_srgb,
    _a.keywords.rgb10a2unorm,
    _a.keywords.rg11b10float,
    _a.keywords.rg32uint,
    _a.keywords.rg32sint,
    _a.keywords.rg32float,
    _a.keywords.rgba16uint,
    _a.keywords.rgba16sint,
    _a.keywords.rgba16float,
    _a.keywords.rgba32uint,
    _a.keywords.rgba32sint,
    _a.keywords.rgba32float
  ];
  TokenTypes.const_literal = [
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.decimal_float_literal,
    _a.tokens.hex_float_literal,
    _a.keywords.true,
    _a.keywords.false
  ];
  TokenTypes.literal_or_ident = [
    _a.tokens.ident,
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.decimal_float_literal,
    _a.tokens.hex_float_literal
  ];
  TokenTypes.element_count_expression = [
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.ident
  ];
  TokenTypes.template_types = [
    _a.keywords.vec2,
    _a.keywords.vec3,
    _a.keywords.vec4,
    _a.keywords.mat2x2,
    _a.keywords.mat2x3,
    _a.keywords.mat2x4,
    _a.keywords.mat3x2,
    _a.keywords.mat3x3,
    _a.keywords.mat3x4,
    _a.keywords.mat4x2,
    _a.keywords.mat4x3,
    _a.keywords.mat4x4,
    _a.keywords.atomic,
    _a.keywords.bitcast,
    ..._a.any_texture_type
  ];
  TokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block, _a.keywords.diagnostic];
  TokenTypes.assignment_operators = [
    _a.tokens.equal,
    _a.tokens.plus_equal,
    _a.tokens.minus_equal,
    _a.tokens.times_equal,
    _a.tokens.division_equal,
    _a.tokens.modulo_equal,
    _a.tokens.and_equal,
    _a.tokens.or_equal,
    _a.tokens.xor_equal,
    _a.tokens.shift_right_equal,
    _a.tokens.shift_left_equal
  ];
  TokenTypes.increment_operators = [
    _a.tokens.plus_plus,
    _a.tokens.minus_minus
  ];
  var Token = class {
    constructor(type, lexeme, line) {
      this.type = type;
      this.lexeme = lexeme;
      this.line = line;
    }
    toString() {
      return this.lexeme;
    }
    isTemplateType() {
      return TokenTypes.template_types.indexOf(this.type) != -1;
    }
    isArrayType() {
      return this.type == TokenTypes.keywords.array;
    }
    isArrayOrTemplateType() {
      return this.isArrayType() || this.isTemplateType();
    }
  };
  var WgslScanner = class {
    constructor(source3) {
      this._tokens = [];
      this._start = 0;
      this._current = 0;
      this._line = 1;
      this._source = source3 !== null && source3 !== void 0 ? source3 : "";
    }
    /// Scan all tokens from the source.
    scanTokens() {
      while (!this._isAtEnd()) {
        this._start = this._current;
        if (!this.scanToken()) {
          throw `Invalid syntax at line ${this._line}`;
        }
      }
      this._tokens.push(new Token(TokenTypes.eof, "", this._line));
      return this._tokens;
    }
    /// Scan a single token from the source.
    scanToken() {
      let lexeme = this._advance();
      if (lexeme == "\n") {
        this._line++;
        return true;
      }
      if (this._isWhitespace(lexeme)) {
        return true;
      }
      if (lexeme == "/") {
        if (this._peekAhead() == "/") {
          while (lexeme != "\n") {
            if (this._isAtEnd()) {
              return true;
            }
            lexeme = this._advance();
          }
          this._line++;
          return true;
        } else if (this._peekAhead() == "*") {
          this._advance();
          let commentLevel = 1;
          while (commentLevel > 0) {
            if (this._isAtEnd()) {
              return true;
            }
            lexeme = this._advance();
            if (lexeme == "\n") {
              this._line++;
            } else if (lexeme == "*") {
              if (this._peekAhead() == "/") {
                this._advance();
                commentLevel--;
                if (commentLevel == 0) {
                  return true;
                }
              }
            } else if (lexeme == "/") {
              if (this._peekAhead() == "*") {
                this._advance();
                commentLevel++;
              }
            }
          }
          return true;
        }
      }
      const simpleToken = TokenTypes.simpleTokens[lexeme];
      if (simpleToken) {
        this._addToken(simpleToken);
        return true;
      }
      let matchType = TokenTypes.none;
      const isAlpha = this._isAlpha(lexeme);
      const isUnderscore = lexeme === "_";
      if (this._isAlphaNumeric(lexeme)) {
        let nextChar = this._peekAhead();
        while (this._isAlphaNumeric(nextChar)) {
          lexeme += this._advance();
          nextChar = this._peekAhead();
        }
      }
      if (isAlpha) {
        const matchedType = TokenTypes.keywords[lexeme];
        if (matchedType) {
          this._addToken(matchedType);
          return true;
        }
      }
      if (isAlpha || isUnderscore) {
        this._addToken(TokenTypes.tokens.ident);
        return true;
      }
      for (; ; ) {
        let matchedType = this._findType(lexeme);
        const nextLexeme = this._peekAhead();
        if (lexeme == ">" && (nextLexeme == ">" || nextLexeme == "=")) {
          let foundLessThan = false;
          let ti = this._tokens.length - 1;
          for (let count3 = 0; count3 < 5 && ti >= 0; ++count3, --ti) {
            if (TokenTypes.assignment_operators.indexOf(this._tokens[ti].type) !== -1) {
              break;
            }
            if (this._tokens[ti].type === TokenTypes.tokens.less_than) {
              if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {
                foundLessThan = true;
              }
              break;
            }
          }
          if (foundLessThan) {
            this._addToken(matchedType);
            return true;
          }
        }
        if (matchedType === TokenTypes.none) {
          let lookAheadLexeme = lexeme;
          let lookAhead = 0;
          const maxLookAhead = 2;
          for (let li = 0; li < maxLookAhead; ++li) {
            lookAheadLexeme += this._peekAhead(li);
            matchedType = this._findType(lookAheadLexeme);
            if (matchedType !== TokenTypes.none) {
              lookAhead = li;
              break;
            }
          }
          if (matchedType === TokenTypes.none) {
            if (matchType === TokenTypes.none) {
              return false;
            }
            this._current--;
            this._addToken(matchType);
            return true;
          }
          lexeme = lookAheadLexeme;
          this._current += lookAhead + 1;
        }
        matchType = matchedType;
        if (this._isAtEnd()) {
          break;
        }
        lexeme += this._advance();
      }
      if (matchType === TokenTypes.none) {
        return false;
      }
      this._addToken(matchType);
      return true;
    }
    _findType(lexeme) {
      for (const name13 in TokenTypes.regexTokens) {
        const type2 = TokenTypes.regexTokens[name13];
        if (this._match(lexeme, type2.rule)) {
          return type2;
        }
      }
      const type = TokenTypes.literalTokens[lexeme];
      if (type) {
        return type;
      }
      return TokenTypes.none;
    }
    _match(lexeme, rule) {
      const match = rule.exec(lexeme);
      return match && match.index == 0 && match[0] == lexeme;
    }
    _isAtEnd() {
      return this._current >= this._source.length;
    }
    _isAlpha(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z";
    }
    _isAlphaNumeric(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 == "_" || c2 >= "0" && c2 <= "9";
    }
    _isWhitespace(c2) {
      return c2 == " " || c2 == "	" || c2 == "\r";
    }
    _advance(amount = 0) {
      let c2 = this._source[this._current];
      amount = amount || 0;
      amount++;
      this._current += amount;
      return c2;
    }
    _peekAhead(offset = 0) {
      offset = offset || 0;
      if (this._current + offset >= this._source.length) {
        return "\0";
      }
      return this._source[this._current + offset];
    }
    _addToken(type) {
      const text = this._source.substring(this._start, this._current);
      this._tokens.push(new Token(type, text, this._line));
    }
  };
  var WgslParser = class {
    constructor() {
      this._tokens = [];
      this._current = 0;
      this._currentLine = 0;
      this._context = new ParseContext();
      this._deferArrayCountEval = [];
    }
    parse(tokensOrCode) {
      this._initialize(tokensOrCode);
      this._deferArrayCountEval.length = 0;
      const statements = [];
      while (!this._isAtEnd()) {
        const statement = this._global_decl_or_directive();
        if (!statement) {
          break;
        }
        statements.push(statement);
      }
      if (this._deferArrayCountEval.length > 0) {
        for (const arrayDecl of this._deferArrayCountEval) {
          const arrayType = arrayDecl["arrayType"];
          const countNode = arrayDecl["countNode"];
          if (countNode instanceof VariableExpr) {
            const variable = countNode;
            const name13 = variable.name;
            const constant = this._context.constants.get(name13);
            if (constant) {
              try {
                const count3 = constant.evaluate(this._context);
                arrayType.count = count3;
              } catch (e3) {
              }
            }
          }
        }
        this._deferArrayCountEval.length = 0;
      }
      return statements;
    }
    _initialize(tokensOrCode) {
      if (tokensOrCode) {
        if (typeof tokensOrCode == "string") {
          const scanner = new WgslScanner(tokensOrCode);
          this._tokens = scanner.scanTokens();
        } else {
          this._tokens = tokensOrCode;
        }
      } else {
        this._tokens = [];
      }
      this._current = 0;
    }
    _error(token, message2) {
      return {
        token,
        message: message2,
        toString: function() {
          return `${message2}`;
        }
      };
    }
    _isAtEnd() {
      return this._current >= this._tokens.length || this._peek().type == TokenTypes.eof;
    }
    _match(types) {
      if (types instanceof TokenType) {
        if (this._check(types)) {
          this._advance();
          return true;
        }
        return false;
      }
      for (let i5 = 0, l3 = types.length; i5 < l3; ++i5) {
        const type = types[i5];
        if (this._check(type)) {
          this._advance();
          return true;
        }
      }
      return false;
    }
    _consume(types, message2) {
      if (this._check(types)) {
        return this._advance();
      }
      throw this._error(this._peek(), message2);
    }
    _check(types) {
      if (this._isAtEnd()) {
        return false;
      }
      const tk = this._peek();
      if (types instanceof Array) {
        const t3 = tk.type;
        const index = types.indexOf(t3);
        return index != -1;
      }
      return tk.type == types;
    }
    _advance() {
      var _a2, _b;
      this._currentLine = (_b = (_a2 = this._peek()) === null || _a2 === void 0 ? void 0 : _a2.line) !== null && _b !== void 0 ? _b : -1;
      if (!this._isAtEnd()) {
        this._current++;
      }
      return this._previous();
    }
    _peek() {
      return this._tokens[this._current];
    }
    _previous() {
      return this._tokens[this._current - 1];
    }
    _global_decl_or_directive() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._match(TokenTypes.keywords.alias)) {
        const type = this._type_alias();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return type;
      }
      if (this._match(TokenTypes.keywords.diagnostic)) {
        const directive = this._diagnostic();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return directive;
      }
      if (this._match(TokenTypes.keywords.requires)) {
        const requires = this._requires_directive();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return requires;
      }
      if (this._match(TokenTypes.keywords.enable)) {
        const enable2 = this._enable_directive();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return enable2;
      }
      const attrs = this._attribute();
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._global_variable_decl();
        if (_var != null) {
          _var.attributes = attrs;
        }
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _var;
      }
      if (this._check(TokenTypes.keywords.override)) {
        const _override = this._override_variable_decl();
        if (_override != null) {
          _override.attributes = attrs;
        }
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _override;
      }
      if (this._check(TokenTypes.keywords.let)) {
        const _let = this._global_let_decl();
        if (_let != null) {
          _let.attributes = attrs;
        }
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _let;
      }
      if (this._check(TokenTypes.keywords.const)) {
        const _const = this._global_const_decl();
        if (_const != null) {
          _const.attributes = attrs;
        }
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _const;
      }
      if (this._check(TokenTypes.keywords.struct)) {
        const _struct = this._struct_decl();
        if (_struct != null) {
          _struct.attributes = attrs;
        }
        return _struct;
      }
      if (this._check(TokenTypes.keywords.fn)) {
        const _fn = this._function_decl();
        if (_fn != null) {
          _fn.attributes = attrs;
        }
        return _fn;
      }
      return null;
    }
    _function_decl() {
      if (!this._match(TokenTypes.keywords.fn)) {
        return null;
      }
      const startLine = this._currentLine;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected function name.").toString();
      this._consume(TokenTypes.tokens.paren_left, "Expected '(' for function arguments.");
      const args = [];
      if (!this._check(TokenTypes.tokens.paren_right)) {
        do {
          if (this._check(TokenTypes.tokens.paren_right)) {
            break;
          }
          const argAttrs = this._attribute();
          const name14 = this._consume(TokenTypes.tokens.ident, "Expected argument name.").toString();
          this._consume(TokenTypes.tokens.colon, "Expected ':' for argument type.");
          const typeAttrs = this._attribute();
          const type = this._type_decl();
          if (type != null) {
            type.attributes = typeAttrs;
            args.push(new Argument(name14, type, argAttrs));
          }
        } while (this._match(TokenTypes.tokens.comma));
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' after function arguments.");
      let _return = null;
      if (this._match(TokenTypes.tokens.arrow)) {
        const attrs = this._attribute();
        _return = this._type_decl();
        if (_return != null) {
          _return.attributes = attrs;
        }
      }
      const body = this._compound_statement();
      const endLine = this._currentLine;
      return new Function(name13, args, _return, body, startLine, endLine);
    }
    _compound_statement() {
      const statements = [];
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for block.");
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const statement = this._statement();
        if (statement !== null) {
          statements.push(statement);
        }
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for block.");
      return statements;
    }
    _statement() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      if (this._check(TokenTypes.keywords.if)) {
        return this._if_statement();
      }
      if (this._check(TokenTypes.keywords.switch)) {
        return this._switch_statement();
      }
      if (this._check(TokenTypes.keywords.loop)) {
        return this._loop_statement();
      }
      if (this._check(TokenTypes.keywords.for)) {
        return this._for_statement();
      }
      if (this._check(TokenTypes.keywords.while)) {
        return this._while_statement();
      }
      if (this._check(TokenTypes.keywords.continuing)) {
        return this._continuing_statement();
      }
      if (this._check(TokenTypes.keywords.static_assert)) {
        return this._static_assert_statement();
      }
      if (this._check(TokenTypes.tokens.brace_left)) {
        return this._compound_statement();
      }
      let result = null;
      if (this._check(TokenTypes.keywords.return)) {
        result = this._return_statement();
      } else if (this._check([
        TokenTypes.keywords.var,
        TokenTypes.keywords.let,
        TokenTypes.keywords.const
      ])) {
        result = this._variable_statement();
      } else if (this._match(TokenTypes.keywords.discard)) {
        result = new Discard();
      } else if (this._match(TokenTypes.keywords.break)) {
        result = new Break();
      } else if (this._match(TokenTypes.keywords.continue)) {
        result = new Continue();
      } else {
        result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
      }
      if (result != null) {
        this._consume(TokenTypes.tokens.semicolon, "Expected ';' after statement.");
      }
      return result;
    }
    _static_assert_statement() {
      if (!this._match(TokenTypes.keywords.static_assert)) {
        return null;
      }
      const expression = this._optional_paren_expression();
      return new StaticAssert(expression);
    }
    _while_statement() {
      if (!this._match(TokenTypes.keywords.while)) {
        return null;
      }
      const condition = this._optional_paren_expression();
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      const block = this._compound_statement();
      return new While(condition, block);
    }
    _continuing_statement() {
      if (!this._match(TokenTypes.keywords.continuing)) {
        return null;
      }
      const block = this._compound_statement();
      return new Continuing(block);
    }
    _for_statement() {
      if (!this._match(TokenTypes.keywords.for)) {
        return null;
      }
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const init = !this._check(TokenTypes.tokens.semicolon) ? this._for_init() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const condition = !this._check(TokenTypes.tokens.semicolon) ? this._short_circuit_or_expression() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const increment = !this._check(TokenTypes.tokens.paren_right) ? this._for_increment() : null;
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      const body = this._compound_statement();
      return new For(init, condition, increment, body);
    }
    _for_init() {
      return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
    }
    _for_increment() {
      return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
    }
    _variable_statement() {
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._variable_decl();
        if (_var === null) {
          throw this._error(this._peek(), "Variable declaration expected.");
        }
        let value = null;
        if (this._match(TokenTypes.tokens.equal)) {
          value = this._short_circuit_or_expression();
        }
        return new Var(_var.name, _var.type, _var.storage, _var.access, value);
      }
      if (this._match(TokenTypes.keywords.let)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for let.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null) {
            type.attributes = typeAttrs;
          }
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for let.");
        const value = this._short_circuit_or_expression();
        return new Let(name13, type, null, null, value);
      }
      if (this._match(TokenTypes.keywords.const)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for const.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null) {
            type.attributes = typeAttrs;
          }
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for const.");
        const value = this._short_circuit_or_expression();
        return new Const(name13, type, null, null, value);
      }
      return null;
    }
    _increment_decrement_statement() {
      const savedPos = this._current;
      const _var = this._unary_expression();
      if (_var == null) {
        return null;
      }
      if (!this._check(TokenTypes.increment_operators)) {
        this._current = savedPos;
        return null;
      }
      const token = this._consume(TokenTypes.increment_operators, "Expected increment operator");
      return new Increment(token.type === TokenTypes.tokens.plus_plus ? IncrementOperator.increment : IncrementOperator.decrement, _var);
    }
    _assignment_statement() {
      let _var = null;
      if (this._check(TokenTypes.tokens.brace_right)) {
        return null;
      }
      let isUnderscore = this._match(TokenTypes.tokens.underscore);
      if (!isUnderscore) {
        _var = this._unary_expression();
      }
      if (!isUnderscore && _var == null) {
        return null;
      }
      const type = this._consume(TokenTypes.assignment_operators, "Expected assignment operator.");
      const value = this._short_circuit_or_expression();
      return new Assign(AssignOperator.parse(type.lexeme), _var, value);
    }
    _func_call_statement() {
      if (!this._check(TokenTypes.tokens.ident)) {
        return null;
      }
      const savedPos = this._current;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected function name.");
      const args = this._argument_expression_list();
      if (args === null) {
        this._current = savedPos;
        return null;
      }
      return new Call(name13.lexeme, args);
    }
    _loop_statement() {
      if (!this._match(TokenTypes.keywords.loop)) {
        return null;
      }
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for loop.");
      const statements = [];
      let statement = this._statement();
      while (statement !== null) {
        if (Array.isArray(statement)) {
          for (let s3 of statement) {
            statements.push(s3);
          }
        } else {
          statements.push(statement);
        }
        statement = this._statement();
      }
      let continuing = null;
      if (this._match(TokenTypes.keywords.continuing)) {
        continuing = this._compound_statement();
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for loop.");
      return new Loop(statements, continuing);
    }
    _switch_statement() {
      if (!this._match(TokenTypes.keywords.switch)) {
        return null;
      }
      const condition = this._optional_paren_expression();
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for switch.");
      const body = this._switch_body();
      if (body == null || body.length == 0) {
        throw this._error(this._previous(), "Expected 'case' or 'default'.");
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for switch.");
      return new Switch(condition, body);
    }
    _switch_body() {
      const cases = [];
      if (this._match(TokenTypes.keywords.case)) {
        const selector = this._case_selectors();
        this._match(TokenTypes.tokens.colon);
        if (this._check(TokenTypes.tokens.attr)) {
          this._attribute();
        }
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch case.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch case.");
        cases.push(new Case(selector, body));
      }
      if (this._match(TokenTypes.keywords.default)) {
        this._match(TokenTypes.tokens.colon);
        if (this._check(TokenTypes.tokens.attr)) {
          this._attribute();
        }
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch default.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch default.");
        cases.push(new Default(body));
      }
      if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {
        const _cases = this._switch_body();
        cases.push(_cases[0]);
      }
      return cases;
    }
    _case_selectors() {
      const selectors = [
        this._shift_expression()
        //?.evaluate(this._context).toString() ?? "",
      ];
      while (this._match(TokenTypes.tokens.comma)) {
        selectors.push(this._shift_expression());
      }
      return selectors;
    }
    _case_body() {
      if (this._match(TokenTypes.keywords.fallthrough)) {
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return [];
      }
      let statement = this._statement();
      if (statement == null) {
        return [];
      }
      if (!(statement instanceof Array)) {
        statement = [statement];
      }
      const nextStatement = this._case_body();
      if (nextStatement.length == 0) {
        return statement;
      }
      return [...statement, nextStatement[0]];
    }
    _if_statement() {
      if (!this._match(TokenTypes.keywords.if)) {
        return null;
      }
      const condition = this._optional_paren_expression();
      if (this._check(TokenTypes.tokens.attr)) {
        this._attribute();
      }
      const block = this._compound_statement();
      let elseif = [];
      if (this._match_elseif()) {
        if (this._check(TokenTypes.tokens.attr)) {
          this._attribute();
        }
        elseif = this._elseif_statement(elseif);
      }
      let _else = null;
      if (this._match(TokenTypes.keywords.else)) {
        if (this._check(TokenTypes.tokens.attr)) {
          this._attribute();
        }
        _else = this._compound_statement();
      }
      return new If(condition, block, elseif, _else);
    }
    _match_elseif() {
      if (this._tokens[this._current].type === TokenTypes.keywords.else && this._tokens[this._current + 1].type === TokenTypes.keywords.if) {
        this._advance();
        this._advance();
        return true;
      }
      return false;
    }
    _elseif_statement(elseif = []) {
      const condition = this._optional_paren_expression();
      const block = this._compound_statement();
      elseif.push(new ElseIf(condition, block));
      if (this._match_elseif()) {
        if (this._check(TokenTypes.tokens.attr)) {
          this._attribute();
        }
        this._elseif_statement(elseif);
      }
      return elseif;
    }
    _return_statement() {
      if (!this._match(TokenTypes.keywords.return)) {
        return null;
      }
      const value = this._short_circuit_or_expression();
      return new Return(value);
    }
    _short_circuit_or_expression() {
      let expr = this._short_circuit_and_expr();
      while (this._match(TokenTypes.tokens.or_or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());
      }
      return expr;
    }
    _short_circuit_and_expr() {
      let expr = this._inclusive_or_expression();
      while (this._match(TokenTypes.tokens.and_and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());
      }
      return expr;
    }
    _inclusive_or_expression() {
      let expr = this._exclusive_or_expression();
      while (this._match(TokenTypes.tokens.or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());
      }
      return expr;
    }
    _exclusive_or_expression() {
      let expr = this._and_expression();
      while (this._match(TokenTypes.tokens.xor)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());
      }
      return expr;
    }
    _and_expression() {
      let expr = this._equality_expression();
      while (this._match(TokenTypes.tokens.and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());
      }
      return expr;
    }
    _equality_expression() {
      const expr = this._relational_expression();
      if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {
        return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());
      }
      return expr;
    }
    _relational_expression() {
      let expr = this._shift_expression();
      while (this._match([
        TokenTypes.tokens.less_than,
        TokenTypes.tokens.greater_than,
        TokenTypes.tokens.less_than_equal,
        TokenTypes.tokens.greater_than_equal
      ])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());
      }
      return expr;
    }
    _shift_expression() {
      let expr = this._additive_expression();
      while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());
      }
      return expr;
    }
    _additive_expression() {
      let expr = this._multiplicative_expression();
      while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());
      }
      return expr;
    }
    _multiplicative_expression() {
      let expr = this._unary_expression();
      while (this._match([
        TokenTypes.tokens.star,
        TokenTypes.tokens.forward_slash,
        TokenTypes.tokens.modulo
      ])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());
      }
      return expr;
    }
    _unary_expression() {
      if (this._match([
        TokenTypes.tokens.minus,
        TokenTypes.tokens.bang,
        TokenTypes.tokens.tilde,
        TokenTypes.tokens.star,
        TokenTypes.tokens.and
      ])) {
        return new UnaryOperator(this._previous().toString(), this._unary_expression());
      }
      return this._singular_expression();
    }
    _singular_expression() {
      const expr = this._primary_expression();
      const p3 = this._postfix_expression();
      if (p3) {
        expr.postfix = p3;
      }
      return expr;
    }
    _postfix_expression() {
      if (this._match(TokenTypes.tokens.bracket_left)) {
        const expr = this._short_circuit_or_expression();
        this._consume(TokenTypes.tokens.bracket_right, "Expected ']'.");
        const arrayIndex = new ArrayIndex(expr);
        const p3 = this._postfix_expression();
        if (p3) {
          arrayIndex.postfix = p3;
        }
        return arrayIndex;
      }
      if (this._match(TokenTypes.tokens.period)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected member name.");
        const p3 = this._postfix_expression();
        const expr = new StringExpr(name13.lexeme);
        if (p3) {
          expr.postfix = p3;
        }
        return expr;
      }
      return null;
    }
    _getStruct(name13) {
      if (this._context.aliases.has(name13)) {
        const alias = this._context.aliases.get(name13).type;
        return alias;
      }
      if (this._context.structs.has(name13)) {
        const struct = this._context.structs.get(name13);
        return struct;
      }
      return null;
    }
    _primary_expression() {
      if (this._match(TokenTypes.tokens.ident)) {
        const name13 = this._previous().toString();
        if (this._check(TokenTypes.tokens.paren_left)) {
          const args2 = this._argument_expression_list();
          const struct = this._getStruct(name13);
          if (struct != null) {
            return new CreateExpr(struct, args2);
          }
          return new CallExpr(name13, args2);
        }
        if (this._context.constants.has(name13)) {
          const c2 = this._context.constants.get(name13);
          return new ConstExpr(name13, c2.value);
        }
        return new VariableExpr(name13);
      }
      if (this._match(TokenTypes.const_literal)) {
        return new LiteralExpr(parseFloat(this._previous().toString()));
      }
      if (this._check(TokenTypes.tokens.paren_left)) {
        return this._paren_expression();
      }
      if (this._match(TokenTypes.keywords.bitcast)) {
        this._consume(TokenTypes.tokens.less_than, "Expected '<'.");
        const type2 = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
        const value = this._paren_expression();
        return new BitcastExpr(type2, value);
      }
      const type = this._type_decl();
      const args = this._argument_expression_list();
      return new TypecastExpr(type, args);
    }
    _argument_expression_list() {
      if (!this._match(TokenTypes.tokens.paren_left)) {
        return null;
      }
      const args = [];
      do {
        if (this._check(TokenTypes.tokens.paren_right)) {
          break;
        }
        const arg = this._short_circuit_or_expression();
        args.push(arg);
      } while (this._match(TokenTypes.tokens.comma));
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' for agument list");
      return args;
    }
    _optional_paren_expression() {
      this._match(TokenTypes.tokens.paren_left);
      const expr = this._short_circuit_or_expression();
      this._match(TokenTypes.tokens.paren_right);
      return new GroupingExpr([expr]);
    }
    _paren_expression() {
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const expr = this._short_circuit_or_expression();
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new GroupingExpr([expr]);
    }
    _struct_decl() {
      if (!this._match(TokenTypes.keywords.struct)) {
        return null;
      }
      const startLine = this._currentLine;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for struct.").toString();
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for struct body.");
      const members = [];
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const memberAttrs = this._attribute();
        const memberName = this._consume(TokenTypes.tokens.ident, "Expected variable name.").toString();
        this._consume(TokenTypes.tokens.colon, "Expected ':' for struct member type.");
        const typeAttrs = this._attribute();
        const memberType = this._type_decl();
        if (memberType != null) {
          memberType.attributes = typeAttrs;
        }
        if (!this._check(TokenTypes.tokens.brace_right))
          this._consume(TokenTypes.tokens.comma, "Expected ',' for struct member.");
        else
          this._match(TokenTypes.tokens.comma);
        members.push(new Member(memberName, memberType, memberAttrs));
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' after struct body.");
      const endLine = this._currentLine;
      const structNode = new Struct(name13, members, startLine, endLine);
      this._context.structs.set(name13, structNode);
      return structNode;
    }
    _global_variable_decl() {
      const _var = this._variable_decl();
      if (_var && this._match(TokenTypes.tokens.equal)) {
        _var.value = this._const_expression();
      }
      return _var;
    }
    _override_variable_decl() {
      const _override = this._override_decl();
      if (_override && this._match(TokenTypes.tokens.equal)) {
        _override.value = this._const_expression();
      }
      return _override;
    }
    _global_const_decl() {
      if (!this._match(TokenTypes.keywords.const)) {
        return null;
      }
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = attrs;
        }
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        const valueExpr = this._short_circuit_or_expression();
        if (valueExpr instanceof CreateExpr) {
          value = valueExpr;
        } else if (valueExpr instanceof ConstExpr && valueExpr.initializer instanceof CreateExpr) {
          value = valueExpr.initializer;
        } else {
          try {
            const constValue = valueExpr.evaluate(this._context);
            value = new LiteralExpr(constValue);
          } catch (_a2) {
            value = valueExpr;
          }
        }
      }
      const c2 = new Const(name13.toString(), type, "", "", value);
      this._context.constants.set(c2.name, c2);
      return c2;
    }
    _global_let_decl() {
      if (!this._match(TokenTypes.keywords.let)) {
        return null;
      }
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = attrs;
        }
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        value = this._const_expression();
      }
      return new Let(name13.toString(), type, "", "", value);
    }
    _const_expression() {
      if (this._match(TokenTypes.const_literal)) {
        return new StringExpr(this._previous().toString());
      }
      const type = this._type_decl();
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      let args = [];
      while (!this._check(TokenTypes.tokens.paren_right)) {
        args.push(this._const_expression());
        if (!this._check(TokenTypes.tokens.comma)) {
          break;
        }
        this._advance();
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new CreateExpr(type, args);
    }
    _variable_decl() {
      if (!this._match(TokenTypes.keywords.var)) {
        return null;
      }
      let storage = "";
      let access = "";
      if (this._match(TokenTypes.tokens.less_than)) {
        storage = this._consume(TokenTypes.storage_class, "Expected storage_class.").toString();
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
      }
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = attrs;
        }
      }
      return new Var(name13.toString(), type, storage, access, null);
    }
    _override_decl() {
      if (!this._match(TokenTypes.keywords.override)) {
        return null;
      }
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null) {
          type.attributes = attrs;
        }
      }
      return new Override(name13.toString(), type, null);
    }
    _diagnostic() {
      this._consume(TokenTypes.tokens.paren_left, "Expected '('");
      const severity = this._consume(TokenTypes.tokens.ident, "Expected severity control name.");
      this._consume(TokenTypes.tokens.comma, "Expected ','");
      const rule = this._consume(TokenTypes.tokens.ident, "Expected diagnostic rule name.");
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
      return new Diagnostic(severity.toString(), rule.toString());
    }
    _enable_directive() {
      const name13 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      return new Enable(name13.toString());
    }
    _requires_directive() {
      const extensions = [this._consume(TokenTypes.tokens.ident, "identity expected.").toString()];
      while (this._match(TokenTypes.tokens.comma)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "identity expected.");
        extensions.push(name13.toString());
      }
      return new Requires(extensions);
    }
    _type_alias() {
      const name13 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      this._consume(TokenTypes.tokens.equal, "Expected '=' for type alias.");
      let aliasType = this._type_decl();
      if (aliasType === null) {
        throw this._error(this._peek(), "Expected Type for Alias.");
      }
      if (this._context.aliases.has(aliasType.name)) {
        aliasType = this._context.aliases.get(aliasType.name).type;
      }
      const aliasNode = new Alias(name13.toString(), aliasType);
      this._context.aliases.set(aliasNode.name, aliasNode);
      return aliasNode;
    }
    _type_decl() {
      if (this._check([
        TokenTypes.tokens.ident,
        ...TokenTypes.texel_format,
        TokenTypes.keywords.bool,
        TokenTypes.keywords.f32,
        TokenTypes.keywords.i32,
        TokenTypes.keywords.u32
      ])) {
        const type2 = this._advance();
        const typeName = type2.toString();
        if (this._context.structs.has(typeName)) {
          return this._context.structs.get(typeName);
        }
        if (this._context.aliases.has(typeName)) {
          return this._context.aliases.get(typeName).type;
        }
        return new Type(type2.toString());
      }
      let type = this._texture_sampler_types();
      if (type) {
        return type;
      }
      if (this._check(TokenTypes.template_types)) {
        let type2 = this._advance().toString();
        let format = null;
        let access = null;
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          access = null;
          if (this._match(TokenTypes.tokens.comma)) {
            access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
          }
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for type.");
        }
        return new TemplateType(type2, format, access);
      }
      if (this._match(TokenTypes.keywords.ptr)) {
        let pointer = this._previous().toString();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for pointer.");
        const storage = this._consume(TokenTypes.storage_class, "Expected storage_class for pointer");
        this._consume(TokenTypes.tokens.comma, "Expected ',' for pointer.");
        const decl = this._type_decl();
        let access = null;
        if (this._match(TokenTypes.tokens.comma)) {
          access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
        }
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for pointer.");
        return new PointerType(pointer, storage.toString(), decl, access);
      }
      const attrs = this._attribute();
      if (this._match(TokenTypes.keywords.array)) {
        let format = null;
        let countInt = -1;
        const array = this._previous();
        let countNode = null;
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          if (this._context.aliases.has(format.name)) {
            format = this._context.aliases.get(format.name).type;
          }
          let count3 = "";
          if (this._match(TokenTypes.tokens.comma)) {
            countNode = this._shift_expression();
            try {
              count3 = countNode.evaluate(this._context).toString();
              countNode = null;
            } catch (e3) {
              count3 = "1";
            }
          }
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for array.");
          countInt = count3 ? parseInt(count3) : 0;
        }
        const arrayType = new ArrayType(array.toString(), attrs, format, countInt);
        if (countNode) {
          this._deferArrayCountEval.push({ arrayType, countNode });
        }
        return arrayType;
      }
      return null;
    }
    _texture_sampler_types() {
      if (this._match(TokenTypes.sampler_type)) {
        return new SamplerType(this._previous().toString(), null, null);
      }
      if (this._match(TokenTypes.depth_texture_type)) {
        return new SamplerType(this._previous().toString(), null, null);
      }
      if (this._match(TokenTypes.sampled_texture_type) || this._match(TokenTypes.multisampled_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, null);
      }
      if (this._match(TokenTypes.storage_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._consume(TokenTypes.texel_format, "Invalid texel format.").toString();
        this._consume(TokenTypes.tokens.comma, "Expected ',' after texel format.");
        const access = this._consume(TokenTypes.access_mode, "Expected access mode for storage texture type.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, access);
      }
      return null;
    }
    _attribute() {
      let attributes = [];
      while (this._match(TokenTypes.tokens.attr)) {
        const name13 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
        const attr = new Attribute(name13.toString(), null);
        if (this._match(TokenTypes.tokens.paren_left)) {
          attr.value = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
          if (this._check(TokenTypes.tokens.comma)) {
            this._advance();
            do {
              const v2 = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
              if (!(attr.value instanceof Array)) {
                attr.value = [attr.value];
              }
              attr.value.push(v2);
            } while (this._match(TokenTypes.tokens.comma));
          }
          this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
        }
        attributes.push(attr);
      }
      if (attributes.length == 0) {
        return null;
      }
      return attributes;
    }
  };
  var TypeInfo = class {
    constructor(name13, attributes) {
      this.name = name13;
      this.attributes = attributes;
      this.size = 0;
    }
    get isArray() {
      return false;
    }
    get isStruct() {
      return false;
    }
    get isTemplate() {
      return false;
    }
  };
  var MemberInfo = class {
    constructor(name13, type, attributes) {
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
      this.offset = 0;
      this.size = 0;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var StructInfo = class extends TypeInfo {
    constructor(name13, attributes) {
      super(name13, attributes);
      this.members = [];
      this.align = 0;
      this.startLine = -1;
      this.endLine = -1;
      this.inUse = false;
    }
    get isStruct() {
      return true;
    }
  };
  var ArrayInfo = class extends TypeInfo {
    constructor(name13, attributes) {
      super(name13, attributes);
      this.count = 0;
      this.stride = 0;
    }
    get isArray() {
      return true;
    }
  };
  var TemplateInfo = class extends TypeInfo {
    constructor(name13, format, attributes, access) {
      super(name13, attributes);
      this.format = format;
      this.access = access;
    }
    get isTemplate() {
      return true;
    }
  };
  var ResourceType;
  (function(ResourceType2) {
    ResourceType2[ResourceType2["Uniform"] = 0] = "Uniform";
    ResourceType2[ResourceType2["Storage"] = 1] = "Storage";
    ResourceType2[ResourceType2["Texture"] = 2] = "Texture";
    ResourceType2[ResourceType2["Sampler"] = 3] = "Sampler";
    ResourceType2[ResourceType2["StorageTexture"] = 4] = "StorageTexture";
  })(ResourceType || (ResourceType = {}));
  var VariableInfo = class {
    constructor(name13, type, group, binding, attributes, resourceType, access) {
      this.name = name13;
      this.type = type;
      this.group = group;
      this.binding = binding;
      this.attributes = attributes;
      this.resourceType = resourceType;
      this.access = access;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get size() {
      return this.type.size;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var AliasInfo = class {
    constructor(name13, type) {
      this.name = name13;
      this.type = type;
    }
  };
  var _TypeSize = class {
    constructor(align, size) {
      this.align = align;
      this.size = size;
    }
  };
  var InputInfo = class {
    constructor(name13, type, locationType, location) {
      this.name = name13;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
      this.interpolation = null;
    }
  };
  var OutputInfo = class {
    constructor(name13, type, locationType, location) {
      this.name = name13;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
    }
  };
  var FunctionInfo = class {
    constructor(name13, stage = null) {
      this.stage = null;
      this.inputs = [];
      this.outputs = [];
      this.resources = [];
      this.startLine = -1;
      this.endLine = -1;
      this.inUse = false;
      this.calls = /* @__PURE__ */ new Set();
      this.name = name13;
      this.stage = stage;
    }
  };
  var EntryFunctions = class {
    constructor() {
      this.vertex = [];
      this.fragment = [];
      this.compute = [];
    }
  };
  var OverrideInfo = class {
    constructor(name13, type, attributes, id) {
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
      this.id = id;
    }
  };
  var _FunctionResources = class {
    constructor(node) {
      this.resources = null;
      this.inUse = false;
      this.info = null;
      this.node = node;
    }
  };
  var WgslReflect = class {
    constructor(code) {
      this.uniforms = [];
      this.storage = [];
      this.textures = [];
      this.samplers = [];
      this.aliases = [];
      this.overrides = [];
      this.structs = [];
      this.entry = new EntryFunctions();
      this.functions = [];
      this._types = /* @__PURE__ */ new Map();
      this._functions = /* @__PURE__ */ new Map();
      if (code) {
        this.update(code);
      }
    }
    _isStorageTexture(type) {
      return type.name == "texture_storage_1d" || type.name == "texture_storage_2d" || type.name == "texture_storage_2d_array" || type.name == "texture_storage_3d";
    }
    update(code) {
      const parser = new WgslParser();
      const ast = parser.parse(code);
      for (const node of ast) {
        if (node instanceof Function) {
          this._functions.set(node.name, new _FunctionResources(node));
        }
      }
      for (const node of ast) {
        if (node instanceof Struct) {
          const info = this._getTypeInfo(node, null);
          if (info instanceof StructInfo) {
            this.structs.push(info);
          }
        }
      }
      for (const node of ast) {
        if (node instanceof Alias) {
          this.aliases.push(this._getAliasInfo(node));
          continue;
        }
        if (node instanceof Override) {
          const v2 = node;
          const id = this._getAttributeNum(v2.attributes, "id", 0);
          const type = v2.type != null ? this._getTypeInfo(v2.type, v2.attributes) : null;
          this.overrides.push(new OverrideInfo(v2.name, type, v2.attributes, id));
          continue;
        }
        if (this._isUniformVar(node)) {
          const v2 = node;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, ResourceType.Uniform, v2.access);
          this.uniforms.push(varInfo);
          continue;
        }
        if (this._isStorageVar(node)) {
          const v2 = node;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v2.access);
          this.storage.push(varInfo);
          continue;
        }
        if (this._isTextureVar(node)) {
          const v2 = node;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v2.access);
          if (isStorageTexture) {
            this.storage.push(varInfo);
          } else {
            this.textures.push(varInfo);
          }
          continue;
        }
        if (this._isSamplerVar(node)) {
          const v2 = node;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, ResourceType.Sampler, v2.access);
          this.samplers.push(varInfo);
          continue;
        }
        if (node instanceof Function) {
          const vertexStage = this._getAttribute(node, "vertex");
          const fragmentStage = this._getAttribute(node, "fragment");
          const computeStage = this._getAttribute(node, "compute");
          const stage = vertexStage || fragmentStage || computeStage;
          const fn = new FunctionInfo(node.name, stage === null || stage === void 0 ? void 0 : stage.name);
          fn.startLine = node.startLine;
          fn.endLine = node.endLine;
          this.functions.push(fn);
          this._functions.get(node.name).info = fn;
          if (stage) {
            this._functions.get(node.name).inUse = true;
            fn.inUse = true;
            fn.resources = this._findResources(node, !!stage);
            fn.inputs = this._getInputs(node.args);
            fn.outputs = this._getOutputs(node.returnType);
            this.entry[stage.name].push(fn);
          }
          continue;
        }
      }
      for (const fn of this._functions.values()) {
        if (fn.info) {
          fn.info.inUse = fn.inUse;
          this._addCalls(fn.node, fn.info.calls);
        }
      }
      for (const u3 of this.uniforms) {
        this._markStructsInUse(u3.type);
      }
      for (const s3 of this.storage) {
        this._markStructsInUse(s3.type);
      }
    }
    _markStructsInUse(type) {
      if (type.isStruct) {
        type.inUse = true;
        for (const m of type.members) {
          this._markStructsInUse(m.type);
        }
      } else if (type.isArray) {
        this._markStructsInUse(type.format);
      } else if (type.isTemplate) {
        this._markStructsInUse(type.format);
      } else {
        const alias = this._getAlias(type.name);
        if (alias) {
          this._markStructsInUse(alias);
        }
      }
    }
    _addCalls(fn, calls) {
      var _a2;
      for (const call of fn.calls) {
        const info = (_a2 = this._functions.get(call.name)) === null || _a2 === void 0 ? void 0 : _a2.info;
        if (info) {
          calls.add(info);
        }
      }
    }
    /// Find a resource by its group and binding.
    findResource(group, binding) {
      for (const u3 of this.uniforms) {
        if (u3.group == group && u3.binding == binding) {
          return u3;
        }
      }
      for (const s3 of this.storage) {
        if (s3.group == group && s3.binding == binding) {
          return s3;
        }
      }
      for (const t3 of this.textures) {
        if (t3.group == group && t3.binding == binding) {
          return t3;
        }
      }
      for (const s3 of this.samplers) {
        if (s3.group == group && s3.binding == binding) {
          return s3;
        }
      }
      return null;
    }
    _findResource(name13) {
      for (const u3 of this.uniforms) {
        if (u3.name == name13) {
          return u3;
        }
      }
      for (const s3 of this.storage) {
        if (s3.name == name13) {
          return s3;
        }
      }
      for (const t3 of this.textures) {
        if (t3.name == name13) {
          return t3;
        }
      }
      for (const s3 of this.samplers) {
        if (s3.name == name13) {
          return s3;
        }
      }
      return null;
    }
    _markStructsFromAST(type) {
      const info = this._getTypeInfo(type, null);
      this._markStructsInUse(info);
    }
    _findResources(fn, isEntry) {
      const resources = [];
      const self2 = this;
      const varStack = [];
      fn.search((node) => {
        if (node instanceof _BlockStart) {
          varStack.push({});
        } else if (node instanceof _BlockEnd) {
          varStack.pop();
        } else if (node instanceof Var) {
          const v2 = node;
          if (isEntry && v2.type !== null) {
            this._markStructsFromAST(v2.type);
          }
          if (varStack.length > 0) {
            varStack[varStack.length - 1][v2.name] = v2;
          }
        } else if (node instanceof CreateExpr) {
          const c2 = node;
          if (isEntry && c2.type !== null) {
            this._markStructsFromAST(c2.type);
          }
        } else if (node instanceof Let) {
          const v2 = node;
          if (isEntry && v2.type !== null) {
            this._markStructsFromAST(v2.type);
          }
          if (varStack.length > 0) {
            varStack[varStack.length - 1][v2.name] = v2;
          }
        } else if (node instanceof VariableExpr) {
          const v2 = node;
          if (varStack.length > 0) {
            const varInfo2 = varStack[varStack.length - 1][v2.name];
            if (varInfo2) {
              return;
            }
          }
          const varInfo = self2._findResource(v2.name);
          if (varInfo) {
            resources.push(varInfo);
          }
        } else if (node instanceof CallExpr) {
          const c2 = node;
          const callFn = self2._functions.get(c2.name);
          if (callFn) {
            if (isEntry) {
              callFn.inUse = true;
            }
            fn.calls.add(callFn.node);
            if (callFn.resources === null) {
              callFn.resources = self2._findResources(callFn.node, isEntry);
            }
            resources.push(...callFn.resources);
          }
        } else if (node instanceof Call) {
          const c2 = node;
          const callFn = self2._functions.get(c2.name);
          if (callFn) {
            if (isEntry) {
              callFn.inUse = true;
            }
            fn.calls.add(callFn.node);
            if (callFn.resources === null) {
              callFn.resources = self2._findResources(callFn.node, isEntry);
            }
            resources.push(...callFn.resources);
          }
        }
      });
      return [...new Map(resources.map((r3) => [r3.name, r3])).values()];
    }
    getBindGroups() {
      const groups = [];
      function _makeRoom(group, binding) {
        if (group >= groups.length) {
          groups.length = group + 1;
        }
        if (groups[group] === void 0) {
          groups[group] = [];
        }
        if (binding >= groups[group].length) {
          groups[group].length = binding + 1;
        }
      }
      for (const u3 of this.uniforms) {
        _makeRoom(u3.group, u3.binding);
        const group = groups[u3.group];
        group[u3.binding] = u3;
      }
      for (const u3 of this.storage) {
        _makeRoom(u3.group, u3.binding);
        const group = groups[u3.group];
        group[u3.binding] = u3;
      }
      for (const t3 of this.textures) {
        _makeRoom(t3.group, t3.binding);
        const group = groups[t3.group];
        group[t3.binding] = t3;
      }
      for (const t3 of this.samplers) {
        _makeRoom(t3.group, t3.binding);
        const group = groups[t3.group];
        group[t3.binding] = t3;
      }
      return groups;
    }
    _getOutputs(type, outputs = void 0) {
      if (outputs === void 0) {
        outputs = [];
      }
      if (type instanceof Struct) {
        this._getStructOutputs(type, outputs);
      } else {
        const output = this._getOutputInfo(type);
        if (output !== null) {
          outputs.push(output);
        }
      }
      return outputs;
    }
    _getStructOutputs(struct, outputs) {
      for (const m of struct.members) {
        if (m.type instanceof Struct) {
          this._getStructOutputs(m.type, outputs);
        } else {
          const location = this._getAttribute(m, "location") || this._getAttribute(m, "builtin");
          if (location !== null) {
            const typeInfo = this._getTypeInfo(m.type, m.type.attributes);
            const locationValue = this._parseInt(location.value);
            const info = new OutputInfo(m.name, typeInfo, location.name, locationValue);
            outputs.push(info);
          }
        }
      }
    }
    _getOutputInfo(type) {
      const location = this._getAttribute(type, "location") || this._getAttribute(type, "builtin");
      if (location !== null) {
        const typeInfo = this._getTypeInfo(type, type.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new OutputInfo("", typeInfo, location.name, locationValue);
        return info;
      }
      return null;
    }
    _getInputs(args, inputs = void 0) {
      if (inputs === void 0) {
        inputs = [];
      }
      for (const arg of args) {
        if (arg.type instanceof Struct) {
          this._getStructInputs(arg.type, inputs);
        } else {
          const input = this._getInputInfo(arg);
          if (input !== null) {
            inputs.push(input);
          }
        }
      }
      return inputs;
    }
    _getStructInputs(struct, inputs) {
      for (const m of struct.members) {
        if (m.type instanceof Struct) {
          this._getStructInputs(m.type, inputs);
        } else {
          const input = this._getInputInfo(m);
          if (input !== null) {
            inputs.push(input);
          }
        }
      }
    }
    _getInputInfo(node) {
      const location = this._getAttribute(node, "location") || this._getAttribute(node, "builtin");
      if (location !== null) {
        const interpolation = this._getAttribute(node, "interpolation");
        const type = this._getTypeInfo(node.type, node.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new InputInfo(node.name, type, location.name, locationValue);
        if (interpolation !== null) {
          info.interpolation = this._parseString(interpolation.value);
        }
        return info;
      }
      return null;
    }
    _parseString(s3) {
      if (s3 instanceof Array) {
        s3 = s3[0];
      }
      return s3;
    }
    _parseInt(s3) {
      if (s3 instanceof Array) {
        s3 = s3[0];
      }
      const n3 = parseInt(s3);
      return isNaN(n3) ? s3 : n3;
    }
    _getAlias(name13) {
      for (const a3 of this.aliases) {
        if (a3.name == name13) {
          return a3.type;
        }
      }
      return null;
    }
    _getAliasInfo(node) {
      return new AliasInfo(node.name, this._getTypeInfo(node.type, null));
    }
    _getTypeInfo(type, attributes) {
      if (this._types.has(type)) {
        return this._types.get(type);
      }
      if (type instanceof ArrayType) {
        const a3 = type;
        const t3 = this._getTypeInfo(a3.format, a3.attributes);
        const info2 = new ArrayInfo(a3.name, attributes);
        info2.format = t3;
        info2.count = a3.count;
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof Struct) {
        const s3 = type;
        const info2 = new StructInfo(s3.name, attributes);
        info2.startLine = s3.startLine;
        info2.endLine = s3.endLine;
        for (const m of s3.members) {
          const t3 = this._getTypeInfo(m.type, m.attributes);
          info2.members.push(new MemberInfo(m.name, t3, m.attributes));
        }
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof SamplerType) {
        const s3 = type;
        const formatIsType = s3.format instanceof Type;
        const format = s3.format ? formatIsType ? this._getTypeInfo(s3.format, null) : new TypeInfo(s3.format, null) : null;
        const info2 = new TemplateInfo(s3.name, format, attributes, s3.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof TemplateType) {
        const t3 = type;
        const format = t3.format ? this._getTypeInfo(t3.format, null) : null;
        const info2 = new TemplateInfo(t3.name, format, attributes, t3.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      const info = new TypeInfo(type.name, attributes);
      this._types.set(type, info);
      this._updateTypeInfo(info);
      return info;
    }
    _updateTypeInfo(type) {
      var _a2, _b;
      const typeSize = this._getTypeSize(type);
      type.size = (_a2 = typeSize === null || typeSize === void 0 ? void 0 : typeSize.size) !== null && _a2 !== void 0 ? _a2 : 0;
      if (type instanceof ArrayInfo) {
        const formatInfo = this._getTypeSize(type["format"]);
        type.stride = (_b = formatInfo === null || formatInfo === void 0 ? void 0 : formatInfo.size) !== null && _b !== void 0 ? _b : 0;
        this._updateTypeInfo(type["format"]);
      }
      if (type instanceof StructInfo) {
        this._updateStructInfo(type);
      }
    }
    _updateStructInfo(struct) {
      var _a2;
      let offset = 0;
      let lastSize = 0;
      let lastOffset = 0;
      let structAlign = 0;
      for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {
        const member = struct.members[mi];
        const sizeInfo = this._getTypeSize(member);
        if (!sizeInfo) {
          continue;
        }
        (_a2 = this._getAlias(member.type.name)) !== null && _a2 !== void 0 ? _a2 : member.type;
        const align = sizeInfo.align;
        const size = sizeInfo.size;
        offset = this._roundUp(align, offset + lastSize);
        lastSize = size;
        lastOffset = offset;
        structAlign = Math.max(structAlign, align);
        member.offset = offset;
        member.size = size;
        this._updateTypeInfo(member.type);
      }
      struct.size = this._roundUp(structAlign, lastOffset + lastSize);
      struct.align = structAlign;
    }
    _getTypeSize(type) {
      var _a2;
      if (type === null || type === void 0) {
        return null;
      }
      const explicitSize = this._getAttributeNum(type.attributes, "size", 0);
      const explicitAlign = this._getAttributeNum(type.attributes, "align", 0);
      if (type instanceof MemberInfo) {
        type = type.type;
      }
      if (type instanceof TypeInfo) {
        const alias = this._getAlias(type.name);
        if (alias !== null) {
          type = alias;
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name];
        if (info !== void 0) {
          const divisor = type["format"] === "f16" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name.substring(0, type.name.length - 1)];
        if (info) {
          const divisor = type.name[type.name.length - 1] === "h" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      if (type instanceof ArrayInfo) {
        let arrayType = type;
        let align = 8;
        let size = 8;
        const E = this._getTypeSize(arrayType.format);
        if (E !== null) {
          size = E.size;
          align = E.align;
        }
        const N2 = arrayType.count;
        const stride = this._getAttributeNum((_a2 = type === null || type === void 0 ? void 0 : type.attributes) !== null && _a2 !== void 0 ? _a2 : null, "stride", this._roundUp(align, size));
        size = N2 * stride;
        if (explicitSize) {
          size = explicitSize;
        }
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      if (type instanceof StructInfo) {
        let align = 0;
        let size = 0;
        let offset = 0;
        let lastSize = 0;
        let lastOffset = 0;
        for (const m of type.members) {
          const mi = this._getTypeSize(m.type);
          if (mi !== null) {
            align = Math.max(mi.align, align);
            offset = this._roundUp(mi.align, offset + lastSize);
            lastSize = mi.size;
            lastOffset = offset;
          }
        }
        size = this._roundUp(align, lastOffset + lastSize);
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      return null;
    }
    _isUniformVar(node) {
      return node instanceof Var && node.storage == "uniform";
    }
    _isStorageVar(node) {
      return node instanceof Var && node.storage == "storage";
    }
    _isTextureVar(node) {
      return node instanceof Var && node.type !== null && WgslReflect._textureTypes.indexOf(node.type.name) != -1;
    }
    _isSamplerVar(node) {
      return node instanceof Var && node.type !== null && WgslReflect._samplerTypes.indexOf(node.type.name) != -1;
    }
    _getAttribute(node, name13) {
      const obj = node;
      if (!obj || !obj["attributes"]) {
        return null;
      }
      const attrs = obj["attributes"];
      for (let a3 of attrs) {
        if (a3.name == name13) {
          return a3;
        }
      }
      return null;
    }
    _getAttributeNum(attributes, name13, defaultValue2) {
      if (attributes === null) {
        return defaultValue2;
      }
      for (let a3 of attributes) {
        if (a3.name == name13) {
          let v2 = a3 !== null && a3.value !== null ? a3.value : defaultValue2;
          if (v2 instanceof Array) {
            v2 = v2[0];
          }
          if (typeof v2 === "number") {
            return v2;
          }
          if (typeof v2 === "string") {
            return parseInt(v2);
          }
          return defaultValue2;
        }
      }
      return defaultValue2;
    }
    _roundUp(k2, n3) {
      return Math.ceil(n3 / k2) * k2;
    }
  };
  WgslReflect._typeInfo = {
    f16: { align: 2, size: 2 },
    i32: { align: 4, size: 4 },
    u32: { align: 4, size: 4 },
    f32: { align: 4, size: 4 },
    atomic: { align: 4, size: 4 },
    vec2: { align: 8, size: 8 },
    vec3: { align: 16, size: 12 },
    vec4: { align: 16, size: 16 },
    mat2x2: { align: 8, size: 16 },
    mat3x2: { align: 8, size: 24 },
    mat4x2: { align: 8, size: 32 },
    mat2x3: { align: 16, size: 32 },
    mat3x3: { align: 16, size: 48 },
    mat4x3: { align: 16, size: 64 },
    mat2x4: { align: 16, size: 32 },
    mat3x4: { align: 16, size: 48 },
    mat4x4: { align: 16, size: 64 }
  };
  WgslReflect._textureTypes = TokenTypes.any_texture_type.map((t3) => {
    return t3.name;
  });
  WgslReflect._samplerTypes = TokenTypes.sampler_type.map((t3) => {
    return t3.name;
  });

  // ../../node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
  function getShaderLayoutFromWGSL(source3) {
    const shaderLayout = { attributes: [], bindings: [] };
    let parsedWGSL;
    try {
      parsedWGSL = parseWGSL(source3);
    } catch (error) {
      log2.error(error.message)();
      return shaderLayout;
    }
    for (const uniform of parsedWGSL.uniforms) {
      const members = [];
      for (const attribute of uniform.type?.members || []) {
        members.push({
          name: attribute.name,
          type: getType(attribute.type)
        });
      }
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniform.name,
        group: uniform.group,
        location: uniform.binding,
        // @ts-expect-error TODO - unused for now but needs fixing
        members
      });
    }
    for (const texture of parsedWGSL.textures) {
      shaderLayout.bindings.push({
        type: "texture",
        name: texture.name,
        group: texture.group,
        location: texture.binding
      });
    }
    for (const sampler of parsedWGSL.samplers) {
      shaderLayout.bindings.push({
        type: "sampler",
        name: sampler.name,
        group: sampler.group,
        location: sampler.binding
      });
    }
    const vertex5 = parsedWGSL.entry.vertex[0];
    const attributeCount = vertex5?.inputs.length || 0;
    for (let i5 = 0; i5 < attributeCount; i5++) {
      const wgslAttribute = vertex5.inputs[i5];
      if (wgslAttribute.locationType === "location") {
        const type = getType(wgslAttribute.type);
        shaderLayout.attributes.push({
          name: wgslAttribute.name,
          location: Number(wgslAttribute.location),
          type
        });
      }
    }
    return shaderLayout;
  }
  function getType(type) {
    return type.format ? `${type.name}<${type.format.name}>` : type.name;
  }
  function parseWGSL(source3) {
    try {
      return new WgslReflect(source3);
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      let message2 = "WGSL parse error";
      if (typeof error === "object" && error?.message) {
        message2 += `: ${error.message} `;
      }
      if (typeof error === "object" && error?.token) {
        message2 += error.token.line || "";
      }
      throw new Error(message2, { cause: error });
    }
  }

  // ../../node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
  var config = globalThis.mathgl.config;
  function formatValue(value, { precision = config.precision } = {}) {
    value = round(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function radians(degrees6, result) {
    return map(degrees6, (degrees7) => degrees7 * DEGREES_TO_RADIANS, result);
  }
  function degrees(radians6, result) {
    return map(radians6, (radians7) => radians7 * RADIANS_TO_DEGREES, result);
  }
  function clamp(value, min6, max6) {
    return map(value, (value2) => Math.max(min6, Math.min(max6, value2)));
  }
  function lerp(a3, b2, t3) {
    if (isArray(a3)) {
      return a3.map((ai, i5) => lerp(ai, b2[i5], t3));
    }
    return t3 * b2 + (1 - t3) * a3;
  }
  function equals(a3, b2, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray(a3) && isArray(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value, func, result) {
    if (isArray(value)) {
      const array = value;
      result = result || duplicateArray(array);
      for (let i5 = 0; i5 < result.length && i5 < array.length; ++i5) {
        const val2 = typeof value === "number" ? value : value[i5];
        result[i5] = func(val2, i5, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector(v2, length16, callerName = "") {
    if (config.debug && !validateVector(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@math.gl/core/dist/lib/assert.js
  function assert6(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector = class extends MathArray {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert6(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i5]);
    }
    setComponent(i5, value) {
      assert6(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add,
    angle: () => angle,
    ceil: () => ceil,
    clone: () => clone,
    copy: () => copy,
    create: () => create,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals2,
    exactEquals: () => exactEquals,
    floor: () => floor,
    forEach: () => forEach2,
    fromValues: () => fromValues,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp2,
    max: () => max,
    min: () => min,
    mul: () => mul,
    multiply: () => multiply,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotate: () => rotate,
    round: () => round3,
    scale: () => scale,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    zero: () => zero
  });

  // ../../node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  function round2(a3) {
    if (a3 >= 0)
      return Math.round(a3);
    return a3 % 0.5 === 0 ? Math.floor(a3) : Math.round(a3);
  }
  var degree = Math.PI / 180;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create() {
    const out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone(a3) {
    const out = new ARRAY_TYPE(2);
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function fromValues(x3, y3) {
    const out = new ARRAY_TYPE(2);
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function copy(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function set(out, x3, y3) {
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function add(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    return out;
  }
  function subtract(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    return out;
  }
  function multiply(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    return out;
  }
  function divide(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    return out;
  }
  function ceil(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    return out;
  }
  function floor(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    return out;
  }
  function min(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    return out;
  }
  function max(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    return out;
  }
  function round3(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    return out;
  }
  function scale(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    return out;
  }
  function scaleAndAdd(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    return out;
  }
  function distance(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    return Math.sqrt(x3 * x3 + y3 * y3);
  }
  function squaredDistance(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    return x3 * x3 + y3 * y3;
  }
  function length(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    return Math.sqrt(x3 * x3 + y3 * y3);
  }
  function squaredLength(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    return x3 * x3 + y3 * y3;
  }
  function negate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    return out;
  }
  function inverse(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    return out;
  }
  function normalize(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    let len8 = x3 * x3 + y3 * y3;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    return out;
  }
  function dot(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1];
  }
  function cross(out, a3, b2) {
    const z2 = a3[0] * b2[1] - a3[1] * b2[0];
    out[0] = out[1] = 0;
    out[2] = z2;
    return out;
  }
  function lerp2(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    return out;
  }
  function random(out, scale22) {
    scale22 = scale22 === void 0 ? 1 : scale22;
    const r3 = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r3) * scale22;
    out[1] = Math.sin(r3) * scale22;
    return out;
  }
  function transformMat2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    return out;
  }
  function transformMat2d(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3 + m[4];
    out[1] = m[1] * x3 + m[3] * y3 + m[5];
    return out;
  }
  function transformMat3(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  function transformMat4(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[4] * y3 + m[12];
    out[1] = m[1] * x3 + m[5] * y3 + m[13];
    return out;
  }
  function rotate(out, a3, b2, rad) {
    const p0 = a3[0] - b2[0];
    const p1 = a3[1] - b2[1];
    const sinC = Math.sin(rad);
    const cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b2[0];
    out[1] = p0 * sinC + p1 * cosC + b2[1];
    return out;
  }
  function angle(a3, b2) {
    const x1 = a3[0];
    const y1 = a3[1];
    const x22 = b2[0];
    const y22 = b2[1];
    const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x22 * x22 + y22 * y22));
    const cosine = mag && (x1 * x22 + y1 * y22) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str(a3) {
    return `vec2(${a3[0]}, ${a3[1]})`;
  }
  function exactEquals(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1];
  }
  function equals2(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const b0 = b2[0];
    const b1 = b2[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  var len = length;
  var sub = subtract;
  var mul = multiply;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var sqrLen = squaredLength;
  var forEach2 = function() {
    const vec = create();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m[3] * x3 + m[7] * y3 || 1;
    out[0] = (m[0] * x3 + m[4] * y3) / w2;
    out[1] = (m[1] * x3 + m[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function vec4_transformMat3(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m[0] * x3 + m[3] * y3 + m[6] * z2;
    out[1] = m[1] * x3 + m[4] * y3 + m[7] * z2;
    out[2] = m[2] * x3 + m[5] * y3 + m[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/classes/vector2.js
  var Vector2 = class extends Vector {
    // Creates a new, empty vec2
    constructor(x3 = 0, y3 = 0) {
      super(2);
      if (isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
        }
        this[0] = x3;
        this[1] = y3;
      }
    }
    set(x3, y3) {
      this[0] = x3;
      this[1] = y3;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 2;
    }
    /**
     * Returns angle from x axis
     * @returns
     */
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    /**
     * Returns angle from y axis
     * @returns
     */
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    // Transforms
    /**
     * Transforms as point
     * @param matrix4
     * @returns
     */
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    /**
     * transforms as point (4th component is implicitly 1)
     * @param matrix4
     * @returns
     */
    transformAsPoint(matrix4) {
      transformMat4(this, this, matrix4);
      return this.check();
    }
    /**
     * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
     * @param matrix4
     * @returns
     */
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat2(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add2,
    angle: () => angle2,
    bezier: () => bezier,
    ceil: () => ceil2,
    clone: () => clone2,
    copy: () => copy2,
    create: () => create2,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals3,
    exactEquals: () => exactEquals2,
    floor: () => floor2,
    forEach: () => forEach3,
    fromValues: () => fromValues2,
    hermite: () => hermite,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp3,
    max: () => max2,
    min: () => min2,
    mul: () => mul2,
    multiply: () => multiply2,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    round: () => round4,
    scale: () => scale2,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set2,
    slerp: () => slerp,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat,
    zero: () => zero2
  });
  function create2() {
    const out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone2(a3) {
    const out = new ARRAY_TYPE(3);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function length2(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues2(x3, y3, z2) {
    const out = new ARRAY_TYPE(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function copy2(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function set2(out, x3, y3, z2) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function add2(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    return out;
  }
  function subtract2(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    return out;
  }
  function multiply2(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    out[2] = a3[2] * b2[2];
    return out;
  }
  function divide2(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    out[2] = a3[2] / b2[2];
    return out;
  }
  function ceil2(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    return out;
  }
  function floor2(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    return out;
  }
  function min2(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    out[2] = Math.min(a3[2], b2[2]);
    return out;
  }
  function max2(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    out[2] = Math.max(a3[2], b2[2]);
    return out;
  }
  function round4(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    out[2] = round2(a3[2]);
    return out;
  }
  function scale2(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    return out;
  }
  function scaleAndAdd2(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    out[2] = a3[2] + b2[2] * scale22;
    return out;
  }
  function distance2(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function squaredDistance2(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function squaredLength2(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function negate2(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    return out;
  }
  function inverse2(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    return out;
  }
  function normalize2(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    out[2] = a3[2] * len8;
    return out;
  }
  function dot2(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross2(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp3(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    return out;
  }
  function slerp(out, a3, b2, t3) {
    const angle9 = Math.acos(Math.min(Math.max(dot2(a3, b2), -1), 1));
    const sinTotal = Math.sin(angle9);
    const ratioA = Math.sin((1 - t3) * angle9) / sinTotal;
    const ratioB = Math.sin(t3 * angle9) / sinTotal;
    out[0] = ratioA * a3[0] + ratioB * b2[0];
    out[1] = ratioA * a3[1] + ratioB * b2[1];
    out[2] = ratioA * a3[2] + ratioB * b2[2];
    return out;
  }
  function hermite(out, a3, b2, c2, d2, t3) {
    const factorTimes2 = t3 * t3;
    const factor1 = factorTimes2 * (2 * t3 - 3) + 1;
    const factor2 = factorTimes2 * (t3 - 2) + t3;
    const factor3 = factorTimes2 * (t3 - 1);
    const factor4 = factorTimes2 * (3 - 2 * t3);
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function bezier(out, a3, b2, c2, d2, t3) {
    const inverseFactor = 1 - t3;
    const inverseFactorTimesTwo = inverseFactor * inverseFactor;
    const factorTimes2 = t3 * t3;
    const factor1 = inverseFactorTimesTwo * inverseFactor;
    const factor2 = 3 * t3 * inverseFactorTimesTwo;
    const factor3 = 3 * factorTimes2 * inverseFactor;
    const factor4 = factorTimes2 * t3;
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function random2(out, scale22) {
    scale22 = scale22 === void 0 ? 1 : scale22;
    const r3 = RANDOM() * 2 * Math.PI;
    const z2 = RANDOM() * 2 - 1;
    const zScale = Math.sqrt(1 - z2 * z2) * scale22;
    out[0] = Math.cos(r3) * zScale;
    out[1] = Math.sin(r3) * zScale;
    out[2] = z2 * scale22;
    return out;
  }
  function transformMat42(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat32(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle2(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot2(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str2(a3) {
    return `vec3(${a3[0]}, ${a3[1]}, ${a3[2]})`;
  }
  function exactEquals2(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2];
  }
  function equals3(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
  }
  var sub2 = subtract2;
  var mul2 = multiply2;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach3 = function() {
    const vec = create2();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray(x3)) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
          checkNumber(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle2(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross2(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN }) {
      rotateX(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN }) {
      rotateY(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN }) {
      rotateZ(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat32(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/vector4.js
  var ZERO2;
  var Vector4 = class extends Vector {
    static get ZERO() {
      if (!ZERO2) {
        ZERO2 = new Vector4(0, 0, 0, 0);
        Object.freeze(ZERO2);
      }
      return ZERO2;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 0) {
      super(-0, -0, -0, -0);
      if (isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
          checkNumber(z2);
          checkNumber(w2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
        this[3] = w2;
      }
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
        checkNumber(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    transform(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
    // three.js compatibility
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix = class extends MathArray {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function create3() {
    const out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply3(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate2(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale3(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES10[INDICES10["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES || (INDICES = {}));
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix3 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    // Constructors
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /** Calculates a 3x3 matrix from the given quaternion
     * q quat  Quaternion to create matrix from
     */
    fromQuaternion(q2) {
      fromQuat(this, q2);
      return this.check();
    }
    /**
     * accepts column major order, stores in column major order
     */
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    /**
     * accepts row major order, stores as column major
     */
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant(this);
    }
    // Modifiers
    transpose() {
      transpose(this, this);
      return this.check();
    }
    /** Invert a matrix. Note that this can fail if the matrix is not invertible */
    invert() {
      invert(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply3(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply3(this, this, a3);
      return this.check();
    }
    rotate(radians6) {
      rotate2(this, this, radians6);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale3(this, this, factor);
      } else {
        scale3(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate(this, this, vec);
      return this.check();
    }
    // Transforms
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat32(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX3;
  var IDENTITY_MATRIX3 = null;
  function getZeroMatrix() {
    if (!ZERO_MATRIX3) {
      ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX3);
    }
    return ZERO_MATRIX3;
  }
  function getIdentityMatrix() {
    if (!IDENTITY_MATRIX3) {
      IDENTITY_MATRIX3 = new Matrix3();
      Object.freeze(IDENTITY_MATRIX3);
    }
    return IDENTITY_MATRIX3;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add3,
    adjoint: () => adjoint,
    clone: () => clone3,
    copy: () => copy3,
    create: () => create4,
    decompose: () => decompose,
    determinant: () => determinant2,
    equals: () => equals4,
    exactEquals: () => exactEquals3,
    frob: () => frob,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues3,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul3,
    multiply: () => multiply4,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate3,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    scale: () => scale4,
    set: () => set3,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create4() {
    const out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone3(a3) {
    const out = new ARRAY_TYPE(16);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function copy3(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function fromValues3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    const out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert2(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    out[0] = a11 * b11 - a12 * b10 + a13 * b09;
    out[1] = a02 * b10 - a01 * b11 - a03 * b09;
    out[2] = a31 * b05 - a32 * b04 + a33 * b03;
    out[3] = a22 * b04 - a21 * b05 - a23 * b03;
    out[4] = a12 * b08 - a10 * b11 - a13 * b07;
    out[5] = a00 * b11 - a02 * b08 + a03 * b07;
    out[6] = a32 * b02 - a30 * b05 - a33 * b01;
    out[7] = a20 * b05 - a22 * b02 + a23 * b01;
    out[8] = a10 * b10 - a11 * b08 + a13 * b06;
    out[9] = a01 * b08 - a00 * b10 - a03 * b06;
    out[10] = a30 * b04 - a31 * b02 + a33 * b00;
    out[11] = a21 * b02 - a20 * b04 - a23 * b00;
    out[12] = a11 * b07 - a10 * b09 - a12 * b06;
    out[13] = a00 * b09 - a01 * b07 + a02 * b06;
    out[14] = a31 * b01 - a30 * b03 - a32 * b00;
    out[15] = a20 * b03 - a21 * b01 + a22 * b00;
    return out;
  }
  function determinant2(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply4(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale4(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate3(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len8 < EPSILON) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromTranslation(out, v2) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromScaling(out, v2) {
    out[0] = v2[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v2[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v2[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation(out, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    if (len8 < EPSILON) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    out[0] = x3 * x3 * t3 + c2;
    out[1] = y3 * x3 * t3 + z2 * s3;
    out[2] = z2 * x3 * t3 - y3 * s3;
    out[3] = 0;
    out[4] = x3 * y3 * t3 - z2 * s3;
    out[5] = y3 * y3 * t3 + c2;
    out[6] = z2 * y3 * t3 + x3 * s3;
    out[7] = 0;
    out[8] = x3 * z2 * t3 + y3 * s3;
    out[9] = y3 * z2 * t3 - x3 * s3;
    out[10] = z2 * z2 * t3 + c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c2;
    out[6] = s3;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s3;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = 0;
    out[2] = -s3;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s3;
    out[9] = 0;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = s3;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s3;
    out[5] = c2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q2, v2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a3) {
    const translation = new ARRAY_TYPE(3);
    const bx = -a3[0];
    const by = -a3[1];
    const bz = -a3[2];
    const bw = a3[3];
    const ax = a3[4];
    const ay = a3[5];
    const az = a3[6];
    const aw = a3[7];
    const magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a3, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  function getRotation(out, mat) {
    const scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    const is1 = 1 / scaling[0];
    const is2 = 1 / scaling[1];
    const is3 = 1 / scaling[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S2;
      out[0] = (sm23 - sm32) / S2;
      out[1] = (sm31 - sm13) / S2;
      out[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S2;
      out[0] = 0.25 * S2;
      out[1] = (sm12 + sm21) / S2;
      out[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S2;
      out[0] = (sm12 + sm21) / S2;
      out[1] = 0.25 * S2;
      out[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S2;
      out[0] = (sm31 + sm13) / S2;
      out[1] = (sm23 + sm32) / S2;
      out[2] = 0.25 * S2;
    }
    return out;
  }
  function decompose(out_r, out_t, out_s, mat) {
    out_t[0] = mat[12];
    out_t[1] = mat[13];
    out_t[2] = mat[14];
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    const is1 = 1 / out_s[0];
    const is2 = 1 / out_s[1];
    const is3 = 1 / out_s[2];
    const sm11 = m11 * is1;
    const sm12 = m12 * is2;
    const sm13 = m13 * is3;
    const sm21 = m21 * is1;
    const sm22 = m22 * is2;
    const sm23 = m23 * is3;
    const sm31 = m31 * is1;
    const sm32 = m32 * is2;
    const sm33 = m33 * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out_r[3] = 0.25 * S2;
      out_r[0] = (sm23 - sm32) / S2;
      out_r[1] = (sm31 - sm13) / S2;
      out_r[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out_r[3] = (sm23 - sm32) / S2;
      out_r[0] = 0.25 * S2;
      out_r[1] = (sm12 + sm21) / S2;
      out_r[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out_r[3] = (sm31 - sm13) / S2;
      out_r[0] = (sm12 + sm21) / S2;
      out_r[1] = 0.25 * S2;
      out_r[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out_r[3] = (sm12 - sm21) / S2;
      out_r[0] = (sm31 + sm13) / S2;
      out_r[1] = (sm23 + sm32) / S2;
      out_r[2] = 0.25 * S2;
    }
    return out_r;
  }
  function fromRotationTranslationScale(out, q2, v2, s3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q2, v2, s3, o3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    const ox = o3[0];
    const oy = o3[1];
    const oz = o3[2];
    const out0 = (1 - (yy + zz)) * sx;
    const out1 = (xy + wz) * sx;
    const out2 = (xz - wy) * sx;
    const out4 = (xy - wz) * sy;
    const out5 = (1 - (xx + zz)) * sy;
    const out6 = (yz + wx) * sy;
    const out8 = (xz + wy) * sz;
    const out9 = (yz - wx) * sz;
    const out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function perspectiveZO(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function orthoZO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    let len8;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len8 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len8;
    z1 *= len8;
    z2 *= len8;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len8 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len8) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len8 = 1 / len8;
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len8 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len8) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len8 = 1 / len8;
      y0 *= len8;
      y1 *= len8;
      y22 *= len8;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target2, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    let z0 = eyex - target2[0];
    let z1 = eyey - target2[1];
    let z2 = eyez - target2[2];
    let len8 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
      z0 *= len8;
      z1 *= len8;
      z2 *= len8;
    }
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x22 = upx * z1 - upy * z0;
    len8 = x0 * x0 + x1 * x1 + x22 * x22;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z2 * x1;
    out[5] = z2 * x0 - z0 * x22;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str3(a3) {
    return `mat4(${a3[0]}, ${a3[1]}, ${a3[2]}, ${a3[3]}, ${a3[4]}, ${a3[5]}, ${a3[6]}, ${a3[7]}, ${a3[8]}, ${a3[9]}, ${a3[10]}, ${a3[11]}, ${a3[12]}, ${a3[13]}, ${a3[14]}, ${a3[15]})`;
  }
  function frob(a3) {
    return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8] + a3[9] * a3[9] + a3[10] * a3[10] + a3[11] * a3[11] + a3[12] * a3[12] + a3[13] * a3[13] + a3[14] * a3[14] + a3[15] * a3[15]);
  }
  function add3(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    out[4] = a3[4] + b2[4];
    out[5] = a3[5] + b2[5];
    out[6] = a3[6] + b2[6];
    out[7] = a3[7] + b2[7];
    out[8] = a3[8] + b2[8];
    out[9] = a3[9] + b2[9];
    out[10] = a3[10] + b2[10];
    out[11] = a3[11] + b2[11];
    out[12] = a3[12] + b2[12];
    out[13] = a3[13] + b2[13];
    out[14] = a3[14] + b2[14];
    out[15] = a3[15] + b2[15];
    return out;
  }
  function subtract3(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    out[3] = a3[3] - b2[3];
    out[4] = a3[4] - b2[4];
    out[5] = a3[5] - b2[5];
    out[6] = a3[6] - b2[6];
    out[7] = a3[7] - b2[7];
    out[8] = a3[8] - b2[8];
    out[9] = a3[9] - b2[9];
    out[10] = a3[10] - b2[10];
    out[11] = a3[11] - b2[11];
    out[12] = a3[12] - b2[12];
    out[13] = a3[13] - b2[13];
    out[14] = a3[14] - b2[14];
    out[15] = a3[15] - b2[15];
    return out;
  }
  function multiplyScalar(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    out[4] = a3[4] * b2;
    out[5] = a3[5] * b2;
    out[6] = a3[6] * b2;
    out[7] = a3[7] * b2;
    out[8] = a3[8] * b2;
    out[9] = a3[9] * b2;
    out[10] = a3[10] * b2;
    out[11] = a3[11] * b2;
    out[12] = a3[12] * b2;
    out[13] = a3[13] * b2;
    out[14] = a3[14] * b2;
    out[15] = a3[15] * b2;
    return out;
  }
  function multiplyScalarAndAdd(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    out[2] = a3[2] + b2[2] * scale22;
    out[3] = a3[3] + b2[3] * scale22;
    out[4] = a3[4] + b2[4] * scale22;
    out[5] = a3[5] + b2[5] * scale22;
    out[6] = a3[6] + b2[6] * scale22;
    out[7] = a3[7] + b2[7] * scale22;
    out[8] = a3[8] + b2[8] * scale22;
    out[9] = a3[9] + b2[9] * scale22;
    out[10] = a3[10] + b2[10] * scale22;
    out[11] = a3[11] + b2[11] * scale22;
    out[12] = a3[12] + b2[12] * scale22;
    out[13] = a3[13] + b2[13] * scale22;
    out[14] = a3[14] + b2[14] * scale22;
    out[15] = a3[15] + b2[15] * scale22;
    return out;
  }
  function exactEquals3(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2] && a3[3] === b2[3] && a3[4] === b2[4] && a3[5] === b2[5] && a3[6] === b2[6] && a3[7] === b2[7] && a3[8] === b2[8] && a3[9] === b2[9] && a3[10] === b2[10] && a3[11] === b2[11] && a3[12] === b2[12] && a3[13] === b2[13] && a3[14] === b2[14] && a3[15] === b2[15];
  }
  function equals4(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const a4 = a3[4];
    const a5 = a3[5];
    const a6 = a3[6];
    const a7 = a3[7];
    const a8 = a3[8];
    const a9 = a3[9];
    const a10 = a3[10];
    const a11 = a3[11];
    const a12 = a3[12];
    const a13 = a3[13];
    const a14 = a3[14];
    const a15 = a3[15];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    const b3 = b2[3];
    const b4 = b2[4];
    const b5 = b2[5];
    const b6 = b2[6];
    const b7 = b2[7];
    const b8 = b2[8];
    const b9 = b2[9];
    const b10 = b2[10];
    const b11 = b2[11];
    const b12 = b2[12];
    const b13 = b2[13];
    const b14 = b2[14];
    const b15 = b2[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul3 = multiply4;
  var sub3 = subtract3;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add4,
    ceil: () => ceil3,
    clone: () => clone4,
    copy: () => copy4,
    create: () => create5,
    cross: () => cross3,
    dist: () => dist3,
    distance: () => distance3,
    div: () => div3,
    divide: () => divide3,
    dot: () => dot3,
    equals: () => equals5,
    exactEquals: () => exactEquals4,
    floor: () => floor3,
    forEach: () => forEach4,
    fromValues: () => fromValues4,
    inverse: () => inverse3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp4,
    max: () => max3,
    min: () => min3,
    mul: () => mul4,
    multiply: () => multiply5,
    negate: () => negate3,
    normalize: () => normalize3,
    random: () => random3,
    round: () => round5,
    scale: () => scale5,
    scaleAndAdd: () => scaleAndAdd3,
    set: () => set4,
    sqrDist: () => sqrDist3,
    sqrLen: () => sqrLen3,
    squaredDistance: () => squaredDistance3,
    squaredLength: () => squaredLength3,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat43,
    transformQuat: () => transformQuat2,
    zero: () => zero3
  });
  function create5() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone4(a3) {
    const out = new ARRAY_TYPE(4);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromValues4(x3, y3, z2, w2) {
    const out = new ARRAY_TYPE(4);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = w2;
    return out;
  }
  function copy4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function set4(out, x3, y3, z2, w2) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = w2;
    return out;
  }
  function add4(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    return out;
  }
  function subtract4(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    out[3] = a3[3] - b2[3];
    return out;
  }
  function multiply5(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    out[2] = a3[2] * b2[2];
    out[3] = a3[3] * b2[3];
    return out;
  }
  function divide3(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    out[2] = a3[2] / b2[2];
    out[3] = a3[3] / b2[3];
    return out;
  }
  function ceil3(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    out[3] = Math.ceil(a3[3]);
    return out;
  }
  function floor3(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    out[3] = Math.floor(a3[3]);
    return out;
  }
  function min3(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    out[2] = Math.min(a3[2], b2[2]);
    out[3] = Math.min(a3[3], b2[3]);
    return out;
  }
  function max3(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    out[2] = Math.max(a3[2], b2[2]);
    out[3] = Math.max(a3[3], b2[3]);
    return out;
  }
  function round5(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    out[2] = round2(a3[2]);
    out[3] = round2(a3[3]);
    return out;
  }
  function scale5(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    return out;
  }
  function scaleAndAdd3(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    out[2] = a3[2] + b2[2] * scale22;
    out[3] = a3[3] + b2[3] * scale22;
    return out;
  }
  function distance3(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    const w2 = b2[3] - a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredDistance3(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    const w2 = b2[3] - a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function length3(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredLength3(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function negate3(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = -a3[3];
    return out;
  }
  function inverse3(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    out[3] = 1 / a3[3];
    return out;
  }
  function normalize3(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = x3 * len8;
    out[1] = y3 * len8;
    out[2] = z2 * len8;
    out[3] = w2 * len8;
    return out;
  }
  function dot3(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
  }
  function cross3(out, u3, v2, w2) {
    const A2 = v2[0] * w2[1] - v2[1] * w2[0];
    const B2 = v2[0] * w2[2] - v2[2] * w2[0];
    const C2 = v2[0] * w2[3] - v2[3] * w2[0];
    const D = v2[1] * w2[2] - v2[2] * w2[1];
    const E = v2[1] * w2[3] - v2[3] * w2[1];
    const F2 = v2[2] * w2[3] - v2[3] * w2[2];
    const G = u3[0];
    const H = u3[1];
    const I2 = u3[2];
    const J = u3[3];
    out[0] = H * F2 - I2 * E + J * D;
    out[1] = -(G * F2) + I2 * C2 - J * B2;
    out[2] = G * E - H * C2 + J * A2;
    out[3] = -(G * D) + H * B2 - I2 * A2;
    return out;
  }
  function lerp4(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    out[3] = aw + t3 * (b2[3] - aw);
    return out;
  }
  function random3(out, scale22) {
    scale22 = scale22 === void 0 ? 1 : scale22;
    let v1;
    let v2;
    let v3;
    let v4;
    let s1;
    let s22;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s22 = v3 * v3 + v4 * v4;
    } while (s22 >= 1);
    const d2 = Math.sqrt((1 - s1) / s22);
    out[0] = scale22 * v1;
    out[1] = scale22 * v2;
    out[2] = scale22 * v3 * d2;
    out[3] = scale22 * v4 * d2;
    return out;
  }
  function transformMat43(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    out[0] = m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12] * w2;
    out[1] = m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13] * w2;
    out[2] = m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14] * w2;
    out[3] = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15] * w2;
    return out;
  }
  function transformQuat2(out, a3, q2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  function zero3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a3) {
    return `vec4(${a3[0]}, ${a3[1]}, ${a3[2]}, ${a3[3]})`;
  }
  function exactEquals4(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2] && a3[3] === b2[3];
  }
  function equals5(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    const b3 = b2[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply5;
  var div3 = divide3;
  var dist3 = distance3;
  var sqrDist3 = squaredDistance3;
  var len3 = length3;
  var sqrLen3 = squaredLength3;
  var forEach4 = function() {
    const vec = create5();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES2;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES10[INDICES10["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES10[INDICES10["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES10[INDICES10["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES10[INDICES10["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES10[INDICES10["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES10[INDICES10["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES10[INDICES10["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES10[INDICES10["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES2 || (INDICES2 = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix2();
    }
    static get ZERO() {
      return getZeroMatrix2();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES2;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX2);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion2) {
      fromQuat3(this, quaternion2);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant2(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose2(this, this);
      return this.check();
    }
    invert() {
      invert2(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply4(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply4(this, this, a3);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians6) {
      rotateX2(this, this, radians6);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians6) {
      rotateY2(this, this, radians6);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians6) {
      rotateZ2(this, this, radians6);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians6, axis) {
      rotate3(this, this, radians6, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale4(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate2(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length: length16 } = vector;
      let out;
      switch (length16) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians6) {
      return this.identity().rotateX(radians6);
    }
    makeTranslation(x3, y3, z2) {
      return this.identity().translate([x3, y3, z2]);
    }
  };
  var ZERO3;
  var IDENTITY;
  function getZeroMatrix2() {
    if (!ZERO3) {
      ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO3);
    }
    return ZERO3;
  }
  function getIdentityMatrix2() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/quat.js
  function create6() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    const s3 = Math.sin(rad);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply6(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const bw = b2[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z2 * z2));
    return out;
  }
  function slerp2(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    let bx = b2[0];
    let by = b2[1];
    let bz = b2[2];
    let bw = b2[3];
    let cosom;
    let omega;
    let scale0;
    let scale1;
    let sinom;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t3) * omega) / sinom;
      scale1 = Math.sin(t3 * omega) / sinom;
    } else {
      scale0 = 1 - t3;
      scale1 = t3;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a3) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const dot17 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    const invDot = dot17 ? 1 / dot17 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat3(out, m) {
    const fTrace = m[0] + m[4] + m[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m[4] > m[0])
        i5 = 1;
      if (m[8] > m[i5 * 3 + i5])
        i5 = 2;
      const j2 = (i5 + 1) % 3;
      const k2 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m[i5 * 3 + i5] - m[j2 * 3 + j2] - m[k2 * 3 + k2] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j2 * 3 + k2] - m[k2 * 3 + j2]) * fRoot;
      out[j2] = (m[j2 * 3 + i5] + m[i5 * 3 + j2]) * fRoot;
      out[k2] = (m[k2 * 3 + i5] + m[i5 * 3 + k2]) * fRoot;
    }
    return out;
  }
  var add5 = add4;
  var scale6 = scale5;
  var dot4 = dot3;
  var lerp5 = lerp4;
  var length4 = length3;
  var squaredLength4 = squaredLength3;
  var normalize4 = normalize3;
  var rotationTo = function() {
    const tmpvec3 = create2();
    const xUnitVec3 = fromValues2(1, 0, 0);
    const yUnitVec3 = fromValues2(0, 1, 0);
    return function(out, a3, b2) {
      const dot17 = dot2(a3, b2);
      if (dot17 < -0.999999) {
        cross2(tmpvec3, xUnitVec3, a3);
        if (len2(tmpvec3) < 1e-6)
          cross2(tmpvec3, yUnitVec3, a3);
        normalize2(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot17 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      cross2(tmpvec3, a3, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot17;
      return normalize4(out, out);
    };
  }();
  var sqlerp = function() {
    const temp1 = create6();
    const temp2 = create6();
    return function(out, a3, b2, c2, d2, t3) {
      slerp2(temp1, a3, d2, t3);
      slerp2(temp2, b2, c2, t3);
      slerp2(out, temp1, temp2, 2 * t3 * (1 - t3));
      return out;
    };
  }();
  var setAxes = function() {
    const matr = create3();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize4(out, fromMat3(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/quaternion.js
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = class extends MathArray {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        this.set(x3, y3, z2, w2);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * NOTE: The resultant quaternion is not normalized, so you should
     * be sure to renormalize the quaternion yourself where necessary.
     * @param m
     * @returns
     */
    fromMatrix3(m) {
      fromMat3(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle(this, axis, rad);
      return this.check();
    }
    /** Set a quat to the identity quaternion */
    identity() {
      identity2(this);
      return this.check();
    }
    // Set the components of a quat to the given values
    // set(i, j, k, l) {
    //   quat_set(this, i, j, k, l);
    //   return this.check();
    // }
    // Sets a quat from the given angle and rotation axis, then returns it.
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    // Getters/setters
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    // Calculates the length of a quat
    len() {
      return length4(this);
    }
    // Calculates the squared length of a quat
    lengthSquared() {
      return squaredLength4(this);
    }
    // Calculates the dot product of two quat's
    // @return {Number}
    dot(a3) {
      return dot4(this, a3);
    }
    // Gets the rotation axis and angle for a given quaternion.
    // If a quaternion is created with setAxisAngle, this method will
    // return the same values as providied in the original parameter
    // list OR functionally equivalent values.
    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
    // is the same as the quaternion formed by [0, 0, 1] and 270.
    // This method favors the latter.
    // @return {{[x,y,z], Number}}
    // getAxisAngle() {
    //   const axis = [];
    // //   const angle = quat_getAxisAngle(axis, this);
    //   return {axis, angle};
    // }
    // MODIFIERS
    // Sets a quaternion to represent the shortest rotation from one vector
    // to another. Both vectors are assumed to be unit length.
    rotationTo(vectorA, vectorB) {
      rotationTo(this, vectorA, vectorB);
      return this.check();
    }
    // Sets the specified quaternion with values corresponding to the given axes.
    // Each axis is a vec3 and is expected to be unit length and perpendicular
    // to all other specified axes.
    // setAxes() {
    //   Number
    // }
    // Performs a spherical linear interpolation with two control points
    // sqlerp() {
    //   Number;
    // }
    // Adds two quat's
    add(a3) {
      add5(this, this, a3);
      return this.check();
    }
    // Calculates the W component of a quat from the X, Y, and Z components.
    // Any existing W component will be ignored.
    calculateW() {
      calculateW(this, this);
      return this.check();
    }
    // Calculates the conjugate of a quat If the quaternion is normalized,
    // this function is faster than quat_invert and produces the same result.
    conjugate() {
      conjugate(this, this);
      return this.check();
    }
    // Calculates the inverse of a quat
    invert() {
      invert3(this, this);
      return this.check();
    }
    // Performs a linear interpolation between two quat's
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      lerp5(this, a3, b2, t3);
      return this.check();
    }
    // Multiplies two quat's
    multiplyRight(a3) {
      multiply6(this, this, a3);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply6(this, a3, this);
      return this.check();
    }
    // Normalize a quat
    normalize() {
      const length16 = this.len();
      const l3 = length16 > 0 ? 1 / length16 : 0;
      this[0] = this[0] * l3;
      this[1] = this[1] * l3;
      this[2] = this[2] * l3;
      this[3] = this[3] * l3;
      if (length16 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    // Rotates a quaternion by the given angle about the X axis
    rotateX(rad) {
      rotateX3(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Y axis
    rotateY(rad) {
      rotateY3(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Z axis
    rotateZ(rad) {
      rotateZ3(this, this, rad);
      return this.check();
    }
    // Scales a quat by a scalar number
    scale(b2) {
      scale6(this, this, b2);
      return this.check();
    }
    // Performs a spherical linear interpolation between two quat
    slerp(arg0, arg1, arg2) {
      let start;
      let target2;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION,
            target: target2,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target2 = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target2 = arg1;
          ratio = arg2;
      }
      slerp2(this, start, target2, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector4()) {
      transformQuat2(result, vector, this);
      return checkVector(result, 4);
    }
    // THREE.js Math API compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a3) {
      return this.multiplyLeft(a3);
    }
    multiply(a3) {
      return this.multiplyRight(a3);
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/spherical-coordinates.js
  var EPSILON2 = 1e-6;
  var EARTH_RADIUS_METERS = 6371e3;
  var SphericalCoordinates = class {
    // bearing: number;
    // pitch: number;
    // altitude: number;
    // lnglatZ coordinates
    // longitude: number;
    // latitude: number;
    // lng: number;
    // lat: number;
    // z: number;
    /**
     * Creates a new SphericalCoordinates object
     * @param options
     * @param [options.phi] =0 - rotation around X (latitude)
     * @param [options.theta] =0 - rotation around Y (longitude)
     * @param [options.radius] =1 - Distance from center
     * @param [options.bearing]
     * @param [options.pitch]
     * @param [options.altitude]
     * @param [options.radiusScale] =1
     */
    // eslint-disable-next-line complexity
    constructor({ phi = 0, theta = 0, radius = 1, bearing, pitch, altitude, radiusScale = EARTH_RADIUS_METERS } = {}) {
      this.phi = phi;
      this.theta = theta;
      this.radius = radius || altitude || 1;
      this.radiusScale = radiusScale || 1;
      if (bearing !== void 0) {
        this.bearing = bearing;
      }
      if (pitch !== void 0) {
        this.pitch = pitch;
      }
      this.check();
    }
    toString() {
      return this.formatString(config);
    }
    formatString({ printTypes = false }) {
      const f4 = formatValue;
      return `${printTypes ? "Spherical" : ""}[rho:${f4(this.radius)},theta:${f4(this.theta)},phi:${f4(this.phi)}]`;
    }
    equals(other) {
      return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
    }
    exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
    /* eslint-disable brace-style */
    // Cartographic (bearing 0 north, pitch 0 look from above)
    get bearing() {
      return 180 - degrees(this.phi);
    }
    set bearing(v2) {
      this.phi = Math.PI - radians(v2);
    }
    get pitch() {
      return degrees(this.theta);
    }
    set pitch(v2) {
      this.theta = radians(v2);
    }
    // get pitch() { return 90 - degrees(this.phi); }
    // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }
    // get altitude() { return this.radius - 1; } // relative altitude
    // lnglatZ coordinates
    get longitude() {
      return degrees(this.phi);
    }
    get latitude() {
      return degrees(this.theta);
    }
    get lng() {
      return degrees(this.phi);
    }
    get lat() {
      return degrees(this.theta);
    }
    get z() {
      return (this.radius - 1) * this.radiusScale;
    }
    /* eslint-enable brace-style */
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
    clone() {
      return new SphericalCoordinates().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
    fromLngLatZ([lng, lat, z2]) {
      this.radius = 1 + z2 / this.radiusScale;
      this.phi = radians(lat);
      this.theta = radians(lng);
      return this.check();
    }
    fromVector3(v2) {
      this.radius = length2(v2);
      if (this.radius > 0) {
        this.theta = Math.atan2(v2[0], v2[1]);
        this.phi = Math.acos(clamp(v2[2] / this.radius, -1, 1));
      }
      return this.check();
    }
    toVector3() {
      return new Vector3(0, 0, this.radius).rotateX({ radians: this.theta }).rotateZ({ radians: this.phi });
    }
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe() {
      this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
      return this;
    }
    check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error("SphericalCoordinates: some fields set to invalid numbers");
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/math-utils.js
  var math_utils_exports = {};
  __export(math_utils_exports, {
    EPSILON1: () => EPSILON1,
    EPSILON10: () => EPSILON10,
    EPSILON11: () => EPSILON11,
    EPSILON12: () => EPSILON12,
    EPSILON13: () => EPSILON13,
    EPSILON14: () => EPSILON14,
    EPSILON15: () => EPSILON15,
    EPSILON16: () => EPSILON16,
    EPSILON17: () => EPSILON17,
    EPSILON18: () => EPSILON18,
    EPSILON19: () => EPSILON19,
    EPSILON2: () => EPSILON22,
    EPSILON20: () => EPSILON20,
    EPSILON3: () => EPSILON3,
    EPSILON4: () => EPSILON4,
    EPSILON5: () => EPSILON5,
    EPSILON6: () => EPSILON6,
    EPSILON7: () => EPSILON7,
    EPSILON8: () => EPSILON8,
    EPSILON9: () => EPSILON9,
    PI_OVER_FOUR: () => PI_OVER_FOUR,
    PI_OVER_SIX: () => PI_OVER_SIX,
    PI_OVER_TWO: () => PI_OVER_TWO,
    TWO_PI: () => TWO_PI
  });
  var EPSILON1 = 0.1;
  var EPSILON22 = 0.01;
  var EPSILON3 = 1e-3;
  var EPSILON4 = 1e-4;
  var EPSILON5 = 1e-5;
  var EPSILON6 = 1e-6;
  var EPSILON7 = 1e-7;
  var EPSILON8 = 1e-8;
  var EPSILON9 = 1e-9;
  var EPSILON10 = 1e-10;
  var EPSILON11 = 1e-11;
  var EPSILON12 = 1e-12;
  var EPSILON13 = 1e-13;
  var EPSILON14 = 1e-14;
  var EPSILON15 = 1e-15;
  var EPSILON16 = 1e-16;
  var EPSILON17 = 1e-17;
  var EPSILON18 = 1e-18;
  var EPSILON19 = 1e-19;
  var EPSILON20 = 1e-20;
  var PI_OVER_TWO = Math.PI / 2;
  var PI_OVER_FOUR = Math.PI / 4;
  var PI_OVER_SIX = Math.PI / 6;
  var TWO_PI = Math.PI * 2;

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-utils.js
  function fp64ify(a3, out = [], startIndex = 0) {
    const hiPart = Math.fround(a3);
    const loPart = a3 - hiPart;
    out[startIndex] = hiPart;
    out[startIndex + 1] = loPart;
    return out;
  }
  function fp64LowPart(a3) {
    return a3 - Math.fround(a3);
  }
  function fp64ifyMatrix4(matrix) {
    const matrixFP64 = new Float32Array(32);
    for (let i5 = 0; i5 < 4; ++i5) {
      for (let j2 = 0; j2 < 4; ++j2) {
        const index = i5 * 4 + j2;
        fp64ify(matrix[j2 * 4 + i5], matrixFP64, index * 2);
      }
    }
    return matrixFP64;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
  var fp32shader = (
    /* glsl */
    `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
  );
  var fp32 = {
    name: "fp32",
    vs: fp32shader
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js
  var fp64arithmeticShader = (
    /* glsl */
    `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-functions-glsl.js
  var fp64functionShader = (
    /* glsl */
    `const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(fp64.ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(fp64.ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js
  var defaultUniforms = {
    // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
    ONE: 1
  };
  var fp64arithmetic = {
    name: "fp64arithmetic",
    vs: fp64arithmeticShader,
    defaultUniforms,
    uniformTypes: { ONE: "f32" },
    // Additional Functions
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };
  var fp64 = {
    name: "fp64",
    vs: fp64functionShader,
    dependencies: [fp64arithmetic],
    // Additional Functions
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];
  var vs = (
    /* glsl */
    `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
  );
  var fs = (
    /* glsl */
    `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
  );
  var picking = {
    props: {},
    uniforms: {},
    name: "picking",
    uniformTypes: {
      isActive: "f32",
      isAttribute: "f32",
      isHighlightActive: "f32",
      useFloatColors: "f32",
      highlightedObjectColor: "vec3<f32>",
      highlightColor: "vec4<f32>"
    },
    defaultUniforms: {
      isActive: false,
      isAttribute: false,
      isHighlightActive: false,
      useFloatColors: true,
      highlightedObjectColor: [0, 0, 0],
      highlightColor: DEFAULT_HIGHLIGHT_COLOR
    },
    vs,
    fs,
    getUniforms
  };
  function getUniforms(opts = {}, prevUniforms) {
    const uniforms = {};
    if (opts.highlightedObjectColor === void 0) {
    } else if (opts.highlightedObjectColor === null) {
      uniforms.isHighlightActive = false;
    } else {
      uniforms.isHighlightActive = true;
      const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
      uniforms.highlightedObjectColor = highlightedObjectColor;
    }
    if (opts.highlightColor) {
      const color = Array.from(opts.highlightColor, (x3) => x3 / 255);
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.highlightColor = color;
    }
    if (opts.isActive !== void 0) {
      uniforms.isActive = Boolean(opts.isActive);
      uniforms.isAttribute = Boolean(opts.isAttribute);
    }
    if (opts.useFloatColors !== void 0) {
      uniforms.useFloatColors = Boolean(opts.useFloatColors);
    }
    return uniforms;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js
  var lightingUniformsGLSL = (
    /* glsl */
    `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js
  var lightingUniformsWGSL = (
    /* wgsl */
    `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  poightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js
  var MAX_LIGHTS = 3;
  var COLOR_FACTOR = 255;
  var LIGHT_TYPE;
  (function(LIGHT_TYPE2) {
    LIGHT_TYPE2[LIGHT_TYPE2["POINT"] = 0] = "POINT";
    LIGHT_TYPE2[LIGHT_TYPE2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  })(LIGHT_TYPE || (LIGHT_TYPE = {}));
  var lighting = {
    props: {},
    uniforms: {},
    name: "lighting",
    defines: {
      MAX_LIGHTS
    },
    uniformTypes: {
      enabled: "i32",
      lightType: "i32",
      directionalLightCount: "i32",
      pointLightCount: "i32",
      ambientLightColor: "vec3<f32>",
      // TODO define as arrays once we have appropriate uniformTypes
      lightColor0: "vec3<f32>",
      lightPosition0: "vec3<f32>",
      // TODO - could combine direction and attenuation
      lightDirection0: "vec3<f32>",
      lightAttenuation0: "vec3<f32>",
      lightColor1: "vec3<f32>",
      lightPosition1: "vec3<f32>",
      lightDirection1: "vec3<f32>",
      lightAttenuation1: "vec3<f32>",
      lightColor2: "vec3<f32>",
      lightPosition2: "vec3<f32>",
      lightDirection2: "vec3<f32>",
      lightAttenuation2: "vec3<f32>"
    },
    defaultUniforms: {
      enabled: 1,
      lightType: LIGHT_TYPE.POINT,
      directionalLightCount: 0,
      pointLightCount: 0,
      ambientLightColor: [0.1, 0.1, 0.1],
      lightColor0: [1, 1, 1],
      lightPosition0: [1, 1, 2],
      // TODO - could combine direction and attenuation
      lightDirection0: [1, 1, 1],
      lightAttenuation0: [1, 0, 0],
      lightColor1: [1, 1, 1],
      lightPosition1: [1, 1, 2],
      lightDirection1: [1, 1, 1],
      lightAttenuation1: [1, 0, 0],
      lightColor2: [1, 1, 1],
      lightPosition2: [1, 1, 2],
      lightDirection2: [1, 1, 1],
      lightAttenuation2: [1, 0, 0]
    },
    source: lightingUniformsWGSL,
    vs: lightingUniformsGLSL,
    fs: lightingUniformsGLSL,
    getUniforms: getUniforms2
  };
  function getUniforms2(props, prevUniforms = {}) {
    props = props ? { ...props } : props;
    if (!props) {
      return { ...lighting.defaultUniforms };
    }
    if (props.lights) {
      props = { ...props, ...extractLightTypes(props.lights), lights: void 0 };
    }
    const { ambientLight, pointLights, directionalLights } = props || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return { ...lighting.defaultUniforms, enabled: 0 };
    }
    const uniforms = {
      ...lighting.defaultUniforms,
      ...prevUniforms,
      ...getLightSourceUniforms({ ambientLight, pointLights, directionalLights })
    };
    if (props.enabled !== void 0) {
      uniforms.enabled = props.enabled ? 1 : 0;
    }
    return uniforms;
  }
  function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
    const lightSourceUniforms = {};
    lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
    let currentLight = 0;
    for (const pointLight of pointLights) {
      lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
      const i5 = currentLight;
      lightSourceUniforms[`lightColor${i5}`] = convertColor(pointLight);
      lightSourceUniforms[`lightPosition${i5}`] = pointLight.position;
      lightSourceUniforms[`lightAttenuation${i5}`] = pointLight.attenuation || [1, 0, 0];
      currentLight++;
    }
    for (const directionalLight of directionalLights) {
      lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
      const i5 = currentLight;
      lightSourceUniforms[`lightColor${i5}`] = convertColor(directionalLight);
      lightSourceUniforms[`lightDirection${i5}`] = directionalLight.direction;
      currentLight++;
    }
    if (currentLight > MAX_LIGHTS) {
      log2.warn("MAX_LIGHTS exceeded")();
    }
    lightSourceUniforms.directionalLightCount = directionalLights.length;
    lightSourceUniforms.pointLightCount = pointLights.length;
    return lightSourceUniforms;
  }
  function extractLightTypes(lights2) {
    const lightSources = { pointLights: [], directionalLights: [] };
    for (const light of lights2 || []) {
      switch (light.type) {
        case "ambient":
          lightSources.ambientLight = light;
          break;
        case "directional":
          lightSources.directionalLights?.push(light);
          break;
        case "point":
          lightSources.pointLights?.push(light);
          break;
        default:
      }
    }
    return lightSources;
  }
  function convertColor(colorDef = {}) {
    const { color = [0, 0, 0], intensity = 1 } = colorDef;
    return color.map((component) => component * intensity / COLOR_FACTOR);
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js
  var PHONG_VS = (
    /* glsl */
    `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
  );
  var PHONG_FS = (
    /* glsl */
    `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js
  var gouraudMaterial = {
    props: {},
    name: "gouraudMaterial",
    // Note these are switched between phong and gouraud
    vs: PHONG_FS.replace("phongMaterial", "gouraudMaterial"),
    fs: PHONG_VS.replace("phongMaterial", "gouraudMaterial"),
    defines: {
      LIGHTING_VERTEX: 1
    },
    dependencies: [lighting],
    uniformTypes: {
      ambient: "f32",
      diffuse: "f32",
      shininess: "f32",
      specularColor: "vec3<f32>"
    },
    defaultUniforms: {
      ambient: 0.35,
      diffuse: 0.6,
      shininess: 32,
      specularColor: [0.15, 0.15, 0.15]
    },
    getUniforms(props) {
      const uniforms = { ...props };
      if (uniforms.specularColor) {
        uniforms.specularColor = uniforms.specularColor.map((x3) => x3 / 255);
      }
      return { ...gouraudMaterial.defaultUniforms, ...uniforms };
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js
  var PHONG_WGSL = (
    /* wgsl */
    `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-material.js
  var phongMaterial = {
    name: "phongMaterial",
    dependencies: [lighting],
    // Note these are switched between phong and gouraud
    source: PHONG_WGSL,
    vs: PHONG_VS,
    fs: PHONG_FS,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    uniformTypes: {
      ambient: "f32",
      diffuse: "f32",
      shininess: "f32",
      specularColor: "vec3<f32>"
    },
    defaultUniforms: {
      ambient: 0.35,
      diffuse: 0.6,
      shininess: 32,
      specularColor: [0.15, 0.15, 0.15]
    },
    getUniforms(props) {
      const uniforms = { ...props };
      if (uniforms.specularColor) {
        uniforms.specularColor = uniforms.specularColor.map((x3) => x3 / 255);
      }
      return { ...phongMaterial.defaultUniforms, ...uniforms };
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/pbr-material/pbr-vertex-glsl.js
  var vs2 = (
    /* glsl */
    `out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/pbr-material/pbr-fragment-glsl.js
  var fs2 = (
    /* glsl */
    `precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/pbr-material/pbr-projection.js
  var uniformBlock = (
    /* glsl */
    `uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`
  );
  var pbrProjection = {
    name: "pbrProjection",
    vs: uniformBlock,
    fs: uniformBlock,
    // TODO why is this needed?
    getUniforms: (props) => props,
    uniformTypes: {
      modelViewProjectionMatrix: "mat4x4<f32>",
      modelMatrix: "mat4x4<f32>",
      normalMatrix: "mat4x4<f32>",
      camera: "vec3<i32>"
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/lighting/pbr-material/pbr-material.js
  var pbrMaterial = {
    props: {},
    uniforms: {},
    name: "pbrMaterial",
    dependencies: [lighting, pbrProjection],
    vs: vs2,
    fs: fs2,
    defines: {
      LIGHTING_FRAGMENT: 1
      // TODO defining these as 0 breaks shader
      // HAS_NORMALMAP: 0
      // HAS_EMISSIVEMAP: 0,
      // HAS_OCCLUSIONMAP: 0,
      // HAS_BASECOLORMAP: 0,
      // HAS_METALROUGHNESSMAP: 0,
      // ALPHA_CUTOFF: 0
      // USE_IBL: 0
      // PBR_DEBUG: 0
    },
    getUniforms: (props) => props,
    uniformTypes: {
      // Material is unlit
      unlit: "i32",
      // Base color map
      baseColorMapEnabled: "i32",
      baseColorFactor: "vec4<f32>",
      normalMapEnabled: "i32",
      normalScale: "f32",
      // #ifdef HAS_NORMALMAP
      emissiveMapEnabled: "i32",
      emissiveFactor: "vec3<f32>",
      // #ifdef HAS_EMISSIVEMAP
      metallicRoughnessValues: "vec2<f32>",
      metallicRoughnessMapEnabled: "i32",
      occlusionMapEnabled: "i32",
      occlusionStrength: "f32",
      // #ifdef HAS_OCCLUSIONMAP
      alphaCutoffEnabled: "i32",
      alphaCutoff: "f32",
      // #ifdef ALPHA_CUTOFF
      // IBL
      IBLenabled: "i32",
      scaleIBLAmbient: "vec2<f32>",
      // #ifdef USE_IBL
      // debugging flags used for shader output of intermediate PBR variables
      // #ifdef PBR_DEBUG
      scaleDiffBaseMR: "vec4<f32>",
      scaleFGDSpec: "vec4<f32>"
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/lights/lights-glsl.js
  var lightingShader = (
    /* glsl */
    `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;

 // Constant-Linear-Exponential
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/lights/lights.js
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor2(colorDef = {}) {
    const { color = [0, 0, 0], intensity = 1 } = colorDef;
    return color.map((component) => component * intensity / 255);
  }
  function getLightSourceUniforms2({ ambientLight, pointLights = [], directionalLights = [] }) {
    const lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor2(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach((pointLight, index) => {
      lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor2(pointLight);
      lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;
      lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [
        1,
        0,
        0
      ];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach((directionalLight, index) => {
      lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor2(directionalLight);
      lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms3(opts = INITIAL_MODULE_OPTIONS) {
    if ("lightSources" in opts) {
      const { ambientLight, pointLights, directionalLights } = opts.lightSources || {};
      const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return { lighting_uEnabled: false };
      }
      return Object.assign({}, getLightSourceUniforms2({ ambientLight, pointLights, directionalLights }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      const lightSources = { pointLights: [], directionalLights: [] };
      for (const light of opts.lights || []) {
        switch (light.type) {
          case "ambient":
            lightSources.ambientLight = light;
            break;
          case "directional":
            lightSources.directionalLights?.push(light);
            break;
          case "point":
            lightSources.pointLights?.push(light);
            break;
          default:
        }
      }
      return getUniforms3({ lightSources });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lightingShader,
    fs: lightingShader,
    getUniforms: getUniforms3,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/phong-lighting/phong-lighting-glsl.js
  var lightingShader2 = (
    /* glsl */
    `
uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`
  );

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/phong-lighting/phong-lighting.js
  var INITIAL_MODULE_OPTIONS2 = {};
  function getMaterialUniforms(material) {
    const { ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30] } = material;
    return {
      lighting_uAmbient: ambient,
      lighting_uDiffuse: diffuse,
      lighting_uShininess: shininess,
      lighting_uSpecularColor: specularColor.map((x3) => x3 / 255)
    };
  }
  function getUniforms4(opts = INITIAL_MODULE_OPTIONS2) {
    if (!("material" in opts)) {
      return {};
    }
    const { material } = opts;
    if (!material) {
      return { lighting_uEnabled: false };
    }
    return getMaterialUniforms(material);
  }
  var gouraudLighting = {
    name: "gouraud-lighting",
    dependencies: [lights],
    vs: lightingShader2,
    defines: {
      LIGHTING_VERTEX: 1
    },
    getUniforms: getUniforms4
  };
  var phongLighting = {
    name: "phong-lighting",
    dependencies: [lights],
    fs: lightingShader2,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    getUniforms: getUniforms4
  };

  // ../core/src/shaderlib/misc/layer-uniforms.ts
  var uniformBlock2 = `uniform layerUniforms {
  uniform float opacity;
} layer;
`;
  var layerUniforms = {
    name: "layer",
    vs: uniformBlock2,
    fs: uniformBlock2,
    getUniforms: (props) => {
      return {
        // apply gamma to opacity to make it visually "linear"
        // TODO - v10: use raw opacity?
        opacity: Math.pow(props.opacity, 1 / 2.2)
      };
    },
    uniformTypes: {
      opacity: "f32"
    }
  };

  // ../core/src/shaderlib/misc/geometry.ts
  var source = (
    /* wgsl */
    `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
  );
  var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
  var vs3 = (
    /* glsl */
    `${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
  );
  var fs3 = (
    /* glsl */
    `${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
  );
  var geometry_default = {
    name: "geometry",
    source,
    vs: vs3,
    fs: fs3
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/input-consts.js
  var COMPUTE_INTERVAL = 25;
  var InputEvent;
  (function(InputEvent2) {
    InputEvent2[InputEvent2["Start"] = 1] = "Start";
    InputEvent2[InputEvent2["Move"] = 2] = "Move";
    InputEvent2[InputEvent2["End"] = 4] = "End";
    InputEvent2[InputEvent2["Cancel"] = 8] = "Cancel";
  })(InputEvent || (InputEvent = {}));
  var InputDirection;
  (function(InputDirection2) {
    InputDirection2[InputDirection2["None"] = 0] = "None";
    InputDirection2[InputDirection2["Left"] = 1] = "Left";
    InputDirection2[InputDirection2["Right"] = 2] = "Right";
    InputDirection2[InputDirection2["Up"] = 4] = "Up";
    InputDirection2[InputDirection2["Down"] = 8] = "Down";
    InputDirection2[InputDirection2["Horizontal"] = 3] = "Horizontal";
    InputDirection2[InputDirection2["Vertical"] = 12] = "Vertical";
    InputDirection2[InputDirection2["All"] = 15] = "All";
  })(InputDirection || (InputDirection = {}));

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer-state.js
  var RecognizerState;
  (function(RecognizerState2) {
    RecognizerState2[RecognizerState2["Possible"] = 1] = "Possible";
    RecognizerState2[RecognizerState2["Began"] = 2] = "Began";
    RecognizerState2[RecognizerState2["Changed"] = 4] = "Changed";
    RecognizerState2[RecognizerState2["Ended"] = 8] = "Ended";
    RecognizerState2[RecognizerState2["Recognized"] = 8] = "Recognized";
    RecognizerState2[RecognizerState2["Cancelled"] = 16] = "Cancelled";
    RecognizerState2[RecognizerState2["Failed"] = 32] = "Failed";
  })(RecognizerState || (RecognizerState = {}));

  // ../../node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction-Consts.js
  var TOUCH_ACTION_COMPUTE = "compute";
  var TOUCH_ACTION_AUTO = "auto";
  var TOUCH_ACTION_MANIPULATION = "manipulation";
  var TOUCH_ACTION_NONE = "none";
  var TOUCH_ACTION_PAN_X = "pan-x";
  var TOUCH_ACTION_PAN_Y = "pan-y";

  // ../../node_modules/mjolnir.js/dist/hammerjs/touchaction/clean-touch-actions.js
  function cleanTouchActions(actions) {
    if (actions.includes(TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }
    const hasPanX = actions.includes(TOUCH_ACTION_PAN_X);
    const hasPanY = actions.includes(TOUCH_ACTION_PAN_Y);
    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    }
    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }
    if (actions.includes(TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }
    return TOUCH_ACTION_AUTO;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/touchaction/touchaction.js
  var TouchAction = class {
    constructor(manager, value) {
      this.actions = "";
      this.manager = manager;
      this.set(value);
    }
    /**
     * set the touchAction value on the element or enable the polyfill
     */
    set(value) {
      if (value === TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }
      if (this.manager.element) {
        this.manager.element.style.touchAction = value;
        this.actions = value;
      }
    }
    /**
     * just re-set the touchAction value
     */
    update() {
      this.set(this.manager.options.touchAction);
    }
    /**
     * compute the value for the touchAction property based on the recognizer's settings
     */
    compute() {
      let actions = [];
      for (const recognizer of this.manager.recognizers) {
        if (recognizer.options.enable) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      }
      return cleanTouchActions(actions.join(" "));
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/split-str.js
  function splitStr(str7) {
    return str7.trim().split(/\s+/g);
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/event-listeners.js
  function addEventListeners(target2, types, handler) {
    if (!target2) {
      return;
    }
    for (const type of splitStr(types)) {
      target2.addEventListener(type, handler, false);
    }
  }
  function removeEventListeners(target2, types, handler) {
    if (!target2) {
      return;
    }
    for (const type of splitStr(types)) {
      target2.removeEventListener(type, handler, false);
    }
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/get-window-for-element.js
  function getWindowForElement(element) {
    const doc = element.ownerDocument || element;
    return doc.defaultView;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/has-parent.js
  function hasParent(node, parent) {
    let ancestor = node;
    while (ancestor) {
      if (ancestor === parent) {
        return true;
      }
      ancestor = ancestor.parentNode;
    }
    return false;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-center.js
  function getCenter(pointers) {
    const pointersLength = pointers.length;
    if (pointersLength === 1) {
      return {
        x: Math.round(pointers[0].clientX),
        y: Math.round(pointers[0].clientY)
      };
    }
    let x3 = 0;
    let y3 = 0;
    let i5 = 0;
    while (i5 < pointersLength) {
      x3 += pointers[i5].clientX;
      y3 += pointers[i5].clientY;
      i5++;
    }
    return {
      x: Math.round(x3 / pointersLength),
      y: Math.round(y3 / pointersLength)
    };
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/simple-clone-input-data.js
  function simpleCloneInputData(input) {
    const pointers = [];
    let i5 = 0;
    while (i5 < input.pointers.length) {
      pointers[i5] = {
        clientX: Math.round(input.pointers[i5].clientX),
        clientY: Math.round(input.pointers[i5].clientY)
      };
      i5++;
    }
    return {
      timeStamp: Date.now(),
      pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-distance.js
  function getPointDistance(p1, p22) {
    const x3 = p22.x - p1.x;
    const y3 = p22.y - p1.y;
    return Math.sqrt(x3 * x3 + y3 * y3);
  }
  function getEventDistance(p1, p22) {
    const x3 = p22.clientX - p1.clientX;
    const y3 = p22.clientY - p1.clientY;
    return Math.sqrt(x3 * x3 + y3 * y3);
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-angle.js
  function getPointAngle(p1, p22) {
    const x3 = p22.x - p1.x;
    const y3 = p22.y - p1.y;
    return Math.atan2(y3, x3) * 180 / Math.PI;
  }
  function getEventAngle(p1, p22) {
    const x3 = p22.clientX - p1.clientX;
    const y3 = p22.clientY - p1.clientY;
    return Math.atan2(y3, x3) * 180 / Math.PI;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-direction.js
  function getDirection(dx, dy) {
    if (dx === dy) {
      return InputDirection.None;
    }
    if (Math.abs(dx) >= Math.abs(dy)) {
      return dx < 0 ? InputDirection.Left : InputDirection.Right;
    }
    return dy < 0 ? InputDirection.Up : InputDirection.Down;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-delta-xy.js
  function computeDeltaXY(session, input) {
    const center = input.center;
    let offset = session.offsetDelta;
    let prevDelta = session.prevDelta;
    const prevInput = session.prevInput;
    if (input.eventType === InputEvent.Start || prevInput?.eventType === InputEvent.End) {
      prevDelta = session.prevDelta = {
        x: prevInput?.deltaX || 0,
        y: prevInput?.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }
    return {
      deltaX: prevDelta.x + (center.x - offset.x),
      deltaY: prevDelta.y + (center.y - offset.y)
    };
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-velocity.js
  function getVelocity(deltaTime, x3, y3) {
    return {
      x: x3 / deltaTime || 0,
      y: y3 / deltaTime || 0
    };
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-scale.js
  function getScale(start, end) {
    return getEventDistance(end[0], end[1]) / getEventDistance(start[0], start[1]);
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/get-rotation.js
  function getRotation2(start, end) {
    return getEventAngle(end[1], end[0]) - getEventAngle(start[1], start[0]);
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/compute-interval-input-data.js
  function computeIntervalInputData(session, input) {
    const last = session.lastInterval || input;
    const deltaTime = input.timeStamp - last.timeStamp;
    let velocity;
    let velocityX;
    let velocityY;
    let direction;
    if (input.eventType !== InputEvent.Cancel && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {
      const deltaX = input.deltaX - last.deltaX;
      const deltaY = input.deltaY - last.deltaY;
      const v2 = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v2.x;
      velocityY = v2.y;
      velocity = Math.abs(v2.x) > Math.abs(v2.y) ? v2.x : v2.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }
    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/compute-input-data.js
  function computeInputData(manager, input) {
    const { session } = manager;
    const { pointers } = input;
    const { length: pointersLength } = pointers;
    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    }
    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }
    const { firstInput, firstMultiple } = session;
    const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    const center = input.center = getCenter(pointers);
    input.timeStamp = Date.now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getPointAngle(offsetCenter, center);
    input.distance = getPointDistance(offsetCenter, center);
    const { deltaX, deltaY } = computeDeltaXY(session, input);
    input.deltaX = deltaX;
    input.deltaY = deltaY;
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    let target2 = manager.element;
    if (hasParent(input.srcEvent.target, target2)) {
      target2 = input.srcEvent.target;
    }
    input.target = target2;
    computeIntervalInputData(session, input);
    return input;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/input-handler.js
  function inputHandler(manager, eventType, input) {
    const pointersLen = input.pointers.length;
    const changedPointersLen = input.changedPointers.length;
    const isFirst = eventType & InputEvent.Start && pointersLen - changedPointersLen === 0;
    const isFinal = eventType & (InputEvent.End | InputEvent.Cancel) && pointersLen - changedPointersLen === 0;
    input.isFirst = Boolean(isFirst);
    input.isFinal = Boolean(isFinal);
    if (isFirst) {
      manager.session = {};
    }
    input.eventType = eventType;
    const processedInput = computeInputData(manager, input);
    manager.emit("hammer.input", processedInput);
    manager.recognize(processedInput);
    manager.session.prevInput = processedInput;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/input/input.js
  var Input = class {
    constructor(manager) {
      this.evEl = "";
      this.evWin = "";
      this.evTarget = "";
      this.domHandler = (ev) => {
        if (this.manager.options.enable) {
          this.handler(ev);
        }
      };
      this.manager = manager;
      this.element = manager.element;
      this.target = manager.options.inputTarget || manager.element;
    }
    callback(eventType, input) {
      inputHandler(this.manager, eventType, input);
    }
    // eslint-disable @typescript-eslint/unbound-method
    /**
     * bind the events
     */
    init() {
      addEventListeners(this.element, this.evEl, this.domHandler);
      addEventListeners(this.target, this.evTarget, this.domHandler);
      addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
    /**
     * unbind the events
     */
    destroy() {
      removeEventListeners(this.element, this.evEl, this.domHandler);
      removeEventListeners(this.target, this.evTarget, this.domHandler);
      removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/inputs/pointerevent.js
  var POINTER_INPUT_MAP = {
    pointerdown: InputEvent.Start,
    pointermove: InputEvent.Move,
    pointerup: InputEvent.End,
    pointercancel: InputEvent.Cancel,
    pointerout: InputEvent.Cancel
  };
  var POINTER_ELEMENT_EVENTS = "pointerdown";
  var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
  var PointerEventInput = class extends Input {
    constructor(manager) {
      super(manager);
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;
      this.store = this.manager.session.pointerEvents = [];
      this.init();
    }
    /**
     * handle mouse events
     */
    handler(ev) {
      const { store } = this;
      let removePointer = false;
      const eventType = POINTER_INPUT_MAP[ev.type];
      const pointerType = ev.pointerType;
      const isTouch = pointerType === "touch";
      let storeIndex = store.findIndex((e3) => e3.pointerId === ev.pointerId);
      if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {
        removePointer = true;
      }
      if (storeIndex < 0) {
        return;
      }
      store[storeIndex] = ev;
      this.callback(eventType, {
        pointers: store,
        changedPointers: [ev],
        eventType,
        pointerType,
        srcEvent: ev
      });
      if (removePointer) {
        store.splice(storeIndex, 1);
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/prefixed.js
  var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
  function prefixed(obj, property) {
    const camelProp = property[0].toUpperCase() + property.slice(1);
    for (const prefix of VENDOR_PREFIXES) {
      const prop = prefix ? prefix + camelProp : property;
      if (prop in obj) {
        return prop;
      }
    }
    return void 0;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/manager.js
  var STOP = 1;
  var FORCED_STOP = 2;
  var defaultOptions = {
    touchAction: "compute",
    enable: true,
    inputTarget: null,
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       */
      userSelect: "none",
      /**
       * (Webkit) Disable default dragging behavior
       */
      // @ts-ignore
      userDrag: "none",
      /**
       * (iOS only) Disables the default callout shown when you touch and hold a touch target.
       * When you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       */
      // @ts-ignore
      touchCallout: "none",
      /**
       * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
       */
      // @ts-ignore
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  var Manager = class {
    constructor(element, options) {
      this.options = {
        ...defaultOptions,
        ...options,
        cssProps: { ...defaultOptions.cssProps, ...options.cssProps },
        inputTarget: options.inputTarget || element
      };
      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};
      this.element = element;
      this.input = new PointerEventInput(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);
      this.toggleCssProps(true);
    }
    /**
     * set options
     */
    set(options) {
      Object.assign(this.options, options);
      if (options.touchAction) {
        this.touchAction.update();
      }
      if (options.inputTarget) {
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    }
    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     */
    stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    }
    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     */
    recognize(inputData) {
      const { session } = this;
      if (session.stopped) {
        return;
      }
      if (this.session.prevented) {
        inputData.srcEvent.preventDefault();
      }
      let recognizer;
      const { recognizers } = this;
      let { curRecognizer } = session;
      if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) {
        curRecognizer = session.curRecognizer = null;
      }
      let i5 = 0;
      while (i5 < recognizers.length) {
        recognizer = recognizers[i5];
        if (session.stopped !== FORCED_STOP && // 1
        (!curRecognizer || recognizer === curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }
        if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i5++;
      }
    }
    /**
     * get a recognizer by its event name.
     */
    get(recognizerName) {
      const { recognizers } = this;
      for (let i5 = 0; i5 < recognizers.length; i5++) {
        if (recognizers[i5].options.event === recognizerName) {
          return recognizers[i5];
        }
      }
      return null;
    }
    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     */
    add(recognizer) {
      if (Array.isArray(recognizer)) {
        for (const item of recognizer) {
          this.add(item);
        }
        return this;
      }
      const existing = this.get(recognizer.options.event);
      if (existing) {
        this.remove(existing);
      }
      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    }
    /**
     * remove a recognizer by name or instance
     */
    remove(recognizerOrName) {
      if (Array.isArray(recognizerOrName)) {
        for (const item of recognizerOrName) {
          this.remove(item);
        }
        return this;
      }
      const recognizer = typeof recognizerOrName === "string" ? this.get(recognizerOrName) : recognizerOrName;
      if (recognizer) {
        const { recognizers } = this;
        const index = recognizers.indexOf(recognizer);
        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }
      return this;
    }
    /**
     * bind event
     */
    on(events, handler) {
      if (!events || !handler) {
        return;
      }
      const { handlers } = this;
      for (const event of splitStr(events)) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      }
    }
    /**
     * unbind event, leave hander blank to remove all handlers
     */
    off(events, handler) {
      if (!events) {
        return;
      }
      const { handlers } = this;
      for (const event of splitStr(events)) {
        if (!handler) {
          delete handlers[event];
        } else if (handlers[event]) {
          handlers[event].splice(handlers[event].indexOf(handler), 1);
        }
      }
    }
    /**
     * emit event to the listeners
     */
    emit(event, data) {
      const handlers = this.handlers[event] && this.handlers[event].slice();
      if (!handlers || !handlers.length) {
        return;
      }
      const evt = data;
      evt.type = event;
      evt.preventDefault = function() {
        data.srcEvent.preventDefault();
      };
      let i5 = 0;
      while (i5 < handlers.length) {
        handlers[i5](evt);
        i5++;
      }
    }
    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy() {
      this.toggleCssProps(false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
    /**
     * add/remove the css properties as defined in manager.options.cssProps
     */
    toggleCssProps(add16) {
      const { element } = this;
      if (!element) {
        return;
      }
      for (const [name13, value] of Object.entries(this.options.cssProps)) {
        const prop = prefixed(element.style, name13);
        if (add16) {
          this.oldCssProps[prop] = element.style[prop];
          element.style[prop] = value;
        } else {
          element.style[prop] = this.oldCssProps[prop] || "";
        }
      }
      if (!add16) {
        this.oldCssProps = {};
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/utils/unique-id.js
  var _uniqueId = 1;
  function uniqueId() {
    return _uniqueId++;
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizer/state-str.js
  function stateStr(state) {
    if (state & RecognizerState.Cancelled) {
      return "cancel";
    } else if (state & RecognizerState.Ended) {
      return "end";
    } else if (state & RecognizerState.Changed) {
      return "move";
    } else if (state & RecognizerState.Began) {
      return "start";
    }
    return "";
  }

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizer/recognizer.js
  var Recognizer = class {
    constructor(options) {
      this.options = options;
      this.id = uniqueId();
      this.state = RecognizerState.Possible;
      this.simultaneous = {};
      this.requireFail = [];
    }
    /**
     * set options
     */
    set(options) {
      Object.assign(this.options, options);
      this.manager.touchAction.update();
      return this;
    }
    /**
     * recognize simultaneous with an other recognizer.
     */
    recognizeWith(recognizerOrName) {
      if (Array.isArray(recognizerOrName)) {
        for (const item of recognizerOrName) {
          this.recognizeWith(item);
        }
        return this;
      }
      let otherRecognizer;
      if (typeof recognizerOrName === "string") {
        otherRecognizer = this.manager.get(recognizerOrName);
        if (!otherRecognizer) {
          throw new Error(`Cannot find recognizer ${recognizerOrName}`);
        }
      } else {
        otherRecognizer = recognizerOrName;
      }
      const { simultaneous } = this;
      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    }
    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     */
    dropRecognizeWith(recognizerOrName) {
      if (Array.isArray(recognizerOrName)) {
        for (const item of recognizerOrName) {
          this.dropRecognizeWith(item);
        }
        return this;
      }
      let otherRecognizer;
      if (typeof recognizerOrName === "string") {
        otherRecognizer = this.manager.get(recognizerOrName);
      } else {
        otherRecognizer = recognizerOrName;
      }
      if (otherRecognizer) {
        delete this.simultaneous[otherRecognizer.id];
      }
      return this;
    }
    /**
     * recognizer can only run when an other is failing
     */
    requireFailure(recognizerOrName) {
      if (Array.isArray(recognizerOrName)) {
        for (const item of recognizerOrName) {
          this.requireFailure(item);
        }
        return this;
      }
      let otherRecognizer;
      if (typeof recognizerOrName === "string") {
        otherRecognizer = this.manager.get(recognizerOrName);
        if (!otherRecognizer) {
          throw new Error(`Cannot find recognizer ${recognizerOrName}`);
        }
      } else {
        otherRecognizer = recognizerOrName;
      }
      const { requireFail } = this;
      if (requireFail.indexOf(otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    }
    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     */
    dropRequireFailure(recognizerOrName) {
      if (Array.isArray(recognizerOrName)) {
        for (const item of recognizerOrName) {
          this.dropRequireFailure(item);
        }
        return this;
      }
      let otherRecognizer;
      if (typeof recognizerOrName === "string") {
        otherRecognizer = this.manager.get(recognizerOrName);
      } else {
        otherRecognizer = recognizerOrName;
      }
      if (otherRecognizer) {
        const index = this.requireFail.indexOf(otherRecognizer);
        if (index > -1) {
          this.requireFail.splice(index, 1);
        }
      }
      return this;
    }
    /**
     * has require failures boolean
     */
    hasRequireFailures() {
      return Boolean(this.requireFail.find((recognier) => recognier.options.enable));
    }
    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     */
    canRecognizeWith(otherRecognizer) {
      return Boolean(this.simultaneous[otherRecognizer.id]);
    }
    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     */
    emit(input) {
      if (!input)
        return;
      const { state } = this;
      if (state < RecognizerState.Ended) {
        this.manager.emit(this.options.event + stateStr(state), input);
      }
      this.manager.emit(this.options.event, input);
      if (input.additionalEvent) {
        this.manager.emit(input.additionalEvent, input);
      }
      if (state >= RecognizerState.Ended) {
        this.manager.emit(this.options.event + stateStr(state), input);
      }
    }
    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     */
    tryEmit(input) {
      if (this.canEmit()) {
        this.emit(input);
      } else {
        this.state = RecognizerState.Failed;
      }
    }
    /**
     * can we emit?
     */
    canEmit() {
      let i5 = 0;
      while (i5 < this.requireFail.length) {
        if (!(this.requireFail[i5].state & (RecognizerState.Failed | RecognizerState.Possible))) {
          return false;
        }
        i5++;
      }
      return true;
    }
    /**
     * update the recognizer
     */
    recognize(inputData) {
      const inputDataClone = { ...inputData };
      if (!this.options.enable) {
        this.reset();
        this.state = RecognizerState.Failed;
        return;
      }
      if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) {
        this.state = RecognizerState.Possible;
      }
      this.state = this.process(inputDataClone);
      if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) {
        this.tryEmit(inputDataClone);
      }
    }
    /**
     * return the event names that are emitted by this recognizer
     */
    getEventNames() {
      return [this.options.event];
    }
    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     */
    reset() {
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizers/attribute.js
  var AttrRecognizer = class extends Recognizer {
    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     */
    attrTest(input) {
      const optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    }
    /**
     * Process the input and return the state for the recognizer
     */
    process(input) {
      const { state } = this;
      const { eventType } = input;
      const isRecognized = state & (RecognizerState.Began | RecognizerState.Changed);
      const isValid = this.attrTest(input);
      if (isRecognized && (eventType & InputEvent.Cancel || !isValid)) {
        return state | RecognizerState.Cancelled;
      } else if (isRecognized || isValid) {
        if (eventType & InputEvent.End) {
          return state | RecognizerState.Ended;
        } else if (!(state & RecognizerState.Began)) {
          return RecognizerState.Began;
        }
        return state | RecognizerState.Changed;
      }
      return RecognizerState.Failed;
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizers/tap.js
  var TapRecognizer = class extends Recognizer {
    constructor(options = {}) {
      super({
        enable: true,
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        time: 250,
        threshold: 9,
        posThreshold: 10,
        ...options
      });
      this.pTime = null;
      this.pCenter = null;
      this._timer = null;
      this._input = null;
      this.count = 0;
    }
    getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    }
    process(input) {
      const { options } = this;
      const validPointers = input.pointers.length === options.pointers;
      const validMovement = input.distance < options.threshold;
      const validTouchTime = input.deltaTime < options.time;
      this.reset();
      if (input.eventType & InputEvent.Start && this.count === 0) {
        return this.failTimeout();
      }
      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType !== InputEvent.End) {
          return this.failTimeout();
        }
        const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }
        this._input = input;
        const tapCount = this.count % options.taps;
        if (tapCount === 0) {
          if (!this.hasRequireFailures()) {
            return RecognizerState.Recognized;
          }
          this._timer = setTimeout(() => {
            this.state = RecognizerState.Recognized;
            this.tryEmit(this._input);
          }, options.interval);
          return RecognizerState.Began;
        }
      }
      return RecognizerState.Failed;
    }
    failTimeout() {
      this._timer = setTimeout(() => {
        this.state = RecognizerState.Failed;
      }, this.options.interval);
      return RecognizerState.Failed;
    }
    reset() {
      clearTimeout(this._timer);
    }
    emit(input) {
      if (this.state === RecognizerState.Recognized) {
        input.tapCount = this.count;
        this.manager.emit(this.options.event, input);
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizers/pan.js
  var EVENT_NAMES = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
  var PanRecognizer = class extends AttrRecognizer {
    constructor(options = {}) {
      super({
        enable: true,
        pointers: 1,
        event: "pan",
        threshold: 10,
        direction: InputDirection.All,
        ...options
      });
      this.pX = null;
      this.pY = null;
    }
    getTouchAction() {
      const { options: { direction } } = this;
      const actions = [];
      if (direction & InputDirection.Horizontal) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if (direction & InputDirection.Vertical) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    }
    getEventNames() {
      return EVENT_NAMES.map((suffix) => this.options.event + suffix);
    }
    directionTest(input) {
      const { options } = this;
      let hasMoved = true;
      let { distance: distance6 } = input;
      let { direction } = input;
      const x3 = input.deltaX;
      const y3 = input.deltaY;
      if (!(direction & options.direction)) {
        if (options.direction & InputDirection.Horizontal) {
          direction = x3 === 0 ? InputDirection.None : x3 < 0 ? InputDirection.Left : InputDirection.Right;
          hasMoved = x3 !== this.pX;
          distance6 = Math.abs(input.deltaX);
        } else {
          direction = y3 === 0 ? InputDirection.None : y3 < 0 ? InputDirection.Up : InputDirection.Down;
          hasMoved = y3 !== this.pY;
          distance6 = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance6 > options.threshold && Boolean(direction & options.direction);
    }
    attrTest(input) {
      return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));
    }
    emit(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      const direction = InputDirection[input.direction].toLowerCase();
      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }
      super.emit(input);
    }
  };

  // ../../node_modules/mjolnir.js/dist/hammerjs/recognizers/pinch.js
  var EVENT_NAMES2 = ["", "start", "move", "end", "cancel", "in", "out"];
  var PinchRecognizer = class extends AttrRecognizer {
    constructor(options = {}) {
      super({
        enable: true,
        event: "pinch",
        threshold: 0,
        pointers: 2,
        ...options
      });
    }
    getTouchAction() {
      return [TOUCH_ACTION_NONE];
    }
    getEventNames() {
      return EVENT_NAMES2.map((suffix) => this.options.event + suffix);
    }
    attrTest(input) {
      return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || Boolean(this.state & RecognizerState.Began));
    }
    emit(input) {
      if (input.scale !== 1) {
        const inOut = input.scale < 1 ? "in" : "out";
        input.additionalEvent = this.options.event + inOut;
      }
      super.emit(input);
    }
  };

  // ../../node_modules/mjolnir.js/dist/inputs/input.js
  var Input2 = class {
    constructor(element, callback, options) {
      this.element = element;
      this.callback = callback;
      this.options = options;
    }
  };

  // ../../node_modules/mjolnir.js/dist/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_4 = typeof window !== "undefined" ? window : global;

  // ../../node_modules/mjolnir.js/dist/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = class extends Input2 {
    constructor(element, callback, options) {
      super(element, callback, { enable: true, ...options });
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        let value = event.deltaY;
        if (globalThis.WheelEvent) {
          if (firefox && event.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL) {
            value /= globalThis.devicePixelRatio;
          }
          if (event.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE) {
            value *= WHEEL_DELTA_PER_LINE;
          }
        }
        if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value) {
          value = value * SHIFT_MULTIPLIER;
        }
        this.callback({
          type: "wheel",
          center: {
            x: event.clientX,
            y: event.clientY
          },
          delta: -value,
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("wheel", this.handleEvent, { passive: false });
    }
    destroy() {
      this.element.removeEventListener("wheel", this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === "wheel") {
        this.options.enable = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/inputs/move-input.js
  var MOUSE_EVENTS = [
    "mousedown",
    "mousemove",
    "mouseup",
    "mouseover",
    "mouseout",
    "mouseleave"
  ];
  var MoveInput = class extends Input2 {
    constructor(element, callback, options) {
      super(element, callback, { enable: true, ...options });
      this.handleEvent = (event) => {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleEnterEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      };
      this.pressed = false;
      const { enable: enable2 } = this.options;
      this.enableMoveEvent = enable2;
      this.enableLeaveEvent = enable2;
      this.enableEnterEvent = enable2;
      this.enableOutEvent = enable2;
      this.enableOverEvent = enable2;
      MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      switch (eventType) {
        case "pointermove":
          this.enableMoveEvent = enabled;
          break;
        case "pointerover":
          this.enableOverEvent = enabled;
          break;
        case "pointerout":
          this.enableOutEvent = enabled;
          break;
        case "pointerenter":
          this.enableEnterEvent = enabled;
          break;
        case "pointerleave":
          this.enableLeaveEvent = enabled;
          break;
        default:
      }
    }
    handleOverEvent(event) {
      if (this.enableOverEvent && event.type === "mouseover") {
        this._emit("pointerover", event);
      }
    }
    handleOutEvent(event) {
      if (this.enableOutEvent && event.type === "mouseout") {
        this._emit("pointerout", event);
      }
    }
    handleEnterEvent(event) {
      if (this.enableEnterEvent && event.type === "mouseenter") {
        this._emit("pointerenter", event);
      }
    }
    handleLeaveEvent(event) {
      if (this.enableLeaveEvent && event.type === "mouseleave") {
        this._emit("pointerleave", event);
      }
    }
    handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case "mousedown":
            if (event.button >= 0) {
              this.pressed = true;
            }
            break;
          case "mousemove":
            if (event.buttons === 0) {
              this.pressed = false;
            }
            if (!this.pressed) {
              this._emit("pointermove", event);
            }
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
      }
    }
    _emit(type, event) {
      this.callback({
        type,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    }
  };

  // ../../node_modules/mjolnir.js/dist/inputs/key-input.js
  var KEY_EVENTS = ["keydown", "keyup"];
  var KeyInput = class extends Input2 {
    constructor(element, callback, options) {
      super(element, callback, { enable: true, tabIndex: 0, ...options });
      this.handleEvent = (event) => {
        const targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: "keydown",
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: "keyup",
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      };
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      element.tabIndex = this.options.tabIndex;
      element.style.outline = "none";
      KEY_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      KEY_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === "keydown") {
        this.enableDownEvent = enabled;
      }
      if (eventType === "keyup") {
        this.enableUpEvent = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/inputs/contextmenu-input.js
  var ContextmenuInput = class extends Input2 {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: "contextmenu",
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === "contextmenu") {
        this.options.enable = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    const eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    const { buttons, button } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
  }
  function getOffsetPosition(event, rootElement) {
    const center = event.center;
    if (!center) {
      return null;
    }
    const rect = rootElement.getBoundingClientRect();
    const scaleX2 = rect.width / rootElement.offsetWidth || 1;
    const scaleY2 = rect.height / rootElement.offsetHeight || 1;
    const offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return { center, offsetCenter };
  }

  // ../../node_modules/mjolnir.js/dist/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = class {
    constructor(eventManager, recognizerName) {
      this.handleEvent = (event) => {
        if (this.isEmpty()) {
          return;
        }
        const mjolnirEvent = this._normalizeEvent(event);
        let target2 = event.srcEvent.target;
        while (target2 && target2 !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target2);
          if (mjolnirEvent.handled) {
            return;
          }
          target2 = target2.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      };
      this.eventManager = eventManager;
      this.recognizerName = recognizerName;
      this.handlers = [];
      this.handlersByElement = /* @__PURE__ */ new Map();
      this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
      return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
      const { handlers, handlersByElement } = this;
      const opts = { ...DEFAULT_OPTIONS, ...options };
      let entries = handlersByElement.get(opts.srcElement);
      if (!entries) {
        entries = [];
        handlersByElement.set(opts.srcElement, entries);
      }
      const entry = {
        type,
        handler,
        srcElement: opts.srcElement,
        priority: opts.priority
      };
      if (once) {
        entry.once = true;
      }
      if (passive) {
        entry.passive = true;
      }
      handlers.push(entry);
      this._active = this._active || !entry.passive;
      let insertPosition = entries.length - 1;
      while (insertPosition >= 0) {
        if (entries[insertPosition].priority >= entry.priority) {
          break;
        }
        insertPosition--;
      }
      entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
      const { handlers, handlersByElement } = this;
      for (let i5 = handlers.length - 1; i5 >= 0; i5--) {
        const entry = handlers[i5];
        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i5, 1);
          const entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);
          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
      this._active = handlers.some((entry) => !entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */
    _emit(event, srcElement) {
      const entries = this.handlersByElement.get(srcElement);
      if (entries) {
        let immediatePropagationStopped = false;
        const stopPropagation = () => {
          event.handled = true;
        };
        const stopImmediatePropagation = () => {
          event.handled = true;
          immediatePropagationStopped = true;
        };
        const entriesToRemove = [];
        for (let i5 = 0; i5 < entries.length; i5++) {
          const { type, handler, once } = entries[i5];
          handler({
            ...event,
            type,
            stopPropagation,
            stopImmediatePropagation
          });
          if (once) {
            entriesToRemove.push(entries[i5]);
          }
          if (immediatePropagationStopped) {
            break;
          }
        }
        for (let i5 = 0; i5 < entriesToRemove.length; i5++) {
          const { type, handler } = entriesToRemove[i5];
          this.remove(type, handler);
        }
      }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */
    _normalizeEvent(event) {
      const rootElement = this.eventManager.getElement();
      return {
        ...event,
        ...whichButtons(event),
        ...getOffsetPosition(event, rootElement),
        preventDefault: () => {
          event.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement
      };
    }
  };

  // ../../node_modules/mjolnir.js/dist/event-manager.js
  function normalizeRecognizer(item) {
    if ("recognizer" in item) {
      return item;
    }
    let recognizer;
    const itemArray = Array.isArray(item) ? [...item] : [item];
    if (typeof itemArray[0] === "function") {
      const RecognizerType = itemArray.shift();
      const options = itemArray.shift() || {};
      recognizer = new RecognizerType(options);
    } else {
      recognizer = itemArray.shift();
    }
    return {
      recognizer,
      recognizeWith: typeof itemArray[0] === "string" ? [itemArray[0]] : itemArray[0],
      requireFailure: typeof itemArray[1] === "string" ? [itemArray[1]] : itemArray[1]
    };
  }
  var EventManager = class {
    constructor(element = null, options = {}) {
      this._onBasicInput = (event) => {
        this.manager.emit(event.srcEvent.type, event);
      };
      this._onOtherEvent = (event) => {
        this.manager.emit(event.type, event);
      };
      this.options = {
        recognizers: [],
        events: {},
        touchAction: "compute",
        tabIndex: 0,
        cssProps: {},
        ...options
      };
      this.events = /* @__PURE__ */ new Map();
      this.element = element;
      if (!element)
        return;
      this.manager = new Manager(element, this.options);
      for (const item of this.options.recognizers) {
        const { recognizer, recognizeWith, requireFailure } = normalizeRecognizer(item);
        this.manager.add(recognizer);
        if (recognizeWith) {
          recognizer.recognizeWith(recognizeWith);
        }
        if (requireFailure) {
          recognizer.requireFailure(requireFailure);
        }
      }
      this.manager.on("hammer.input", this._onBasicInput);
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new KeyInput(element, this._onOtherEvent, {
        enable: false,
        tabIndex: options.tabIndex
      });
      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
        enable: false
      });
      this.on(this.options.events);
    }
    getElement() {
      return this.element;
    }
    // Tear down internal event management implementations.
    destroy() {
      if (!this.element)
        return;
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
    }
    /** Register an event handler function to be called on `event` */
    on(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
      this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
      this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */
    _toggleRecognizer(name13, enabled) {
      const { manager } = this;
      if (!manager) {
        return;
      }
      const recognizer = manager.get(name13);
      if (recognizer) {
        recognizer.set({ enable: enabled });
        manager.touchAction.update();
      }
      this.wheelInput?.enableEventType(name13, enabled);
      this.moveInput?.enableEventType(name13, enabled);
      this.keyInput?.enableEventType(name13, enabled);
      this.contextmenuInput?.enableEventType(name13, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */
    _addEventHandler(event, handler, opts, once, passive) {
      if (typeof event !== "string") {
        opts = handler;
        for (const [eventName, eventHandler] of Object.entries(event)) {
          this._addEventHandler(eventName, eventHandler, opts, once, passive);
        }
        return;
      }
      const { manager, events } = this;
      if (!manager)
        return;
      let eventRegistrar = events.get(event);
      if (!eventRegistrar) {
        const recognizerName = this._getRecognizerName(event) || event;
        eventRegistrar = new EventRegistrar(this, recognizerName);
        events.set(event, eventRegistrar);
        if (manager) {
          manager.on(event, eventRegistrar.handleEvent);
        }
      }
      eventRegistrar.add(event, handler, opts, once, passive);
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
      }
    }
    /**
     * Process the event deregistration for a single event + handler.
     */
    _removeEventHandler(event, handler) {
      if (typeof event !== "string") {
        for (const [eventName, eventHandler] of Object.entries(event)) {
          this._removeEventHandler(eventName, eventHandler);
        }
        return;
      }
      const { events } = this;
      const eventRegistrar = events.get(event);
      if (!eventRegistrar) {
        return;
      }
      eventRegistrar.remove(event, handler);
      if (eventRegistrar.isEmpty()) {
        const { recognizerName } = eventRegistrar;
        let isRecognizerUsed = false;
        for (const eh of events.values()) {
          if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
            isRecognizerUsed = true;
            break;
          }
        }
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
    _getRecognizerName(event) {
      return this.manager.recognizers.find((recognizer) => {
        return recognizer.getEventNames().includes(event);
      })?.options.event;
    }
  };

  // ../core/src/lib/constants.ts
  var COORDINATE_SYSTEM = {
    /**
     * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
     */
    DEFAULT: -1,
    /**
     * Positions are interpreted as [longitude, latitude, elevation]
     * longitude/latitude are in degrees, elevation is in meters.
     * Dimensions are in meters.
     */
    LNGLAT: 1,
    /**
     * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
     * Dimensions are in meters.
     */
    METER_OFFSETS: 2,
    /**
     * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
     * deltaLng/deltaLat are in degrees, elevation is in meters.
     * Dimensions are in meters.
     */
    LNGLAT_OFFSETS: 3,
    /**
     * Positions and dimensions are in the common units of the viewport.
     */
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: () => {
      log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
      return 0;
    }
  });
  var PROJECTION_MODE = {
    /**
     * Render geospatial data in Web Mercator projection
     */
    WEB_MERCATOR: 1,
    /**
     * Render geospatial data as a 3D globe
     */
    GLOBE: 2,
    /**
     * (Internal use only) Web Mercator projection at high zoom
     */
    WEB_MERCATOR_AUTO_OFFSET: 4,
    /**
     * No transformation
     */
    IDENTITY: 0
  };
  var UNIT = {
    common: 0,
    meters: 1,
    pixels: 2
  };
  var EVENT_HANDLERS = {
    click: "onClick",
    dblclick: "onClick",
    panstart: "onDragStart",
    panmove: "onDrag",
    panend: "onDragEnd"
  };
  var RECOGNIZERS = {
    multipan: [PanRecognizer, { threshold: 10, direction: InputDirection.Vertical, pointers: 2 }],
    pinch: [PinchRecognizer, {}, null, ["multipan"]],
    pan: [PanRecognizer, { threshold: 1 }, ["pinch"], ["multipan"]],
    dblclick: [TapRecognizer, { event: "dblclick", taps: 2 }],
    click: [TapRecognizer, { event: "click" }, null, ["dblclick"]]
  };
  var OPERATION = {
    DRAW: "draw",
    MASK: "mask",
    TERRAIN: "terrain"
  };

  // ../core/src/utils/memoize.ts
  function isEqual(a3, b2) {
    if (a3 === b2) {
      return true;
    }
    if (Array.isArray(a3)) {
      const len8 = a3.length;
      if (!b2 || b2.length !== len8) {
        return false;
      }
      for (let i5 = 0; i5 < len8; i5++) {
        if (a3[i5] !== b2[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // ../core/src/shaderlib/project/viewport-uniforms.ts
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) {
      coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
    }
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport.isGeospatial ? (
        // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
        [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]
      ) : null;
    }
    switch (viewport.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          geospatialOrigin = [0, 0, 0];
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [
            Math.fround(viewport.center[0]),
            Math.fround(viewport.center[1]),
            0
          ];
          geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport.position.map(Math.fround);
        shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    return { geospatialOrigin, shaderCoordinateOrigin, offsetMode };
  }
  function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const { viewMatrixUncentered, projectionMatrix } = viewport;
    let { viewMatrix: viewMatrix2, viewProjectionMatrix } = viewport;
    let projectionCenter = ZERO_VECTOR;
    let originCommon = ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(
      viewport,
      coordinateSystem,
      coordinateOrigin
    );
    if (offsetMode) {
      originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [
        cameraPosCommon[0] - originCommon[0],
        cameraPosCommon[1] - originCommon[1],
        cameraPosCommon[2] - originCommon[2]
      ];
      originCommon[3] = 1;
      projectionCenter = vec4_exports.transformMat4([], originCommon, viewProjectionMatrix);
      viewMatrix2 = viewMatrixUncentered || viewMatrix2;
      viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix2);
      viewProjectionMatrix = mat4_exports.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix: viewMatrix2,
      viewProjectionMatrix,
      projectionCenter,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport({
    viewport,
    devicePixelRatio = 1,
    modelMatrix: modelMatrix2 = null,
    // Match Layer.defaultProps
    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    autoWrapLongitude = false
  }) {
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    const uniforms = getMemoizedViewportUniforms({
      viewport,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.wrapLongitude = autoWrapLongitude;
    uniforms.modelMatrix = modelMatrix2 || IDENTITY_MATRIX4;
    return uniforms;
  }
  function calculateViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  }) {
    const {
      projectionCenter,
      viewProjectionMatrix,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [
      viewport.width * devicePixelRatio,
      viewport.height * devicePixelRatio
    ];
    const focalDistance = vec4_exports.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
      // Projection mode values
      coordinateSystem,
      projectionMode: viewport.projectionMode,
      coordinateOrigin: shaderCoordinateOrigin,
      commonOrigin: originCommon.slice(0, 3),
      center: projectionCenter,
      // Backward compatibility
      // TODO: remove in v9
      // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
      pseudoMeters: Boolean(viewport._pseudoMeters),
      // Screen size
      viewportSize,
      devicePixelRatio,
      focalDistance,
      commonUnitsPerMeter: distanceScales.unitsPerMeter,
      commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      scale: viewport.scale,
      // This is the mercator scale (2 ** zoom)
      wrapLongitude: false,
      viewProjectionMatrix,
      modelMatrix: IDENTITY_MATRIX4,
      // This is for lighting calculations
      cameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          if (!viewport._pseudoMeters) {
            uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
          }
          uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // ../core/src/shaderlib/project/project.wgsl.ts
  var COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`).join("");
  var PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`).join("");
  var UNIT_WGSL_CONSTANTS = Object.keys(UNIT).map((key) => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`).join("");
  var projectWGSLHeader = (
    /* wgsl */
    `${COORDINATE_SYSTEM_WGSL_CONSTANTS}
${PROJECTION_MODE_WGSL_CONSTANTS}
${UNIT_WGSL_CONSTANTS}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
  );
  var projectWGSL = (
    /* wgsl */
    `${projectWGSLHeader}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the z\u2011axis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
  );

  // ../core/src/shaderlib/project/project.glsl.ts
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
  var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
  var projectGLSL = (
    /* glsl */
    `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}

uniform projectUniforms {
  bool wrapLongitude;
  int coordinateSystem;
  vec3 commonUnitsPerMeter;
  int projectionMode;
  float scale;
  vec3 commonUnitsPerWorldUnit;
  vec3 commonUnitsPerWorldUnit2;
  vec4 center;
  mat4 modelMatrix;
  mat4 viewProjectionMatrix;
  vec2 viewportSize;
  float devicePixelRatio;
  float focalDistance;
  vec3 cameraPosition;
  vec3 coordinateOrigin;
  vec3 commonOrigin;
  bool pseudoMeters;
} project;


const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0; // meters
const float GLOBE_RADIUS = 256.0;

// returns an adjustment factor for uCommonUnitsPerMeter
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project.pseudoMeters == false) {

    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear
    // Adjust by 1 / cos(latitude)
    // If geometry.position (vertex in common space) is populated, use it
    // Otherwise use geometry.worldPosition (anchor in world space)
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }

    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)
    // Taylor series of 1 / cos(latitude)
    // Max error < 0.003
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}

//
// Scaling offsets - scales meters to "world distance"
// Note the scalar version of project_size is for scaling the z component only
//
float project_size(float meters) {
  // For scatter relevant
  return meters * project.commonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project.commonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Get rotation matrix that aligns the z axis with the given up vector
// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  // Tangent on XY plane
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}

//
// Projecting normal - transform deltas from current coordinate system to
// normals in the worldspace
//
vec3 project_normal(vec3 vector) {
  // Apply model matrix
  vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

//
// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]
//
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project.wrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

//
// Projects positions (defined by project.coordinateSystem) to common space (defined by project.projectionMode)
//
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project.coordinateOrigin;
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        // Too far from the projection center for offset mode to be accurate
        // Only use high parts
        return vec4(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
    (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.
    position_world.xyz -= project.coordinateOrigin;
  }

  // Translation is already added to the high parts
  return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}

//
// Projects from common space coordinates to clip space.
// Uses project.viewProjectionMatrix
//
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset that corresponds to a given number of screen pixels
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project.scale;
  // UNIT_PIXELS
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project.scale;
}
`
  );

  // ../core/src/shaderlib/project/project.ts
  var INITIAL_MODULE_OPTIONS3 = {};
  function getUniforms5(opts = INITIAL_MODULE_OPTIONS3) {
    if ("viewport" in opts) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32, geometry_default],
    source: projectWGSL,
    vs: projectGLSL,
    getUniforms: getUniforms5,
    uniformTypes: {
      wrapLongitude: "f32",
      coordinateSystem: "i32",
      commonUnitsPerMeter: "vec3<f32>",
      projectionMode: "i32",
      scale: "f32",
      commonUnitsPerWorldUnit: "vec3<f32>",
      commonUnitsPerWorldUnit2: "vec3<f32>",
      center: "vec4<f32>",
      modelMatrix: "mat4x4<f32>",
      viewProjectionMatrix: "mat4x4<f32>",
      viewportSize: "vec2<f32>",
      devicePixelRatio: "f32",
      focalDistance: "f32",
      cameraPosition: "vec3<f32>",
      coordinateOrigin: "vec3<f32>",
      commonOrigin: "vec3<f32>",
      pseudoMeters: "f32"
    }
    // @ts-ignore TODO v9.1
  };

  // ../core/src/shaderlib/project32/project32.ts
  var source2 = (
    /* wgsl */
    `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
  );
  var vs4 = (
    /* glsl */
    `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
  );
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    source: source2,
    vs: vs4
  };

  // ../../node_modules/@math.gl/web-mercator/dist/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    const result = vec4_exports.transformMat4([], vector, matrix);
    vec4_exports.scale(result, result, 1 / result[3]);
    return result;
  }
  function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function lerp6(start, end, step) {
    return step * end + (1 - step) * start;
  }
  function clamp2(x3, min6, max6) {
    return x3 < min6 ? min6 : x3 > max6 ? max6 : x3;
  }
  function ieLog2(x3) {
    return Math.log(x3) * Math.LOG2E;
  }
  var log22 = Math.log2 || ieLog2;

  // ../../node_modules/@math.gl/web-mercator/dist/assert.js
  function assert7(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // ../../node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var MAX_LATITUDE = 85.051129;
  var DEFAULT_ALTITUDE = 1.5;
  function zoomToScale(zoom) {
    return Math.pow(2, zoom);
  }
  function scaleToZoom(scale22) {
    return log22(scale22);
  }
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert7(Number.isFinite(lng));
    assert7(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS2;
    const phi2 = lat * DEGREES_TO_RADIANS2;
    const x3 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y3 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x3, y3];
  }
  function worldToLngLat(xy) {
    const [x3, y3] = xy;
    const lambda2 = x3 / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y3 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(options) {
    const { latitude } = options;
    assert7(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }
  function getDistanceScales(options) {
    const { latitude, longitude, highPrecision = false } = options;
    assert7(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    const result = {
      unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
      metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
      unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
      degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
    };
    if (highPrecision) {
      const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x3, y3, z2] = xyz;
    const { unitsPerMeter: unitsPerMeter2, unitsPerMeter2: unitsPerMeter22 } = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x3 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y3);
    worldspace[1] += y3 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y3);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z2 || 0);
    return Number.isFinite(z0) || Number.isFinite(z2) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(options) {
    const {
      // Viewport props
      height,
      pitch,
      bearing,
      altitude,
      // Pre-calculated parameters
      scale: scale22,
      center
    } = options;
    const vm = createMat4();
    mat4_exports.translate(vm, vm, [0, 0, -altitude]);
    mat4_exports.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    mat4_exports.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS2);
    const relativeScale = scale22 / height;
    mat4_exports.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
    if (center) {
      mat4_exports.translate(vm, vm, vec3_exports.negate([], center));
    }
    return vm;
  }
  function getProjectionParameters(options) {
    const { width, height, altitude, pitch = 0, offset, center, scale: scale22, nearZMultiplier = 1, farZMultiplier = 1 } = options;
    let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
    if (altitude !== void 0) {
      fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS2;
    const pitchRadians = pitch * DEGREES_TO_RADIANS2;
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
      cameraToSeaLevelDistance += center[2] * scale22 / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
      fov: fovRadians,
      aspect: width / height,
      focalDistance,
      near: nearZMultiplier,
      far: farZ
    };
  }
  function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
  }
  function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x3, y3, z2 = 0] = xyz;
    assert7(Number.isFinite(x3) && Number.isFinite(y3) && Number.isFinite(z2));
    return transformVector(pixelProjectionMatrix, [x3, y3, z2, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x3, y3, z2] = xyz;
    assert7(Number.isFinite(x3) && Number.isFinite(y3), "invalid pixel coordinate");
    if (Number.isFinite(z2)) {
      const coord = transformVector(pixelUnprojectionMatrix, [x3, y3, z2, 1]);
      return coord;
    }
    const coord0 = transformVector(pixelUnprojectionMatrix, [x3, y3, 0, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x3, y3, 1, 1]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t3 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return vec2_exports.lerp([], coord0, coord1, t3);
  }

  // ../../node_modules/@math.gl/web-mercator/dist/fit-bounds.js
  function fitBounds(options) {
    const {
      width,
      height,
      bounds,
      minExtent = 0,
      // 0.01 would be about 1000 meters (degree is ~110KM)
      maxZoom = 24,
      // ~x4,000,000 => About 10 meter extents
      offset = [0, 0]
    } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
    const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
    const size = [
      Math.max(Math.abs(se[0] - nw[0]), minExtent),
      Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
      width - padding.left - padding.right - Math.abs(offset[0]) * 2,
      height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    assert7(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX2 = targetSize[0] / size[0];
    const scaleY2 = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX2;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    const centerLngLat = worldToLngLat(center);
    const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
    assert7(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }
  function getPaddingObject(padding = 0) {
    if (typeof padding === "number") {
      return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
      };
    }
    assert7(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport, z2 = 0) {
    const { width, height, unproject } = viewport;
    const unprojectOps = { targetZ: z2 };
    const bottomLeft = unproject([0, height], unprojectOps);
    const bottomRight = unproject([width, height], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport, 0, z2);
      topRight = unprojectOnFarPlane(viewport, width, z2);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport, x3, targetZ) {
    const { pixelUnprojectionMatrix } = viewport;
    const coord0 = transformVector(pixelUnprojectionMatrix, [x3, 0, 1, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x3, viewport.height, 1, 1]);
    const z2 = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t3 = (z2 - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = vec2_exports.lerp([], coord0, coord1, t3);
    const result = worldToLngLat(coord);
    result.push(targetZ);
    return result;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
  var TILE_SIZE2 = 512;
  function normalizeViewportProps(props) {
    const { width, height, pitch = 0 } = props;
    let { longitude, latitude, zoom, bearing = 0 } = props;
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod(bearing + 180, 360) - 180;
    }
    const minZoom = log22(height / TILE_SIZE2);
    if (zoom <= minZoom) {
      zoom = minZoom;
      latitude = 0;
    } else {
      const halfHeightPixels = height / 2 / Math.pow(2, zoom);
      const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
      if (latitude < minLatitude) {
        latitude = minLatitude;
      } else {
        const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
        if (latitude > maxLatitude) {
          latitude = maxLatitude;
        }
      }
    }
    return { width, height, longitude, latitude, zoom, pitch, bearing };
  }

  // ../../node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js
  var EPSILON21 = 0.01;
  var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
  var DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
    // screenSpeed and maxDuration are used only if specified
  };
  function flyToViewport(startProps, endProps, t3, options) {
    const { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
    if (u1 < EPSILON21) {
      const viewport = {};
      for (const key of VIEWPORT_TRANSITION_PROPS) {
        const startValue = startProps[key];
        const endValue = endProps[key];
        viewport[key] = lerp6(startValue, endValue, t3);
      }
      return viewport;
    }
    const s3 = t3 * S2;
    const w2 = Math.cosh(r0) / Math.cosh(r0 + rho * s3);
    const u3 = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s3) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w2;
    const newZoom = startZoom + scaleToZoom(scaleIncrement);
    const newCenterWorld = vec2_exports.scale([], uDelta, u3);
    vec2_exports.add(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = worldToLngLat(newCenterWorld);
    return {
      longitude: newCenter[0],
      latitude: newCenter[1],
      zoom: newZoom
    };
  }
  function getFlyToDuration(startProps, endProps, options) {
    const opts = { ...DEFAULT_OPTS, ...options };
    const { screenSpeed, speed, maxDuration } = opts;
    const { S: S2, rho } = getFlyToTransitionParams(startProps, endProps, opts);
    const length16 = 1e3 * S2;
    let duration;
    if (Number.isFinite(screenSpeed)) {
      duration = length16 / (screenSpeed / rho);
    } else {
      duration = length16 / speed;
    }
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
  }
  function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [startProps.longitude, startProps.latitude];
    const startScale = zoomToScale(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [endProps.longitude, endProps.latitude];
    const scale22 = zoomToScale(endZoom - startZoom);
    const startCenterXY = lngLatToWorld(startCenter);
    const endCenterXY = lngLatToWorld(endCenter);
    const uDelta = vec2_exports.sub([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale22;
    const u1 = vec2_exports.length(uDelta) * startScale;
    const _u1 = Math.max(u1, EPSILON21);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S2 = (r1 - r0) / rho;
    return { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0, r1 };
  }

  // ../core/src/shaderlib/shadow/shadow.ts
  var uniformBlock3 = (
    /* glsl */
    `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
  );
  var vertex = (
    /* glsl */
    `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
  );
  var vs5 = `
${uniformBlock3}
${vertex}
`;
  var fragment = (
    /* glsl */
    `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
  );
  var fs4 = `
${uniformBlock3}
${fragment}
`;
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x3, y3, z2] = xyz;
    const coord = pixelsToWorld([x3, y3, z2], pixelUnprojectionMatrix);
    if (Number.isFinite(z2)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition({
    viewport,
    center
  }) {
    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices({
    viewport,
    shadowMatrices
  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? void 0 : 1;
    const corners = [
      [0, 0, farZ],
      // top left ground
      [viewport.width, 0, farZ],
      // top right ground
      [0, viewport.height, farZ],
      // bottom left ground
      [viewport.width, viewport.height, farZ],
      // bottom right ground
      [0, 0, -1],
      // top left near
      [viewport.width, 0, -1],
      // top right near
      [0, viewport.height, -1],
      // bottom left near
      [viewport.width, viewport.height, -1]
      // bottom right near
    ].map(
      (pixel) => (
        // @ts-expect-error z may be undefined
        screenToCommonSpace(pixel, pixelUnprojectionMatrix)
      )
    );
    for (const shadowMatrix of shadowMatrices) {
      const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      const positions = corners.map((corner) => viewMatrix2.transform(corner));
      const projectionMatrix = new Matrix4().ortho({
        left: Math.min(...positions.map((position) => position[0])),
        right: Math.max(...positions.map((position) => position[0])),
        bottom: Math.min(...positions.map((position) => position[1])),
        top: Math.max(...positions.map((position) => position[1])),
        near: Math.min(...positions.map((position) => -position[2])),
        far: Math.max(...positions.map((position) => -position[2]))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
  }
  function createShadowUniforms(opts) {
    const { shadowEnabled = true, project: projectProps } = opts;
    if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {
      return {
        drawShadowMap: false,
        useShadowMap: false,
        shadow_uShadowMap0: opts.dummyShadowMap,
        shadow_uShadowMap1: opts.dummyShadowMap
      };
    }
    const projectUniforms = project_default.getUniforms(projectProps);
    const center = getMemoizedViewportCenterPosition({
      viewport: projectProps.viewport,
      center: projectUniforms.center
    });
    const projectCenters = [];
    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: projectProps.viewport
    }).slice();
    for (let i5 = 0; i5 < opts.shadowMatrices.length; i5++) {
      const viewProjectionMatrix = viewProjectionMatrices[i5];
      const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());
      if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i5] = viewProjectionMatrixCentered;
        projectCenters[i5] = center;
      } else {
        viewProjectionMatrices[i5] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i5] = viewProjectionMatrixCentered.transform(center);
      }
    }
    const uniforms = {
      drawShadowMap: Boolean(opts.drawToShadowMap),
      useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      color: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      lightId: opts.shadowLightId || 0,
      lightCount: opts.shadowMatrices.length,
      shadow_uShadowMap0: opts.dummyShadowMap,
      shadow_uShadowMap1: opts.dummyShadowMap
    };
    for (let i5 = 0; i5 < viewProjectionMatrices.length; i5++) {
      uniforms[`viewProjectionMatrix${i5}`] = viewProjectionMatrices[i5];
      uniforms[`projectCenter${i5}`] = projectCenters[i5];
    }
    for (let i5 = 0; i5 < 2; i5++) {
      uniforms[`shadow_uShadowMap${i5}`] = opts.shadowMaps && opts.shadowMaps[i5] || opts.dummyShadowMap;
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs5,
    fs: fs4,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
      "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
    },
    getUniforms: createShadowUniforms,
    uniformTypes: {
      drawShadowMap: "f32",
      useShadowMap: "f32",
      color: "vec4<f32>",
      lightId: "i32",
      lightCount: "f32",
      viewProjectionMatrix0: "mat4x4<f32>",
      viewProjectionMatrix1: "mat4x4<f32>",
      projectCenter0: "vec4<f32>",
      projectCenter1: "vec4<f32>"
    }
  };

  // ../core/src/shaderlib/picking/picking.ts
  var picking_default = {
    ...picking,
    defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
      "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
      }
    }
  };

  // ../core/src/shaderlib/index.ts
  var DEFAULT_MODULES = [geometry_default];
  var SHADER_HOOKS_GLSL = [
    "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
    "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
  ];
  var SHADER_HOOKS_WGSL = [
    // Not yet supported
  ];
  function getShaderAssembler(language) {
    const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
    for (const shaderModule of DEFAULT_MODULES) {
      shaderAssembler.addDefaultModule(shaderModule);
    }
    const shaderHooks = language === "glsl" ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;
    for (const shaderHook of shaderHooks) {
      shaderAssembler.addShaderHook(shaderHook);
    }
    return shaderAssembler;
  }

  // ../core/src/effects/lighting/ambient-light.ts
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = class {
    constructor(props = {}) {
      this.type = "ambient";
      const { color = DEFAULT_LIGHT_COLOR } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
      this.id = props.id || `ambient-${idCount++}`;
      this.color = color;
      this.intensity = intensity;
    }
  };

  // ../core/src/effects/lighting/directional-light.ts
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = class {
    constructor(props = {}) {
      this.type = "directional";
      const { color = DEFAULT_LIGHT_COLOR2 } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY2 } = props;
      const { direction = DEFAULT_LIGHT_DIRECTION } = props;
      const { _shadow = false } = props;
      this.id = props.id || `directional-${idCount2++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    getProjectedLight(opts) {
      return this;
    }
  };

  // ../core/src/passes/pass.ts
  var Pass = class {
    /** Create a new Pass instance */
    constructor(device, props = { id: "pass" }) {
      const { id } = props;
      this.id = id;
      this.device = device;
      this.props = { ...props };
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    render(params) {
    }
    // eslint-disable-line @typescript-eslint/no-empty-function
    cleanup() {
    }
    // eslint-disable-line @typescript-eslint/no-empty-function
  };

  // ../core/src/passes/layers-pass.ts
  var LayersPass = class extends Pass {
    constructor() {
      super(...arguments);
      this._lastRenderIndex = -1;
    }
    render(options) {
      const [width, height] = this.device.canvasContext.getDrawingBufferSize();
      const clearCanvas = options.clearCanvas ?? true;
      const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);
      const clearDepth = clearCanvas ? 1 : false;
      const clearStencil = clearCanvas ? 0 : false;
      const colorMask = options.colorMask ?? 15;
      const parameters2 = { viewport: [0, 0, width, height] };
      if (options.colorMask) {
        parameters2.colorMask = colorMask;
      }
      if (options.scissorRect) {
        parameters2.scissorRect = options.scissorRect;
      }
      const renderPass = this.device.beginRenderPass({
        framebuffer: options.target,
        parameters: parameters2,
        clearColor,
        clearDepth,
        clearStencil
      });
      try {
        return this._drawLayers(renderPass, options);
      } finally {
        renderPass.end();
        this.device.submit();
      }
    }
    /** Draw a list of layers in a list of viewports */
    _drawLayers(renderPass, options) {
      const {
        target: target2,
        shaderModuleProps,
        viewports,
        views,
        onViewportActive,
        clearStack = true
      } = options;
      options.pass = options.pass || "unknown";
      if (clearStack) {
        this._lastRenderIndex = -1;
      }
      const renderStats = [];
      for (const viewport of viewports) {
        const view = views && views[viewport.id];
        onViewportActive?.(viewport);
        const drawLayerParams = this._getDrawLayerParams(viewport, options);
        const subViewports = viewport.subViewports || [viewport];
        for (const subViewport of subViewports) {
          const stats2 = this._drawLayersInViewport(
            renderPass,
            {
              target: target2,
              shaderModuleProps,
              viewport: subViewport,
              view,
              pass: options.pass,
              layers: options.layers
            },
            drawLayerParams
          );
          renderStats.push(stats2);
        }
      }
      return renderStats;
    }
    // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
    // this is only done once for the parent viewport
    /* Resolve the parameters needed to draw each layer */
    _getDrawLayerParams(viewport, {
      layers,
      pass,
      isPicking = false,
      layerFilter,
      cullRect,
      effects,
      shaderModuleProps
    }, evaluateShouldDrawOnly = false) {
      const drawLayerParams = [];
      const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
      const drawContext = {
        layer: layers[0],
        viewport,
        isPicking,
        renderPass: pass,
        cullRect
      };
      const layerFilterCache = {};
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const shouldDrawLayer = this._shouldDrawLayer(
          layer,
          drawContext,
          layerFilter,
          layerFilterCache
        );
        const layerParam = { shouldDrawLayer };
        if (shouldDrawLayer && !evaluateShouldDrawOnly) {
          layerParam.shouldDrawLayer = true;
          layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          layerParam.shaderModuleProps = this._getShaderModuleProps(
            layer,
            effects,
            pass,
            shaderModuleProps
          );
          layerParam.layerParameters = {
            ...layer.context.deck?.props.parameters,
            ...this.getLayerParameters(layer, layerIndex, viewport)
          };
        }
        drawLayerParams[layerIndex] = layerParam;
      }
      return drawLayerParams;
    }
    // Draws a list of layers in one viewport
    // TODO - when picking we could completely skip rendering viewports that dont
    // intersect with the picking rect
    /* eslint-disable max-depth, max-statements */
    _drawLayersInViewport(renderPass, { layers, shaderModuleProps: globalModuleParameters, pass, target: target2, viewport, view }, drawLayerParams) {
      const glViewport = getGLViewport(this.device, {
        shaderModuleProps: globalModuleParameters,
        target: target2,
        viewport
      });
      if (view && view.props.clear) {
        const clearOpts = view.props.clear === true ? { color: true, depth: true } : view.props.clear;
        const clearRenderPass = this.device.beginRenderPass({
          framebuffer: target2,
          parameters: {
            viewport: glViewport,
            scissorRect: glViewport
          },
          clearColor: clearOpts.color ? [0, 0, 0, 0] : false,
          clearDepth: clearOpts.depth ? 1 : false
        });
        clearRenderPass.end();
      }
      const renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      renderPass.setParameters({ viewport: glViewport });
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const drawLayerParameters = drawLayerParams[layerIndex];
        const { shouldDrawLayer } = drawLayerParameters;
        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }
        if (layer.isComposite) {
          renderStatus.compositeCount++;
        }
        if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {
          const { layerRenderIndex, shaderModuleProps, layerParameters } = drawLayerParameters;
          renderStatus.visibleCount++;
          this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
          if (shaderModuleProps.project) {
            shaderModuleProps.project.viewport = viewport;
          }
          layer.context.renderPass = renderPass;
          try {
            layer._drawLayer({
              renderPass,
              shaderModuleProps,
              uniforms: { layerIndex: layerRenderIndex },
              parameters: layerParameters
            });
          } catch (err) {
            layer.raiseError(err, `drawing ${layer} to ${pass}`);
          }
        }
      }
      return renderStatus;
    }
    /* eslint-enable max-depth, max-statements */
    /* Methods for subclass overrides */
    shouldDrawLayer(layer) {
      return true;
    }
    getShaderModuleProps(layer, effects, otherShaderModuleProps) {
      return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return layer.props.parameters;
    }
    /* Private */
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
      const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
      if (!shouldDrawLayer) {
        return false;
      }
      drawContext.layer = layer;
      let parent = layer.parent;
      while (parent) {
        if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
          return false;
        }
        drawContext.layer = parent;
        parent = parent.parent;
      }
      if (layerFilter) {
        const rootLayerId = drawContext.layer.id;
        if (!(rootLayerId in layerFilterCache)) {
          layerFilterCache[rootLayerId] = layerFilter(drawContext);
        }
        if (!layerFilterCache[rootLayerId]) {
          return false;
        }
      }
      layer.activateViewport(drawContext.viewport);
      return true;
    }
    _getShaderModuleProps(layer, effects, pass, overrides) {
      const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const layerProps = layer.internalState?.propsInTransition || layer.props;
      const shaderModuleProps = {
        layer: layerProps,
        picking: {
          isActive: false
        },
        project: {
          viewport: layer.context.viewport,
          devicePixelRatio,
          modelMatrix: layerProps.modelMatrix,
          coordinateSystem: layerProps.coordinateSystem,
          coordinateOrigin: layerProps.coordinateOrigin,
          autoWrapLongitude: layer.wrapLongitude
        }
      };
      if (effects) {
        for (const effect of effects) {
          mergeModuleParameters(
            shaderModuleProps,
            effect.getShaderModuleProps?.(layer, shaderModuleProps)
          );
        }
      }
      return mergeModuleParameters(
        shaderModuleProps,
        this.getShaderModuleProps(layer, effects, shaderModuleProps),
        overrides
      );
    }
  };
  function layerIndexResolver(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn) => {
      const indexOverride = layer.props._offset;
      const layerId = layer.id;
      const parentId = layer.parent && layer.parent.id;
      let index;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex(layer.parent, false);
      }
      if (parentId in resolvers) {
        const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index = startIndex;
      }
      if (isDrawn && index >= startIndex) {
        startIndex = index + 1;
      }
      layerIndices[layerId] = index;
      return index;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(device, {
    shaderModuleProps,
    target: target2,
    viewport
  }) {
    const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ?? // @ts-expect-error TODO - assuming WebGL context
    device.canvasContext.cssToDeviceRatio();
    const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
    const height = target2 ? target2.height : drawingBufferHeight;
    const dimensions = viewport;
    return [
      dimensions.x * pixelRatio,
      height - (dimensions.y + dimensions.height) * pixelRatio,
      dimensions.width * pixelRatio,
      dimensions.height * pixelRatio
    ];
  }
  function mergeModuleParameters(target2, ...sources) {
    for (const source3 of sources) {
      if (source3) {
        for (const key in source3) {
          if (target2[key]) {
            Object.assign(target2[key], source3[key]);
          } else {
            target2[key] = source3[key];
          }
        }
      }
    }
    return target2;
  }

  // ../core/src/passes/shadow-pass.ts
  var ShadowPass = class extends LayersPass {
    constructor(device, props) {
      super(device, props);
      const shadowMap = device.createTexture({
        format: "rgba8unorm",
        width: 1,
        height: 1,
        sampler: {
          minFilter: "linear",
          magFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        },
        mipmaps: true
      });
      const depthBuffer = device.createTexture({
        format: "depth16unorm",
        width: 1,
        height: 1,
        mipmaps: false
      });
      this.fbo = device.createFramebuffer({
        id: "shadowmap",
        width: 1,
        height: 1,
        colorAttachments: [shadowMap],
        // Depth attachment has to be specified for depth test to work
        depthStencilAttachment: depthBuffer
      });
    }
    delete() {
      if (this.fbo) {
        this.fbo.destroy();
        this.fbo = null;
      }
    }
    getShadowMap() {
      return this.fbo.colorAttachments[0].texture;
    }
    render(params) {
      const target2 = this.fbo;
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const viewport = params.viewports[0];
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;
      const clearColor = [1, 1, 1, 1];
      if (width !== target2.width || height !== target2.height) {
        target2.resize({ width, height });
      }
      super.render({ ...params, clearColor, target: target2, pass: "shadow" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: false,
        depthWriteEnabled: true,
        depthCompare: "less-equal"
      };
    }
    shouldDrawLayer(layer) {
      return layer.props.shadowEnabled !== false;
    }
    getShaderModuleProps(layer, effects, otherShaderModuleProps) {
      return {
        shadow: {
          project: otherShaderModuleProps.project,
          drawToShadowMap: true
        }
      };
    }
  };

  // ../core/src/effects/lighting/lighting-effect.ts
  var DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [255, 255, 255],
    intensity: 1
  };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
    {
      color: [255, 255, 255],
      intensity: 1,
      direction: [-1, 3, -1]
    },
    {
      color: [255, 255, 255],
      intensity: 0.9,
      direction: [1, -8, -2.5]
    }
  ];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = class {
    constructor(props = {}) {
      this.id = "lighting-effect";
      this.shadowColor = DEFAULT_SHADOW_COLOR2;
      this.shadow = false;
      this.directionalLights = [];
      this.pointLights = [];
      this.shadowPasses = [];
      this.dummyShadowMap = null;
      this.setProps(props);
    }
    setup(context) {
      this.context = context;
      const { device, deck } = context;
      if (this.shadow && !this.dummyShadowMap) {
        this._createShadowPasses(device);
        deck._addDefaultShaderModule(shadow_default);
        this.dummyShadowMap = device.createTexture({
          width: 1,
          height: 1
        });
      }
    }
    setProps(props) {
      this.ambientLight = void 0;
      this.directionalLights = [];
      this.pointLights = [];
      for (const key in props) {
        const lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            this.ambientLight = lightSource;
            break;
          case "directional":
            this.directionalLights.push(lightSource);
            break;
          case "point":
            this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      this._applyDefaultLights();
      this.shadow = this.directionalLights.some((light) => light.shadow);
      if (this.context) {
        this.setup(this.context);
      }
      this.props = props;
    }
    preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
      if (!this.shadow)
        return;
      this.shadowMatrices = this._calculateMatrices();
      for (let i5 = 0; i5 < this.shadowPasses.length; i5++) {
        const shadowPass = this.shadowPasses[i5];
        shadowPass.render({
          layers,
          layerFilter,
          viewports,
          onViewportActive,
          views,
          shaderModuleProps: {
            shadow: {
              shadowLightId: i5,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
      }
    }
    getShaderModuleProps(layer, otherShaderModuleProps) {
      const shadowProps = this.shadow ? {
        project: otherShaderModuleProps.project,
        shadowMaps: this.shadowPasses.map((shadowPass) => shadowPass.getShadowMap()),
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {};
      const lightingProps = {
        enabled: true,
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map(
          (directionalLight) => directionalLight.getProjectedLight({ layer })
        ),
        pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
      };
      const materialProps = layer.props.material;
      return {
        shadow: shadowProps,
        lighting: lightingProps,
        phongMaterial: materialProps,
        gouraudMaterial: materialProps
      };
    }
    cleanup(context) {
      for (const shadowPass of this.shadowPasses) {
        shadowPass.delete();
      }
      this.shadowPasses.length = 0;
      if (this.dummyShadowMap) {
        this.dummyShadowMap.destroy();
        this.dummyShadowMap = null;
        context.deck._removeDefaultShaderModule(shadow_default);
      }
    }
    _calculateMatrices() {
      const lightMatrices = [];
      for (const light of this.directionalLights) {
        const viewMatrix2 = new Matrix4().lookAt({
          eye: new Vector3(light.direction).negate()
        });
        lightMatrices.push(viewMatrix2);
      }
      return lightMatrices;
    }
    _createShadowPasses(device) {
      for (let i5 = 0; i5 < this.directionalLights.length; i5++) {
        const shadowPass = new ShadowPass(device);
        this.shadowPasses[i5] = shadowPass;
      }
    }
    _applyDefaultLights() {
      const { ambientLight, pointLights, directionalLights } = this;
      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(
          new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),
          new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])
        );
      }
    }
  };

  // ../core/src/utils/typed-array-manager.ts
  var TypedArrayManager = class {
    constructor(options = {}) {
      this._pool = [];
      this.opts = { overAlloc: 2, poolSize: 100 };
      this.setOptions(options);
    }
    setOptions(options) {
      Object.assign(this.opts, options);
    }
    allocate(typedArray, count3, {
      size = 1,
      type,
      padding = 0,
      copy: copy12 = false,
      initialize = false,
      maxCount
    }) {
      const Type2 = type || typedArray && typedArray.constructor || Float32Array;
      const newSize = count3 * size + padding;
      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }
        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type2(typedArray.buffer, 0, newSize);
        }
      }
      let maxSize = Infinity;
      if (maxCount) {
        maxSize = maxCount * size + padding;
      }
      const newArray = this._allocate(Type2, newSize, initialize, maxSize);
      if (typedArray && copy12) {
        newArray.set(typedArray);
      } else if (!initialize) {
        newArray.fill(0, 0, 4);
      }
      this._release(typedArray);
      return newArray;
    }
    release(typedArray) {
      this._release(typedArray);
    }
    _allocate(Type2, size, initialize, maxSize) {
      let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
      if (sizeToAllocate > maxSize) {
        sizeToAllocate = maxSize;
      }
      const pool = this._pool;
      const byteLength = Type2.BYTES_PER_ELEMENT * sizeToAllocate;
      const i5 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i5 >= 0) {
        const array = new Type2(pool.splice(i5, 1)[0], 0, sizeToAllocate);
        if (initialize) {
          array.fill(0);
        }
        return array;
      }
      return new Type2(sizeToAllocate);
    }
    _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }
      const pool = this._pool;
      const { buffer } = typedArray;
      const { byteLength } = buffer;
      const i5 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i5 < 0) {
        pool.push(buffer);
      } else if (i5 > 0 || pool.length < this.opts.poolSize) {
        pool.splice(i5, 0, buffer);
      }
      if (pool.length > this.opts.poolSize) {
        pool.shift();
      }
    }
  };
  var typed_array_manager_default = new TypedArrayManager();

  // ../core/src/utils/math-utils.ts
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function mod2(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    return {
      left: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[0],
        viewProjectionMatrix[7] + viewProjectionMatrix[4],
        viewProjectionMatrix[11] + viewProjectionMatrix[8],
        viewProjectionMatrix[15] + viewProjectionMatrix[12]
      ),
      right: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[0],
        viewProjectionMatrix[7] - viewProjectionMatrix[4],
        viewProjectionMatrix[11] - viewProjectionMatrix[8],
        viewProjectionMatrix[15] - viewProjectionMatrix[12]
      ),
      bottom: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[1],
        viewProjectionMatrix[7] + viewProjectionMatrix[5],
        viewProjectionMatrix[11] + viewProjectionMatrix[9],
        viewProjectionMatrix[15] + viewProjectionMatrix[13]
      ),
      top: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[1],
        viewProjectionMatrix[7] - viewProjectionMatrix[5],
        viewProjectionMatrix[11] - viewProjectionMatrix[9],
        viewProjectionMatrix[15] - viewProjectionMatrix[13]
      ),
      near: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[2],
        viewProjectionMatrix[7] + viewProjectionMatrix[6],
        viewProjectionMatrix[11] + viewProjectionMatrix[10],
        viewProjectionMatrix[15] + viewProjectionMatrix[14]
      ),
      far: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[2],
        viewProjectionMatrix[7] - viewProjectionMatrix[6],
        viewProjectionMatrix[11] - viewProjectionMatrix[10],
        viewProjectionMatrix[15] - viewProjectionMatrix[14]
      )
    };
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a3, b2, c2, d2) {
    scratchVector.set(a3, b2, c2);
    const L2 = scratchVector.len();
    return { distance: d2 / L2, normal: new Vector3(-a3 / L2, -b2 / L2, -c2 / L2) };
  }
  function fp64LowPart2(x3) {
    return x3 - Math.fround(x3);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, options) {
    const { size = 1, startIndex = 0 } = options;
    const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
    const count3 = (endIndex - startIndex) / size;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count3, {
      type: Float32Array,
      size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (let j2 = 0; j2 < size; j2++) {
        const value = typedArray[sourceIndex++];
        scratchArray[targetIndex + j2] = value;
        scratchArray[targetIndex + j2 + size] = fp64LowPart2(value);
      }
      targetIndex += size * 2;
    }
    return scratchArray.subarray(0, count3 * size * 2);
  }
  function mergeBounds(boundsList) {
    let mergedBounds = null;
    let isMerged = false;
    for (const bounds of boundsList) {
      if (!bounds)
        continue;
      if (!mergedBounds) {
        mergedBounds = bounds;
      } else {
        if (!isMerged) {
          mergedBounds = [
            [mergedBounds[0][0], mergedBounds[0][1]],
            [mergedBounds[1][0], mergedBounds[1][1]]
          ];
          isMerged = true;
        }
        mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
        mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
        mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
        mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
      }
    }
    return mergedBounds;
  }

  // ../core/src/viewports/viewport.ts
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY2 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  function createProjectionMatrix({
    width,
    height,
    orthographic,
    fovyRadians,
    focalDistance,
    padding,
    near,
    far
  }) {
    const aspect = width / height;
    const matrix = orthographic ? new Matrix4().orthographic({ fovy: fovyRadians, aspect, focalDistance, near, far }) : new Matrix4().perspective({ fovy: fovyRadians, aspect, near, far });
    if (padding) {
      const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
      const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
      const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
      matrix[8] -= offsetX * 2 / width;
      matrix[9] += offsetY * 2 / height;
    }
    return matrix;
  }
  var _Viewport = class {
    // eslint-disable-next-line complexity
    constructor(opts = {}) {
      this._frustumPlanes = {};
      this.id = opts.id || this.constructor.displayName || "viewport";
      this.x = opts.x || 0;
      this.y = opts.y || 0;
      this.width = opts.width || 1;
      this.height = opts.height || 1;
      this.zoom = opts.zoom || 0;
      this.padding = opts.padding;
      this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = opts.focalDistance || 1;
      this.position = opts.position || ZERO_VECTOR2;
      this.modelMatrix = opts.modelMatrix || null;
      const { longitude, latitude } = opts;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this._initProps(opts);
      this._initMatrices(opts);
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      if (this.isGeospatial) {
        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
      }
      return PROJECTION_MODE.IDENTITY;
    }
    // Two viewports are equal if width and height are identical, and if
    // their view and projection matrices are (approximately) equal.
    equals(viewport) {
      if (!(viewport instanceof _Viewport)) {
        return false;
      }
      if (this === viewport) {
        return true;
      }
      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    }
    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */
    project(xyz, { topLeft = true } = {}) {
      const worldPosition = this.projectPosition(xyz);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x3, y3] = coord;
      const y22 = topLeft ? y3 : this.height - y3;
      return xyz.length === 2 ? [x3, y22] : [x3, y22, coord[2]];
    }
    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether origin is top left
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */
    unproject(xyz, { topLeft = true, targetZ } = {}) {
      const [x3, y3, z2] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x3, y22, z2], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z2)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection
    projectPosition(xyz) {
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    }
    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */
    projectFlat(xyz) {
      if (this.isGeospatial) {
        const result = lngLatToWorld(xyz);
        result[1] = clamp(result[1], -318, 830);
        return result;
      }
      return xyz;
    }
    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */
    unprojectFlat(xyz) {
      if (this.isGeospatial) {
        return worldToLngLat(xyz);
      }
      return xyz;
    }
    /**
     * Get bounds of the current viewport
     * @return {Array} - [minX, minY, maxX, maxY]
     */
    getBounds(options = {}) {
      const unprojectOption = { targetZ: options.z || 0 };
      const topLeft = this.unproject([0, 0], unprojectOption);
      const topRight = this.unproject([this.width, 0], unprojectOption);
      const bottomLeft = this.unproject([0, this.height], unprojectOption);
      const bottomRight = this.unproject([this.width, this.height], unprojectOption);
      return [
        Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
        Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
      ];
    }
    getDistanceScales(coordinateOrigin) {
      if (coordinateOrigin && this.isGeospatial) {
        return getDistanceScales({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
    containsPixel({
      x: x3,
      y: y3,
      width = 1,
      height = 1
    }) {
      return x3 < this.x + this.width && this.x < x3 + width && y3 < this.y + this.height && this.y < y3 + height;
    }
    // Extract frustum planes in common space
    getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }
      Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
      return this._frustumPlanes;
    }
    // EXPERIMENTAL METHODS
    /**
     * Needed by panning and linear transition
     * Pan the viewport to place a given world coordinate at screen point [x, y]
     *
     * @param {Array} coords - world coordinates
     * @param {Array} pixel - [x,y] coordinates on screen
     * @return {Object} props of the new viewport
     */
    panByPosition(coords, pixel) {
      return null;
    }
    // INTERNAL METHODS
    /* eslint-disable complexity, max-statements */
    _initProps(opts) {
      const longitude = opts.longitude;
      const latitude = opts.latitude;
      if (this.isGeospatial) {
        if (!Number.isFinite(opts.zoom)) {
          this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
        }
        this.distanceScales = opts.distanceScales || getDistanceScales({ latitude, longitude });
      }
      const scale22 = Math.pow(2, this.zoom);
      this.scale = scale22;
      const { position, modelMatrix: modelMatrix2 } = opts;
      let meterOffset = ZERO_VECTOR2;
      if (position) {
        meterOffset = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(position, []) : position;
      }
      if (this.isGeospatial) {
        const center = this.projectPosition([longitude, latitude, 0]);
        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
      } else {
        this.center = this.projectPosition(meterOffset);
      }
    }
    /* eslint-enable complexity, max-statements */
    _initMatrices(opts) {
      const {
        // View matrix
        viewMatrix: viewMatrix2 = IDENTITY2,
        // Projection matrix
        projectionMatrix = null,
        // Projection matrix parameters, used if projectionMatrix not supplied
        orthographic = false,
        fovyRadians,
        fovy = 75,
        near = 0.1,
        // Distance of near clipping plane
        far = 1e3,
        // Distance of far clipping plane
        padding = null,
        // Center offset in pixels
        focalDistance = 1
      } = opts;
      this.viewMatrixUncentered = viewMatrix2;
      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
      this.projectionMatrix = projectionMatrix || createProjectionMatrix({
        width: this.width,
        height: this.height,
        orthographic,
        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
        focalDistance,
        padding,
        near,
        far
      });
      const vpm = createMat42();
      mat4_exports.multiply(vpm, vpm, this.projectionMatrix);
      mat4_exports.multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = mat4_exports.invert([], this.viewMatrix) || this.viewMatrix;
      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
      const viewportMatrix = createMat42();
      const pixelProjectionMatrix = createMat42();
      mat4_exports.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      mat4_exports.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      mat4_exports.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.pixelUnprojectionMatrix = mat4_exports.invert(createMat42(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log_default.warn("Pixel project matrix not invertible")();
      }
    }
  };
  var Viewport = _Viewport;
  Viewport.displayName = "Viewport";

  // ../core/src/viewports/web-mercator-viewport.ts
  var _WebMercatorViewport = class extends Viewport {
    /* eslint-disable complexity, max-statements */
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 1.01,
        nearZ,
        farZ,
        orthographic = false,
        projectionMatrix,
        repeat = false,
        worldOffset = 0,
        position,
        padding,
        // backward compatibility
        // TODO: remove in v9
        legacyMeterSizes = false
      } = opts;
      let { width, height, altitude = 1.5 } = opts;
      const scale22 = Math.pow(2, zoom);
      width = width || 1;
      height = height || 1;
      let fovy;
      let projectionParameters = null;
      if (projectionMatrix) {
        altitude = projectionMatrix[5] / 2;
        fovy = altitudeToFovy(altitude);
      } else {
        if (opts.fovy) {
          fovy = opts.fovy;
          altitude = fovyToAltitude(fovy);
        } else {
          fovy = altitudeToFovy(altitude);
        }
        let offset;
        if (padding) {
          const { top = 0, bottom = 0 } = padding;
          offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
        }
        projectionParameters = getProjectionParameters({
          width,
          height,
          scale: scale22,
          center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
          offset,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
        if (Number.isFinite(nearZ)) {
          projectionParameters.near = nearZ;
        }
        if (Number.isFinite(farZ)) {
          projectionParameters.far = farZ;
        }
      }
      let viewMatrixUncentered = getViewMatrix({
        height,
        pitch,
        bearing,
        scale: scale22,
        altitude
      });
      if (worldOffset) {
        const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      super({
        ...opts,
        // x, y,
        width,
        height,
        // view matrix
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        // projection matrix parameters
        ...projectionParameters,
        fovy,
        focalDistance: altitude
      });
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.orthographic = orthographic;
      this._subViewports = repeat ? [] : null;
      this._pseudoMeters = legacyMeterSizes;
      Object.freeze(this);
    }
    /* eslint-enable complexity, max-statements */
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const bounds = this.getBounds();
        const minOffset = Math.floor((bounds[0] + 180) / 360);
        const maxOffset = Math.ceil((bounds[2] - 180) / 360);
        for (let x3 = minOffset; x3 <= maxOffset; x3++) {
          const offsetViewport = x3 ? new _WebMercatorViewport({
            ...this,
            worldOffset: x3
          }) : this;
          this._subViewports.push(offsetViewport);
        }
      }
      return this._subViewports;
    }
    projectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.projectPosition(xyz);
      }
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.unprojectPosition(xyz);
      }
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) / unitsPerMeter(Y);
      return [X, Y, Z];
    }
    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */
    addMetersToLngLat(lngLatZ, xyz) {
      return addMetersToLngLat(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate11 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
      const newCenter = vec2_exports.add([], this.center, translate11);
      const [longitude, latitude] = this.unprojectFlat(newCenter);
      return { longitude, latitude };
    }
    getBounds(options = {}) {
      const corners = getBounds(this, options.z || 0);
      return [
        Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
        Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
        Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
        Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
      ];
    }
    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     */
    fitBounds(bounds, options = {}) {
      const { width, height } = this;
      const { longitude, latitude, zoom } = fitBounds({ width, height, bounds, ...options });
      return new _WebMercatorViewport({ width, height, longitude, latitude, zoom });
    }
  };
  var WebMercatorViewport2 = _WebMercatorViewport;
  WebMercatorViewport2.displayName = "WebMercatorViewport";

  // ../core/src/shaderlib/project/project-functions.ts
  var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p3 = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof WebMercatorViewport2) {
      const [longitude, latitude, z2 = 0] = lngLatZ;
      const distanceScales = viewport.getDistanceScales([longitude, latitude]);
      p3[2] = z2 * distanceScales.unitsPerMeter[2];
    }
    return p3;
  }
  function normalizeParameters(opts) {
    const { viewport, modelMatrix: modelMatrix2, coordinateOrigin } = opts;
    let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      fromCoordinateOrigin = coordinateOrigin;
    }
    return {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    };
  }
  function getWorldPosition(position, {
    viewport,
    modelMatrix: modelMatrix2,
    coordinateSystem,
    coordinateOrigin,
    offsetMode
  }) {
    let [x3, y3, z2 = 0] = position;
    if (modelMatrix2) {
      [x3, y3, z2] = vec4_exports.transformMat4([], [x3, y3, z2, 1], modelMatrix2);
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x3, y3, z2], viewport, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition(
          [x3 + coordinateOrigin[0], y3 + coordinateOrigin[1], z2 + (coordinateOrigin[2] || 0)],
          viewport,
          offsetMode
        );
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(
          addMetersToLngLat(coordinateOrigin, [x3, y3, z2]),
          viewport,
          offsetMode
        );
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport.isGeospatial ? [x3 + coordinateOrigin[0], y3 + coordinateOrigin[1], z2 + coordinateOrigin[2]] : viewport.projectPosition([x3, y3, z2]);
    }
  }
  function projectPosition(position, params) {
    const {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = normalizeParameters(params);
    const { autoOffset = true } = params;
    const {
      geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
      shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
      offsetMode = false
    } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
    const worldPosition = getWorldPosition(position, {
      viewport,
      modelMatrix: modelMatrix2,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      const positionCommonSpace = viewport.projectPosition(
        geospatialOrigin || shaderCoordinateOrigin
      );
      vec3_exports.sub(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // ../core/src/effects/lighting/point-light.ts
  var DEFAULT_LIGHT_COLOR3 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY3 = 1;
  var DEFAULT_ATTENUATION = [1, 0, 0];
  var DEFAULT_LIGHT_POSITION = [0, 0, 1];
  var idCount3 = 0;
  var PointLight = class {
    constructor(props = {}) {
      this.type = "point";
      const { color = DEFAULT_LIGHT_COLOR3 } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY3 } = props;
      const { position = DEFAULT_LIGHT_POSITION } = props;
      this.id = props.id || `point-${idCount3++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "point";
      this.position = position;
      this.attenuation = getAttenuation(props);
      this.projectedLight = { ...this };
    }
    getProjectedLight({ layer }) {
      const { projectedLight } = this;
      const viewport = layer.context.viewport;
      const { coordinateSystem, coordinateOrigin } = layer.props;
      const position = projectPosition(this.position, {
        viewport,
        coordinateSystem,
        coordinateOrigin,
        fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        fromCoordinateOrigin: [0, 0, 0]
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = position;
      return projectedLight;
    }
  };
  function getAttenuation(props) {
    if (props.attenuation) {
      return props.attenuation;
    }
    return DEFAULT_ATTENUATION;
  }

  // ../core/src/effects/lighting/camera-light.ts
  var CameraLight = class extends PointLight {
    getProjectedLight({ layer }) {
      const { projectedLight } = this;
      const viewport = layer.context.viewport;
      const { coordinateSystem, coordinateOrigin, modelMatrix: modelMatrix2 } = layer.props;
      const { cameraPosition } = getUniformsFromViewport({
        viewport,
        modelMatrix: modelMatrix2,
        coordinateSystem,
        coordinateOrigin
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = cameraPosition;
      return projectedLight;
    }
  };

  // ../../node_modules/@math.gl/sun/dist/suncalc.js
  var DEGREES_TO_RADIANS5 = Math.PI / 180;
  var DAY_IN_MS = 1e3 * 60 * 60 * 24;
  var JD1970 = 2440588;
  var JD2000 = 2451545;
  var e = DEGREES_TO_RADIANS5 * 23.4397;
  var M0 = 357.5291;
  var M1 = 0.98560028;
  var THETA0 = 280.147;
  var THETA1 = 360.9856235;
  function getSunPosition(timestamp, latitude, longitude) {
    const longitudeWestInRadians = DEGREES_TO_RADIANS5 * -longitude;
    const phi = DEGREES_TO_RADIANS5 * latitude;
    const d2 = toDays(timestamp);
    const c2 = getSunCoords(d2);
    const H = getSiderealTime(d2, longitudeWestInRadians) - c2.rightAscension;
    return {
      azimuth: getAzimuth(H, phi, c2.declination),
      altitude: getAltitude(H, phi, c2.declination)
    };
  }
  function getSunDirection(timestamp, latitude, longitude) {
    const { azimuth, altitude } = getSunPosition(timestamp, latitude, longitude);
    return [
      Math.sin(azimuth) * Math.cos(altitude),
      Math.cos(azimuth) * Math.cos(altitude),
      -Math.sin(altitude)
    ];
  }
  function toJulianDay(timestamp) {
    const ts = typeof timestamp === "number" ? timestamp : timestamp.getTime();
    return ts / DAY_IN_MS - 0.5 + JD1970;
  }
  function toDays(timestamp) {
    return toJulianDay(timestamp) - JD2000;
  }
  function getRightAscension(eclipticLongitude, b2) {
    const lambda = eclipticLongitude;
    return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b2) * Math.sin(e), Math.cos(lambda));
  }
  function getDeclination(eclipticLongitude, b2) {
    const lambda = eclipticLongitude;
    return Math.asin(Math.sin(b2) * Math.cos(e) + Math.cos(b2) * Math.sin(e) * Math.sin(lambda));
  }
  function getAzimuth(hourAngle, latitudeInRadians, declination) {
    const H = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
  }
  function getAltitude(hourAngle, latitudeInRadians, declination) {
    const H = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
  }
  function getSiderealTime(dates, longitudeWestInRadians) {
    return DEGREES_TO_RADIANS5 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
  }
  function getSolarMeanAnomaly(days) {
    return DEGREES_TO_RADIANS5 * (M0 + M1 * days);
  }
  function getEclipticLongitude(meanAnomaly) {
    const M2 = meanAnomaly;
    const C2 = DEGREES_TO_RADIANS5 * (1.9148 * Math.sin(M2) + 0.02 * Math.sin(2 * M2) + 3e-4 * Math.sin(3 * M2));
    const P2 = DEGREES_TO_RADIANS5 * 102.9372;
    return M2 + C2 + P2 + Math.PI;
  }
  function getSunCoords(dates) {
    const M2 = getSolarMeanAnomaly(dates);
    const L2 = getEclipticLongitude(M2);
    return {
      declination: getDeclination(L2, 0),
      rightAscension: getRightAscension(L2, 0)
    };
  }

  // ../core/src/effects/lighting/sun-light.ts
  var SunLight = class extends DirectionalLight {
    constructor(opts) {
      super(opts);
      this.timestamp = opts.timestamp;
    }
    getProjectedLight({ layer }) {
      const { viewport } = layer.context;
      const isGlobe = viewport.resolution && viewport.resolution > 0;
      if (isGlobe) {
        const [x3, y3, z2] = getSunDirection(this.timestamp, 0, 0);
        this.direction = [x3, -z2, y3];
      } else {
        const { latitude, longitude } = viewport;
        this.direction = getSunDirection(this.timestamp, latitude, longitude);
      }
      return this;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/animation/timeline.js
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    time = 0;
    channels = /* @__PURE__ */ new Map();
    animations = /* @__PURE__ */ new Map();
    playing = false;
    lastEngineTime = -1;
    constructor() {
    }
    addChannel(props) {
      const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
      const channelId = channelHandles++;
      const channel = {
        time: 0,
        delay,
        duration,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(channelId, channel);
      return channelId;
    }
    removeChannel(channelId) {
      this.channels.delete(channelId);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === channelId) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(channelId) {
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
      if (channelId === void 0) {
        return this.time;
      }
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const { animation, channel } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(channelId) {
      this.animations.delete(channelId);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/animation-loop/request-animation-frame.js
  function requestAnimationFramePolyfill(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFramePolyfill(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // ../../node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js
  var statIdCounter = 0;
  var DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => {
      return null;
    },
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (error) => console.error(error),
    // eslint-disable-line no-console
    stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
    // view parameters
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
  };
  var AnimationLoop = class {
    device = null;
    canvas = null;
    props;
    animationProps = null;
    timeline = null;
    stats;
    cpuTime;
    gpuTime;
    frameRate;
    display;
    needsRedraw = "initialized";
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    _error = null;
    // _gpuTimeQuery: Query | null = null;
    /*
     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
     */
    constructor(props) {
      this.props = { ...DEFAULT_ANIMATION_LOOP_PROPS, ...props };
      props = this.props;
      if (!props.device) {
        throw new Error("No device provided");
      }
      const { useDevicePixels = true } = this.props;
      this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this.setProps({
        autoResizeViewport: props.autoResizeViewport,
        autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
      this.stop();
      this._setDisplay(null);
    }
    /** @deprecated Use .destroy() */
    delete() {
      this.destroy();
    }
    setError(error) {
      this.props.onError(error);
      this._error = Error();
      const canvas2 = this.device?.canvasContext?.canvas;
      if (canvas2 instanceof HTMLCanvasElement) {
        const errorDiv = document.createElement("h1");
        errorDiv.innerHTML = error.message;
        errorDiv.style.position = "absolute";
        errorDiv.style.top = "20%";
        errorDiv.style.left = "10px";
        errorDiv.style.color = "black";
        errorDiv.style.backgroundColor = "red";
        document.body.appendChild(errorDiv);
      }
    }
    /** Flags this animation loop as needing redraw */
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    /** TODO - move these props to CanvasContext? */
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.props.autoResizeViewport = props.autoResizeViewport || false;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
      }
      if ("useDevicePixels" in props) {
        this.props.useDevicePixels = props.useDevicePixels || false;
      }
      return this;
    }
    /** Starts a render loop if not already running */
    async start() {
      if (this._running) {
        return this;
      }
      this._running = true;
      try {
        let appContext;
        if (!this._initialized) {
          this._initialized = true;
          await this._initDevice();
          this._initialize();
          await this.props.onInitialize(this._getAnimationProps());
        }
        if (!this._running) {
          return null;
        }
        if (appContext !== false) {
          this._cancelAnimationFrame();
          this._requestAnimationFrame();
        }
        return this;
      } catch (err) {
        const error = err instanceof Error ? err : new Error("Unknown error");
        this.props.onError(error);
        throw error;
      }
    }
    /** Stops a render loop if already running, finalizing */
    stop() {
      if (this._running) {
        if (this.animationProps && !this._error) {
          this.props.onFinalize(this.animationProps);
        }
        this._cancelAnimationFrame();
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._running = false;
      }
      return this;
    }
    /** Explicitly draw a frame */
    redraw() {
      if (this.device?.isLost || this._error) {
        return this;
      }
      this._beginFrameTimers();
      this._setupFrame();
      this._updateAnimationProps();
      this._renderFrame(this._getAnimationProps());
      this._clearNeedsRedraw();
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endFrameTimers();
      return this;
    }
    /** Add a timeline, it will be automatically updated by the animation loop. */
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    /** Remove a timeline */
    detachTimeline() {
      this.timeline = null;
    }
    /** Wait until a render completes */
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve2) => {
          this._resolveNextFrame = resolve2;
        });
      }
      return this._nextFramePromise;
    }
    /** TODO - should use device.deviceContext */
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      if (this.canvas instanceof HTMLCanvasElement) {
        return this.canvas.toDataURL();
      }
      throw new Error("OffscreenCanvas");
    }
    // PRIVATE METHODS
    _initialize() {
      this._startEventHandling();
      this._initializeAnimationProps();
      this._updateAnimationProps();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.destroy();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _requestAnimationFrame() {
      if (!this._running) {
        return;
      }
      this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
      if (this._animationFrameId === null) {
        return;
      }
      cancelAnimationFramePolyfill(this._animationFrameId);
      this._animationFrameId = null;
    }
    _animationFrame() {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._requestAnimationFrame();
    }
    // Called on each frame, can be overridden to call onRender multiple times
    // to support e.g. stereoscopic rendering
    _renderFrame(animationProps) {
      if (this.display) {
        this.display._renderFrame(animationProps);
        return;
      }
      this.props.onRender(this._getAnimationProps());
      this.device?.submit();
    }
    _clearNeedsRedraw() {
      this.needsRedraw = false;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    // Initialize the  object that will be passed to app callbacks
    _initializeAnimationProps() {
      const canvas2 = this.device?.canvasContext?.canvas;
      if (!this.device || !canvas2) {
        throw new Error("loop");
      }
      this.animationProps = {
        animationLoop: this,
        device: this.device,
        canvas: canvas2,
        timeline: this.timeline,
        // Initial values
        useDevicePixels: this.props.useDevicePixels,
        needsRedraw: false,
        // Placeholders
        width: 1,
        height: 1,
        aspect: 1,
        // Animation props
        time: 0,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        // Experimental
        _mousePosition: null
        // Event props
      };
    }
    _getAnimationProps() {
      if (!this.animationProps) {
        throw new Error("animationProps");
      }
      return this.animationProps;
    }
    // Update the context object that will be passed to app callbacks
    _updateAnimationProps() {
      if (!this.animationProps) {
        return;
      }
      const { width, height, aspect } = this._getSizeAndAspect();
      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    /** Wait for supplied device */
    async _initDevice() {
      this.device = await this.props.device;
      if (!this.device) {
        throw new Error("No device provided");
      }
      this.canvas = this.device.canvasContext?.canvas || null;
    }
    _createInfoDiv() {
      if (this.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div5 = document.createElement("div");
        div5.style.position = "absolute";
        div5.style.left = "10px";
        div5.style.bottom = "10px";
        div5.style.width = "300px";
        div5.style.background = "white";
        if (this.canvas instanceof HTMLCanvasElement) {
          wrapperDiv.appendChild(this.canvas);
        }
        wrapperDiv.appendChild(div5);
        const html = this.props.onAddHTML(div5);
        if (html) {
          div5.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      if (!this.device) {
        return { width: 1, height: 1, aspect: 1 };
      }
      const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];
      let aspect = 1;
      const canvas2 = this.device?.canvasContext?.canvas;
      if (canvas2 && canvas2.clientHeight) {
        aspect = canvas2.clientWidth / canvas2.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }
      return { width, height, aspect };
    }
    /** Default viewport setup */
    _resizeViewport() {
      if (this.props.autoResizeViewport && this.device.gl) {
        this.device.gl.viewport(
          0,
          0,
          // @ts-expect-error Expose canvasContext
          this.device.gl.drawingBufferWidth,
          // @ts-expect-error Expose canvasContext
          this.device.gl.drawingBufferHeight
        );
      }
    }
    /**
     * Resize the render buffer of the canvas to match canvas client size
     * Optionally multiplying with devicePixel ratio
     */
    _resizeCanvasDrawingBuffer() {
      if (this.props.autoResizeDrawingBuffer) {
        this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
      }
    }
    _beginFrameTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      this.cpuTime.timeStart();
    }
    _endFrameTimers() {
      this.cpuTime.timeEnd();
    }
    // Event handling
    _startEventHandling() {
      if (this.canvas) {
        this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
        this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
      }
    }
    _onMousemove(event) {
      if (event instanceof MouseEvent) {
        this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
      }
    }
    _onMouseleave(event) {
      this._getAnimationProps()._mousePosition = null;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/utils/uid.js
  var uidCounters2 = {};
  function uid2(id = "id") {
    uidCounters2[id] = uidCounters2[id] || 1;
    const count3 = uidCounters2[id]++;
    return `${id}-${count3}`;
  }

  // ../../node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
  var GPUGeometry = class {
    id;
    userData = {};
    /** Determines how vertices are read from the 'vertex' attributes */
    topology;
    bufferLayout = [];
    vertexCount;
    indices;
    attributes;
    constructor(props) {
      this.id = props.id || uid2("geometry");
      this.topology = props.topology;
      this.indices = props.indices || null;
      this.attributes = props.attributes;
      this.vertexCount = props.vertexCount;
      this.bufferLayout = props.bufferLayout || [];
      if (this.indices) {
        if (!(this.indices.usage & Buffer2.INDEX)) {
          throw new Error("Index buffer must have INDEX usage");
        }
      }
    }
    destroy() {
      this.indices?.destroy();
      for (const attribute of Object.values(this.attributes)) {
        attribute.destroy();
      }
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getIndexes() {
      return this.indices || null;
    }
    _calculateVertexCount(positions) {
      const vertexCount = positions.byteLength / 12;
      return vertexCount;
    }
  };
  function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
      return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
      topology: geometry.topology || "triangle-list",
      bufferLayout,
      vertexCount: geometry.vertexCount,
      indices,
      attributes
    });
  }
  function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
      return void 0;
    }
    const data = geometry.indices.value;
    return device.createBuffer({ usage: Buffer2.INDEX, data });
  }
  function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
      let name13 = attributeName;
      switch (attributeName) {
        case "POSITION":
          name13 = "positions";
          break;
        case "NORMAL":
          name13 = "normals";
          break;
        case "TEXCOORD_0":
          name13 = "texCoords";
          break;
        case "COLOR_0":
          name13 = "colors";
          break;
      }
      if (attribute) {
        attributes[name13] = device.createBuffer({
          data: attribute.value,
          id: `${attributeName}-buffer`
        });
        const { value, size, normalized } = attribute;
        bufferLayout.push({ name: name13, format: getVertexFormatFromAttribute(value, size, normalized) });
      }
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return { attributes, bufferLayout, vertexCount };
  }

  // ../../node_modules/@luma.gl/engine/dist/factories/pipeline-factory.js
  var _PipelineFactory = class {
    /** Get the singleton default pipeline factory for the specified device */
    static getDefaultPipelineFactory(device) {
      device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new _PipelineFactory(device);
      return device._lumaData.defaultPipelineFactory;
    }
    device;
    destroyPolicy;
    _hashCounter = 0;
    _hashes = {};
    _renderPipelineCache = {};
    _computePipelineCache = {};
    constructor(device) {
      this.device = device;
      this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
    createRenderPipeline(props) {
      const allProps = { ...RenderPipeline.defaultProps, ...props };
      const hash = this._hashRenderPipeline(allProps);
      if (!this._renderPipelineCache[hash]) {
        const pipeline = this.device.createRenderPipeline({
          ...allProps,
          id: allProps.id ? `${allProps.id}-cached` : void 0
        });
        pipeline.hash = hash;
        this._renderPipelineCache[hash] = { pipeline, useCount: 0 };
      }
      this._renderPipelineCache[hash].useCount++;
      return this._renderPipelineCache[hash].pipeline;
    }
    createComputePipeline(props) {
      const allProps = { ...ComputePipeline.defaultProps, ...props };
      const hash = this._hashComputePipeline(allProps);
      if (!this._computePipelineCache[hash]) {
        const pipeline = this.device.createComputePipeline({
          ...allProps,
          id: allProps.id ? `${allProps.id}-cached` : void 0
        });
        pipeline.hash = hash;
        this._computePipelineCache[hash] = { pipeline, useCount: 0 };
      }
      this._computePipelineCache[hash].useCount++;
      return this._computePipelineCache[hash].pipeline;
    }
    release(pipeline) {
      const hash = pipeline.hash;
      const cache3 = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;
      cache3[hash].useCount--;
      if (cache3[hash].useCount === 0) {
        if (this.destroyPolicy === "unused") {
          cache3[hash].pipeline.destroy();
          delete cache3[hash];
        }
      }
    }
    // PRIVATE
    _hashComputePipeline(props) {
      const shaderHash = this._getHash(props.shader.source);
      return `${shaderHash}`;
    }
    /** Calculate a hash based on all the inputs for a render pipeline */
    _hashRenderPipeline(props) {
      const vsHash = props.vs ? this._getHash(props.vs.source) : 0;
      const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
      const varyingHash = "-";
      const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
      switch (this.device.type) {
        case "webgl":
          return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
        default:
          const parameterHash = this._getHash(JSON.stringify(props.parameters));
          return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
  };
  var PipelineFactory = _PipelineFactory;
  __publicField(PipelineFactory, "defaultProps", { ...RenderPipeline.defaultProps });

  // ../../node_modules/@luma.gl/engine/dist/factories/shader-factory.js
  var _ShaderFactory = class {
    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
    static getDefaultShaderFactory(device) {
      device._lumaData.defaultShaderFactory ||= new _ShaderFactory(device);
      return device._lumaData.defaultShaderFactory;
    }
    device;
    destroyPolicy;
    _cache = {};
    /** @internal */
    constructor(device) {
      this.device = device;
      this.destroyPolicy = device.props._factoryDestroyPolicy;
    }
    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
    createShader(props) {
      const key = this._hashShader(props);
      let cacheEntry = this._cache[key];
      if (!cacheEntry) {
        const shader = this.device.createShader({
          ...props,
          id: props.id ? `${props.id}-cached` : void 0
        });
        this._cache[key] = cacheEntry = { shader, useCount: 0 };
      }
      cacheEntry.useCount++;
      return cacheEntry.shader;
    }
    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
    release(shader) {
      const key = this._hashShader(shader);
      const cacheEntry = this._cache[key];
      if (cacheEntry) {
        cacheEntry.useCount--;
        if (cacheEntry.useCount === 0) {
          if (this.destroyPolicy === "unused") {
            delete this._cache[key];
            cacheEntry.shader.destroy();
          }
        }
      }
    }
    // PRIVATE
    _hashShader(value) {
      return `${value.stage}:${value.source}`;
    }
  };
  var ShaderFactory = _ShaderFactory;
  __publicField(ShaderFactory, "defaultProps", { ...Shader.defaultProps });

  // ../../node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
  function getDebugTableForShaderLayout(layout, name13) {
    const table = {};
    const header = "Values";
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
      return { "No attributes or varyings": { [header]: "N/A" } };
    }
    for (const attributeDeclaration of layout.attributes) {
      if (attributeDeclaration) {
        const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
        table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
      }
    }
    for (const varyingDeclaration of layout.varyings || []) {
      const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
      table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration) };
    }
    return table;
  }

  // ../../node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
  var canvas = null;
  var ctx = null;
  function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = id;
      canvas.title = id;
      canvas.style.zIndex = "100";
      canvas.style.position = "absolute";
      canvas.style.top = top;
      canvas.style.left = left;
      canvas.style.border = "blue 5px solid";
      canvas.style.transform = "scaleY(-1)";
      document.body.appendChild(canvas);
      ctx = canvas.getContext("2d");
    }
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
      canvas.width = fbo.width / 2;
      canvas.height = fbo.height / 2;
      canvas.style.width = "400px";
      canvas.style.height = "400px";
    }
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx?.createImageData(fbo.width, fbo.height);
    if (imageData) {
      const offset = 0;
      for (let i5 = 0; i5 < color.length; i5 += 4) {
        imageData.data[offset + i5 + 0] = color[i5 + 0] * rgbaScale;
        imageData.data[offset + i5 + 1] = color[i5 + 1] * rgbaScale;
        imageData.data[offset + i5 + 2] = color[i5 + 2] * rgbaScale;
        imageData.data[offset + i5 + 3] = opaque ? 255 : color[i5 + 3] * rgbaScale;
      }
      ctx?.putImageData(imageData, 0, 0);
    }
  }

  // ../../node_modules/@luma.gl/engine/dist/utils/deep-equal.js
  function deepEqual(a3, b2, depth) {
    if (a3 === b2) {
      return true;
    }
    if (!depth || !a3 || !b2) {
      return false;
    }
    if (Array.isArray(a3)) {
      if (!Array.isArray(b2) || a3.length !== b2.length) {
        return false;
      }
      for (let i5 = 0; i5 < a3.length; i5++) {
        if (!deepEqual(a3[i5], b2[i5], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b2)) {
      return false;
    }
    if (typeof a3 === "object" && typeof b2 === "object") {
      const aKeys = Object.keys(a3);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b2.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a3[key], b2[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@math.gl/types/dist/is-array.js
  function isTypedArray2(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function isNumberArray2(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number";
    }
    return false;
  }
  function isNumericArray(value) {
    return isTypedArray2(value) || isNumberArray2(value);
  }

  // ../../node_modules/@luma.gl/engine/dist/model/split-uniforms-and-bindings.js
  function isUniformValue(value) {
    return isNumericArray(value) || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings(uniforms) {
    const result = { bindings: {}, uniforms: {} };
    Object.keys(uniforms).forEach((name13) => {
      const uniform = uniforms[name13];
      if (isUniformValue(uniform)) {
        result.uniforms[name13] = uniform;
      } else {
        result.bindings[name13] = uniform;
      }
    });
    return result;
  }

  // ../../node_modules/@luma.gl/engine/dist/shader-inputs.js
  var ShaderInputs = class {
    options = {
      disableWarnings: false
    };
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    // @ts-ignore Fix typings
    modules;
    /** Stores the uniform values for each module */
    moduleUniforms;
    /** Stores the uniform bindings for each module  */
    moduleBindings;
    /** Tracks if uniforms have changed */
    // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
    /**
     * Create a new UniformStore instance
     * @param modules
     */
    constructor(modules, options) {
      Object.assign(this.options, options);
      const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter((module) => module.dependencies));
      for (const resolvedModule of resolvedModules) {
        modules[resolvedModule.name] = resolvedModule;
      }
      log2.log(1, "Creating ShaderInputs with modules", Object.keys(modules))();
      this.modules = modules;
      this.moduleUniforms = {};
      this.moduleBindings = {};
      for (const [name13, module] of Object.entries(modules)) {
        this._addModule(module);
        if (module.name && name13 !== module.name && !this.options.disableWarnings) {
          log2.warn(`Module name: ${name13} vs ${module.name}`)();
        }
      }
    }
    /** Destroy */
    destroy() {
    }
    /**
     * Set module props
     */
    setProps(props) {
      for (const name13 of Object.keys(props)) {
        const moduleName = name13;
        const moduleProps = props[moduleName] || {};
        const module = this.modules[moduleName];
        if (!module) {
          if (!this.options.disableWarnings) {
            log2.warn(`Module ${name13} not found`)();
          }
          continue;
        }
        const oldUniforms = this.moduleUniforms[moduleName];
        const oldBindings = this.moduleBindings[moduleName];
        const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;
        const { uniforms, bindings } = splitUniformsAndBindings(uniformsAndBindings);
        this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };
        this.moduleBindings[moduleName] = { ...oldBindings, ...bindings };
      }
    }
    /**
     * Return the map of modules
     * @todo should should this include the resolved dependencies?
     */
    getModules() {
      return Object.values(this.modules);
    }
    /** Get all uniform values for all modules */
    getUniformValues() {
      return this.moduleUniforms;
    }
    /** Merges all bindings for the shader (from the various modules) */
    getBindingValues() {
      const bindings = {};
      for (const moduleBindings of Object.values(this.moduleBindings)) {
        Object.assign(bindings, moduleBindings);
      }
      return bindings;
    }
    // INTERNAL
    /** Return a debug table that can be used for console.table() or log.table() */
    getDebugTable() {
      const table = {};
      for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
        for (const [key, value] of Object.entries(module)) {
          table[`${moduleName}.${key}`] = {
            type: this.modules[moduleName].uniformTypes?.[key],
            value: String(value)
          };
        }
      }
      return table;
    }
    _addModule(module) {
      const moduleName = module.name;
      this.moduleUniforms[moduleName] = module.defaultUniforms || {};
      this.moduleBindings[moduleName] = {};
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/application-utils/load-file.js
  var pathPrefix2 = "";
  async function loadImageBitmap(url, opts) {
    const image = new Image();
    image.crossOrigin = opts?.crossOrigin || "anonymous";
    image.src = url.startsWith("http") ? url : pathPrefix2 + url;
    await image.decode();
    return opts ? await createImageBitmap(image, opts) : await createImageBitmap(image);
  }

  // ../../node_modules/@luma.gl/engine/dist/async-texture/async-texture.js
  var AsyncTexture = class {
    device;
    id;
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    texture;
    // @ts-expect-error
    sampler;
    // @ts-expect-error
    view;
    ready;
    isReady = false;
    destroyed = false;
    resolveReady = () => {
    };
    rejectReady = () => {
    };
    get [Symbol.toStringTag]() {
      return "AsyncTexture";
    }
    toString() {
      return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
    }
    constructor(device, props) {
      this.device = device;
      this.id = props.id || uid2("async-texture");
      if (typeof props?.data === "string" && props.dimension === "2d") {
        props = { ...props, data: loadImageBitmap(props.data) };
      }
      this.ready = new Promise((resolve2, reject) => {
        this.resolveReady = () => {
          this.isReady = true;
          resolve2();
        };
        this.rejectReady = reject;
      });
      this.initAsync(props);
    }
    async initAsync(props) {
      let resolveReady;
      let rejectReady;
      const asyncData = props.data;
      const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);
      if (this.destroyed) {
        return;
      }
      const syncProps = { ...props, data };
      this.texture = this.device.createTexture(syncProps);
      this.sampler = this.texture.sampler;
      this.view = this.texture.view;
      this.isReady = true;
    }
    destroy() {
      if (this.texture) {
        this.texture.destroy();
        this.texture = null;
      }
      this.destroyed = true;
    }
    /**
     * Textures are immutable and cannot be resized after creation,
     * but we can create a similar texture with the same parameters but a new size.
     * @note Does not copy contents of the texture
     * @todo Abort pending promise and create a texture with the new size?
     */
    resize(size) {
      if (!this.isReady) {
        throw new Error("Cannot resize texture before it is ready");
      }
      if (size.width === this.texture.width && size.height === this.texture.height) {
        return false;
      }
      if (this.texture) {
        const texture = this.texture;
        this.texture = texture.clone(size);
        texture.destroy();
      }
      return true;
    }
  };
  async function awaitAllPromises(x3) {
    x3 = await x3;
    if (Array.isArray(x3)) {
      return await Promise.all(x3.map(awaitAllPromises));
    }
    if (x3 && typeof x3 === "object" && x3.constructor === Object) {
      const object = x3;
      const values = await Promise.all(Object.values(object));
      const keys = Object.keys(object);
      const resolvedObject = {};
      for (let i5 = 0; i5 < keys.length; i5++) {
        resolvedObject[keys[i5]] = values[i5];
      }
      return resolvedObject;
    }
    return x3;
  }

  // ../../node_modules/@luma.gl/engine/dist/model/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var _Model = class {
    device;
    id;
    // @ts-expect-error assigned in function called from constructor
    source;
    // @ts-expect-error assigned in function called from constructor
    vs;
    // @ts-expect-error assigned in function called from constructor
    fs;
    pipelineFactory;
    shaderFactory;
    userData = {};
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    parameters;
    /** The primitive topology */
    topology;
    /** Buffer layout */
    bufferLayout;
    // Dynamic properties
    /** Use instanced rendering */
    isInstanced = void 0;
    /** instance count. `undefined` means not instanced */
    instanceCount = 0;
    /** Vertex count */
    vertexCount;
    /** Index buffer */
    indexBuffer = null;
    /** Buffer-valued attributes */
    bufferAttributes = {};
    /** Constant-valued attributes */
    constantAttributes = {};
    /** Bindings (textures, samplers, uniform buffers) */
    bindings = {};
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
    uniforms = {};
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    vertexArray;
    /** TransformFeedback, WebGL 2 only. */
    transformFeedback = null;
    /** The underlying GPU "program". @note May be recreated if parameters change */
    pipeline;
    /** ShaderInputs instance */
    // @ts-expect-error Assigned in function called by constructor
    shaderInputs;
    // @ts-expect-error Assigned in function called by constructor
    _uniformStore;
    _attributeInfos = {};
    _gpuGeometry = null;
    _getModuleUniforms;
    props;
    _pipelineNeedsUpdate = "newly created";
    _needsRedraw = "initializing";
    _destroyed = false;
    /** "Time" of last draw. Monotonically increasing timestamp */
    _lastDrawTimestamp = -1;
    get [Symbol.toStringTag]() {
      return "Model";
    }
    toString() {
      return `Model(${this.id})`;
    }
    constructor(device, props) {
      this.props = { ..._Model.defaultProps, ...props };
      props = this.props;
      this.id = props.id || uid2("model");
      this.device = device;
      Object.assign(this.userData, props.userData);
      const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
      const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, { disableWarnings: this.props.disableWarnings });
      this.setShaderInputs(shaderInputs);
      const platformInfo = getPlatformInfo(device);
      const modules = (
        // @ts-ignore shaderInputs is assigned in setShaderInputs above.
        (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || []
      );
      const isWebGPU = this.device.type === "webgpu";
      if (isWebGPU && this.props.source) {
        const { source: source3, getUniforms: getUniforms8 } = this.props.shaderAssembler.assembleWGSLShader({
          platformInfo,
          ...this.props,
          modules
        });
        this.source = source3;
        this._getModuleUniforms = getUniforms8;
        this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);
      } else {
        const { vs: vs14, fs: fs11, getUniforms: getUniforms8 } = this.props.shaderAssembler.assembleGLSLShaderPair({
          platformInfo,
          ...this.props,
          modules
        });
        this.vs = vs14;
        this.fs = fs11;
        this._getModuleUniforms = getUniforms8;
      }
      this.vertexCount = this.props.vertexCount;
      this.instanceCount = this.props.instanceCount;
      this.topology = this.props.topology;
      this.bufferLayout = this.props.bufferLayout;
      this.parameters = this.props.parameters;
      if (props.geometry) {
        this.setGeometry(props.geometry);
      }
      this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
      this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
      this.pipeline = this._updatePipeline();
      this.vertexArray = device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
      if ("isInstanced" in props) {
        this.isInstanced = props.isInstanced;
      }
      if (props.instanceCount) {
        this.setInstanceCount(props.instanceCount);
      }
      if (props.vertexCount) {
        this.setVertexCount(props.vertexCount);
      }
      if (props.indexBuffer) {
        this.setIndexBuffer(props.indexBuffer);
      }
      if (props.attributes) {
        this.setAttributes(props.attributes);
      }
      if (props.constantAttributes) {
        this.setConstantAttributes(props.constantAttributes);
      }
      if (props.bindings) {
        this.setBindings(props.bindings);
      }
      if (props.uniforms) {
        this.setUniformsWebGL(props.uniforms);
      }
      if (props.moduleSettings) {
        this.updateModuleSettingsWebGL(props.moduleSettings);
      }
      if (props.transformFeedback) {
        this.transformFeedback = props.transformFeedback;
      }
      Object.seal(this);
    }
    destroy() {
      if (this._destroyed)
        return;
      this.pipelineFactory.release(this.pipeline);
      this.shaderFactory.release(this.pipeline.vs);
      if (this.pipeline.fs) {
        this.shaderFactory.release(this.pipeline.fs);
      }
      this._uniformStore.destroy();
      this._gpuGeometry?.destroy();
      this._destroyed = true;
    }
    // Draw call
    /** Query redraw status. Clears the status. */
    needsRedraw() {
      if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
        this.setNeedsRedraw("contents of bound textures or buffers updated");
      }
      const needsRedraw = this._needsRedraw;
      this._needsRedraw = false;
      return needsRedraw;
    }
    /** Mark the model as needing a redraw */
    setNeedsRedraw(reason) {
      this._needsRedraw ||= reason;
    }
    predraw() {
      this.updateShaderInputs();
      this.pipeline = this._updatePipeline();
    }
    draw(renderPass) {
      const loadingBinding = this._areBindingsLoading();
      if (loadingBinding) {
        log2.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();
        return false;
      }
      try {
        renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);
        this.predraw();
      } finally {
        renderPass.popDebugGroup();
      }
      let drawSuccess;
      try {
        renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);
        this._logDrawCallStart();
        this.pipeline = this._updatePipeline();
        const syncBindings = this._getBindings();
        this.pipeline.setBindings(syncBindings, {
          disableWarnings: this.props.disableWarnings
        });
        if (!isObjectEmpty(this.uniforms)) {
          this.pipeline.setUniformsWebGL(this.uniforms);
        }
        const { indexBuffer } = this.vertexArray;
        const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
        drawSuccess = this.pipeline.draw({
          renderPass,
          vertexArray: this.vertexArray,
          isInstanced: this.isInstanced,
          vertexCount: this.vertexCount,
          instanceCount: this.instanceCount,
          indexCount,
          transformFeedback: this.transformFeedback || void 0,
          // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
          // so we must provide our unique parameters to each draw
          // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
          parameters: this.parameters,
          topology: this.topology
        });
      } finally {
        renderPass.popDebugGroup();
        this._logDrawCallEnd();
      }
      this._logFramebuffer(renderPass);
      if (drawSuccess) {
        this._lastDrawTimestamp = this.device.timestamp;
        this._needsRedraw = false;
      } else {
        this._needsRedraw = "waiting for resource initialization";
      }
      return drawSuccess;
    }
    // Update fixed fields (can trigger pipeline rebuild)
    /**
     * Updates the optional geometry
     * Geometry, set topology and bufferLayout
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */
    setGeometry(geometry) {
      this._gpuGeometry?.destroy();
      const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
      if (gpuGeometry) {
        this.setTopology(gpuGeometry.topology || "triangle-list");
        const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
        this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
        if (this.vertexArray) {
          this._setGeometryAttributes(gpuGeometry);
        }
      }
      this._gpuGeometry = gpuGeometry;
    }
    /**
     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
     */
    setTopology(topology) {
      if (topology !== this.topology) {
        this.topology = topology;
        this._setPipelineNeedsUpdate("topology");
      }
    }
    /**
     * Updates the buffer layout.
     * @note Triggers a pipeline rebuild / pipeline cache fetch
     */
    setBufferLayout(bufferLayout) {
      const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
      this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
      this._setPipelineNeedsUpdate("bufferLayout");
      this.pipeline = this._updatePipeline();
      this.vertexArray = this.device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
    }
    /**
     * Set GPU parameters.
     * @note Can trigger a pipeline rebuild / pipeline cache fetch.
     * @param parameters
     */
    setParameters(parameters2) {
      if (!deepEqual(parameters2, this.parameters, 2)) {
        this.parameters = parameters2;
        this._setPipelineNeedsUpdate("parameters");
      }
    }
    // Update dynamic fields
    /**
     * Updates the instance count (used in draw calls)
     * @note Any attributes with stepMode=instance need to be at least this big
     */
    setInstanceCount(instanceCount) {
      this.instanceCount = instanceCount;
      if (this.isInstanced === void 0 && instanceCount > 0) {
        this.isInstanced = true;
      }
      this.setNeedsRedraw("instanceCount");
    }
    /**
     * Updates the vertex count (used in draw calls)
     * @note Any attributes with stepMode=vertex need to be at least this big
     */
    setVertexCount(vertexCount) {
      this.vertexCount = vertexCount;
      this.setNeedsRedraw("vertexCount");
    }
    /** Set the shader inputs */
    setShaderInputs(shaderInputs) {
      this.shaderInputs = shaderInputs;
      this._uniformStore = new UniformStore(this.shaderInputs.modules);
      for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {
        if (shaderModuleHasUniforms(module)) {
          const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
          this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
        }
      }
      this.setNeedsRedraw("shaderInputs");
    }
    /** Update uniform buffers from the model's shader inputs */
    updateShaderInputs() {
      this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
      this.setBindings(this.shaderInputs.getBindingValues());
      this.setNeedsRedraw("shaderInputs");
    }
    /**
     * Sets bindings (textures, samplers, uniform buffers)
     */
    setBindings(bindings) {
      Object.assign(this.bindings, bindings);
      this.setNeedsRedraw("bindings");
    }
    /**
     * Updates optional transform feedback. WebGL only.
     */
    setTransformFeedback(transformFeedback) {
      this.transformFeedback = transformFeedback;
      this.setNeedsRedraw("transformFeedback");
    }
    /**
     * Sets the index buffer
     * @todo - how to unset it if we change geometry?
     */
    setIndexBuffer(indexBuffer) {
      this.vertexArray.setIndexBuffer(indexBuffer);
      this.setNeedsRedraw("indexBuffer");
    }
    /**
     * Sets attributes (buffers)
     * @note Overrides any attributes previously set with the same name
     */
    setAttributes(buffers, options) {
      const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;
      if (buffers.indices) {
        log2.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
      }
      const bufferLayoutHelper = new BufferLayoutHelper(this.bufferLayout);
      for (const [bufferName, buffer] of Object.entries(buffers)) {
        const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);
        if (!bufferLayout) {
          if (!disableWarnings) {
            log2.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
          }
          continue;
        }
        const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);
        let set10 = false;
        for (const attributeName of attributeNames) {
          const attributeInfo = this._attributeInfos[attributeName];
          if (attributeInfo) {
            this.vertexArray.setBuffer(attributeInfo.location, buffer);
            set10 = true;
          }
        }
        if (!set10 && !disableWarnings) {
          log2.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
        }
      }
      this.setNeedsRedraw("attributes");
    }
    /**
     * Sets constant attributes
     * @note Overrides any attributes previously set with the same name
     * Constant attributes are only supported in WebGL, not in WebGPU
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @param constantAttributes
     */
    setConstantAttributes(attributes, options) {
      for (const [attributeName, value] of Object.entries(attributes)) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          this.vertexArray.setConstantWebGL(attributeInfo.location, value);
        } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
          log2.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
        }
      }
      this.setNeedsRedraw("constants");
    }
    // DEPRECATED METHODS
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */
    setUniforms(uniforms) {
      this.setUniformsWebGL(uniforms);
    }
    /**
     * Sets individual uniforms
     * @deprecated WebGL only, use uniform buffers for portability
     * @param uniforms
     */
    setUniformsWebGL(uniforms) {
      if (!isObjectEmpty(uniforms)) {
        this.pipeline.setUniformsWebGL(uniforms);
        Object.assign(this.uniforms, uniforms);
      }
      this.setNeedsRedraw("uniforms");
    }
    /**
     * @deprecated Updates shader module settings (which results in uniforms being set)
     */
    updateModuleSettingsWebGL(props) {
      const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));
      Object.assign(this.bindings, bindings);
      Object.assign(this.uniforms, uniforms);
      this.setNeedsRedraw("moduleSettings");
    }
    // Internal methods
    /** Check that bindings are loaded. Returns id of first binding that is still loading. */
    _areBindingsLoading() {
      for (const binding of Object.values(this.bindings)) {
        if (binding instanceof AsyncTexture && !binding.isReady) {
          return binding.id;
        }
      }
      return false;
    }
    /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
    _getBindings() {
      const validBindings = {};
      for (const [name13, binding] of Object.entries(this.bindings)) {
        if (binding instanceof AsyncTexture) {
          if (binding.isReady) {
            validBindings[name13] = binding.texture;
          }
        } else {
          validBindings[name13] = binding;
        }
      }
      return validBindings;
    }
    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
    _getBindingsUpdateTimestamp() {
      let timestamp = 0;
      for (const binding of Object.values(this.bindings)) {
        if (binding instanceof TextureView) {
          timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
        } else if (binding instanceof Buffer2 || binding instanceof Texture) {
          timestamp = Math.max(timestamp, binding.updateTimestamp);
        } else if (binding instanceof AsyncTexture) {
          timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) : (
            // The texture will become available in the future
            Infinity
          );
        } else if (!(binding instanceof Sampler)) {
          timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
        }
      }
      return timestamp;
    }
    /**
     * Updates the optional geometry attributes
     * Geometry, sets several attributes, indexBuffer, and also vertex count
     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
     */
    _setGeometryAttributes(gpuGeometry) {
      const attributes = { ...gpuGeometry.attributes };
      for (const [attributeName] of Object.entries(attributes)) {
        if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
          delete attributes[attributeName];
        }
      }
      this.vertexCount = gpuGeometry.vertexCount;
      this.setIndexBuffer(gpuGeometry.indices || null);
      this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
      this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
      this.setNeedsRedraw("geometry attributes");
    }
    /** Mark pipeline as needing update */
    _setPipelineNeedsUpdate(reason) {
      this._pipelineNeedsUpdate ||= reason;
      this.setNeedsRedraw(reason);
    }
    /** Update pipeline if needed */
    _updatePipeline() {
      if (this._pipelineNeedsUpdate) {
        let prevShaderVs = null;
        let prevShaderFs = null;
        if (this.pipeline) {
          log2.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
          prevShaderVs = this.pipeline.vs;
          prevShaderFs = this.pipeline.fs;
        }
        this._pipelineNeedsUpdate = false;
        const vs14 = this.shaderFactory.createShader({
          id: `${this.id}-vertex`,
          stage: "vertex",
          source: this.source || this.vs,
          debugShaders: this.props.debugShaders
        });
        let fs11 = null;
        if (this.source) {
          fs11 = vs14;
        } else if (this.fs) {
          fs11 = this.shaderFactory.createShader({
            id: `${this.id}-fragment`,
            stage: "fragment",
            source: this.source || this.fs,
            debugShaders: this.props.debugShaders
          });
        }
        this.pipeline = this.pipelineFactory.createRenderPipeline({
          ...this.props,
          bufferLayout: this.bufferLayout,
          topology: this.topology,
          parameters: this.parameters,
          // TODO - why set bindings here when we reset them every frame?
          // Should we expose a BindGroup abstraction?
          bindings: this._getBindings(),
          vs: vs14,
          fs: fs11
        });
        this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
        if (prevShaderVs)
          this.shaderFactory.release(prevShaderVs);
        if (prevShaderFs)
          this.shaderFactory.release(prevShaderFs);
      }
      return this.pipeline;
    }
    /** Throttle draw call logging */
    _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
      const logDrawTimeout = log2.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (log2.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
        return;
      }
      this._lastLogTime = Date.now();
      this._logOpen = true;
      log2.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log2.level <= 2 })();
    }
    _logDrawCallEnd() {
      if (this._logOpen) {
        const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
        log2.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
        const uniformTable = this.shaderInputs.getDebugTable();
        for (const [name13, value] of Object.entries(this.uniforms)) {
          uniformTable[name13] = { value };
        }
        log2.table(LOG_DRAW_PRIORITY, uniformTable)();
        const attributeTable = this._getAttributeDebugTable();
        log2.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
        log2.table(LOG_DRAW_PRIORITY, attributeTable)();
        log2.groupEnd(LOG_DRAW_PRIORITY)();
        this._logOpen = false;
      }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
      const debugFramebuffers = this.device.props.debugFramebuffers;
      this._drawCount++;
      if (!debugFramebuffers) {
        return;
      }
      const framebuffer = renderPass.props.framebuffer;
      if (framebuffer) {
        debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });
      }
    }
    _getAttributeDebugTable() {
      const table = {};
      for (const [name13, attributeInfo] of Object.entries(this._attributeInfos)) {
        const values = this.vertexArray.attributes[attributeInfo.location];
        table[attributeInfo.location] = {
          name: name13,
          type: attributeInfo.shaderType,
          values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : "null"
        };
      }
      if (this.vertexArray.indexBuffer) {
        const { indexBuffer } = this.vertexArray;
        const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
        table.indices = {
          name: "indices",
          type: indexBuffer.indexType,
          values: values.toString()
        };
      }
      return table;
    }
    // TODO - fix typing of luma data types
    _getBufferOrConstantValues(attribute, dataType) {
      const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
      const typedArray = attribute instanceof Buffer2 ? new TypedArrayConstructor(attribute.debugData) : attribute;
      return typedArray.toString();
    }
  };
  var Model = _Model;
  __publicField(Model, "defaultProps", {
    ...RenderPipeline.defaultProps,
    source: void 0,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  });
  function shaderModuleHasUniforms(module) {
    return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));
  }
  function getPlatformInfo(device) {
    return {
      type: device.type,
      shaderLanguage: device.info.shadingLanguage,
      shaderLanguageVersion: device.info.shadingLanguageVersion,
      gpu: device.info.gpu,
      // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
      features: device.features
    };
  }
  function isObjectEmpty(obj) {
    for (const key in obj) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@luma.gl/engine/dist/compute/buffer-transform.js
  var _BufferTransform = class {
    device;
    model;
    transformFeedback;
    static isSupported(device) {
      return device?.info?.type === "webgl";
    }
    constructor(device, props = _BufferTransform.defaultProps) {
      if (!_BufferTransform.isSupported(device)) {
        throw new Error("BufferTransform not yet implemented on WebGPU");
      }
      this.device = device;
      this.model = new Model(this.device, {
        id: props.id || "buffer-transform-model",
        fs: props.fs || getPassthroughFS(),
        topology: props.topology || "point-list",
        varyings: props.outputs || props.varyings,
        ...props
      });
      this.transformFeedback = this.device.createTransformFeedback({
        layout: this.model.pipeline.shaderLayout,
        // @ts-expect-error TODO
        buffers: props.feedbackBuffers
      });
      this.model.setTransformFeedback(this.transformFeedback);
      Object.seal(this);
    }
    /** Destroy owned resources. */
    destroy() {
      if (this.model) {
        this.model.destroy();
      }
    }
    /** @deprecated Use {@link destroy}. */
    delete() {
      this.destroy();
    }
    /** Run one transform loop. */
    run(options) {
      if (options?.inputBuffers) {
        this.model.setAttributes(options.inputBuffers);
      }
      if (options?.outputBuffers) {
        this.transformFeedback.setBuffers(options.outputBuffers);
      }
      const renderPass = this.device.beginRenderPass(options);
      this.model.draw(renderPass);
      renderPass.end();
    }
    // DEPRECATED METHODS
    /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
    getBuffer(varyingName) {
      return this.transformFeedback.getBuffer(varyingName);
    }
    /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
    readAsync(varyingName) {
      const result = this.getBuffer(varyingName);
      if (!result) {
        throw new Error("BufferTransform#getBuffer");
      }
      if (result instanceof Buffer2) {
        return result.readAsync();
      }
      const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
      return buffer.readAsync(byteOffset, byteLength);
    }
  };
  var BufferTransform = _BufferTransform;
  __publicField(BufferTransform, "defaultProps", {
    ...Model.defaultProps,
    outputs: void 0,
    feedbackBuffers: void 0
  });

  // ../../node_modules/@luma.gl/engine/dist/compute/texture-transform.js
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    device;
    model;
    sampler;
    currentIndex = 0;
    samplerTextureMap = null;
    bindings = [];
    // each element is an object : {sourceTextures, targetTexture, framebuffer}
    resources = {};
    // resources to be deleted
    constructor(device, props) {
      this.device = device;
      this.sampler = device.createSampler({
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
        minFilter: "nearest",
        magFilter: "nearest",
        mipmapFilter: "nearest"
      });
      this.model = new Model(this.device, {
        id: props.id || "texture-transform-model",
        fs: props.fs || getPassthroughFS({
          input: props.targetTextureVarying,
          inputChannels: props.targetTextureChannels,
          output: FS_OUTPUT_VARIABLE
        }),
        vertexCount: props.vertexCount,
        // TODO(donmccurdy): Naming?
        ...props
      });
      this._initialize(props);
      Object.seal(this);
    }
    // Delete owned resources.
    destroy() {
      this.model.destroy();
      for (const binding of this.bindings) {
        binding.framebuffer?.destroy();
      }
    }
    /** @deprecated Use {@link destroy}. */
    delete() {
      this.destroy();
    }
    run(options) {
      const { framebuffer } = this.bindings[this.currentIndex];
      const renderPass = this.device.beginRenderPass({ framebuffer, ...options });
      this.model.draw(renderPass);
      renderPass.end();
    }
    getTargetTexture() {
      const { targetTexture } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    // Private
    _initialize(props) {
      this._updateBindings(props);
    }
    _updateBindings(props) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
    }
    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          // @ts-expect-error
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const { width, height } = targetTexture;
        if (binding.framebuffer) {
          binding.framebuffer.destroy();
        }
        binding.framebuffer = this.device.createFramebuffer({
          id: "transform-framebuffer",
          width,
          height,
          colorAttachments: [targetTexture]
        });
        binding.framebuffer.resize({ width, height });
      }
      return binding;
    }
    // set texture filtering parameters on source textures.
    _setSourceTextureParameters() {
      const index = this.currentIndex;
      const { sourceTextures } = this.bindings[index];
      for (const name13 in sourceTextures) {
        sourceTextures[name13].sampler = this.sampler;
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometry/geometry.js
  var Geometry = class {
    id;
    /** Determines how vertices are read from the 'vertex' attributes */
    topology;
    vertexCount;
    indices;
    attributes;
    userData = {};
    constructor(props) {
      const { attributes = {}, indices = null, vertexCount = null } = props;
      this.id = props.id || uid2("geometry");
      this.topology = props.topology;
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;
      }
      this.attributes = {};
      for (const [attributeName, attributeValue] of Object.entries(attributes)) {
        const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
        if (!ArrayBuffer.isView(attribute.value)) {
          throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);
        }
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          if (this.indices) {
            throw new Error("Multiple indices detected");
          }
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
      return this.vertexCount;
    }
    /**
     * Return an object with all attributes plus indices added as a field.
     * TODO Geometry types are a mess
     */
    getAttributes() {
      return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
    }
    // PRIVATE
    _print(attributeName) {
      return `Geometry ${this.id} attribute ${attributeName}`;
    }
    /**
     * GeometryAttribute
     * value: typed array
     * type: indices, vertices, uvs
     * size: elements per vertex
     * target: WebGL buffer type (string or constant)
     *
     * @param attributes
     * @param indices
     * @returns
     */
    _setAttributes(attributes, indices) {
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attribute of Object.values(attributes)) {
        const { value, size, constant } = attribute;
        if (!constant && value && size !== void 0 && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }
      return vertexCount;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/models/clip-space.js
  var CLIPSPACE_VERTEX_SHADER_WGSL = (
    /* wgsl */
    `struct VertexInputs {
  @location(0) clipSpacePosition: vec2<f32>,
  @location(1) texCoord: vec2<f32>,
  @location(2) coordinate: vec2<f32>  
}

struct FragmentInputs {
  @builtin(position) Position : vec4<f32>,
  @location(0) position : vec2<f32>,
  @location(1) coordinate : vec2<f32>,
  @location(2) uv : vec2<f32>
};

@vertex
fn vertexMain(inputs: VertexInputs) -> FragmentInputs {
  var outputs: FragmentInputs;
  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);
  outputs.position = inputs.clipSpacePosition;
  outputs.coordinate = inputs.coordinate;
  outputs.uv = inputs.texCoord;
  return outputs;
}
`
  );
  var CLIPSPACE_VERTEX_SHADER = (
    /* glsl */
    `#version 300 es
in vec2 clipSpacePositions;
in vec2 texCoords;
in vec2 coordinates;

out vec2 position;
out vec2 coordinate;
out vec2 uv;

void main(void) {
  gl_Position = vec4(clipSpacePositions, 0., 1.);
  position = clipSpacePositions;
  coordinate = coordinates;
  uv = texCoords;
}
`
  );
  var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
  var ClipSpace = class extends Model {
    constructor(device, props) {
      const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
      if (props.source) {
        props = { ...props, source: `${CLIPSPACE_VERTEX_SHADER_WGSL}
${props.source}` };
      }
      super(device, {
        id: props.id || uid2("clip-space"),
        ...props,
        vs: CLIPSPACE_VERTEX_SHADER,
        vertexCount: 4,
        geometry: new Geometry({
          topology: "triangle-strip",
          vertexCount: 4,
          attributes: {
            clipSpacePositions: { size: 2, value: new Float32Array(POSITIONS) },
            texCoords: { size: 2, value: new Float32Array(TEX_COORDS) },
            coordinates: { size: 2, value: new Float32Array(TEX_COORDS) }
          }
        })
      });
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/scenegraph-node.js
  var ScenegraphNode = class {
    id;
    matrix = new Matrix4();
    display = true;
    position = new Vector3();
    rotation = new Vector3();
    scale = new Vector3(1, 1, 1);
    userData = {};
    props = {};
    constructor(props = {}) {
      const { id } = props;
      this.id = id || uid2(this.constructor.name);
      this._setScenegraphNodeProps(props);
    }
    getBounds() {
      return null;
    }
    destroy() {
    }
    /** @deprecated use .destroy() */
    delete() {
      this.destroy();
    }
    setProps(props) {
      this._setScenegraphNodeProps(props);
      return this;
    }
    toString() {
      return `{type: ScenegraphNode, id: ${this.id})}`;
    }
    setPosition(position) {
      this.position = position;
      return this;
    }
    setRotation(rotation) {
      this.rotation = rotation;
      return this;
    }
    setScale(scale22) {
      this.scale = scale22;
      return this;
    }
    setMatrix(matrix, copyMatrix = true) {
      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
    setMatrixComponents(components) {
      const { position, rotation, scale: scale22, update = true } = components;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale22) {
        this.setScale(scale22);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
    updateMatrix() {
      const pos = this.position;
      const rot = this.rotation;
      const scale22 = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale22);
      return this;
    }
    update(options = {}) {
      const { position, rotation, scale: scale22 } = options;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale22) {
        this.setScale(scale22);
      }
      this.updateMatrix();
      return this;
    }
    getCoordinateUniforms(viewMatrix2, modelMatrix2) {
      modelMatrix2 = modelMatrix2 || this.matrix;
      const worldMatrix = new Matrix4(viewMatrix2).multiplyRight(modelMatrix2);
      const worldInverse = worldMatrix.invert();
      const worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix: viewMatrix2,
        modelMatrix: modelMatrix2,
        objectMatrix: modelMatrix2,
        worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
    // TODO - copied code, not yet vetted
    /*
      transform() {
        if (!this.parent) {
          this.endPosition.set(this.position);
          this.endRotation.set(this.rotation);
          this.endScale.set(this.scale);
        } else {
          const parent = this.parent;
          this.endPosition.set(this.position.add(parent.endPosition));
          this.endRotation.set(this.rotation.add(parent.endRotation));
          this.endScale.set(this.scale.add(parent.endScale));
        }
    
        const ch = this.children;
        for (let i = 0; i < ch.length; ++i) {
          ch[i].transform();
        }
    
        return this;
      }
      */
    _setScenegraphNodeProps(props) {
      if ("position" in props) {
        this.setPosition(props.position);
      }
      if ("rotation" in props) {
        this.setRotation(props.rotation);
      }
      if ("scale" in props) {
        this.setScale(props.scale);
      }
      if ("matrix" in props) {
        this.setMatrix(props.matrix);
      }
      Object.assign(this.props, props);
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/group-node.js
  var GroupNode = class extends ScenegraphNode {
    children;
    constructor(props = {}) {
      props = Array.isArray(props) ? { children: props } : props;
      const { children = [] } = props;
      log2.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
      super(props);
      this.children = children;
    }
    getBounds() {
      const result = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      this.traverse((node, { worldMatrix }) => {
        const bounds = node.getBounds();
        if (!bounds) {
          return;
        }
        const [min6, max6] = bounds;
        const center = new Vector3(min6).add(max6).divide([2, 2, 2]);
        worldMatrix.transformAsPoint(center, center);
        const halfSize = new Vector3(max6).subtract(min6).divide([2, 2, 2]);
        worldMatrix.transformAsVector(halfSize, halfSize);
        for (let v2 = 0; v2 < 8; v2++) {
          const position = new Vector3(v2 & 1 ? -1 : 1, v2 & 2 ? -1 : 1, v2 & 4 ? -1 : 1).multiply(halfSize).add(center);
          for (let i5 = 0; i5 < 3; i5++) {
            result[0][i5] = Math.min(result[0][i5], position[i5]);
            result[1][i5] = Math.max(result[1][i5], position[i5]);
          }
        }
      });
      if (!Number.isFinite(result[0][0])) {
        return null;
      }
      return result;
    }
    destroy() {
      this.children.forEach((child) => child.destroy());
      this.removeAll();
      super.destroy();
    }
    // Unpacks arrays and nested arrays of children
    add(...children) {
      for (const child of children) {
        if (Array.isArray(child)) {
          this.add(...child);
        } else {
          this.children.push(child);
        }
      }
      return this;
    }
    remove(child) {
      const children = this.children;
      const indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
    removeAll() {
      this.children = [];
      return this;
    }
    traverse(visitor, { worldMatrix = new Matrix4() } = {}) {
      const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
      for (const child of this.children) {
        if (child instanceof GroupNode) {
          child.traverse(visitor, { worldMatrix: modelMatrix2 });
        } else {
          visitor(child, { worldMatrix: modelMatrix2 });
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/model-node.js
  var ModelNode = class extends ScenegraphNode {
    model;
    bounds = null;
    managedResources;
    // TODO - is this used? override callbacks to make sure we call them with this
    // onBeforeRender = null;
    // onAfterRender = null;
    // AfterRender = null;
    constructor(props) {
      super(props);
      this.model = props.model;
      this.managedResources = props.managedResources || [];
      this.bounds = props.bounds || null;
      this.setProps(props);
    }
    destroy() {
      if (this.model) {
        this.model.destroy();
        this.model = null;
      }
      this.managedResources.forEach((resource) => resource.destroy());
      this.managedResources = [];
    }
    getBounds() {
      return this.bounds;
    }
    // Expose model methods
    draw(renderPass) {
      return this.model.draw(renderPass);
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js
  var CubeGeometry = class extends Geometry {
    constructor(props = {}) {
      const { id = uid2("cube-geometry"), indices = true } = props;
      super(indices ? {
        ...props,
        id,
        topology: "triangle-list",
        indices: { size: 1, value: CUBE_INDICES },
        attributes: { ...ATTRIBUTES, ...props.attributes }
      } : {
        ...props,
        id,
        topology: "triangle-list",
        indices: void 0,
        attributes: { ...NON_INDEXED_ATTRIBUTES, ...props.attributes }
      });
    }
  };
  var CUBE_INDICES = new Uint16Array([
    0,
    1,
    2,
    0,
    2,
    3,
    4,
    5,
    6,
    4,
    6,
    7,
    8,
    9,
    10,
    8,
    10,
    11,
    12,
    13,
    14,
    12,
    14,
    15,
    16,
    17,
    18,
    16,
    18,
    19,
    20,
    21,
    22,
    20,
    22,
    23
  ]);
  var CUBE_POSITIONS = new Float32Array([
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1
  ]);
  var CUBE_NORMALS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    // Back face
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    // Bottom face
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    // Right face
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    // Left face
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0
  ]);
  var CUBE_TEX_COORDS = new Float32Array([
    // Front face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    // Back face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Top face
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    // Bottom face
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    // Right face
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    // Left face
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1
  ]);
  var CUBE_NON_INDEXED_POSITIONS = new Float32Array([
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1
  ]);
  var CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0
  ]);
  var CUBE_NON_INDEXED_COLORS = new Float32Array([
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    1
  ]);
  var ATTRIBUTES = {
    POSITION: { size: 3, value: CUBE_POSITIONS },
    NORMAL: { size: 3, value: CUBE_NORMALS },
    TEXCOORD_0: { size: 2, value: CUBE_TEX_COORDS }
  };
  var NON_INDEXED_ATTRIBUTES = {
    POSITION: { size: 3, value: CUBE_NON_INDEXED_POSITIONS },
    // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},
    TEXCOORD_0: { size: 2, value: CUBE_NON_INDEXED_TEX_COORDS },
    COLOR_0: { size: 3, value: CUBE_NON_INDEXED_COLORS }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometries/sphere-geometry.js
  var SphereGeometry = class extends Geometry {
    constructor(props = {}) {
      const { id = uid2("sphere-geometry") } = props;
      const { indices, attributes } = tesselateSphere(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: { ...attributes, ...props.attributes }
      });
    }
  };
  function tesselateSphere(props) {
    const { nlat = 10, nlong = 10 } = props;
    const startLat = 0;
    const endLat = Math.PI;
    const latRange = endLat - startLat;
    const startLong = 0;
    const endLong = 2 * Math.PI;
    const longRange = endLong - startLong;
    const numVertices = (nlat + 1) * (nlong + 1);
    const radius = (n1, n22, n3, u3, v2) => props.radius || 1;
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
    const indices = new IndexType(nlat * nlong * 6);
    for (let y3 = 0; y3 <= nlat; y3++) {
      for (let x3 = 0; x3 <= nlong; x3++) {
        const u3 = x3 / nlong;
        const v2 = y3 / nlat;
        const index = x3 + y3 * (nlong + 1);
        const i22 = index * 2;
        const i32 = index * 3;
        const theta = longRange * u3;
        const phi = latRange * v2;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const ux = cosTheta * sinPhi;
        const uy = cosPhi;
        const uz = sinTheta * sinPhi;
        const r3 = radius(ux, uy, uz, u3, v2);
        positions[i32 + 0] = r3 * ux;
        positions[i32 + 1] = r3 * uy;
        positions[i32 + 2] = r3 * uz;
        normals[i32 + 0] = ux;
        normals[i32 + 1] = uy;
        normals[i32 + 2] = uz;
        texCoords[i22 + 0] = u3;
        texCoords[i22 + 1] = 1 - v2;
      }
    }
    const numVertsAround = nlong + 1;
    for (let x3 = 0; x3 < nlong; x3++) {
      for (let y3 = 0; y3 < nlat; y3++) {
        const index = (x3 * nlat + y3) * 6;
        indices[index + 0] = y3 * numVertsAround + x3;
        indices[index + 1] = y3 * numVertsAround + x3 + 1;
        indices[index + 2] = (y3 + 1) * numVertsAround + x3;
        indices[index + 3] = (y3 + 1) * numVertsAround + x3;
        indices[index + 4] = y3 * numVertsAround + x3 + 1;
        indices[index + 5] = (y3 + 1) * numVertsAround + x3 + 1;
      }
    }
    return {
      indices: { size: 1, value: indices },
      attributes: {
        POSITION: { size: 3, value: positions },
        NORMAL: { size: 3, value: normals },
        TEXCOORD_0: { size: 2, value: texCoords }
      }
    };
  }

  // ../core/src/passes/screen-pass-uniforms.ts
  var uniformBlock4 = `uniform screenUniforms {
  vec2 texSize;
} screen;
`;
  var screenUniforms = {
    name: "screen",
    fs: uniformBlock4,
    uniformTypes: {
      texSize: "vec2<f32>"
    }
  };

  // ../core/src/passes/screen-pass.ts
  var ScreenPass = class extends Pass {
    constructor(device, props) {
      super(device, props);
      const { module, fs: fs11, id } = props;
      const parameters2 = { depthWriteEnabled: false, depthCompare: "always" };
      this.model = new ClipSpace(device, { id, fs: fs11, modules: [module, screenUniforms], parameters: parameters2 });
    }
    render(params) {
      this._renderPass(this.device, params);
    }
    delete() {
      this.model.destroy();
      this.model = null;
    }
    // Private methods
    /**
     * Renders the pass.
     * This is an abstract method that should be overridden.
     * @param inputBuffer - Frame buffer that contains the result of the previous pass
     * @param outputBuffer - Frame buffer that serves as the output render target
     */
    _renderPass(device, options) {
      const { clearCanvas, inputBuffer, outputBuffer } = options;
      const texSize = [inputBuffer.width, inputBuffer.height];
      const screenProps = {
        texSrc: inputBuffer.colorAttachments[0],
        texSize
      };
      this.model.shaderInputs.setProps({
        screen: screenProps,
        ...options.moduleProps
      });
      const renderPass = this.device.beginRenderPass({
        framebuffer: outputBuffer,
        parameters: { viewport: [0, 0, ...texSize] },
        clearColor: clearCanvas ? [0, 0, 0, 0] : false,
        clearDepth: 1,
        clearStencil: false
      });
      this.model.draw(renderPass);
      renderPass.end();
    }
  };

  // ../core/src/effects/post-process-effect.ts
  var PostProcessEffect = class {
    constructor(module, props) {
      this.id = `${module.name}-pass`;
      this.props = props;
      initializeShaderModule(module);
      this.module = module;
    }
    setup({ device }) {
      this.passes = createPasses(device, this.module, this.id);
    }
    setProps(props) {
      this.props = props;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    preRender() {
    }
    postRender(params) {
      const passes = this.passes;
      const { target: target2 } = params;
      let inputBuffer = params.inputBuffer;
      let outputBuffer = params.swapBuffer;
      for (let index = 0; index < passes.length; index++) {
        const isLastPass = index === passes.length - 1;
        const renderToTarget = target2 !== void 0 && isLastPass;
        if (renderToTarget) {
          outputBuffer = target2;
        }
        const clearCanvas = !renderToTarget || Boolean(params.clearCanvas);
        const moduleProps = {};
        const uniforms = this.module.passes[index].uniforms;
        moduleProps[this.module.name] = { ...this.props, ...uniforms };
        passes[index].render({ clearCanvas, inputBuffer, outputBuffer, moduleProps });
        const switchBuffer = outputBuffer;
        outputBuffer = inputBuffer;
        inputBuffer = switchBuffer;
      }
      return inputBuffer;
    }
    cleanup() {
      if (this.passes) {
        for (const pass of this.passes) {
          pass.delete();
        }
        this.passes = void 0;
      }
    }
  };
  function createPasses(device, module, id) {
    return module.passes.map((pass, index) => {
      const fs11 = getFragmentShaderForRenderPass(module, pass);
      const idn = `${id}-${index}`;
      return new ScreenPass(device, { id: idn, module, fs: fs11 });
    });
  }
  var FS_TEMPLATE_INPUTS = `#version 300 es
uniform sampler2D texSrc;

in vec2 position;
in vec2 coordinate;
in vec2 uv;

out vec4 fragColor;
`;
  var FILTER_FS_TEMPLATE = (func) => `${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = texture(texSrc, coordinate);
  fragColor = ${func}(fragColor, screen.texSize, coordinate);
}
`;
  var SAMPLER_FS_TEMPLATE = (func) => `${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = ${func}(texSrc, screen.texSize, coordinate);
}
`;
  function getFragmentShaderForRenderPass(module, pass) {
    if (pass.filter) {
      const func = typeof pass.filter === "string" ? pass.filter : `${module.name}_filterColor_ext`;
      return FILTER_FS_TEMPLATE(func);
    }
    if (pass.sampler) {
      const func = typeof pass.sampler === "string" ? pass.sampler : `${module.name}_sampleColor`;
      return SAMPLER_FS_TEMPLATE(func);
    }
    return "";
  }

  // ../core/src/passes/pick-layers-pass.ts
  var PICKING_BLENDING = {
    blendColorOperation: "add",
    blendColorSrcFactor: "one",
    blendColorDstFactor: "zero",
    blendAlphaOperation: "add",
    blendAlphaSrcFactor: "constant-alpha",
    blendAlphaDstFactor: "zero"
  };
  var PickLayersPass = class extends LayersPass {
    constructor() {
      super(...arguments);
      this._colorEncoderState = null;
    }
    render(props) {
      if ("pickingFBO" in props) {
        return this._drawPickingBuffer(props);
      }
      return super.render(props);
    }
    // Private
    // Draws list of layers and viewports into the picking buffer
    // Note: does not sample the buffer, that has to be done by the caller
    _drawPickingBuffer({
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect: { x: x3, y: y3, width, height },
      cullRect,
      effects,
      pass = "picking",
      pickZ,
      shaderModuleProps
    }) {
      this.pickZ = pickZ;
      const colorEncoderState = this._resetColorEncoder(pickZ);
      const scissorRect = [x3, y3, width, height];
      const renderStatus = super.render({
        target: pickingFBO,
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        cullRect,
        effects: effects?.filter((e3) => e3.useInPicking),
        pass,
        isPicking: true,
        shaderModuleProps,
        clearColor: [0, 0, 0, 0],
        colorMask: 15,
        scissorRect
      });
      this._colorEncoderState = null;
      const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
      return { decodePickingColor, stats: renderStatus };
    }
    shouldDrawLayer(layer) {
      const { pickable, operation } = layer.props;
      return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
    }
    getShaderModuleProps(layer, effects, otherShaderModuleProps) {
      return {
        picking: {
          isActive: 1,
          isAttribute: this.pickZ
        },
        lighting: { enabled: false }
      };
    }
    getLayerParameters(layer, layerIndex, viewport) {
      const pickParameters = {
        ...layer.props.parameters
      };
      const { pickable, operation } = layer.props;
      if (!this._colorEncoderState || operation.includes("terrain")) {
        pickParameters.blend = false;
      } else if (pickable && operation.includes("draw")) {
        Object.assign(pickParameters, PICKING_BLENDING);
        pickParameters.blend = true;
        pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
      }
      return pickParameters;
    }
    _resetColorEncoder(pickZ) {
      this._colorEncoderState = pickZ ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      };
      return this._colorEncoderState;
    }
  };
  function encodeColor(encoded, layer, viewport) {
    const { byLayer, byAlpha } = encoded;
    let a3;
    let entry = byLayer.get(layer);
    if (entry) {
      entry.viewports.push(viewport);
      a3 = entry.a;
    } else {
      a3 = byLayer.size + 1;
      if (a3 <= 255) {
        entry = { a: a3, layer, viewports: [viewport] };
        byLayer.set(layer, entry);
        byAlpha[a3] = entry;
      } else {
        log_default.warn("Too many pickable layers, only picking the first 255")();
        a3 = 0;
      }
    }
    return [0, 0, 0, a3 / 255];
  }
  function decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
      pickedLayer: entry.layer,
      pickedViewports: entry.viewports,
      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
  }

  // ../core/src/lifecycle/constants.ts
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var COMPONENT_SYMBOL = Symbol.for("component");
  var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
  var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
  var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
  var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
  var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

  // ../core/src/utils/flatten.ts
  function flatten(array, filter = () => true) {
    if (!Array.isArray(array)) {
      return filter(array) ? [array] : [];
    }
    return flattenArray(array, filter, []);
  }
  function flattenArray(array, filter, result) {
    let index = -1;
    while (++index < array.length) {
      const value = array[index];
      if (Array.isArray(value)) {
        flattenArray(value, filter, result);
      } else if (filter(value)) {
        result.push(value);
      }
    }
    return result;
  }
  function fillArray({ target: target2, source: source3, start = 0, count: count3 = 1 }) {
    const length16 = source3.length;
    const total = count3 * length16;
    let copied = 0;
    for (let i5 = start; copied < length16; copied++) {
      target2[i5++] = source3[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target2.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target2.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target2;
  }

  // ../core/src/lib/resource/resource.ts
  var Resource2 = class {
    constructor(id, data, context) {
      this._loadCount = 0;
      this._subscribers = /* @__PURE__ */ new Set();
      this.id = id;
      this.context = context;
      this.setData(data);
    }
    // consumer: {onChange: Function}
    subscribe(consumer) {
      this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
      this._subscribers.delete(consumer);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(data, forceUpdate) {
      if (data === this._data && !forceUpdate) {
        return;
      }
      this._data = data;
      const loadCount = ++this._loadCount;
      let loader = data;
      if (typeof data === "string") {
        loader = load(data);
      }
      if (loader instanceof Promise) {
        this.isLoaded = false;
        this._loader = loader.then((result) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = void 0;
            this._content = result;
          }
        }).catch((error) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = error || true;
          }
        });
      } else {
        this.isLoaded = true;
        this._error = void 0;
        this._content = data;
      }
      for (const subscriber of this._subscribers) {
        subscriber.onChange(this.getData());
      }
    }
  };

  // ../core/src/lib/resource/resource-manager.ts
  var ResourceManager = class {
    constructor(props) {
      this.protocol = props.protocol || "resource://";
      this._context = {
        device: props.device,
        // @ts-expect-error
        gl: props.device?.gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    contains(resourceId) {
      if (resourceId.startsWith(this.protocol)) {
        return true;
      }
      return resourceId in this._resources;
    }
    add({
      resourceId,
      data,
      forceUpdate = false,
      persistent = true
    }) {
      let res = this._resources[resourceId];
      if (res) {
        res.setData(data, forceUpdate);
      } else {
        res = new Resource2(resourceId, data, this._context);
        this._resources[resourceId] = res;
      }
      res.persistent = persistent;
    }
    remove(resourceId) {
      const res = this._resources[resourceId];
      if (res) {
        res.delete();
        delete this._resources[resourceId];
      }
    }
    unsubscribe({ consumerId }) {
      const consumer = this._consumers[consumerId];
      if (consumer) {
        for (const requestId in consumer) {
          const request = consumer[requestId];
          const resource = this._resources[request.resourceId];
          if (resource) {
            resource.unsubscribe(request);
          }
        }
        delete this._consumers[consumerId];
        this.prune();
      }
    }
    subscribe({
      resourceId,
      onChange,
      consumerId,
      requestId = "default"
    }) {
      const { _resources: resources, protocol } = this;
      if (resourceId.startsWith(protocol)) {
        resourceId = resourceId.replace(protocol, "");
        if (!resources[resourceId]) {
          this.add({ resourceId, data: null, persistent: false });
        }
      }
      const res = resources[resourceId];
      this._track(consumerId, requestId, res, onChange);
      if (res) {
        return res.getData();
      }
      return void 0;
    }
    prune() {
      if (!this._pruneRequest) {
        this._pruneRequest = setTimeout(() => this._prune(), 0);
      }
    }
    finalize() {
      for (const key in this._resources) {
        this._resources[key].delete();
      }
    }
    _track(consumerId, requestId, resource, onChange) {
      const consumers = this._consumers;
      const consumer = consumers[consumerId] = consumers[consumerId] || {};
      let request = consumer[requestId];
      const oldResource = request && request.resourceId && this._resources[request.resourceId];
      if (oldResource) {
        oldResource.unsubscribe(request);
        this.prune();
      }
      if (resource) {
        if (request) {
          request.onChange = onChange;
          request.resourceId = resource.id;
        } else {
          request = {
            onChange,
            resourceId: resource.id
          };
        }
        consumer[requestId] = request;
        resource.subscribe(request);
      }
    }
    _prune() {
      this._pruneRequest = null;
      for (const key of Object.keys(this._resources)) {
        const res = this._resources[key];
        if (!res.persistent && !res.inUse()) {
          res.delete();
          delete this._resources[key];
        }
      }
    }
  };

  // ../core/src/lib/layer-manager.ts
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var LayerManager = class {
    /**
     * @param device
     * @param param1
     */
    // eslint-disable-next-line
    constructor(device, props) {
      this._lastRenderedLayers = [];
      this._needsRedraw = false;
      this._needsUpdate = false;
      this._nextLayers = null;
      this._debug = false;
      // This flag is separate from _needsUpdate because it can be set during an update and should trigger another full update
      this._defaultShaderModulesChanged = false;
      //
      // INTERNAL METHODS
      //
      /** Make a viewport "current" in layer context, updating viewportChanged flags */
      this.activateViewport = (viewport) => {
        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
        if (viewport) {
          this.context.viewport = viewport;
        }
      };
      const { deck, stats: stats2, viewport, timeline } = props || {};
      this.layers = [];
      this.resourceManager = new ResourceManager({ device, protocol: "deck://" });
      this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        device,
        // @ts-expect-error
        gl: device?.gl,
        deck,
        shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || "glsl"),
        defaultShaderModules: [layerUniforms],
        renderPass: void 0,
        stats: stats2 || new Stats({ id: "deck.gl" }),
        // Make sure context.viewport is not empty on the first layer initialization
        viewport: viewport || new Viewport({ id: "DEFAULT-INITIAL-VIEWPORT" }),
        // Current viewport, exposed to layers for project* function
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager,
        onError: void 0
      };
      Object.seal(this);
    }
    /** Method to call when the layer manager is not needed anymore. */
    finalize() {
      this.resourceManager.finalize();
      for (const layer of this.layers) {
        this._finalizeLayer(layer);
      }
    }
    /** Check if a redraw is needed */
    needsRedraw(opts = { clearRedrawFlags: false }) {
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      for (const layer of this.layers) {
        const layerNeedsRedraw = layer.getNeedsRedraw(opts);
        redraw = redraw || layerNeedsRedraw;
      }
      return redraw;
    }
    /** Check if a deep update of all layers is needed */
    needsUpdate() {
      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
        return "layers changed";
      }
      if (this._defaultShaderModulesChanged) {
        return "shader modules changed";
      }
      return this._needsUpdate;
    }
    /** Layers will be redrawn (in next animation frame) */
    setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
    /** Layers will be updated deeply (in next animation frame)
      Potentially regenerating attributes and sub layers */
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
    /** Gets a list of currently rendered layers. Optionally filter by id. */
    getLayers({ layerIds } = {}) {
      return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    /** Set props needed for layer rendering and picking. */
    setProps(props) {
      if ("debug" in props) {
        this._debug = props.debug;
      }
      if ("userData" in props) {
        this.context.userData = props.userData;
      }
      if ("layers" in props) {
        this._nextLayers = props.layers;
      }
      if ("onError" in props) {
        this.context.onError = props.onError;
      }
    }
    /** Supply a new layer list, initiating sublayer generation and layer matching */
    setLayers(newLayers, reason) {
      debug(TRACE_SET_LAYERS, this, reason, newLayers);
      this._lastRenderedLayers = newLayers;
      const flatLayers = flatten(newLayers, Boolean);
      for (const layer of flatLayers) {
        layer.context = this.context;
      }
      this._updateLayers(this.layers, flatLayers);
    }
    /** Update layers from last cycle if `setNeedsUpdate()` has been called */
    updateLayers() {
      const reason = this.needsUpdate();
      if (reason) {
        this.setNeedsRedraw(`updating layers: ${reason}`);
        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
      }
      this._nextLayers = null;
    }
    /** Register a default shader module */
    addDefaultShaderModule(module) {
      const { defaultShaderModules } = this.context;
      if (!defaultShaderModules.find((m) => m.name === module.name)) {
        defaultShaderModules.push(module);
        this._defaultShaderModulesChanged = true;
      }
    }
    /** Deregister a default shader module */
    removeDefaultShaderModule(module) {
      const { defaultShaderModules } = this.context;
      const i5 = defaultShaderModules.findIndex((m) => m.name === module.name);
      if (i5 >= 0) {
        defaultShaderModules.splice(i5, 1);
        this._defaultShaderModulesChanged = true;
      }
    }
    _handleError(stage, error, layer) {
      layer.raiseError(error, `${stage} of ${layer}`);
    }
    // TODO - mark layers with exceptions as bad and remove from rendering cycle?
    /** Match all layers, checking for caught errors
      to avoid having an exception in one layer disrupt other layers */
    _updateLayers(oldLayers, newLayers) {
      const oldLayerMap = {};
      for (const oldLayer of oldLayers) {
        if (oldLayerMap[oldLayer.id]) {
          log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
        } else {
          oldLayerMap[oldLayer.id] = oldLayer;
        }
      }
      if (this._defaultShaderModulesChanged) {
        for (const layer of oldLayers) {
          layer.setNeedsUpdate();
          layer.setChangeFlags({ extensionsChanged: true });
        }
        this._defaultShaderModulesChanged = false;
      }
      const generatedLayers = [];
      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
      this._finalizeOldLayers(oldLayerMap);
      let needsUpdate = false;
      for (const layer of generatedLayers) {
        if (layer.hasUniformTransition()) {
          needsUpdate = `Uniform transition in ${layer}`;
          break;
        }
      }
      this._needsUpdate = needsUpdate;
      this.layers = generatedLayers;
    }
    /* eslint-disable complexity,max-statements */
    // Note: adds generated layers to `generatedLayers` array parameter
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
      for (const newLayer of newLayers) {
        newLayer.context = this.context;
        const oldLayer = oldLayerMap[newLayer.id];
        if (oldLayer === null) {
          log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
        }
        oldLayerMap[newLayer.id] = null;
        let sublayers = null;
        try {
          if (this._debug && oldLayer !== newLayer) {
            newLayer.validateProps();
          }
          if (!oldLayer) {
            this._initializeLayer(newLayer);
          } else {
            this._transferLayerState(oldLayer, newLayer);
            this._updateLayer(newLayer);
          }
          generatedLayers.push(newLayer);
          sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
        } catch (err) {
          this._handleError("matching", err, newLayer);
        }
        if (sublayers) {
          this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
      }
    }
    /* eslint-enable complexity,max-statements */
    // Finalize any old layers that were not matched
    _finalizeOldLayers(oldLayerMap) {
      for (const layerId in oldLayerMap) {
        const layer = oldLayerMap[layerId];
        if (layer) {
          this._finalizeLayer(layer);
        }
      }
    }
    // / EXCEPTION SAFE LAYER ACCESS
    /** Safely initializes a single layer, calling layer methods */
    _initializeLayer(layer) {
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        this._handleError("initialization", err, layer);
      }
    }
    /** Transfer state from one layer to a newer version */
    _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      if (newLayer !== oldLayer) {
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      }
    }
    /** Safely updates a single layer, cleaning all flags */
    _updateLayer(layer) {
      try {
        layer._update();
      } catch (err) {
        this._handleError("update", err, layer);
      }
    }
    /** Safely finalizes a single layer, removing all resources */
    _finalizeLayer(layer) {
      this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      try {
        layer._finalize();
        layer.lifecycle = LIFECYCLE.FINALIZED;
      } catch (err) {
        this._handleError("finalization", err, layer);
      }
    }
  };

  // ../core/src/utils/deep-equal.ts
  function deepEqual2(a3, b2, depth) {
    if (a3 === b2) {
      return true;
    }
    if (!depth || !a3 || !b2) {
      return false;
    }
    if (Array.isArray(a3)) {
      if (!Array.isArray(b2) || a3.length !== b2.length) {
        return false;
      }
      for (let i5 = 0; i5 < a3.length; i5++) {
        if (!deepEqual2(a3[i5], b2[i5], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b2)) {
      return false;
    }
    if (typeof a3 === "object" && typeof b2 === "object") {
      const aKeys = Object.keys(a3);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b2.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual2(a3[key], b2[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../core/src/lib/view-manager.ts
  var ViewManager = class {
    constructor(props) {
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "First render";
      this._needsUpdate = "Initialize";
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    /** Remove all resources and event listeners */
    finalize() {
      for (const key in this.controllers) {
        const controller = this.controllers[key];
        if (controller) {
          controller.finalize();
        }
      }
      this.controllers = {};
    }
    /** Check if a redraw is needed */
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    /** Checks each viewport for transition updates */
    updateViewStates() {
      for (const viewId in this.controllers) {
        const controller = this.controllers[viewId];
        if (controller) {
          controller.updateTransition();
        }
      }
    }
    /** Get a set of viewports for a given width and height
     * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
     * @param rect (object, optional) - filter the viewports
     *   + not provided - return all viewports
     *   + {x, y} - only return viewports that contain this pixel
     *   + {x, y, width, height} - only return viewports that overlap with this rectangle
     */
    getViewports(rect) {
      if (rect) {
        return this._viewports.filter((viewport) => viewport.containsPixel(rect));
      }
      return this._viewports;
    }
    /** Get a map of all views */
    getViews() {
      const viewMap = {};
      this.views.forEach((view) => {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
    /** Resolves a viewId string to a View */
    getView(viewId) {
      return this.views.find((view) => view.id === viewId);
    }
    /** Returns the viewState for a specific viewId. Matches the viewState by
      1. view.viewStateId
      2. view.id
      3. root viewState
      then applies the view's filter if any */
    getViewState(viewOrViewId) {
      const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
      const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether origin is top left
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */
    unproject(xyz, opts) {
      const viewports = this.getViewports();
      const pixel = { x: xyz[0], y: xyz[1] };
      for (let i5 = viewports.length - 1; i5 >= 0; --i5) {
        const viewport = viewports[i5];
        if (viewport.containsPixel(pixel)) {
          const p3 = xyz.slice();
          p3[0] -= viewport.x;
          p3[1] -= viewport.y;
          return viewport.unproject(p3, opts);
        }
      }
      return null;
    }
    /** Update the manager with new Deck props */
    setProps(props) {
      if (props.views) {
        this._setViews(props.views);
      }
      if (props.viewState) {
        this._setViewState(props.viewState);
      }
      if ("width" in props || "height" in props) {
        this._setSize(props.width, props.height);
      }
      if (!this._isUpdating) {
        this._update();
      }
    }
    //
    // PRIVATE METHODS
    //
    _update() {
      this._isUpdating = true;
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      this._isUpdating = false;
    }
    _setSize(width, height) {
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate("Size changed");
      }
    }
    // Update the view descriptor list and set change flag if needed
    // Does not actually rebuild the `Viewport`s until `getViewports` is called
    _setViews(views) {
      views = flatten(views, Boolean);
      const viewsChanged = this._diffViews(views, this.views);
      if (viewsChanged) {
        this.setNeedsUpdate("views changed");
      }
      this.views = views;
    }
    _setViewState(viewState) {
      if (viewState) {
        const viewStateChanged = !deepEqual2(viewState, this.viewState, 3);
        if (viewStateChanged) {
          this.setNeedsUpdate("viewState changed");
        }
        this.viewState = viewState;
      } else {
        log_default.warn("missing `viewState` or `initialViewState`")();
      }
    }
    _createController(view, props) {
      const Controller2 = props.type;
      const controller = new Controller2({
        timeline: this.timeline,
        eventManager: this._eventManager,
        // Set an internal callback that calls the prop callback if provided
        onViewStateChange: this._eventCallbacks.onViewStateChange,
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        })
      });
      return controller;
    }
    _updateController(view, viewState, viewport, controller) {
      const controllerProps = view.controller;
      if (controllerProps && viewport) {
        const resolvedProps = {
          ...viewState,
          ...controllerProps,
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        };
        if (!controller || controller.constructor !== controllerProps.type) {
          controller = this._createController(view, resolvedProps);
        }
        if (controller) {
          controller.setProps(resolvedProps);
        }
        return controller;
      }
      return null;
    }
    // Rebuilds viewports from descriptors towards a certain window size
    _rebuildViewports() {
      const { views } = this;
      const oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};
      let invalidateControllers = false;
      for (let i5 = views.length; i5--; ) {
        const view = views[i5];
        const viewState = this.getViewState(view);
        const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });
        let oldController = oldControllers[view.id];
        const hasController = Boolean(view.controller);
        if (hasController && !oldController) {
          invalidateControllers = true;
        }
        if ((invalidateControllers || !hasController) && oldController) {
          oldController.finalize();
          oldController = null;
        }
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
        if (viewport) {
          this._viewports.unshift(viewport);
        }
      }
      for (const id in oldControllers) {
        const oldController = oldControllers[id];
        if (oldController && !this.controllers[id]) {
          oldController.finalize();
        }
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {};
      this._viewports.forEach((viewport) => {
        if (viewport.id) {
          this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        }
      });
    }
    // Check if viewport array has changed, returns true if any change
    // Note that descriptors can be the same
    _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }
      return newViews.some((_2, i5) => !newViews[i5].equals(oldViews[i5]));
    }
  };

  // ../core/src/utils/positions.ts
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value) {
    switch (typeof value) {
      case "number":
        return {
          position: value,
          relative: false
        };
      case "string":
        const match = PERCENT_OR_PIXELS_REGEX.exec(value);
        if (match && match.length >= 3) {
          const relative = match[2] === "%";
          const position = parseFloat(match[1]);
          return {
            position: relative ? position / 100 : position,
            relative
          };
        }
      default:
        throw new Error(`Could not parse position string ${value}`);
    }
  }
  function getPosition(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
  }

  // ../core/src/views/view.ts
  var View = class {
    constructor(props) {
      const { id, x: x3 = 0, y: y3 = 0, width = "100%", height = "100%", padding = null } = props;
      this.id = id || this.constructor.displayName || "view";
      this.props = { ...props, id: this.id };
      this._x = parsePosition(x3);
      this._y = parsePosition(y3);
      this._width = parsePosition(width);
      this._height = parsePosition(height);
      this._padding = padding && {
        left: parsePosition(padding.left || 0),
        right: parsePosition(padding.right || 0),
        top: parsePosition(padding.top || 0),
        bottom: parsePosition(padding.bottom || 0)
      };
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    equals(view) {
      if (this === view) {
        return true;
      }
      return this.constructor === view.constructor && deepEqual2(this.props, view.props, 2);
    }
    /** Make viewport from canvas dimensions and view state */
    makeViewport({ width, height, viewState }) {
      viewState = this.filterViewState(viewState);
      const viewportDimensions = this.getDimensions({ width, height });
      if (!viewportDimensions.height || !viewportDimensions.width) {
        return null;
      }
      const ViewportType = this.getViewportType(viewState);
      return new ViewportType({ ...viewState, ...this.props, ...viewportDimensions });
    }
    getViewStateId() {
      const { viewState } = this.props;
      if (typeof viewState === "string") {
        return viewState;
      }
      return viewState?.id || this.id;
    }
    // Allows view to override (or completely define) viewState
    filterViewState(viewState) {
      if (this.props.viewState && typeof this.props.viewState === "object") {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }
        const newViewState = { ...viewState };
        for (const key in this.props.viewState) {
          if (key !== "id") {
            newViewState[key] = this.props.viewState[key];
          }
        }
        return newViewState;
      }
      return viewState;
    }
    /** Resolve the dimensions of the view from overall canvas dimensions */
    getDimensions({ width, height }) {
      const dimensions = {
        x: getPosition(this._x, width),
        y: getPosition(this._y, height),
        width: getPosition(this._width, width),
        height: getPosition(this._height, height)
      };
      if (this._padding) {
        dimensions.padding = {
          left: getPosition(this._padding.left, width),
          top: getPosition(this._padding.top, height),
          right: getPosition(this._padding.right, width),
          bottom: getPosition(this._padding.bottom, height)
        };
      }
      return dimensions;
    }
    // Used by sub classes to resolve controller props
    get controller() {
      const opts = this.props.controller;
      if (!opts) {
        return null;
      }
      if (opts === true) {
        return { type: this.ControllerType };
      }
      if (typeof opts === "function") {
        return { type: opts };
      }
      return { type: this.ControllerType, ...opts };
    }
  };

  // ../core/src/transitions/transition.ts
  var Transition = class {
    /**
     * @params timeline {Timeline}
     */
    constructor(timeline) {
      this._inProgress = false;
      this._handle = null;
      this.time = 0;
      // @ts-expect-error
      this.settings = {
        duration: 0
      };
      this._timeline = timeline;
    }
    /* Public API */
    get inProgress() {
      return this._inProgress;
    }
    /**
     * (re)start this transition.
     * @params props {object} - optional overriding props. see constructor
     */
    start(settings) {
      this.cancel();
      this.settings = settings;
      this._inProgress = true;
      this.settings.onStart?.(this);
    }
    /**
     * end this transition if it is in progress.
     */
    end() {
      if (this._inProgress) {
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
        this.settings.onEnd?.(this);
      }
    }
    /**
     * cancel this transition if it is in progress.
     */
    cancel() {
      if (this._inProgress) {
        this.settings.onInterrupt?.(this);
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
      }
    }
    /**
     * update this transition. Returns `true` if updated.
     */
    update() {
      if (!this._inProgress) {
        return false;
      }
      if (this._handle === null) {
        const { _timeline: timeline, settings } = this;
        this._handle = timeline.addChannel({
          delay: timeline.getTime(),
          duration: settings.duration
        });
      }
      this.time = this._timeline.getTime(this._handle);
      this._onUpdate();
      this.settings.onUpdate?.(this);
      if (this._timeline.isFinished(this._handle)) {
        this.end();
      }
      return true;
    }
    /* Private API */
    _onUpdate() {
    }
  };

  // ../core/src/controllers/transition-manager.ts
  var noop2 = () => {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_EASING = (t3) => t3;
  var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
  var TransitionManager = class {
    constructor(opts) {
      this._onTransitionUpdate = (transition) => {
        const {
          time,
          settings: { interpolator, startProps, endProps, duration, easing }
        } = transition;
        const t3 = easing(time / duration);
        const viewport = interpolator.interpolateProps(startProps, endProps, t3);
        this.propsInTransition = this.getControllerState({
          ...this.props,
          ...viewport
        }).getViewportProps();
        this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      };
      this.getControllerState = opts.getControllerState;
      this.propsInTransition = null;
      this.transition = new Transition(opts.timeline);
      this.onViewStateChange = opts.onViewStateChange || noop2;
      this.onStateChange = opts.onStateChange || noop2;
    }
    finalize() {
      this.transition.cancel();
    }
    // Returns current transitioned viewport.
    getViewportInTransition() {
      return this.propsInTransition;
    }
    // Process the vewiport change, either ignore or trigger a new transition.
    // Return true if a new transition is triggered, false otherwise.
    processViewStateChange(nextProps) {
      let transitionTriggered = false;
      const currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        let startProps = currentProps;
        if (this.transition.inProgress) {
          const { interruption, endProps } = this.transition.settings;
          startProps = {
            ...currentProps,
            ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
          };
        }
        this._triggerTransition(startProps, nextProps);
        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }
      return transitionTriggered;
    }
    updateTransition() {
      this.transition.update();
    }
    // Helper methods
    _isTransitionEnabled(props) {
      const { transitionDuration, transitionInterpolator } = props;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress && this.propsInTransition) {
        return this.transition.settings.interpolator.arePropsEqual(
          props,
          this.propsInTransition
        );
      }
      return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        const transitionSettings = this.transition.settings;
        return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.
        this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(
          currentProps,
          nextProps
        );
      }
      return true;
    }
    _triggerTransition(startProps, endProps) {
      const startViewstate = this.getControllerState(startProps);
      const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
      const transitionInterpolator = endProps.transitionInterpolator;
      const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration === 0) {
        return;
      }
      const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      const transitionSettings = {
        duration,
        easing: endProps.transitionEasing || DEFAULT_EASING,
        interpolator: transitionInterpolator,
        interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      };
      this.transition.start(transitionSettings);
      this.onStateChange({ inTransition: true });
      this.updateTransition();
    }
    _onTransitionEnd(callback) {
      return (transition) => {
        this.propsInTransition = null;
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
        callback?.(transition);
      };
    }
  };

  // ../core/src/utils/assert.ts
  function assert8(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "deck.gl: assertion failed.");
    }
  }

  // ../core/src/transitions/transition-interpolator.ts
  var TransitionInterpolator = class {
    /**
     * @param opts {array|object}
     * @param opts.compare {array} - prop names used in equality check
     * @param opts.extract {array} - prop names needed for interpolation
     * @param opts.required {array} - prop names that must be supplied
     * alternatively, supply one list of prop names as `opts` if all of the above are the same.
     */
    constructor(opts) {
      const { compare: compare2, extract, required } = opts;
      this._propsToCompare = compare2;
      this._propsToExtract = extract || compare2;
      this._requiredProps = required;
    }
    /**
     * Checks if two sets of props need transition in between
     * @param currentProps {object} - a list of viewport props
     * @param nextProps {object} - a list of viewport props
     * @returns {bool} - true if two props are equivalent
     */
    arePropsEqual(currentProps, nextProps) {
      for (const key of this._propsToCompare) {
        if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Called before transition starts to validate/pre-process start and end props
     * @param startProps {object} - a list of starting viewport props
     * @param endProps {object} - a list of target viewport props
     * @returns {Object} {start, end} - start and end props to be passed
     *   to `interpolateProps`
     */
    initializeProps(startProps, endProps) {
      const startViewStateProps = {};
      const endViewStateProps = {};
      for (const key of this._propsToExtract) {
        if (key in startProps || key in endProps) {
          startViewStateProps[key] = startProps[key];
          endViewStateProps[key] = endProps[key];
        }
      }
      this._checkRequiredProps(startViewStateProps);
      this._checkRequiredProps(endViewStateProps);
      return { start: startViewStateProps, end: endViewStateProps };
    }
    /**
     * Returns transition duration
     * @param startProps {object} - a list of starting viewport props
     * @param endProps {object} - a list of target viewport props
     * @returns {Number} - transition duration in milliseconds
     */
    getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }
      this._requiredProps.forEach((propName) => {
        const value = props[propName];
        assert8(
          Number.isFinite(value) || Array.isArray(value),
          `${propName} is required for transition`
        );
      });
    }
  };

  // ../core/src/transitions/linear-interpolator.ts
  var DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = class extends TransitionInterpolator {
    /**
     * @param {Object} opts
     * @param {Array} opts.transitionProps - list of props to apply linear transition to.
     * @param {Array} opts.around - a screen point to zoom/rotate around.
     * @param {Function} opts.makeViewport - construct a viewport instance with given props.
     */
    constructor(opts = {}) {
      const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      const normalizedOpts = Array.isArray(opts) ? {} : opts;
      normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
        compare: transitionProps,
        required: transitionProps
      } : transitionProps || {
        compare: DEFAULT_PROPS3,
        required: DEFAULT_REQUIRED_PROPS
      };
      super(normalizedOpts.transitionProps);
      this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
      const result = super.initializeProps(startProps, endProps);
      const { makeViewport: makeViewport2, around } = this.opts;
      if (makeViewport2 && around) {
        const startViewport = makeViewport2(startProps);
        const endViewport = makeViewport2(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
      return result;
    }
    interpolateProps(startProps, endProps, t3) {
      const propsInTransition = {};
      for (const key of this._propsToExtract) {
        propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t3);
      }
      if (endProps.aroundPosition && this.opts.makeViewport) {
        const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });
        Object.assign(
          propsInTransition,
          viewport.panByPosition(
            endProps.aroundPosition,
            // anchor point in current screen coordinates
            lerp(startProps.around, endProps.around, t3)
          )
        );
      }
      return propsInTransition;
    }
  };

  // ../core/src/controllers/controller.ts
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = (t3) => 1 - (1 - t3) * (1 - t3);
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
    DOUBLE_CLICK: ["dblclick"],
    KEYBOARD: ["keydown"]
  };
  var pinchEventWorkaround = {};
  var Controller = class {
    constructor(opts) {
      this.state = {};
      this._events = {};
      this._interactionState = {
        isDragging: false
      };
      this._customEvents = [];
      this._eventStartBlocked = null;
      this._panMove = false;
      this.invertPan = false;
      this.dragMode = "rotate";
      this.inertia = 0;
      this.scrollZoom = true;
      this.dragPan = true;
      this.dragRotate = true;
      this.doubleClickZoom = true;
      this.touchZoom = true;
      this.touchRotate = false;
      this.keyboard = true;
      this.transitionManager = new TransitionManager({
        ...opts,
        getControllerState: (props) => new this.ControllerState(props),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      });
      this.handleEvent = this.handleEvent.bind(this);
      this.eventManager = opts.eventManager;
      this.onViewStateChange = opts.onViewStateChange || (() => {
      });
      this.onStateChange = opts.onStateChange || (() => {
      });
      this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
      this.toggleEvents(this._customEvents, false);
      this.toggleEvents(customEvents, true);
      this._customEvents = customEvents;
      if (this.props) {
        this.setProps(this.props);
      }
    }
    finalize() {
      for (const eventName in this._events) {
        if (this._events[eventName]) {
          this.eventManager?.off(eventName, this.handleEvent);
        }
      }
      this.transitionManager.finalize();
    }
    /**
     * Callback for events
     */
    handleEvent(event) {
      this._controllerState = void 0;
      const eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "multipanstart":
          return eventStartBlocked ? false : this._onMultiPanStart(event);
        case "multipanmove":
          return this._onMultiPan(event);
        case "multipanend":
          return this._onMultiPanEnd(event);
        case "dblclick":
          return this._onDoubleClick(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object
    get controllerState() {
      this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      });
      return this._controllerState;
    }
    getCenter(event) {
      const { x: x3, y: y3 } = this.props;
      const { offsetCenter } = event;
      return [offsetCenter.x - x3, offsetCenter.y - y3];
    }
    isPointInBounds(pos, event) {
      const { width, height } = this.props;
      if (event && event.handled) {
        return false;
      }
      const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
      if (inside && event) {
        event.stopPropagation();
      }
      return inside;
    }
    isFunctionKeyPressed(event) {
      const { srcEvent } = event;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
    // This triggers a brief `pan` event.
    // Calling this method will temporarily disable *start events to avoid conflicting transitions.
    blockEvents(timeout) {
      const timer = setTimeout(() => {
        if (this._eventStartBlocked === timer) {
          this._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
    /**
     * Extract interactivity options
     */
    setProps(props) {
      if (props.dragMode) {
        this.dragMode = props.dragMode;
      }
      this.props = props;
      if (!("transitionInterpolator" in props)) {
        props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
      }
      this.transitionManager.processViewStateChange(props);
      const { inertia } = props;
      this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
      const {
        scrollZoom = true,
        dragPan = true,
        dragRotate = true,
        doubleClickZoom = true,
        touchZoom = true,
        touchRotate = false,
        keyboard = true
      } = props;
      const isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.MULTI_PAN, isInteractive && touchRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_CLICK, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
      if (this.eventManager) {
        eventNames.forEach((eventName) => {
          if (this._events[eventName] !== enabled) {
            this._events[eventName] = enabled;
            if (enabled) {
              this.eventManager.on(eventName, this.handleEvent);
            } else {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
        });
      }
    }
    // Private Methods
    /* Callback util */
    // formats map state and invokes callback function
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
      const viewState = { ...newControllerState.getViewportProps(), ...extraProps };
      const changed = this.controllerState !== newControllerState;
      this.state = newControllerState.getState();
      this._setInteractionState(interactionState);
      if (changed) {
        const oldViewState = this.controllerState && this.controllerState.getViewportProps();
        if (this.onViewStateChange) {
          this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });
        }
      }
    }
    _onTransition(params) {
      this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });
    }
    _setInteractionState(newStates) {
      Object.assign(this._interactionState, newStates);
      this.onStateChange(this._interactionState);
    }
    /* Event handlers */
    // Default handler for the `panstart` event.
    _onPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
      if (this.invertPan || this.dragMode === "pan") {
        alternateMode = !alternateMode;
      }
      const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
        pos
      });
      this._panMove = alternateMode;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    // Default handler for the `panmove` and `panend` event.
    _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.
    _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.pan({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
    _onPanMoveEnd(event) {
      const { inertia } = this;
      if (this.dragPan && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [
          pos[0] + event.velocityX * inertia / 2,
          pos[1] + event.velocityY * inertia / 2
        ];
        const newControllerState = this.controllerState.pan({ pos: endPos2 }).panEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isPanning: true
          }
        );
      } else {
        const newControllerState = this.controllerState.panEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.
    _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.rotate({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onPanRotateEnd(event) {
      const { inertia } = this;
      if (this.dragRotate && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [
          pos[0] + event.velocityX * inertia / 2,
          pos[1] + event.velocityY * inertia / 2
        ];
        const newControllerState = this.controllerState.rotate({ pos: endPos2 }).rotateEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isRotating: true
          }
        );
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    // Default handler for the `wheel` event.
    _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      event.srcEvent.preventDefault();
      const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
      const { delta } = event;
      let scale22 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale22 !== 0) {
        scale22 = 1 / scale22;
      }
      const newControllerState = this.controllerState.zoom({ pos, scale: scale22 });
      this.updateViewport(
        newControllerState,
        { ...this._getTransitionProps({ around: pos }), transitionDuration: smooth ? 250 : 1 },
        {
          isZooming: true,
          isPanning: true
        }
      );
      return true;
    }
    _onMultiPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.rotateStart({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    _onMultiPan(event) {
      if (!this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      const pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      const newControllerState = this.controllerState.rotate({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onMultiPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const { inertia } = this;
      if (this.touchRotate && inertia && event.velocityY) {
        const pos = this.getCenter(event);
        const endPos2 = [pos[0], pos[1] += event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({ pos: endPos2 });
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isRotating: true
          }
        );
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    // Default handler for the `pinchstart` event.
    _onPinchStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
      pinchEventWorkaround._startPinchRotation = event.rotation;
      pinchEventWorkaround._lastPinchEvent = event;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    // Default handler for the `pinchmove` and `pinchend` events.
    _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      let newControllerState = this.controllerState;
      if (this.touchZoom) {
        const { scale: scale22 } = event;
        const pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({ pos, scale: scale22 });
      }
      if (this.touchRotate) {
        const { rotation } = event;
        newControllerState = newControllerState.rotate({
          deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
        });
      }
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      pinchEventWorkaround._lastPinchEvent = event;
      return true;
    }
    _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const { inertia } = this;
      const { _lastPinchEvent } = pinchEventWorkaround;
      if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
        const pos = this.getCenter(event);
        let newControllerState = this.controllerState.rotateEnd();
        const z2 = Math.log2(event.scale);
        const velocityZ = (z2 - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
        const endScale = Math.pow(2, z2 + velocityZ * inertia / 2);
        newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps({ around: pos }),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: false
          }
        );
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      pinchEventWorkaround._startPinchRotation = null;
      pinchEventWorkaround._lastPinchEvent = null;
      return true;
    }
    // Default handler for the `dblclick` event.
    _onDoubleClick(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const isZoomOut = this.isFunctionKeyPressed(event);
      const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });
      this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
        isZooming: true,
        isPanning: true
      });
      this.blockEvents(100);
      return true;
    }
    // Default handler for the `keydown` event
    _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      const funcKey = this.isFunctionKeyPressed(event);
      const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
      const { controllerState } = this;
      let newControllerState;
      const interactionState = {};
      switch (event.srcEvent.code) {
        case "Minus":
          newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "Equal":
          newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "ArrowLeft":
          if (funcKey) {
            newControllerState = controllerState.rotateLeft(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowRight":
          if (funcKey) {
            newControllerState = controllerState.rotateRight(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowUp":
          if (funcKey) {
            newControllerState = controllerState.rotateUp(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowDown":
          if (funcKey) {
            newControllerState = controllerState.rotateDown(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        default:
          return false;
      }
      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
    _getTransitionProps(opts) {
      const { transition } = this;
      if (!transition || !transition.transitionInterpolator) {
        return NO_TRANSITION_PROPS;
      }
      return opts ? {
        ...transition,
        transitionInterpolator: new LinearInterpolator({
          ...opts,
          ...transition.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : transition;
    }
  };

  // ../core/src/controllers/view-state.ts
  var ViewState = class {
    constructor(props, state) {
      this._viewportProps = this.applyConstraints(props);
      this._state = state;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  };

  // ../core/src/controllers/map-controller.ts
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var MapState = class extends ViewState {
    constructor(options) {
      const {
        /** Mapbox viewport properties */
        /** The width of the viewport */
        width,
        /** The height of the viewport */
        height,
        /** The latitude at the center of the viewport */
        latitude,
        /** The longitude at the center of the viewport */
        longitude,
        /** The tile zoom level of the map. */
        zoom,
        /** The bearing of the viewport in degrees */
        bearing = 0,
        /** The pitch of the viewport in degrees */
        pitch = 0,
        /**
         * Specify the altitude of the viewport camera
         * Unit: map heights, default 1.5
         * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
         */
        altitude = 1.5,
        /** Viewport position */
        position = [0, 0, 0],
        /** Viewport constraints */
        maxZoom = 20,
        minZoom = 0,
        maxPitch = 60,
        minPitch = 0,
        /** Interaction states, required to calculate change during transform */
        /* The point on map being grabbed when the operation first started */
        startPanLngLat,
        /* Center of the zoom when the operation first started */
        startZoomLngLat,
        /* Pointer position when rotation started */
        startRotatePos,
        /** Bearing when current perspective rotate operation started */
        startBearing,
        /** Pitch when current perspective rotate operation started */
        startPitch,
        /** Zoom when current zoom operation started */
        startZoom,
        /** Normalize viewport props to fit map height into viewport */
        normalize: normalize16 = true
      } = options;
      assert8(Number.isFinite(longitude));
      assert8(Number.isFinite(latitude));
      assert8(Number.isFinite(zoom));
      super(
        {
          width,
          height,
          latitude,
          longitude,
          zoom,
          bearing,
          pitch,
          altitude,
          maxZoom,
          minZoom,
          maxPitch,
          minPitch,
          normalize: normalize16,
          position
        },
        {
          startPanLngLat,
          startZoomLngLat,
          startRotatePos,
          startBearing,
          startPitch,
          startZoom
        }
      );
      this.makeViewport = options.makeViewport;
    }
    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    panStart({ pos }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */
    pan({ pos, startPos }) {
      const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanLngLat, pos);
      return this._getUpdatedState(newProps);
    }
    /**
     * End panning
     * Must call if `panStart()` was called
     */
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the center is
     */
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startBearing, startPitch } = this.getState();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */
    zoomStart({ pos }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */
    zoom({
      pos,
      startPos,
      scale: scale22
    }) {
      let { startZoom, startZoomLngLat } = this.getState();
      if (!startZoomLngLat) {
        startZoom = this.getViewportProps().zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomLngLat) {
        return this;
      }
      const { maxZoom, minZoom } = this.getViewportProps();
      let zoom = startZoom + Math.log2(scale22);
      zoom = clamp(zoom, minZoom, maxZoom);
      const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });
      return this._getUpdatedState({
        zoom,
        ...zoomedViewport.panByPosition(startZoomLngLat, pos)
      });
    }
    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
      return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
      return this._panFromCenter([speed, 0]);
    }
    moveRight(speed = 100) {
      return this._panFromCenter([-speed, 0]);
    }
    moveUp(speed = 100) {
      return this._panFromCenter([0, speed]);
    }
    moveDown(speed = 100) {
      return this._panFromCenter([0, -speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { bearing, longitude } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    // Apply any constraints (mathematical or defined by _viewportProps) to map state
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const { maxPitch, minPitch, pitch } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      const { normalize: normalize16 = true } = props;
      if (normalize16) {
        Object.assign(props, normalizeViewportProps(props));
      }
      return props;
    }
    /* Private methods */
    _zoomFromCenter(scale22) {
      const { width, height } = this.getViewportProps();
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale22
      });
    }
    _panFromCenter(offset) {
      const { width, height } = this.getViewportProps();
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
      const deltaX = pos[0] - startPos[0];
      const deltaY = pos[1] - startPos[1];
      const centerY = pos[1];
      const startY = startPos[1];
      const { width, height } = this.getViewportProps();
      const deltaScaleX = deltaX / width;
      let deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = clamp(deltaScaleY, -1, 1);
      const { minPitch, maxPitch } = this.getViewportProps();
      const bearing = startBearing + 180 * deltaScaleX;
      let pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  };
  var MapController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = MapState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
            required: ["longitude", "latitude", "zoom"]
          }
        })
      };
      this.dragMode = "pan";
    }
    setProps(props) {
      props.position = props.position || [0, 0, 0];
      const oldProps = this.props;
      super.setProps(props);
      const dimensionChanged = !oldProps || oldProps.height !== props.height;
      if (dimensionChanged) {
        this.updateViewport(
          new this.ControllerState({
            makeViewport: this.makeViewport,
            ...props,
            ...this.state
          })
        );
      }
    }
  };

  // ../core/src/views/map-view.ts
  var MapView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    getViewportType() {
      return WebMercatorViewport2;
    }
    get ControllerType() {
      return MapController;
    }
  };
  MapView.displayName = "MapView";

  // ../core/src/lib/effect-manager.ts
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  function compareEffects(e1, e22) {
    const o1 = e1.order ?? Infinity;
    const o22 = e22.order ?? Infinity;
    return o1 - o22;
  }
  var EffectManager = class {
    constructor(context) {
      this._resolvedEffects = [];
      /** Effect instances and order preference pairs, sorted by order */
      this._defaultEffects = [];
      this.effects = [];
      this._context = context;
      this._needsRedraw = "Initial render";
      this._setEffects([]);
    }
    /**
     * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
     */
    addDefaultEffect(effect) {
      const defaultEffects = this._defaultEffects;
      if (!defaultEffects.find((e3) => e3.id === effect.id)) {
        const index = defaultEffects.findIndex((e3) => compareEffects(e3, effect) > 0);
        if (index < 0) {
          defaultEffects.push(effect);
        } else {
          defaultEffects.splice(index, 0, effect);
        }
        effect.setup(this._context);
        this._setEffects(this.effects);
      }
    }
    setProps(props) {
      if ("effects" in props) {
        if (!deepEqual2(props.effects, this.effects, 1)) {
          this._setEffects(props.effects);
        }
      }
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(effects) {
      const oldEffectsMap = {};
      for (const effect of this.effects) {
        oldEffectsMap[effect.id] = effect;
      }
      const nextEffects = [];
      for (const effect of effects) {
        const oldEffect = oldEffectsMap[effect.id];
        let effectToAdd = effect;
        if (oldEffect && oldEffect !== effect) {
          if (oldEffect.setProps) {
            oldEffect.setProps(effect.props);
            effectToAdd = oldEffect;
          } else {
            oldEffect.cleanup(this._context);
          }
        } else if (!oldEffect) {
          effect.setup(this._context);
        }
        nextEffects.push(effectToAdd);
        delete oldEffectsMap[effect.id];
      }
      for (const removedEffectId in oldEffectsMap) {
        oldEffectsMap[removedEffectId].cleanup(this._context);
      }
      this.effects = nextEffects;
      this._resolvedEffects = nextEffects.concat(this._defaultEffects);
      if (!effects.some((effect) => effect instanceof LightingEffect)) {
        this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
      this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const effect of this._resolvedEffects) {
        effect.cleanup(this._context);
      }
      this.effects.length = 0;
      this._resolvedEffects.length = 0;
      this._defaultEffects.length = 0;
    }
  };

  // ../core/src/passes/draw-layers-pass.ts
  var DrawLayersPass = class extends LayersPass {
    shouldDrawLayer(layer) {
      const { operation } = layer.props;
      return operation.includes("draw") || operation.includes("terrain");
    }
  };

  // ../core/src/lib/deck-renderer.ts
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = class {
    constructor(device) {
      this.device = device;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(device);
      this.pickLayersPass = new PickLayersPass(device);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
    }
    setProps(props) {
      if (this.layerFilter !== props.layerFilter) {
        this.layerFilter = props.layerFilter;
        this._needsRedraw = "layerFilter changed";
      }
      if (this.drawPickingColors !== props.drawPickingColors) {
        this.drawPickingColors = props.drawPickingColors;
        this._needsRedraw = "drawPickingColors changed";
      }
    }
    renderLayers(opts) {
      if (!opts.viewports.length) {
        return;
      }
      const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      const renderOpts = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...opts
      };
      if (renderOpts.effects) {
        this._preRender(renderOpts.effects, renderOpts);
      }
      const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
      if (this.lastPostProcessEffect) {
        renderOpts.clearColor = [0, 0, 0, 0];
        renderOpts.clearCanvas = true;
      }
      const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });
      if (renderOpts.effects) {
        this._postRender(renderOpts.effects, renderOpts);
      }
      this.renderCount++;
      debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    finalize() {
      const { renderBuffers } = this;
      for (const buffer of renderBuffers) {
        buffer.delete();
      }
      renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
      this.lastPostProcessEffect = null;
      opts.preRenderStats = opts.preRenderStats || {};
      for (const effect of effects) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
        if (effect.postRender) {
          this.lastPostProcessEffect = effect.id;
        }
      }
      if (this.lastPostProcessEffect) {
        this._resizeRenderBuffers();
      }
    }
    _resizeRenderBuffers() {
      const { renderBuffers } = this;
      const size = this.device.canvasContext.getDrawingBufferSize();
      if (renderBuffers.length === 0) {
        [0, 1].map((i5) => {
          const texture = this.device.createTexture({
            sampler: { minFilter: "linear", magFilter: "linear" }
          });
          renderBuffers.push(
            this.device.createFramebuffer({
              id: `deck-renderbuffer-${i5}`,
              colorAttachments: [texture]
            })
          );
        });
      }
      for (const buffer of renderBuffers) {
        buffer.resize(size);
      }
    }
    _postRender(effects, opts) {
      const { renderBuffers } = this;
      const params = {
        ...opts,
        inputBuffer: renderBuffers[0],
        swapBuffer: renderBuffers[1]
      };
      for (const effect of effects) {
        if (effect.postRender) {
          params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
          const buffer = effect.postRender(params);
          params.inputBuffer = buffer;
          params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
      }
    }
  };

  // ../core/src/lib/picking/query-object.ts
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function getClosestObject({
    pickedColors,
    decodePickingColor,
    deviceX,
    deviceY,
    deviceRadius,
    deviceRect
  }) {
    const { x: x3, y: y3, width, height } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i5 = 0;
    for (let row = 0; row < height; row++) {
      const dy = row + y3 - deviceY;
      const dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i5 += 4 * width;
      } else {
        for (let col = 0; col < width; col++) {
          const pickedLayerIndex = pickedColors[i5 + 3] - 1;
          if (pickedLayerIndex >= 0) {
            const dx = col + x3 - deviceX;
            const d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i5;
            }
          }
          i5 += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);
      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width);
        const dx = closestPixelIndex / 4 - dy * width;
        return {
          ...pickedObject,
          pickedColor,
          pickedX: x3 + dx,
          pickedY: y3 + dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects({
    pickedColors,
    decodePickingColor
  }) {
    const uniqueColors = /* @__PURE__ */ new Map();
    if (pickedColors) {
      for (let i5 = 0; i5 < pickedColors.length; i5 += 4) {
        const pickedLayerIndex = pickedColors[i5 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const pickedColor = pickedColors.slice(i5, i5 + 4);
          const colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            const pickedObject = decodePickingColor(pickedColor);
            if (pickedObject) {
              uniqueColors.set(colorKey, {
                ...pickedObject,
                color: pickedColor
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // ../core/src/lib/picking/pick-info.ts
  function getEmptyPickingInfo({
    pickInfo,
    viewports,
    pixelRatio,
    x: x3,
    y: y3,
    z: z2
  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) {
      pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, { x: x3, y: y3 });
    }
    let coordinate;
    if (pickedViewport) {
      const point = [x3 - pickedViewport.x, y3 - pickedViewport.y];
      if (z2 !== void 0) {
        point[2] = z2;
      }
      coordinate = pickedViewport.unproject(point);
    }
    return {
      color: null,
      layer: null,
      viewport: pickedViewport,
      index: -1,
      picked: false,
      x: x3,
      y: y3,
      pixel: [x3, y3],
      coordinate,
      devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
      pixelRatio
    };
  }
  function processPickInfo(opts) {
    const { pickInfo, lastPickedInfo, mode, layers } = opts;
    const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
    const affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      const lastPickedPixelIndex = lastPickedInfo.index;
      const lastPickedLayerId = lastPickedInfo.layerId;
      const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    const baseInfo = getEmptyPickingInfo(opts);
    const infos = /* @__PURE__ */ new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer) => {
      let info = { ...baseInfo };
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({ layer, info, mode });
      const rootLayer = info.layer;
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      infos.set(rootLayer.id, info);
      if (mode === "hover") {
        rootLayer.updateAutoHighlight(info);
      }
    });
    return infos;
  }
  function getLayerPickingInfo({
    layer,
    info,
    mode
  }) {
    while (layer && info) {
      const sourceLayer = info.layer || null;
      info.sourceLayer = sourceLayer;
      info.layer = layer;
      info = layer.getPickingInfo({ info, mode, sourceLayer });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel) {
    for (let i5 = viewports.length - 1; i5 >= 0; i5--) {
      const viewport = viewports[i5];
      if (viewport.containsPixel(pixel)) {
        return viewport;
      }
    }
    return viewports[0];
  }

  // ../core/src/lib/deck-picker.ts
  var DeckPicker = class {
    constructor(device) {
      this._pickable = true;
      this.device = device;
      this.pickLayersPass = new PickLayersPass(device);
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(props) {
      if ("layerFilter" in props) {
        this.layerFilter = props.layerFilter;
      }
      if ("_pickable" in props) {
        this._pickable = props._pickable;
      }
    }
    finalize() {
      if (this.pickingFBO) {
        this.pickingFBO.destroy();
      }
      if (this.depthFBO) {
        this.depthFBO.destroy();
      }
    }
    /** Pick the closest info at given coordinate */
    pickObject(opts) {
      return this._pickClosestObject(opts);
    }
    /** Get all unique infos within a bounding box */
    pickObjects(opts) {
      return this._pickVisibleObjects(opts);
    }
    // Returns a new picking info object by assuming the last picked object is still picked
    getLastPickedObject({ x: x3, y: y3, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
      const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
      const layer = lastPickedLayerId ? layers.find((l3) => l3.id === lastPickedLayerId) : null;
      const viewport = lastPickedViewportId && viewports.find((v2) => v2.id === lastPickedViewportId) || viewports[0];
      const coordinate = viewport && viewport.unproject([x3 - viewport.x, y3 - viewport.y]);
      const info = {
        x: x3,
        y: y3,
        viewport,
        coordinate,
        layer
      };
      return { ...lastPickedInfo, ...info };
    }
    // Private
    /** Ensures that picking framebuffer exists and matches the canvas size */
    _resizeBuffer() {
      if (!this.pickingFBO) {
        this.pickingFBO = this.device.createFramebuffer({
          colorAttachments: ["rgba8unorm"],
          depthStencilAttachment: "depth16unorm"
        });
        if (this.device.isTextureFormatRenderable("rgba32float")) {
          const depthFBO = this.device.createFramebuffer({
            colorAttachments: ["rgba32float"],
            depthStencilAttachment: "depth16unorm"
          });
          this.depthFBO = depthFBO;
        }
      }
      const { canvas: canvas2 } = this.device.getDefaultCanvasContext();
      this.pickingFBO?.resize({ width: canvas2.width, height: canvas2.height });
      this.depthFBO?.resize({ width: canvas2.width, height: canvas2.height });
    }
    /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
    _getPickable(layers) {
      if (this._pickable === false) {
        return null;
      }
      const pickableLayers = layers.filter(
        (layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite
      );
      return pickableLayers.length ? pickableLayers : null;
    }
    /** Pick the closest object at the given coordinate */
    // eslint-disable-next-line max-statements,complexity
    _pickClosestObject({
      layers,
      views,
      viewports,
      x: x3,
      y: y3,
      radius = 0,
      depth = 1,
      mode = "query",
      unproject3D,
      onViewportActive,
      effects
    }) {
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers || viewports.length === 0) {
        return {
          result: [],
          emptyInfo: getEmptyPickingInfo({ viewports, x: x3, y: y3, pixelRatio })
        };
      }
      this._resizeBuffer();
      const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x3, y3], true);
      const devicePixel = [
        devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
        devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
      ];
      const deviceRadius = Math.round(radius * pixelRatio);
      const { width, height } = this.pickingFBO;
      const deviceRect = this._getPickingRect({
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      const cullRect = {
        x: x3 - radius,
        y: y3 - radius,
        width: radius * 2 + 1,
        height: radius * 2 + 1
      };
      let infos;
      const result = [];
      const affectedLayers = /* @__PURE__ */ new Set();
      for (let i5 = 0; i5 < depth; i5++) {
        let pickInfo;
        if (deviceRect) {
          const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            cullRect,
            effects,
            pass: `picking:${mode}`
          });
          pickInfo = getClosestObject({
            ...pickedResult,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
        } else {
          pickInfo = {
            pickedColor: null,
            pickedObjectIndex: -1
          };
        }
        let z2;
        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
          const { pickedColors: pickedColors2 } = this._drawAndSample(
            {
              layers: [pickInfo.pickedLayer],
              views,
              viewports,
              onViewportActive,
              deviceRect: {
                x: pickInfo.pickedX,
                y: pickInfo.pickedY,
                width: 1,
                height: 1
              },
              cullRect,
              effects,
              pass: `picking:${mode}:z`
            },
            true
          );
          if (pickedColors2[3]) {
            z2 = pickedColors2[0];
          }
        }
        if (pickInfo.pickedLayer && i5 + 1 < depth) {
          affectedLayers.add(pickInfo.pickedLayer);
          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
        }
        infos = processPickInfo({
          pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode,
          layers: pickableLayers,
          viewports,
          x: x3,
          y: y3,
          z: z2,
          pixelRatio
        });
        for (const info of infos.values()) {
          if (info.layer) {
            result.push(info);
          }
        }
        if (!pickInfo.pickedColor) {
          break;
        }
      }
      for (const layer of affectedLayers) {
        layer.restorePickingColors();
      }
      return { result, emptyInfo: infos.get(null) };
    }
    /** Pick all objects within the given bounding box */
    // eslint-disable-next-line max-statements
    _pickVisibleObjects({
      layers,
      views,
      viewports,
      x: x3,
      y: y3,
      width = 1,
      height = 1,
      mode = "query",
      maxObjects = null,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers || viewports.length === 0) {
        return [];
      }
      this._resizeBuffer();
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const leftTop = this.device.canvasContext.cssToDevicePixels([x3, y3], true);
      const deviceLeft = leftTop.x;
      const deviceTop = leftTop.y + leftTop.height;
      const rightBottom = this.device.canvasContext.cssToDevicePixels([x3 + width, y3 + height], true);
      const deviceRight = rightBottom.x + rightBottom.width;
      const deviceBottom = rightBottom.y;
      const deviceRect = {
        x: deviceLeft,
        y: deviceBottom,
        // deviceTop and deviceRight represent the first pixel outside the desired rect
        width: deviceRight - deviceLeft,
        height: deviceTop - deviceBottom
      };
      const pickedResult = this._drawAndSample({
        layers: pickableLayers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect: { x: x3, y: y3, width, height },
        effects,
        pass: `picking:${mode}`
      });
      const pickInfos = getUniqueObjects(pickedResult);
      const uniquePickedObjects = /* @__PURE__ */ new Map();
      const uniqueInfos = [];
      const limitMaxObjects = Number.isFinite(maxObjects);
      for (let i5 = 0; i5 < pickInfos.length; i5++) {
        if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
          break;
        }
        const pickInfo = pickInfos[i5];
        let info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x3,
          y: y3,
          pixelRatio
        };
        info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
        const pickedLayerId = info.layer.id;
        if (!uniquePickedObjects.has(pickedLayerId)) {
          uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
        }
        const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
        const pickedObjectKey = info.object ?? info.index;
        if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
          uniqueObjectsInLayer.add(pickedObjectKey);
          uniqueInfos.push(info);
        }
      }
      return uniqueInfos;
    }
    _drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect,
      effects,
      pass
    }, pickZ = false) {
      const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
      const opts = {
        layers,
        layerFilter: this.layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect,
        cullRect,
        effects,
        pass,
        pickZ,
        preRenderStats: {},
        isPicking: true
      };
      for (const effect of effects) {
        if (effect.useInPicking) {
          opts.preRenderStats[effect.id] = effect.preRender(opts);
        }
      }
      const { decodePickingColor } = this.pickLayersPass.render(opts);
      const { x: x3, y: y3, width, height } = deviceRect;
      const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
      this.device.readPixelsToArrayWebGL(pickingFBO, {
        sourceX: x3,
        sourceY: y3,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return { pickedColors, decodePickingColor };
    }
    // Calculate a picking rect centered on deviceX and deviceY and clipped to device
    // Returns null if pixel is outside of device
    _getPickingRect({
      deviceX,
      deviceY,
      deviceRadius,
      deviceWidth,
      deviceHeight
    }) {
      const x3 = Math.max(0, deviceX - deviceRadius);
      const y3 = Math.max(0, deviceY - deviceRadius);
      const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x3;
      const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y3;
      if (width <= 0 || height <= 0) {
        return null;
      }
      return { x: x3, y: y3, width, height };
    }
  };

  // ../core/src/lib/widget-manager.ts
  var PLACEMENTS = {
    "top-left": { top: 0, left: 0 },
    "top-right": { top: 0, right: 0 },
    "bottom-left": { bottom: 0, left: 0 },
    "bottom-right": { bottom: 0, right: 0 },
    fill: { top: 0, left: 0, bottom: 0, right: 0 }
  };
  var DEFAULT_PLACEMENT = "top-left";
  var ROOT_CONTAINER_ID = "__root";
  var WidgetManager = class {
    constructor({ deck, parentElement }) {
      /** Widgets added via the imperative API */
      this.defaultWidgets = [];
      /** Widgets received from the declarative API */
      this.widgets = [];
      /** Resolved widgets from both imperative and declarative APIs */
      this.resolvedWidgets = [];
      /** Mounted HTML containers */
      this.containers = {};
      /** Viewport provided to widget on redraw */
      this.lastViewports = {};
      this.deck = deck;
      this.parentElement = parentElement;
    }
    getWidgets() {
      return this.resolvedWidgets;
    }
    /** Declarative API to configure widgets */
    setProps(props) {
      if (props.widgets && !deepEqual2(props.widgets, this.widgets, 1)) {
        this._setWidgets(props.widgets);
      }
    }
    finalize() {
      for (const widget of this.getWidgets()) {
        this._remove(widget);
      }
      this.defaultWidgets.length = 0;
      this.resolvedWidgets.length = 0;
      for (const id in this.containers) {
        this.containers[id].remove();
      }
    }
    /** Imperative API. Widgets added this way are not affected by the declarative prop. */
    addDefault(widget) {
      if (!this.defaultWidgets.find((w2) => w2.id === widget.id)) {
        this._add(widget);
        this.defaultWidgets.push(widget);
        this._setWidgets(this.widgets);
      }
    }
    /** Resolve widgets from the declarative prop */
    _setWidgets(nextWidgets) {
      const oldWidgetMap = {};
      for (const widget of this.resolvedWidgets) {
        oldWidgetMap[widget.id] = widget;
      }
      this.resolvedWidgets.length = 0;
      for (const widget of this.defaultWidgets) {
        oldWidgetMap[widget.id] = null;
        this.resolvedWidgets.push(widget);
      }
      for (let widget of nextWidgets) {
        const oldWidget = oldWidgetMap[widget.id];
        if (!oldWidget) {
          this._add(widget);
        } else if (
          // Widget placement changed
          oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement
        ) {
          this._remove(oldWidget);
          this._add(widget);
        } else if (widget !== oldWidget) {
          oldWidget.setProps(widget.props);
          widget = oldWidget;
        }
        oldWidgetMap[widget.id] = null;
        this.resolvedWidgets.push(widget);
      }
      for (const id in oldWidgetMap) {
        const oldWidget = oldWidgetMap[id];
        if (oldWidget) {
          this._remove(oldWidget);
        }
      }
      this.widgets = nextWidgets;
    }
    _add(widget) {
      const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
      const element = widget.onAdd({ deck: this.deck, viewId });
      if (element) {
        this._getContainer(viewId, placement).append(element);
      }
      widget._element = element;
    }
    _remove(widget) {
      widget.onRemove?.();
      if (widget._element) {
        widget._element.remove();
      }
      widget._element = void 0;
    }
    /* global document */
    _getContainer(viewId, placement) {
      const containerId = viewId || ROOT_CONTAINER_ID;
      let viewContainer = this.containers[containerId];
      if (!viewContainer) {
        viewContainer = document.createElement("div");
        viewContainer.style.pointerEvents = "none";
        viewContainer.style.position = "absolute";
        viewContainer.style.overflow = "hidden";
        this.parentElement?.append(viewContainer);
        this.containers[containerId] = viewContainer;
      }
      let container = viewContainer.querySelector(`.${placement}`);
      if (!container) {
        container = document.createElement("div");
        container.className = placement;
        container.style.position = "absolute";
        container.style.zIndex = "2";
        Object.assign(container.style, PLACEMENTS[placement]);
        viewContainer.append(container);
      }
      return container;
    }
    _updateContainers() {
      const canvasWidth = this.deck.width;
      const canvasHeight = this.deck.height;
      for (const id in this.containers) {
        const viewport = this.lastViewports[id] || null;
        const visible = id === ROOT_CONTAINER_ID || viewport;
        const container = this.containers[id];
        if (visible) {
          container.style.display = "block";
          container.style.left = `${viewport ? viewport.x : 0}px`;
          container.style.top = `${viewport ? viewport.y : 0}px`;
          container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
          container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
        } else {
          container.style.display = "none";
        }
      }
    }
    onRedraw({ viewports, layers }) {
      const viewportsById = viewports.reduce((acc, v2) => {
        acc[v2.id] = v2;
        return acc;
      }, {});
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (viewId) {
          const viewport = viewportsById[viewId];
          if (viewport) {
            if (widget.onViewportChange) {
              widget.onViewportChange(viewport);
            }
            widget.onRedraw?.({ viewports: [viewport], layers });
          }
        } else {
          if (widget.onViewportChange) {
            for (const viewport of viewports) {
              widget.onViewportChange(viewport);
            }
          }
          widget.onRedraw?.({ viewports, layers });
        }
      }
      this.lastViewports = viewportsById;
      this._updateContainers();
    }
    onHover(info, event) {
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (!viewId || viewId === info.viewport?.id) {
          widget.onHover?.(info, event);
        }
      }
    }
    onEvent(info, event) {
      const eventHandlerProp = EVENT_HANDLERS[event.type];
      if (!eventHandlerProp) {
        return;
      }
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (!viewId || viewId === info.viewport?.id) {
          widget[eventHandlerProp]?.(info, event);
        }
      }
    }
  };

  // ../core/src/lib/tooltip.ts
  var defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  var Tooltip = class {
    constructor() {
      this.id = "default-tooltip";
      this.placement = "fill";
      this.props = {};
      this.isVisible = false;
    }
    onAdd({ deck }) {
      const el = document.createElement("div");
      el.className = "deck-tooltip";
      Object.assign(el.style, defaultStyle);
      this.deck = deck;
      this.element = el;
      return el;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    setProps() {
    }
    onViewportChange(viewport) {
      if (this.isVisible && viewport.id === this.lastViewport?.id && viewport !== this.lastViewport) {
        this.setTooltip(null);
      }
    }
    onHover(info) {
      const { deck } = this;
      const getTooltip = deck && deck.props.getTooltip;
      if (!getTooltip) {
        return;
      }
      const displayInfo = getTooltip(info);
      this.lastViewport = info.viewport;
      this.setTooltip(displayInfo, info.x, info.y);
    }
    setTooltip(displayInfo, x3, y3) {
      const el = this.element;
      if (!el) {
        return;
      }
      if (typeof displayInfo === "string") {
        el.innerText = displayInfo;
      } else if (!displayInfo) {
        this.isVisible = false;
        el.style.display = "none";
        return;
      } else {
        if (displayInfo.text) {
          el.innerText = displayInfo.text;
        }
        if (displayInfo.html) {
          el.innerHTML = displayInfo.html;
        }
        if (displayInfo.className) {
          el.className = displayInfo.className;
        }
      }
      this.isVisible = true;
      el.style.display = "block";
      el.style.transform = `translate(${x3}px, ${y3}px)`;
      if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
        Object.assign(el.style, displayInfo.style);
      }
    }
  };

  // ../../node_modules/@luma.gl/constants/dist/webgl-constants.js
  var GLEnum;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GLEnum4[GLEnum4["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GLEnum4[GLEnum4["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    GLEnum4[GLEnum4["POINTS"] = 0] = "POINTS";
    GLEnum4[GLEnum4["LINES"] = 1] = "LINES";
    GLEnum4[GLEnum4["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum4[GLEnum4["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum4[GLEnum4["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum4[GLEnum4["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum4[GLEnum4["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    GLEnum4[GLEnum4["ZERO"] = 0] = "ZERO";
    GLEnum4[GLEnum4["ONE"] = 1] = "ONE";
    GLEnum4[GLEnum4["SRC_COLOR"] = 768] = "SRC_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GLEnum4[GLEnum4["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum4[GLEnum4["DST_ALPHA"] = 772] = "DST_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GLEnum4[GLEnum4["DST_COLOR"] = 774] = "DST_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GLEnum4[GLEnum4["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GLEnum4[GLEnum4["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    GLEnum4[GLEnum4["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    GLEnum4[GLEnum4["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum4[GLEnum4["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum4[GLEnum4["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    GLEnum4[GLEnum4["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GLEnum4[GLEnum4["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GLEnum4[GLEnum4["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GLEnum4[GLEnum4["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    GLEnum4[GLEnum4["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    GLEnum4[GLEnum4["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    GLEnum4[GLEnum4["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    GLEnum4[GLEnum4["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    GLEnum4[GLEnum4["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    GLEnum4[GLEnum4["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    GLEnum4[GLEnum4["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    GLEnum4[GLEnum4["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    GLEnum4[GLEnum4["FRONT_FACE"] = 2886] = "FRONT_FACE";
    GLEnum4[GLEnum4["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    GLEnum4[GLEnum4["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    GLEnum4[GLEnum4["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    GLEnum4[GLEnum4["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    GLEnum4[GLEnum4["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    GLEnum4[GLEnum4["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    GLEnum4[GLEnum4["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    GLEnum4[GLEnum4["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    GLEnum4[GLEnum4["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    GLEnum4[GLEnum4["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum4[GLEnum4["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum4[GLEnum4["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum4[GLEnum4["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum4[GLEnum4["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum4[GLEnum4["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum4[GLEnum4["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum4[GLEnum4["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum4[GLEnum4["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum4[GLEnum4["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    GLEnum4[GLEnum4["VIEWPORT"] = 2978] = "VIEWPORT";
    GLEnum4[GLEnum4["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum4[GLEnum4["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum4[GLEnum4["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum4[GLEnum4["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum4[GLEnum4["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum4[GLEnum4["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum4[GLEnum4["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum4[GLEnum4["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum4[GLEnum4["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum4[GLEnum4["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum4[GLEnum4["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum4[GLEnum4["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum4[GLEnum4["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum4[GLEnum4["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum4[GLEnum4["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum4[GLEnum4["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum4[GLEnum4["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum4[GLEnum4["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum4[GLEnum4["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum4[GLEnum4["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum4[GLEnum4["VENDOR"] = 7936] = "VENDOR";
    GLEnum4[GLEnum4["RENDERER"] = 7937] = "RENDERER";
    GLEnum4[GLEnum4["VERSION"] = 7938] = "VERSION";
    GLEnum4[GLEnum4["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum4[GLEnum4["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum4[GLEnum4["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    GLEnum4[GLEnum4["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    GLEnum4[GLEnum4["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    GLEnum4[GLEnum4["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    GLEnum4[GLEnum4["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    GLEnum4[GLEnum4["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    GLEnum4[GLEnum4["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    GLEnum4[GLEnum4["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    GLEnum4[GLEnum4["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["CULL_FACE"] = 2884] = "CULL_FACE";
    GLEnum4[GLEnum4["FRONT"] = 1028] = "FRONT";
    GLEnum4[GLEnum4["BACK"] = 1029] = "BACK";
    GLEnum4[GLEnum4["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    GLEnum4[GLEnum4["BLEND"] = 3042] = "BLEND";
    GLEnum4[GLEnum4["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    GLEnum4[GLEnum4["DITHER"] = 3024] = "DITHER";
    GLEnum4[GLEnum4["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    GLEnum4[GLEnum4["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    GLEnum4[GLEnum4["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    GLEnum4[GLEnum4["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    GLEnum4[GLEnum4["NO_ERROR"] = 0] = "NO_ERROR";
    GLEnum4[GLEnum4["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GLEnum4[GLEnum4["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GLEnum4[GLEnum4["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GLEnum4[GLEnum4["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GLEnum4[GLEnum4["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    GLEnum4[GLEnum4["CW"] = 2304] = "CW";
    GLEnum4[GLEnum4["CCW"] = 2305] = "CCW";
    GLEnum4[GLEnum4["DONT_CARE"] = 4352] = "DONT_CARE";
    GLEnum4[GLEnum4["FASTEST"] = 4353] = "FASTEST";
    GLEnum4[GLEnum4["NICEST"] = 4354] = "NICEST";
    GLEnum4[GLEnum4["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    GLEnum4[GLEnum4["BYTE"] = 5120] = "BYTE";
    GLEnum4[GLEnum4["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum4[GLEnum4["SHORT"] = 5122] = "SHORT";
    GLEnum4[GLEnum4["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum4[GLEnum4["INT"] = 5124] = "INT";
    GLEnum4[GLEnum4["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum4[GLEnum4["FLOAT"] = 5126] = "FLOAT";
    GLEnum4[GLEnum4["DOUBLE"] = 5130] = "DOUBLE";
    GLEnum4[GLEnum4["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum4[GLEnum4["ALPHA"] = 6406] = "ALPHA";
    GLEnum4[GLEnum4["RGB"] = 6407] = "RGB";
    GLEnum4[GLEnum4["RGBA"] = 6408] = "RGBA";
    GLEnum4[GLEnum4["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum4[GLEnum4["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GLEnum4[GLEnum4["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    GLEnum4[GLEnum4["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    GLEnum4[GLEnum4["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    GLEnum4[GLEnum4["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    GLEnum4[GLEnum4["LINK_STATUS"] = 35714] = "LINK_STATUS";
    GLEnum4[GLEnum4["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    GLEnum4[GLEnum4["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    GLEnum4[GLEnum4["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    GLEnum4[GLEnum4["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    GLEnum4[GLEnum4["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum4[GLEnum4["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum4[GLEnum4["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum4[GLEnum4["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum4[GLEnum4["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum4[GLEnum4["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    GLEnum4[GLEnum4["NEVER"] = 512] = "NEVER";
    GLEnum4[GLEnum4["LESS"] = 513] = "LESS";
    GLEnum4[GLEnum4["EQUAL"] = 514] = "EQUAL";
    GLEnum4[GLEnum4["LEQUAL"] = 515] = "LEQUAL";
    GLEnum4[GLEnum4["GREATER"] = 516] = "GREATER";
    GLEnum4[GLEnum4["NOTEQUAL"] = 517] = "NOTEQUAL";
    GLEnum4[GLEnum4["GEQUAL"] = 518] = "GEQUAL";
    GLEnum4[GLEnum4["ALWAYS"] = 519] = "ALWAYS";
    GLEnum4[GLEnum4["KEEP"] = 7680] = "KEEP";
    GLEnum4[GLEnum4["REPLACE"] = 7681] = "REPLACE";
    GLEnum4[GLEnum4["INCR"] = 7682] = "INCR";
    GLEnum4[GLEnum4["DECR"] = 7683] = "DECR";
    GLEnum4[GLEnum4["INVERT"] = 5386] = "INVERT";
    GLEnum4[GLEnum4["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum4[GLEnum4["DECR_WRAP"] = 34056] = "DECR_WRAP";
    GLEnum4[GLEnum4["NEAREST"] = 9728] = "NEAREST";
    GLEnum4[GLEnum4["LINEAR"] = 9729] = "LINEAR";
    GLEnum4[GLEnum4["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    GLEnum4[GLEnum4["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    GLEnum4[GLEnum4["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum4[GLEnum4["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    GLEnum4[GLEnum4["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum4[GLEnum4["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum4[GLEnum4["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum4[GLEnum4["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum4[GLEnum4["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    GLEnum4[GLEnum4["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum4[GLEnum4["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum4[GLEnum4["REPEAT"] = 10497] = "REPEAT";
    GLEnum4[GLEnum4["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum4[GLEnum4["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    GLEnum4[GLEnum4["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum4[GLEnum4["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    GLEnum4[GLEnum4["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum4[GLEnum4["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum4[GLEnum4["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum4[GLEnum4["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum4[GLEnum4["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum4[GLEnum4["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum4[GLEnum4["BOOL"] = 35670] = "BOOL";
    GLEnum4[GLEnum4["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum4[GLEnum4["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum4[GLEnum4["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum4[GLEnum4["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum4[GLEnum4["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum4[GLEnum4["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum4[GLEnum4["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum4[GLEnum4["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    GLEnum4[GLEnum4["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum4[GLEnum4["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum4[GLEnum4["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum4[GLEnum4["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum4[GLEnum4["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum4[GLEnum4["HIGH_INT"] = 36341] = "HIGH_INT";
    GLEnum4[GLEnum4["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum4[GLEnum4["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum4[GLEnum4["RGBA4"] = 32854] = "RGBA4";
    GLEnum4[GLEnum4["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum4[GLEnum4["RGB565"] = 36194] = "RGB565";
    GLEnum4[GLEnum4["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum4[GLEnum4["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum4[GLEnum4["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum4[GLEnum4["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum4[GLEnum4["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum4[GLEnum4["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum4[GLEnum4["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum4[GLEnum4["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum4[GLEnum4["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum4[GLEnum4["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum4[GLEnum4["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum4[GLEnum4["NONE"] = 0] = "NONE";
    GLEnum4[GLEnum4["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum4[GLEnum4["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum4[GLEnum4["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum4[GLEnum4["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum4[GLEnum4["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum4[GLEnum4["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum4[GLEnum4["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    GLEnum4[GLEnum4["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum4[GLEnum4["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum4[GLEnum4["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    GLEnum4[GLEnum4["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum4[GLEnum4["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum4[GLEnum4["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum4[GLEnum4["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum4[GLEnum4["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum4[GLEnum4["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum4[GLEnum4["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum4[GLEnum4["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum4[GLEnum4["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum4[GLEnum4["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum4[GLEnum4["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum4[GLEnum4["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
    GLEnum4[GLEnum4["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum4[GLEnum4["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum4[GLEnum4["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum4[GLEnum4["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum4[GLEnum4["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum4[GLEnum4["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum4[GLEnum4["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum4[GLEnum4["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum4[GLEnum4["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum4[GLEnum4["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum4[GLEnum4["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    GLEnum4[GLEnum4["RED"] = 6403] = "RED";
    GLEnum4[GLEnum4["RGB8"] = 32849] = "RGB8";
    GLEnum4[GLEnum4["RGBA8"] = 32856] = "RGBA8";
    GLEnum4[GLEnum4["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum4[GLEnum4["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    GLEnum4[GLEnum4["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum4[GLEnum4["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum4[GLEnum4["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum4[GLEnum4["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum4[GLEnum4["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum4[GLEnum4["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum4[GLEnum4["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum4[GLEnum4["SRGB"] = 35904] = "SRGB";
    GLEnum4[GLEnum4["SRGB8"] = 35905] = "SRGB8";
    GLEnum4[GLEnum4["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum4[GLEnum4["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum4[GLEnum4["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum4[GLEnum4["RGB32F"] = 34837] = "RGB32F";
    GLEnum4[GLEnum4["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum4[GLEnum4["RGB16F"] = 34843] = "RGB16F";
    GLEnum4[GLEnum4["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum4[GLEnum4["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum4[GLEnum4["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum4[GLEnum4["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum4[GLEnum4["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum4[GLEnum4["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum4[GLEnum4["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum4[GLEnum4["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum4[GLEnum4["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum4[GLEnum4["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum4[GLEnum4["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum4[GLEnum4["RGB32I"] = 36227] = "RGB32I";
    GLEnum4[GLEnum4["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum4[GLEnum4["RGB16I"] = 36233] = "RGB16I";
    GLEnum4[GLEnum4["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum4[GLEnum4["RGB8I"] = 36239] = "RGB8I";
    GLEnum4[GLEnum4["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum4[GLEnum4["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum4[GLEnum4["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum4[GLEnum4["R8"] = 33321] = "R8";
    GLEnum4[GLEnum4["RG8"] = 33323] = "RG8";
    GLEnum4[GLEnum4["R16F"] = 33325] = "R16F";
    GLEnum4[GLEnum4["R32F"] = 33326] = "R32F";
    GLEnum4[GLEnum4["RG16F"] = 33327] = "RG16F";
    GLEnum4[GLEnum4["RG32F"] = 33328] = "RG32F";
    GLEnum4[GLEnum4["R8I"] = 33329] = "R8I";
    GLEnum4[GLEnum4["R8UI"] = 33330] = "R8UI";
    GLEnum4[GLEnum4["R16I"] = 33331] = "R16I";
    GLEnum4[GLEnum4["R16UI"] = 33332] = "R16UI";
    GLEnum4[GLEnum4["R32I"] = 33333] = "R32I";
    GLEnum4[GLEnum4["R32UI"] = 33334] = "R32UI";
    GLEnum4[GLEnum4["RG8I"] = 33335] = "RG8I";
    GLEnum4[GLEnum4["RG8UI"] = 33336] = "RG8UI";
    GLEnum4[GLEnum4["RG16I"] = 33337] = "RG16I";
    GLEnum4[GLEnum4["RG16UI"] = 33338] = "RG16UI";
    GLEnum4[GLEnum4["RG32I"] = 33339] = "RG32I";
    GLEnum4[GLEnum4["RG32UI"] = 33340] = "RG32UI";
    GLEnum4[GLEnum4["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum4[GLEnum4["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum4[GLEnum4["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum4[GLEnum4["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum4[GLEnum4["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    GLEnum4[GLEnum4["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum4[GLEnum4["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    GLEnum4[GLEnum4["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum4[GLEnum4["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum4[GLEnum4["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum4[GLEnum4["RG"] = 33319] = "RG";
    GLEnum4[GLEnum4["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum4[GLEnum4["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    GLEnum4[GLEnum4["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    GLEnum4[GLEnum4["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    GLEnum4[GLEnum4["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    GLEnum4[GLEnum4["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    GLEnum4[GLEnum4["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    GLEnum4[GLEnum4["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum4[GLEnum4["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum4[GLEnum4["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum4[GLEnum4["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum4[GLEnum4["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum4[GLEnum4["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum4[GLEnum4["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum4[GLEnum4["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum4[GLEnum4["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum4[GLEnum4["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum4[GLEnum4["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum4[GLEnum4["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum4[GLEnum4["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum4[GLEnum4["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum4[GLEnum4["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum4[GLEnum4["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum4[GLEnum4["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum4[GLEnum4["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    GLEnum4[GLEnum4["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum4[GLEnum4["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum4[GLEnum4["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum4[GLEnum4["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum4[GLEnum4["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum4[GLEnum4["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum4[GLEnum4["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum4[GLEnum4["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum4[GLEnum4["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    GLEnum4[GLEnum4["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum4[GLEnum4["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum4[GLEnum4["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum4[GLEnum4["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum4[GLEnum4["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum4[GLEnum4["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    GLEnum4[GLEnum4["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum4[GLEnum4["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum4[GLEnum4["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum4[GLEnum4["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum4[GLEnum4["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum4[GLEnum4["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum4[GLEnum4["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum4[GLEnum4["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum4[GLEnum4["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum4[GLEnum4["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    GLEnum4[GLEnum4["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum4[GLEnum4["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    GLEnum4[GLEnum4["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum4[GLEnum4["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum4[GLEnum4["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum4[GLEnum4["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum4[GLEnum4["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum4[GLEnum4["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum4[GLEnum4["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum4[GLEnum4["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum4[GLEnum4["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    GLEnum4[GLEnum4["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum4[GLEnum4["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum4[GLEnum4["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum4[GLEnum4["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum4[GLEnum4["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum4[GLEnum4["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum4[GLEnum4["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum4[GLEnum4["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum4[GLEnum4["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum4[GLEnum4["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum4[GLEnum4["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum4[GLEnum4["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum4[GLEnum4["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    GLEnum4[GLEnum4["COLOR"] = 6144] = "COLOR";
    GLEnum4[GLEnum4["DEPTH"] = 6145] = "DEPTH";
    GLEnum4[GLEnum4["STENCIL"] = 6146] = "STENCIL";
    GLEnum4[GLEnum4["MIN"] = 32775] = "MIN";
    GLEnum4[GLEnum4["MAX"] = 32776] = "MAX";
    GLEnum4[GLEnum4["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum4[GLEnum4["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum4[GLEnum4["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum4[GLEnum4["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum4[GLEnum4["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum4[GLEnum4["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum4[GLEnum4["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum4[GLEnum4["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum4[GLEnum4["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum4[GLEnum4["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum4[GLEnum4["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum4[GLEnum4["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    GLEnum4[GLEnum4["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    GLEnum4[GLEnum4["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    GLEnum4[GLEnum4["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum4[GLEnum4["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum4[GLEnum4["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum4[GLEnum4["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum4[GLEnum4["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum4[GLEnum4["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum4[GLEnum4["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum4[GLEnum4["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum4[GLEnum4["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum4[GLEnum4["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    GLEnum4[GLEnum4["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GLEnum4[GLEnum4["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    GLEnum4[GLEnum4["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    GLEnum4[GLEnum4["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    GLEnum4[GLEnum4["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    GLEnum4[GLEnum4["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    GLEnum4[GLEnum4["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    GLEnum4[GLEnum4["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    GLEnum4[GLEnum4["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
    GLEnum4[GLEnum4["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
    GLEnum4[GLEnum4["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
    GLEnum4[GLEnum4["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
    GLEnum4[GLEnum4["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
    GLEnum4[GLEnum4["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
    GLEnum4[GLEnum4["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
    GLEnum4[GLEnum4["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
    GLEnum4[GLEnum4["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
    GLEnum4[GLEnum4["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
    GLEnum4[GLEnum4["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
    GLEnum4[GLEnum4["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
    GLEnum4[GLEnum4["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
    GLEnum4[GLEnum4["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
    GLEnum4[GLEnum4["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
    GLEnum4[GLEnum4["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
    GLEnum4[GLEnum4["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
    GLEnum4[GLEnum4["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
    GLEnum4[GLEnum4["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
    GLEnum4[GLEnum4["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
    GLEnum4[GLEnum4["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
    GLEnum4[GLEnum4["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
    GLEnum4[GLEnum4["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
  })(GLEnum || (GLEnum = {}));

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    // TBD
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    // TBD
    [2930]: true,
    [3024]: true,
    [35725]: null,
    // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006]: null,
    [36007]: null,
    [34229]: null,
    [34964]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32926]: false,
    [32928]: false,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
    [2978]: [0, 0, 1024, 1024],
    [36389]: null,
    [36662]: null,
    [36663]: null,
    [35053]: null,
    [35055]: null,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var bindFramebuffer = (gl, value, key) => {
    const target2 = key === 36006 ? 36009 : 36008;
    return gl.bindFramebuffer(target2, value);
  };
  var bindBuffer = (gl, value, key) => {
    const bindingMap = {
      [34964]: 34962,
      [36662]: 36662,
      [36663]: 36663,
      [35053]: 35051,
      [35055]: 35052
    };
    const glTarget = bindingMap[key];
    gl.bindBuffer(glTarget, value);
  };
  function isArray2(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [35725]: (gl, value) => gl.useProgram(value),
    [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
    [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
    [34229]: (gl, value) => gl.bindVertexArray(value),
    // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006]: bindFramebuffer,
    [36010]: bindFramebuffer,
    // Buffers
    [34964]: bindBuffer,
    [36662]: bindBuffer,
    [36663]: bindBuffer,
    [35053]: bindBuffer,
    [35055]: bindBuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32926]: enable,
    [32928]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    // WEBGL2 EXTENSIONS
    // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
    [34383]: enable,
    // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
    // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
    // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
    // POLYGON_MODE_WEBGL  TODO - extension function needed
    [10754]: enable,
    // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
    [12288]: enable,
    [12289]: enable,
    [12290]: enable,
    [12291]: enable,
    [12292]: enable,
    [12293]: enable,
    [12294]: enable,
    [12295]: enable,
    // PIXEL PACK/UNPACK MODES
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    // Function-style setters
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      const separateModes = typeof args === "number" ? [args, args] : args;
      gl.blendEquationSeparate(...separateModes);
    },
    blendFunc: (gl, args) => {
      const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...separateFuncs);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(value[0], value[1] || false),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray2(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache3) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache3[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache3) => gl.blendEquationSeparate(getValue(32777, values, cache3), getValue(34877, values, cache3)),
    blendFunc: (gl, values, cache3) => gl.blendFuncSeparate(getValue(32969, values, cache3), getValue(32968, values, cache3), getValue(32971, values, cache3), getValue(32970, values, cache3)),
    polygonOffset: (gl, values, cache3) => gl.polygonOffset(getValue(32824, values, cache3), getValue(10752, values, cache3)),
    sampleCoverage: (gl, values, cache3) => gl.sampleCoverage(getValue(32938, values, cache3), getValue(32939, values, cache3)),
    stencilFuncFront: (gl, values, cache3) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache3), getValue(2967, values, cache3), getValue(2963, values, cache3)),
    stencilFuncBack: (gl, values, cache3) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache3), getValue(36003, values, cache3), getValue(36004, values, cache3)),
    stencilOpFront: (gl, values, cache3) => gl.stencilOpSeparate(1028, getValue(2964, values, cache3), getValue(2965, values, cache3), getValue(2966, values, cache3)),
    stencilOpBack: (gl, values, cache3) => gl.stencilOpSeparate(1029, getValue(34817, values, cache3), getValue(34818, values, cache3), getValue(34819, values, cache3))
  };
  var GL_HOOKED_SETTERS = {
    // GENERIC SETTERS
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, value) => update({
      [pname]: value
    }),
    // SPECIFIC SETTERS
    useProgram: (update, value) => update({
      [35725]: value
    }),
    bindRenderbuffer: (update, target2, value) => update({
      [36007]: value
    }),
    bindTransformFeedback: (update, target2, value) => update({
      [36389]: value
    }),
    bindVertexArray: (update, value) => update({
      [34229]: value
    }),
    bindFramebuffer: (update, target2, framebuffer) => {
      switch (target2) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({ [36006]: framebuffer });
        case 36008:
          return update({ [36010]: framebuffer });
        default:
          return null;
      }
    },
    bindBuffer: (update, target2, buffer) => {
      const pname = {
        [34962]: [34964],
        [36662]: [36662],
        [36663]: [36663],
        [35051]: [35053],
        [35052]: [35055]
      }[target2];
      if (pname) {
        return update({ [pname]: buffer });
      }
      return { valueChanged: true };
    },
    blendColor: (update, r3, g2, b2, a3) => update({
      [32773]: new Float32Array([r3, g2, b2, a3])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r3, g2, b2, a3) => update({
      [3106]: new Float32Array([r3, g2, b2, a3])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s3) => update({
      [2961]: s3
    }),
    colorMask: (update, r3, g2, b2, a3) => update({
      [3107]: [r3, g2, b2, a3]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert15) => update({
      [32938]: value,
      [32939]: invert15
    }),
    scissor: (update, x3, y3, width, height) => update({
      [3088]: new Int32Array([x3, y3, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x3, y3, width, height) => update({
      [2978]: [x3, y3, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };
  var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
    34016,
    36388,
    36387,
    35983,
    35368,
    34965,
    35739,
    35738,
    3074,
    34853,
    34854,
    34855,
    34856,
    34857,
    34858,
    34859,
    34860,
    34861,
    34862,
    34863,
    34864,
    34865,
    34866,
    34867,
    34868,
    35097,
    32873,
    35869,
    32874,
    34068
  ]);

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js
  function setGLParameters(gl, parameters2) {
    if (isObjectEmpty2(parameters2)) {
      return;
    }
    const compositeSetters = {};
    for (const key in parameters2) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, parameters2[key], glConstant);
        }
      }
    }
    const cache3 = gl.state && gl.state.cache;
    if (cache3) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, parameters2, cache3);
      }
    }
  }
  function getGLParameters(gl, parameters2 = GL_PARAMETER_DEFAULTS) {
    if (typeof parameters2 === "number") {
      const key = parameters2;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters2) ? parameters2 : Object.keys(parameters2);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetGLParameters(gl) {
    setGLParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function isObjectEmpty2(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js
  function deepArrayEqual(x3, y3) {
    if (x3 === y3) {
      return true;
    }
    const isArrayX = Array.isArray(x3) || ArrayBuffer.isView(x3);
    const isArrayY = Array.isArray(y3) || ArrayBuffer.isView(y3);
    if (isArrayX && isArrayY && x3.length === y3.length) {
      for (let i5 = 0; i5 < x3.length; ++i5) {
        if (x3[i5] !== y3[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js
  var WebGLStateTracker = class {
    static get(gl) {
      return gl.state;
    }
    gl;
    program = null;
    stateStack = [];
    enable = true;
    cache = null;
    log;
    initialized = false;
    constructor(gl, props) {
      this.gl = gl;
      this.log = props?.log || (() => {
      });
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push(values = {}) {
      this.stateStack.push({});
    }
    pop() {
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setGLParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    /**
     * Initialize WebGL state caching on a context
     * can be called multiple times to enable/disable
     *
     * @note After calling this function, context state will be cached
     * .push() and .pop() will be available for saving,
     * temporarily modifying, and then restoring state.
     */
    trackState(gl, options) {
      this.cache = options.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      if (this.initialized) {
        throw new Error("WebGLStateTracker");
      }
      this.initialized = true;
      this.gl.state = this;
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    /**
    // interceptor for context set functions - update our cache and our stack
    // values (Object) - the key values for this setter
     * @param values
     * @returns
     */
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
      for (const key in values) {
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return { valueChanged, oldValue };
    }
  };
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get(pname) {
      if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
        return originalGetterFunc(pname);
      }
      const glState = WebGLStateTracker.get(gl);
      if (!(pname in glState.cache)) {
        glState.cache[pname] = originalGetterFunc(pname);
      }
      return glState.enable ? (
        // Call the getter the params so that it can e.g. serve from a cache
        glState.cache[pname]
      ) : (
        // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
        originalGetterFunc(pname)
      );
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-from-cache`,
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    if (!gl[functionName]) {
      return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set10(...params) {
      const glState = WebGLStateTracker.get(gl);
      const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-to-cache`,
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      const glState = WebGLStateTracker.get(gl);
      if (glState.program !== handle) {
        originalUseProgram(handle);
        glState.program = handle;
      }
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js
  function createBrowserContext(canvas2, props, webglContextAttributes) {
    let errorMessage = "";
    const webglProps = {
      preserveDrawingBuffer: true,
      // failIfMajorPerformanceCaveat: true,
      ...webglContextAttributes
    };
    let gl = null;
    gl ||= canvas2.getContext("webgl2", webglProps);
    if (webglProps.failIfMajorPerformanceCaveat) {
      errorMessage ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.";
    }
    if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {
      webglProps.failIfMajorPerformanceCaveat = false;
      gl = canvas2.getContext("webgl2", webglProps);
      gl.luma ||= {};
      gl.luma.softwareRenderer = true;
    }
    if (!gl) {
      gl = canvas2.getContext("webgl", {});
      if (gl) {
        gl = null;
        errorMessage ||= "Your browser only supports WebGL1";
      }
    }
    if (!gl) {
      errorMessage ||= "Your browser does not support WebGL";
      throw new Error(`Failed to create WebGL context: ${errorMessage}`);
    }
    const { onContextLost, onContextRestored } = props;
    canvas2.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
    canvas2.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
    gl.luma ||= {};
    return gl;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js
  function getWebGLExtension(gl, name13, extensions) {
    if (extensions[name13] === void 0) {
      extensions[name13] = gl.getExtension(name13) || null;
    }
    return extensions[name13];
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js
  function getDeviceInfo(gl, extensions) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
    const ext = extensions.WEBGL_debug_renderer_info;
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    const version = gl.getParameter(7938);
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    const shadingLanguage = "glsl";
    const shadingLanguageVersion = 300;
    return {
      type: "webgl",
      gpu,
      gpuType,
      gpuBackend,
      vendor,
      renderer,
      version,
      shadingLanguage,
      shadingLanguageVersion
    };
  }
  function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
      return "nvidia";
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
      return "intel";
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
      return "apple";
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
      return "amd";
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "software";
    }
    return "unknown";
  }
  function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
      return "metal";
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
      return "opengl";
    }
    return "unknown";
  }
  function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "cpu";
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch (gpuVendor) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js
  function getGLFromVertexType(dataType) {
    switch (dataType) {
      case "uint8":
        return 5121;
      case "sint8":
        return 5120;
      case "unorm8":
        return 5121;
      case "snorm8":
        return 5120;
      case "uint16":
        return 5123;
      case "sint16":
        return 5122;
      case "unorm16":
        return 5123;
      case "snorm16":
        return 5122;
      case "uint32":
        return 5125;
      case "sint32":
        return 5124;
      case "float16":
        return 5131;
      case "float32":
        return 5126;
    }
    throw new Error(String(dataType));
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js
  var X_S3TC = "WEBGL_compressed_texture_s3tc";
  var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
  var X_RGTC = "EXT_texture_compression_rgtc";
  var X_BPTC = "EXT_texture_compression_bptc";
  var X_ETC2 = "WEBGL_compressed_texture_etc";
  var X_ASTC = "WEBGL_compressed_texture_astc";
  var X_ETC1 = "WEBGL_compressed_texture_etc1";
  var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
  var X_ATC = "WEBGL_compressed_texture_atc";
  var EXT_texture_norm16 = "EXT_texture_norm16";
  var EXT_render_snorm = "EXT_render_snorm";
  var EXT_color_buffer_float = "EXT_color_buffer_float";
  var TEXTURE_FEATURES = {
    "float32-renderable-webgl": ["EXT_color_buffer_float"],
    "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
    "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
    "snorm8-renderable-webgl": [EXT_render_snorm],
    "norm16-renderable-webgl": [EXT_texture_norm16],
    "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
    "float32-filterable": ["OES_texture_float_linear"],
    "float16-filterable-webgl": ["OES_texture_half_float_linear"],
    "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
    "texture-blend-float-webgl": ["EXT_float_blend"],
    "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
    // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
    // 'texture-compression-bc3-webgl': [X_S3TC],
    "texture-compression-bc5-webgl": [X_RGTC],
    "texture-compression-bc7-webgl": [X_BPTC],
    "texture-compression-etc2": [X_ETC2],
    "texture-compression-astc": [X_ASTC],
    "texture-compression-etc1-webgl": [X_ETC1],
    "texture-compression-pvrtc-webgl": [X_PVRTC],
    "texture-compression-atc-webgl": [X_ATC]
  };
  function isTextureFeature(feature) {
    return feature in TEXTURE_FEATURES;
  }
  function checkTextureFeature(gl, feature, extensions) {
    const textureExtensions = TEXTURE_FEATURES[feature] || [];
    return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
  }
  var WEBGL_TEXTURE_FORMATS = {
    // 8-bit formats
    "r8unorm": { gl: 33321, rb: true },
    "r8snorm": { gl: 36756 },
    "r8uint": { gl: 33330, rb: true },
    "r8sint": { gl: 33329, rb: true },
    // 16-bit formats
    "rg8unorm": { gl: 33323, rb: true },
    "rg8snorm": { gl: 36757 },
    "rg8uint": { gl: 33336, rb: true },
    "rg8sint": { gl: 33335, rb: true },
    "r16uint": { gl: 33332, rb: true },
    "r16sint": { gl: 33331, rb: true },
    "r16float": { gl: 33325, rb: true },
    "r16unorm-webgl": { gl: 33322, rb: true },
    "r16snorm-webgl": { gl: 36760 },
    // Packed 16-bit formats
    "rgba4unorm-webgl": { gl: 32854, rb: true },
    "rgb565unorm-webgl": { gl: 36194, rb: true },
    "rgb5a1unorm-webgl": { gl: 32855, rb: true },
    // 24-bit formats
    "rgb8unorm-webgl": { gl: 32849 },
    "rgb8snorm-webgl": { gl: 36758 },
    // 32-bit formats  
    "rgba8unorm": { gl: 32856 },
    "rgba8unorm-srgb": { gl: 35907 },
    "rgba8snorm": { gl: 36759 },
    "rgba8uint": { gl: 36220 },
    "rgba8sint": { gl: 36238 },
    // reverse colors, webgpu only
    "bgra8unorm": {},
    "bgra8unorm-srgb": {},
    "rg16uint": { gl: 33338 },
    "rg16sint": { gl: 33337 },
    "rg16float": { gl: 33327, rb: true },
    "rg16unorm-webgl": { gl: 33324 },
    "rg16snorm-webgl": { gl: 36761 },
    "r32uint": { gl: 33334, rb: true },
    "r32sint": { gl: 33333, rb: true },
    "r32float": { gl: 33326 },
    // Packed 32-bit formats
    "rgb9e5ufloat": { gl: 35901 },
    // , filter: true},
    "rg11b10ufloat": { gl: 35898, rb: true },
    "rgb10a2unorm": { gl: 32857, rb: true },
    "rgb10a2uint-webgl": { gl: 36975, rb: true },
    // 48-bit formats
    "rgb16unorm-webgl": { gl: 32852 },
    // rgb not renderable
    "rgb16snorm-webgl": { gl: 36762 },
    // rgb not renderable
    // 64-bit formats
    "rg32uint": { gl: 33340, rb: true },
    "rg32sint": { gl: 33339, rb: true },
    "rg32float": { gl: 33328, rb: true },
    "rgba16uint": { gl: 36214, rb: true },
    "rgba16sint": { gl: 36232, rb: true },
    "rgba16float": { gl: 34842 },
    "rgba16unorm-webgl": { gl: 32859, rb: true },
    "rgba16snorm-webgl": { gl: 36763 },
    // 96-bit formats (deprecated!)
    "rgb32float-webgl": { gl: 34837, x: EXT_color_buffer_float, dataFormat: 6407, types: [5126] },
    // 128-bit formats
    "rgba32uint": { gl: 36208, rb: true },
    "rgba32sint": { gl: 36226, rb: true },
    "rgba32float": { gl: 34836, rb: true },
    // Depth and stencil formats
    "stencil8": { gl: 36168, rb: true },
    // 8 stencil bits
    "depth16unorm": { gl: 33189, dataFormat: 6402, types: [5123], rb: true },
    // 16 depth bits
    "depth24plus": { gl: 33190, dataFormat: 6402, types: [5125] },
    "depth32float": { gl: 36012, dataFormat: 6402, types: [5126], rb: true },
    // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
    "depth24plus-stencil8": { gl: 35056, rb: true, depthTexture: true, dataFormat: 34041, types: [34042] },
    // "depth32float-stencil8" feature - TODO below is render buffer only?
    "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: true },
    // BC compressed formats: check device.features.has("texture-compression-bc");
    "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC },
    "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB },
    "bc1-rgba-unorm": { gl: 33777, x: X_S3TC },
    "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB },
    "bc2-rgba-unorm": { gl: 33778, x: X_S3TC },
    "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB },
    "bc3-rgba-unorm": { gl: 33779, x: X_S3TC },
    "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB },
    "bc4-r-unorm": { gl: 36283, x: X_RGTC },
    "bc4-r-snorm": { gl: 36284, x: X_RGTC },
    "bc5-rg-unorm": { gl: 36285, x: X_RGTC },
    "bc5-rg-snorm": { gl: 36286, x: X_RGTC },
    "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC },
    "bc6h-rgb-float": { gl: 36494, x: X_BPTC },
    "bc7-rgba-unorm": { gl: 36492, x: X_BPTC },
    "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC },
    // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
    // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
    "etc2-rgb8unorm": { gl: 37492 },
    "etc2-rgb8unorm-srgb": { gl: 37494 },
    "etc2-rgb8a1unorm": { gl: 37496 },
    "etc2-rgb8a1unorm-srgb": { gl: 37497 },
    "etc2-rgba8unorm": { gl: 37493 },
    "etc2-rgba8unorm-srgb": { gl: 37495 },
    "eac-r11unorm": { gl: 37488 },
    "eac-r11snorm": { gl: 37489 },
    "eac-rg11unorm": { gl: 37490 },
    "eac-rg11snorm": { gl: 37491 },
    // X_ASTC compressed formats: device.features.has("texture-compression-astc")
    "astc-4x4-unorm": { gl: 37808 },
    "astc-4x4-unorm-srgb": { gl: 37840 },
    "astc-5x4-unorm": { gl: 37809 },
    "astc-5x4-unorm-srgb": { gl: 37841 },
    "astc-5x5-unorm": { gl: 37810 },
    "astc-5x5-unorm-srgb": { gl: 37842 },
    "astc-6x5-unorm": { gl: 37811 },
    "astc-6x5-unorm-srgb": { gl: 37843 },
    "astc-6x6-unorm": { gl: 37812 },
    "astc-6x6-unorm-srgb": { gl: 37844 },
    "astc-8x5-unorm": { gl: 37813 },
    "astc-8x5-unorm-srgb": { gl: 37845 },
    "astc-8x6-unorm": { gl: 37814 },
    "astc-8x6-unorm-srgb": { gl: 37846 },
    "astc-8x8-unorm": { gl: 37815 },
    "astc-8x8-unorm-srgb": { gl: 37847 },
    "astc-10x5-unorm": { gl: 37819 },
    "astc-10x5-unorm-srgb": { gl: 37851 },
    "astc-10x6-unorm": { gl: 37817 },
    "astc-10x6-unorm-srgb": { gl: 37849 },
    "astc-10x8-unorm": { gl: 37818 },
    "astc-10x8-unorm-srgb": { gl: 37850 },
    "astc-10x10-unorm": { gl: 37819 },
    "astc-10x10-unorm-srgb": { gl: 37851 },
    "astc-12x10-unorm": { gl: 37820 },
    "astc-12x10-unorm-srgb": { gl: 37852 },
    "astc-12x12-unorm": { gl: 37821 },
    "astc-12x12-unorm-srgb": { gl: 37853 },
    // WEBGL_compressed_texture_pvrtc
    "pvrtc-rgb4unorm-webgl": { gl: 35840 },
    "pvrtc-rgba4unorm-webgl": { gl: 35842 },
    "pvrtc-rbg2unorm-webgl": { gl: 35841 },
    "pvrtc-rgba2unorm-webgl": { gl: 35843 },
    // WEBGL_compressed_texture_etc1
    "etc1-rbg-unorm-webgl": { gl: 36196 },
    // WEBGL_compressed_texture_atc
    "atc-rgb-unorm-webgl": { gl: 35986 },
    "atc-rgba-unorm-webgl": { gl: 35986 },
    "atc-rgbai-unorm-webgl": { gl: 34798 }
  };
  function getTextureFormatCapabilitiesWebGL(gl, formatSupport, extensions) {
    let supported = formatSupport.create;
    const webglFormatInfo = WEBGL_TEXTURE_FORMATS[formatSupport.format];
    if (webglFormatInfo?.gl === void 0) {
      supported = false;
    }
    if (webglFormatInfo?.x) {
      supported = supported && Boolean(getWebGLExtension(gl, webglFormatInfo.x, extensions));
    }
    return {
      format: formatSupport.format,
      // @ts-ignore
      create: supported && formatSupport.create,
      // @ts-ignore
      render: supported && formatSupport.render,
      // @ts-ignore
      filter: supported && formatSupport.filter,
      // @ts-ignore
      blend: supported && formatSupport.blend,
      // @ts-ignore
      store: supported && formatSupport.store
    };
  }
  function getTextureFormatWebGL(format) {
    const formatData = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = convertTextureFormatToGL(format);
    const decoded = decodeTextureFormat(format);
    return {
      internalFormat: webglFormat,
      format: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.channels, decoded.integer, decoded.normalized, webglFormat),
      // depth formats don't have a type
      type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121,
      compressed: decoded.compressed || false
    };
  }
  function getDepthStencilAttachmentWebGL(format) {
    const formatInfo = decodeTextureFormat(format);
    switch (formatInfo.attachment) {
      case "depth":
        return 36096;
      case "stencil":
        return 36128;
      case "depth-stencil":
        return 33306;
      default:
        throw new Error(`Not a depth stencil format: ${format}`);
    }
  }
  function getWebGLPixelDataFormat(channels, integer, normalized, format) {
    if (format === 6408 || format === 6407) {
      return format;
    }
    switch (channels) {
      case "r":
        return integer && !normalized ? 36244 : 6403;
      case "rg":
        return integer && !normalized ? 33320 : 33319;
      case "rgb":
        return integer && !normalized ? 36248 : 6407;
      case "rgba":
        return integer && !normalized ? 36249 : 6408;
      case "bgra":
        throw new Error("bgra pixels not supported by WebGL");
      default:
        return 6408;
    }
  }
  function convertTextureFormatToGL(format) {
    const formatInfo = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = formatInfo?.gl;
    if (webglFormat === void 0) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js
  var WEBGL_FEATURES = {
    // optional WebGPU features
    "depth-clip-control": "EXT_depth_clamp",
    // TODO these seem subtly different
    // 'timestamp-query' // GPUQueryType "timestamp-query"
    // "indirect-first-instance"
    // Textures are handled by getTextureFeatures()
    // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
    // optional WebGL features
    "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
    "compilation-status-async-webgl": "KHR_parallel_shader_compile",
    "polygon-mode-webgl": "WEBGL_polygon_mode",
    "provoking-vertex-webgl": "WEBGL_provoking_vertex",
    "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
    "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
    "shader-conservative-depth-webgl": "EXT_conservative_depth"
    // Textures are handled by getTextureFeatures()
  };
  var WebGLDeviceFeatures = class extends DeviceFeatures {
    gl;
    extensions;
    testedFeatures = /* @__PURE__ */ new Set();
    constructor(gl, extensions, disabledFeatures) {
      super([], disabledFeatures);
      this.gl = gl;
      this.extensions = extensions;
      getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
    }
    *[Symbol.iterator]() {
      const features = this.getFeatures();
      for (const feature of features) {
        if (this.has(feature)) {
          yield feature;
        }
      }
      return [];
    }
    has(feature) {
      if (this.disabledFeatures?.[feature]) {
        return false;
      }
      if (!this.testedFeatures.has(feature)) {
        this.testedFeatures.add(feature);
        if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
          this.features.add(feature);
        }
        if (this.getWebGLFeature(feature)) {
          this.features.add(feature);
        }
      }
      return this.features.has(feature);
    }
    // FOR DEVICE
    initializeFeatures() {
      const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
      for (const feature of features) {
        this.has(feature);
      }
    }
    // IMPLEMENTATION
    getFeatures() {
      return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
    }
    /** Extract all WebGL features */
    getWebGLFeature(feature) {
      const featureInfo = WEBGL_FEATURES[feature];
      const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
      return isSupported;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js
  var WebGLDeviceLimits = class extends DeviceLimits {
    get maxTextureDimension1D() {
      return 0;
    }
    // WebGL does not support 1D textures
    get maxTextureDimension2D() {
      return this.getParameter(3379);
    }
    get maxTextureDimension3D() {
      return this.getParameter(32883);
    }
    get maxTextureArrayLayers() {
      return this.getParameter(35071);
    }
    get maxBindGroups() {
      return 0;
    }
    get maxDynamicUniformBuffersPerPipelineLayout() {
      return 0;
    }
    // TBD
    get maxDynamicStorageBuffersPerPipelineLayout() {
      return 0;
    }
    // TBD
    get maxSampledTexturesPerShaderStage() {
      return this.getParameter(35660);
    }
    // ) TBD
    get maxSamplersPerShaderStage() {
      return this.getParameter(35661);
    }
    get maxStorageBuffersPerShaderStage() {
      return 0;
    }
    // TBD
    get maxStorageTexturesPerShaderStage() {
      return 0;
    }
    // TBD
    get maxUniformBuffersPerShaderStage() {
      return this.getParameter(35375);
    }
    get maxUniformBufferBindingSize() {
      return this.getParameter(35376);
    }
    get maxStorageBufferBindingSize() {
      return 0;
    }
    get minUniformBufferOffsetAlignment() {
      return this.getParameter(35380);
    }
    get minStorageBufferOffsetAlignment() {
      return 0;
    }
    get maxVertexBuffers() {
      return 16;
    }
    // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
    get maxVertexAttributes() {
      return this.getParameter(34921);
    }
    get maxVertexBufferArrayStride() {
      return 2048;
    }
    // TBD, this is just the default value from WebGPU
    get maxInterStageShaderComponents() {
      return this.getParameter(35659);
    }
    get maxComputeWorkgroupStorageSize() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeInvocationsPerWorkgroup() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeX() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeY() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeZ() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupsPerDimension() {
      return 0;
    }
    // WebGL does not support compute shaders
    // PRIVATE
    gl;
    limits = {};
    constructor(gl) {
      super();
      this.gl = gl;
    }
    getParameter(parameter) {
      if (this.limits[parameter] === void 0) {
        this.limits[parameter] = this.gl.getParameter(parameter);
      }
      return this.limits[parameter] || 0;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js
  var WEBGLFramebuffer = class extends Framebuffer {
    device;
    gl;
    handle;
    colorAttachments = [];
    depthStencilAttachment = null;
    constructor(device, props) {
      super(device, props);
      const isDefaultFramebuffer = props.handle === null;
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
      if (!isDefaultFramebuffer) {
        device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
        this.autoCreateAttachmentTextures();
        this.updateAttachments();
      }
    }
    /** destroys any auto created resources etc. */
    destroy() {
      super.destroy();
      if (!this.destroyed && this.handle !== null) {
        this.gl.deleteFramebuffer(this.handle);
      }
    }
    updateAttachments() {
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (let i5 = 0; i5 < this.colorAttachments.length; ++i5) {
        const attachment = this.colorAttachments[i5];
        if (attachment) {
          const attachmentPoint = 36064 + i5;
          this._attachTextureView(attachmentPoint, attachment);
        }
      }
      if (this.depthStencilAttachment) {
        const attachmentPoint = getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format);
        this._attachTextureView(attachmentPoint, this.depthStencilAttachment);
      }
      if (this.device.props.debug) {
        const status = this.gl.checkFramebufferStatus(36160);
        if (status !== 36053) {
          throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle);
    }
    // PRIVATE
    /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
    // protected override createDepthStencilTexture(format: TextureFormat): Texture {
    //   // return new WEBGLRenderbuffer(this.device, {
    //   return new WEBGLTexture(this.device, {
    //     id: `${this.id}-depth-stencil`,
    //     format,
    //     width: this.width,
    //     height: this.height,
    //     mipmaps: false
    //   });
    // }
    /**
     * @param attachment
     * @param texture
     * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
     * @param level = 0 - mipmapLevel
     */
    _attachTextureView(attachment, textureView) {
      const { gl } = this.device;
      const { texture } = textureView;
      const level = textureView.props.baseMipLevel;
      const layer = textureView.props.baseArrayLayer;
      gl.bindTexture(texture.glTarget, texture.handle);
      switch (texture.glTarget) {
        case 35866:
        case 32879:
          gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          throw new Error("Illegal texture type");
      }
      gl.bindTexture(texture.glTarget, null);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    switch (status) {
      case 36053:
        return "success";
      case 36054:
        return "Mismatched attachments";
      case 36055:
        return "No attachments";
      case 36057:
        return "Height/width mismatch";
      case 36061:
        return "Unsupported or split attachments";
      case 36182:
        return "Samples mismatch";
      default:
        return `${status}`;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js
  var WebGLCanvasContext = class extends CanvasContext {
    device;
    format = "rgba8unorm";
    depthStencilFormat = "depth24plus";
    presentationSize;
    _framebuffer = null;
    get [Symbol.toStringTag]() {
      return "WebGLCanvasContext";
    }
    constructor(device, props) {
      super(props);
      this.device = device;
      this.presentationSize = [-1, -1];
      this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
      this.update();
    }
    getCurrentFramebuffer() {
      this.update();
      this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
      return this._framebuffer;
    }
    /** Resizes and updates render targets if necessary */
    update() {
      const size = this.getPixelSize();
      const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
      if (sizeChanged) {
        this.presentationSize = size;
        this.resize();
      }
    }
    /**
     * Resize the canvas' drawing buffer.
     *
     * Can match the canvas CSS size, and optionally also consider devicePixelRatio
     * Can be called every frame
     *
     * Regardless of size, the drawing buffer will always be scaled to the viewport, but
     * for best visual results, usually set to either:
     *  canvas CSS width x canvas CSS height
     *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
     * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
     */
    resize(options) {
      if (!this.device.gl)
        return;
      if (this.canvas) {
        const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
        this.setDevicePixelRatio(devicePixelRatio, options);
        return;
      }
    }
    commit() {
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/utils/load-script.js
  async function loadScript(scriptUrl, scriptId) {
    const head = document.getElementsByTagName("head")[0];
    if (!head) {
      throw new Error("loadScript");
    }
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    return new Promise((resolve2, reject) => {
      script.onload = resolve2;
      script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
      head.appendChild(script);
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/spector.js
  var LOG_LEVEL = 1;
  var spector = null;
  var initialized = false;
  var DEFAULT_SPECTOR_PROPS = {
    debugSpectorJS: log2.get("debug-spectorjs"),
    // https://github.com/BabylonJS/Spector.js#basic-usage
    // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
    // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
    debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
    gl: void 0
  };
  async function loadSpectorJS(props) {
    if (!globalThis.SPECTOR) {
      try {
        await loadScript(props.debugSpectorJSUrl || DEFAULT_SPECTOR_PROPS.debugSpectorJSUrl);
      } catch (error) {
        log2.warn(String(error));
      }
    }
  }
  function initializeSpectorJS(props) {
    props = { ...DEFAULT_SPECTOR_PROPS, ...props };
    if (!props.debugSpectorJS) {
      return null;
    }
    if (!spector && globalThis.SPECTOR && !globalThis.luma?.spector) {
      log2.probe(LOG_LEVEL, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
      const { Spector: SpectorJS } = globalThis.SPECTOR;
      spector = new SpectorJS();
      if (globalThis.luma) {
        globalThis.luma.spector = spector;
      }
    }
    if (!spector) {
      return null;
    }
    if (!initialized) {
      initialized = true;
      spector.spyCanvases();
      spector?.onCaptureStarted.add((capture) => log2.info("Spector capture started:", capture)());
      spector?.onCapture.add((capture) => {
        log2.info("Spector capture complete:", capture)();
        spector?.getResultUI();
        spector?.resultView.display();
        spector?.resultView.addCapture(capture);
      });
    }
    if (props.gl) {
      const gl = props.gl;
      const device = gl.device;
      spector?.startCapture(props.gl, 500);
      gl.device = device;
      new Promise((resolve2) => setTimeout(resolve2, 2e3)).then((_2) => {
        log2.info("Spector capture stopped after 2 seconds")();
        spector?.stopCapture();
      });
    }
    return spector;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
  var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
  function getWebGLContextData(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
  }
  async function loadWebGLDeveloperTools() {
    if (isBrowser2() && !globalThis.WebGLDebugUtils) {
      globalThis.global = globalThis.global || globalThis;
      globalThis.global.module = {};
      await loadScript(WEBGL_DEBUG_CDN_URL);
    }
  }
  function makeDebugContext(gl, props = {}) {
    return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
  }
  function getRealContext(gl) {
    const data = getWebGLContextData(gl);
    return data.realContext ? data.realContext : gl;
  }
  function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
      log2.warn("webgl-debug not loaded")();
      return gl;
    }
    const data = getWebGLContextData(gl);
    if (data.debugContext) {
      return data.debugContext;
    }
    globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
    for (const key in GLEnum) {
      if (!(key in glDebug) && typeof GLEnum[key] === "number") {
        glDebug[key] = GLEnum[key];
      }
    }
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    return debugContext;
  }
  function getFunctionString(functionName, functionArgs) {
    functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
    return `gl.${functionName}(${args})`;
  }
  function onGLError(props, err, functionName, args) {
    args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
    log2.error(message2)();
    debugger;
  }
  function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = "";
    if (log2.level >= 1) {
      functionString = getFunctionString(functionName, functionArgs);
      if (props.traceWebGL) {
        log2.log(1, functionString)();
      }
    }
    for (const arg of functionArgs) {
      if (arg === void 0) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        debugger;
      }
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/utils/uid.js
  var uidCounters3 = {};
  function uid3(id = "id") {
    uidCounters3[id] = uidCounters3[id] || 1;
    const count3 = uidCounters3[id]++;
    return `${id}-${count3}`;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js
  var WEBGLBuffer = class extends Buffer2 {
    device;
    gl;
    handle;
    /** Target in OpenGL defines the type of buffer */
    glTarget;
    /** Usage is a hint on how frequently the buffer will be updates */
    glUsage;
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    glIndexType = 5123;
    /** Number of bytes allocated on the GPU for this buffer */
    byteLength;
    /** Number of bytes used */
    bytesUsed;
    constructor(device, props = {}) {
      super(device, props);
      this.device = device;
      this.gl = this.device.gl;
      const handle = typeof props === "object" ? props.handle : void 0;
      this.handle = handle || this.gl.createBuffer();
      device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
      this.glTarget = getWebGLTarget(this.props.usage);
      this.glUsage = getWebGLUsage(this.props.usage);
      this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
      if (props.data) {
        this._initWithData(props.data, props.byteOffset, props.byteLength);
      } else {
        this._initWithByteLength(props.byteLength || 0);
      }
    }
    // PRIVATE METHODS
    /** Allocate a new buffer and initialize to contents of typed array */
    _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, byteLength, this.glUsage);
      this.gl.bufferSubData(glTarget, byteOffset, data);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(data, byteOffset, byteLength);
      this.trackAllocatedMemory(byteLength);
    }
    // Allocate a GPU buffer of specified size.
    _initWithByteLength(byteLength) {
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, data, this.glUsage);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(null, 0, byteLength);
      this.trackAllocatedMemory(byteLength);
      return this;
    }
    destroy() {
      if (!this.destroyed && this.handle) {
        this.removeStats();
        this.trackDeallocatedMemory();
        this.gl.deleteBuffer(this.handle);
        this.destroyed = true;
        this.handle = null;
      }
    }
    write(data, byteOffset = 0) {
      const srcOffset = 0;
      const byteLength = void 0;
      const glTarget = 36663;
      this.gl.bindBuffer(glTarget, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(glTarget, byteOffset, data);
      }
      this.gl.bindBuffer(glTarget, null);
      this._setDebugData(data, byteOffset, data.byteLength);
    }
    /** Asynchronously read data from the buffer */
    async readAsync(byteOffset = 0, byteLength) {
      return this.readSyncWebGL(byteOffset, byteLength);
    }
    /** Synchronously read data from the buffer. WebGL only. */
    readSyncWebGL(byteOffset = 0, byteLength) {
      byteLength = byteLength ?? this.byteLength - byteOffset;
      const data = new Uint8Array(byteLength);
      const dstOffset = 0;
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
      this.gl.bindBuffer(36662, null);
      this._setDebugData(data, byteOffset, byteLength);
      return data;
    }
  };
  function getWebGLTarget(usage) {
    if (usage & Buffer2.INDEX) {
      return 34963;
    }
    if (usage & Buffer2.VERTEX) {
      return 34962;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35345;
    }
    return 34962;
  }
  function getWebGLUsage(usage) {
    if (usage & Buffer2.INDEX) {
      return 35044;
    }
    if (usage & Buffer2.VERTEX) {
      return 35044;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35048;
    }
    return 35044;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js
  function parseShaderCompilerLog(errLog) {
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines) {
      if (line.length <= 1) {
        continue;
      }
      const segments = line.split(":");
      if (segments.length === 2) {
        const [messageType2, message2] = segments;
        messages.push({
          message: message2.trim(),
          type: getMessageType(messageType2),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [messageType, linePosition, lineNumber, ...rest] = segments;
      let lineNum = parseInt(lineNumber, 10);
      if (isNaN(lineNum)) {
        lineNum = 0;
      }
      let linePos = parseInt(linePosition, 10);
      if (isNaN(linePos)) {
        linePos = 0;
      }
      messages.push({
        message: rest.join(":").trim(),
        type: getMessageType(messageType),
        lineNum,
        linePos
        // TODO
      });
    }
    return messages;
  }
  function getMessageType(messageType) {
    const MESSAGE_TYPES = ["warning", "error", "info"];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js
  var WEBGLShader = class extends Shader {
    device;
    handle;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      switch (this.props.stage) {
        case "vertex":
          this.handle = this.props.handle || this.device.gl.createShader(35633);
          break;
        case "fragment":
          this.handle = this.props.handle || this.device.gl.createShader(35632);
          break;
        default:
          throw new Error(this.props.stage);
      }
      this._compile(this.source);
    }
    destroy() {
      if (this.handle) {
        this.removeStats();
        this.device.gl.deleteShader(this.handle);
        this.destroyed = true;
      }
    }
    get asyncCompilationStatus() {
      return this._waitForCompilationComplete().then(() => this.compilationStatus);
    }
    async getCompilationInfo() {
      await this._waitForCompilationComplete();
      return this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
      const shaderLog = this.device.gl.getShaderInfoLog(this.handle);
      return shaderLog ? parseShaderCompilerLog(shaderLog) : [];
    }
    getTranslatedSource() {
      const extensions = this.device.getExtension("WEBGL_debug_shaders");
      const ext = extensions.WEBGL_debug_shaders;
      return ext?.getTranslatedShaderSource(this.handle) || null;
    }
    // PRIVATE METHODS
    /** Compile a shader and get compilation status */
    async _compile(source3) {
      source3 = source3.startsWith("#version ") ? source3 : `#version 300 es
${source3}`;
      const { gl } = this.device;
      gl.shaderSource(this.handle, source3);
      gl.compileShader(this.handle);
      if (!this.device.props.debug) {
        this.compilationStatus = "pending";
        return;
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        this._getCompilationStatus();
        this.debugShader();
        if (this.compilationStatus === "error") {
          throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
        }
        return;
      }
      log2.once(1, "Shader compilation is asynchronous")();
      await this._waitForCompilationComplete();
      log2.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
      this._getCompilationStatus();
      this.debugShader();
    }
    /** Use KHR_parallel_shader_compile extension if available */
    async _waitForCompilationComplete() {
      const waitMs = async (ms) => await new Promise((resolve2) => setTimeout(resolve2, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getShaderParameter(this.handle, 37297);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */
    _getCompilationStatus() {
      this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js
  function withDeviceAndGLParameters(device, parameters2, glParameters, func) {
    if (isObjectEmpty3(parameters2)) {
      return func(device);
    }
    const webglDevice = device;
    webglDevice.pushState();
    try {
      setDeviceParameters(device, parameters2);
      setGLParameters(webglDevice.gl, glParameters);
      return func(device);
    } finally {
      webglDevice.popState();
    }
  }
  function setDeviceParameters(device, parameters2) {
    const webglDevice = device;
    const { gl } = webglDevice;
    if (parameters2.cullMode) {
      switch (parameters2.cullMode) {
        case "none":
          gl.disable(2884);
          break;
        case "front":
          gl.enable(2884);
          gl.cullFace(1028);
          break;
        case "back":
          gl.enable(2884);
          gl.cullFace(1029);
          break;
      }
    }
    if (parameters2.frontFace) {
      gl.frontFace(map2("frontFace", parameters2.frontFace, {
        ccw: 2305,
        cw: 2304
      }));
    }
    if (parameters2.unclippedDepth) {
      if (device.features.has("depth-clip-control")) {
        gl.enable(34383);
      }
    }
    if (parameters2.depthBias !== void 0) {
      gl.enable(32823);
      gl.polygonOffset(parameters2.depthBias, parameters2.depthBiasSlopeScale || 0);
    }
    if (parameters2.provokingVertex) {
      if (device.features.has("provoking-vertex-webgl")) {
        const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
        const ext = extensions.WEBGL_provoking_vertex;
        const vertex5 = map2("provokingVertex", parameters2.provokingVertex, {
          first: 36429,
          last: 36430
        });
        ext?.provokingVertexWEBGL(vertex5);
      }
    }
    if (parameters2.polygonMode || parameters2.polygonOffsetLine) {
      if (device.features.has("polygon-mode-webgl")) {
        if (parameters2.polygonMode) {
          const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
          const ext = extensions.WEBGL_polygon_mode;
          const mode = map2("polygonMode", parameters2.polygonMode, {
            fill: 6914,
            line: 6913
          });
          ext?.polygonModeWEBGL(1028, mode);
          ext?.polygonModeWEBGL(1029, mode);
        }
        if (parameters2.polygonOffsetLine) {
          gl.enable(10754);
        }
      }
    }
    if (device.features.has("shader-clip-cull-distance-webgl")) {
      if (parameters2.clipDistance0) {
        gl.enable(12288);
      }
      if (parameters2.clipDistance1) {
        gl.enable(12289);
      }
      if (parameters2.clipDistance2) {
        gl.enable(12290);
      }
      if (parameters2.clipDistance3) {
        gl.enable(12291);
      }
      if (parameters2.clipDistance4) {
        gl.enable(12292);
      }
      if (parameters2.clipDistance5) {
        gl.enable(12293);
      }
      if (parameters2.clipDistance6) {
        gl.enable(12294);
      }
      if (parameters2.clipDistance7) {
        gl.enable(12295);
      }
    }
    if (parameters2.depthWriteEnabled !== void 0) {
      gl.depthMask(mapBoolean("depthWriteEnabled", parameters2.depthWriteEnabled));
    }
    if (parameters2.depthCompare) {
      parameters2.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
      gl.depthFunc(convertCompareFunction("depthCompare", parameters2.depthCompare));
    }
    if (parameters2.stencilWriteMask) {
      const mask = parameters2.stencilWriteMask;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, mask);
    }
    if (parameters2.stencilReadMask) {
      log2.warn("stencilReadMask not supported under WebGL");
    }
    if (parameters2.stencilCompare) {
      const mask = parameters2.stencilReadMask || 4294967295;
      const glValue = convertCompareFunction("depthCompare", parameters2.stencilCompare);
      parameters2.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
      gl.stencilFuncSeparate(1028, glValue, 0, mask);
      gl.stencilFuncSeparate(1029, glValue, 0, mask);
    }
    if (parameters2.stencilPassOperation && parameters2.stencilFailOperation && parameters2.stencilDepthFailOperation) {
      const dppass = convertStencilOperation("stencilPassOperation", parameters2.stencilPassOperation);
      const sfail = convertStencilOperation("stencilFailOperation", parameters2.stencilFailOperation);
      const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters2.stencilDepthFailOperation);
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
    }
    switch (parameters2.blend) {
      case true:
        gl.enable(3042);
        break;
      case false:
        gl.disable(3042);
        break;
      default:
    }
    if (parameters2.blendColorOperation || parameters2.blendAlphaOperation) {
      const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters2.blendColorOperation || "add");
      const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters2.blendAlphaOperation || "add");
      gl.blendEquationSeparate(colorEquation, alphaEquation);
      const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters2.blendColorSrcFactor || "one");
      const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters2.blendColorDstFactor || "zero");
      const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters2.blendAlphaSrcFactor || "one");
      const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters2.blendAlphaDstFactor || "zero");
      gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
  }
  function convertCompareFunction(parameter, value) {
    return map2(parameter, value, {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    });
  }
  function convertStencilOperation(parameter, value) {
    return map2(parameter, value, {
      keep: 7680,
      zero: 0,
      replace: 7681,
      invert: 5386,
      "increment-clamp": 7682,
      "decrement-clamp": 7683,
      "increment-wrap": 34055,
      "decrement-wrap": 34056
    });
  }
  function convertBlendOperationToEquation(parameter, value) {
    return map2(parameter, value, {
      add: 32774,
      subtract: 32778,
      "reverse-subtract": 32779,
      min: 32775,
      max: 32776
    });
  }
  function convertBlendFactorToFunction(parameter, value) {
    return map2(parameter, value, {
      one: 1,
      zero: 0,
      "src-color": 768,
      "one-minus-src-color": 769,
      "dst-color": 774,
      "one-minus-dst-color": 775,
      "src-alpha": 770,
      "one-minus-src-alpha": 771,
      "dst-alpha": 772,
      "one-minus-dst-alpha": 773,
      "src-alpha-saturated": 776,
      "constant-color": 32769,
      "one-minus-constant-color": 32770,
      "constant-alpha": 32771,
      "one-minus-constant-alpha": 32772
    });
  }
  function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
  }
  function map2(parameter, value, valueMap) {
    if (!(value in valueMap)) {
      throw new Error(message(parameter, value));
    }
    return valueMap[value];
  }
  function mapBoolean(parameter, value) {
    return value;
  }
  function isObjectEmpty3(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js
  function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
      params[10242] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
      params[10243] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
      params[32882] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
      params[10240] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
      params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
    }
    if (props.lodMinClamp !== void 0) {
      params[33082] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== void 0) {
      params[33083] = props.lodMaxClamp;
    }
    if (props.type === "comparison-sampler") {
      params[34892] = 34894;
    }
    if (props.compare) {
      params[34893] = convertCompareFunction("compare", props.compare);
    }
    if (props.maxAnisotropy) {
      params[34046] = props.maxAnisotropy;
    }
    return params;
  }
  function convertAddressMode(addressMode) {
    switch (addressMode) {
      case "clamp-to-edge":
        return 33071;
      case "repeat":
        return 10497;
      case "mirror-repeat":
        return 33648;
    }
  }
  function convertMaxFilterMode(maxFilter) {
    switch (maxFilter) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
    }
  }
  function convertMinFilterMode(minFilter, mipmapFilter = "none") {
    if (!mipmapFilter) {
      return convertMaxFilterMode(minFilter);
    }
    switch (mipmapFilter) {
      case "none":
        return convertMaxFilterMode(minFilter);
      case "nearest":
        return minFilter === "nearest" ? 9984 : 9986;
      case "linear":
        return minFilter === "nearest" ? 9985 : 9987;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js
  var WEBGLSampler = class extends Sampler {
    device;
    handle;
    parameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.parameters = convertSamplerParametersToWebGL(props);
      this.handle = this.handle || this.device.gl.createSampler();
      this._setSamplerParameters(this.parameters);
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteSampler(this.handle);
        this.handle = void 0;
      }
    }
    toString() {
      return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    /** Set sampler parameters on the sampler */
    _setSamplerParameters(parameters2) {
      for (const [pname, value] of Object.entries(parameters2)) {
        const param = Number(pname);
        switch (param) {
          case 33082:
          case 33083:
            this.device.gl.samplerParameterf(this.handle, param, value);
            break;
          default:
            this.device.gl.samplerParameteri(this.handle, param, value);
            break;
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js
  var WEBGLTextureView = class extends TextureView {
    device;
    gl;
    handle;
    // Does not have a WebGL representation
    texture;
    constructor(device, props) {
      super(device, { ...Texture.defaultProps, ...props });
      this.device = device;
      this.gl = this.device.gl;
      this.handle = null;
      this.texture = props.texture;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType, options) {
    const { clamped = true } = options || {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
      case 36244:
        return 1;
      case 33339:
      case 33340:
      case 33328:
      case 33320:
      case 33319:
        return 2;
      case 6407:
      case 36248:
      case 34837:
        return 3;
      case 6408:
      case 36249:
      case 34836:
        return 4;
      default:
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        return 0;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js
  function withGLParameters(gl, parameters2, func) {
    if (isObjectEmpty4(parameters2)) {
      return func(gl);
    }
    const { nocatch = true } = parameters2;
    const webglState = WebGLStateTracker.get(gl);
    webglState.push();
    setGLParameters(gl, parameters2);
    let value;
    if (nocatch) {
      value = func(gl);
      webglState.pop();
    } else {
      try {
        value = func(gl);
      } finally {
        webglState.pop();
      }
    }
    return value;
  }
  function isObjectEmpty4(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js
  function initializeTextureStorage(gl, levels, options) {
    const { dimension, width, height, depth = 0 } = options;
    const { glInternalFormat } = options;
    const glTarget = options.glTarget;
    switch (dimension) {
      case "2d-array":
      case "3d":
        gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);
        break;
      default:
        gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);
    }
  }
  function copyExternalImageToMipLevel(gl, handle, image, options) {
    const { width, height } = options;
    const { dimension, depth = 0, mipLevel = 0 } = options;
    const { x: x3 = 0, y: y3 = 0, z: z2 = 0 } = options;
    const { glFormat, glType } = options;
    const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    const glParameters = options.flipY ? { [37440]: true } : {};
    withGLParameters(gl, glParameters, () => {
      switch (dimension) {
        case "2d-array":
        case "3d":
          gl.bindTexture(glTarget, handle);
          gl.texSubImage3D(glTarget, mipLevel, x3, y3, z2, width, height, depth, glFormat, glType, image);
          gl.bindTexture(glTarget, null);
          break;
        case "2d":
        case "cube":
          gl.bindTexture(glTarget, handle);
          gl.texSubImage2D(glTarget, mipLevel, x3, y3, width, height, glFormat, glType, image);
          gl.bindTexture(glTarget, null);
          break;
        default:
          throw new Error(dimension);
      }
    });
  }
  function copyCPUDataToMipLevel(gl, typedArray, options) {
    const { dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0 } = options;
    const { x: x3 = 0, y: y3 = 0, z: z2 = 0 } = options;
    const { glFormat, glType, compressed } = options;
    const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);
    switch (dimension) {
      case "2d-array":
      case "3d":
        if (compressed) {
          gl.compressedTexSubImage3D(glTarget, mipLevel, x3, y3, z2, width, height, depth, glFormat, typedArray, byteOffset);
        } else {
          gl.texSubImage3D(glTarget, mipLevel, x3, y3, z2, width, height, depth, glFormat, glType, typedArray, byteOffset);
        }
        break;
      case "2d":
      case "cube":
        if (compressed) {
          gl.compressedTexSubImage2D(glTarget, mipLevel, x3, y3, width, height, glFormat, typedArray, byteOffset);
        } else {
          gl.texSubImage2D(glTarget, mipLevel, x3, y3, width, height, glFormat, glType, typedArray, byteOffset);
        }
        break;
      default:
        throw new Error(dimension);
    }
  }
  function getWebGLTextureTarget(dimension) {
    switch (dimension) {
      case "1d":
        break;
      case "2d":
        return 3553;
      case "3d":
        return 32879;
      case "cube":
        return 34067;
      case "2d-array":
        return 35866;
      case "cube-array":
        break;
    }
    throw new Error(dimension);
  }
  function getWebGLCubeFaceTarget(glTarget, dimension, level) {
    return dimension === "cube" ? 34069 + level : glTarget;
  }
  function readPixelsToArray(source3, options) {
    const {
      sourceX = 0,
      sourceY = 0,
      sourceAttachment = 0
      // TODO - support gl.readBuffer
    } = options || {};
    let {
      target: target2 = null,
      // following parameters are auto deduced if not provided
      sourceWidth,
      sourceHeight,
      sourceDepth,
      sourceFormat,
      sourceType
    } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer(source3);
    const { gl, handle } = framebuffer;
    sourceWidth ||= framebuffer.width;
    sourceHeight ||= framebuffer.height;
    const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;
    if (!texture) {
      throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);
    }
    sourceDepth = texture?.depth || 1;
    sourceFormat ||= texture?.glFormat || 6408;
    sourceType ||= texture?.glType || 5121;
    target2 = getPixelArray(target2, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);
    sourceType = sourceType || getGLTypeFromTypedArray(target2);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readBuffer(36064 + sourceAttachment);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target2);
    gl.readBuffer(36064);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return target2;
  }
  function readPixelsToBuffer(source3, options) {
    const { target: target2, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
    let { sourceWidth, sourceHeight, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer(source3);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const webglFramebuffer = framebuffer;
    sourceType = sourceType || 5121;
    let webglBufferTarget = target2;
    if (!webglBufferTarget) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
    }
    const commandEncoder = source3.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
      sourceTexture: source3,
      width: sourceWidth,
      height: sourceHeight,
      origin: [sourceX, sourceY],
      destinationBuffer: webglBufferTarget,
      byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return webglBufferTarget;
  }
  function getFramebuffer(source3) {
    if (!(source3 instanceof Framebuffer)) {
      return { framebuffer: toFramebuffer(source3), deleteFramebuffer: true };
    }
    return { framebuffer: source3, deleteFramebuffer: false };
  }
  function toFramebuffer(texture, props) {
    const { device, width, height, id } = texture;
    const framebuffer = device.createFramebuffer({
      ...props,
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [texture]
    });
    return framebuffer;
  }
  function getPixelArray(pixelArray, glType, glFormat, width, height, depth) {
    if (pixelArray) {
      return pixelArray;
    }
    glType ||= 5121;
    const ArrayType2 = getTypedArrayFromGLType(glType, { clamped: false });
    const components = glFormatToComponents(glFormat);
    return new ArrayType2(width * height * components);
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js
  var WEBGLTexture = class extends Texture {
    // readonly MAX_ATTRIBUTES: number;
    device;
    gl;
    handle;
    sampler = void 0;
    // TODO - currently unused in WebGL. Create dummy sampler?
    view = void 0;
    // TODO - currently unused in WebGL. Create dummy view?
    mipmaps;
    // Texture type
    /** Whether the internal format is compressed */
    compressed;
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */
    glTarget;
    /** The WebGL format - essentially channel structure */
    glFormat;
    /** The WebGL data format - the type of each channel */
    glType;
    /** The WebGL constant corresponding to the WebGPU style constant in format */
    glInternalFormat;
    // state
    /** Texture binding slot - TODO - move to texture view? */
    textureUnit = 0;
    constructor(device, props) {
      super(device, props);
      const propsWithData = { ...this.props };
      propsWithData.data = props.data;
      this.device = device;
      this.gl = this.device.gl;
      this.glTarget = getWebGLTextureTarget(this.props.dimension);
      const formatInfo = getTextureFormatWebGL(this.props.format);
      this.glInternalFormat = formatInfo.internalFormat;
      this.glFormat = formatInfo.format;
      this.glType = formatInfo.type;
      this.compressed = formatInfo.compressed;
      this.mipmaps = Boolean(this.props.mipmaps);
      this._initialize(propsWithData);
      Object.seal(this);
    }
    /** Initialize texture with supplied props */
    // eslint-disable-next-line max-statements
    _initialize(propsWithData) {
      this.handle = this.props.handle || this.gl.createTexture();
      this.device.setSpectorMetadata(this.handle, { ...this.props, data: propsWithData.data });
      let { width, height } = propsWithData;
      if (!width || !height) {
        const textureSize = Texture.getTextureDataSize(propsWithData.data);
        width = textureSize?.width || 1;
        height = textureSize?.height || 1;
      }
      this.width = width;
      this.height = height;
      this.depth = propsWithData.depth;
      this.setSampler(propsWithData.sampler);
      this.view = new WEBGLTextureView(this.device, { ...this.props, texture: this });
      this.bind();
      initializeTextureStorage(this.gl, this.mipLevels, this);
      if (propsWithData.data) {
        switch (propsWithData.dimension) {
          case "1d":
            this.setTexture1DData(propsWithData.data);
            break;
          case "2d":
            this.setTexture2DData(propsWithData.data);
            break;
          case "3d":
            this.setTexture3DData(propsWithData.data);
            break;
          case "cube":
            this.setTextureCubeData(propsWithData.data);
            break;
          case "2d-array":
            this.setTextureArrayData(propsWithData.data);
            break;
          case "cube-array":
            this.setTextureCubeArrayData(propsWithData.data);
            break;
          default:
            throw new Error(propsWithData.dimension);
        }
      }
      if (this.mipmaps) {
        this.generateMipmap();
      }
    }
    destroy() {
      if (this.handle) {
        this.gl.deleteTexture(this.handle);
        this.removeStats();
        this.trackDeallocatedMemory("Texture");
        this.destroyed = true;
      }
    }
    createView(props) {
      return new WEBGLTextureView(this.device, { ...props, texture: this });
    }
    setSampler(sampler = {}) {
      let samplerProps;
      if (sampler instanceof WEBGLSampler) {
        this.sampler = sampler;
        samplerProps = sampler.props;
      } else {
        this.sampler = new WEBGLSampler(this.device, sampler);
        samplerProps = sampler;
      }
      const parameters2 = convertSamplerParametersToWebGL(samplerProps);
      this._setSamplerParameters(parameters2);
    }
    // Call to regenerate mipmaps after modifying texture(s)
    generateMipmap(options) {
      const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);
      if (!isFilterableAndRenderable) {
        log2.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();
        if (!options?.force) {
          return;
        }
      }
      try {
        this.gl.bindTexture(this.glTarget, this.handle);
        this.gl.generateMipmap(this.glTarget);
      } catch (error) {
        log2.warn(`Error generating mipmap for ${this}: ${error.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
    }
    // Image Data Setters
    copyExternalImage(options) {
      const size = Texture.getExternalImageSize(options.image);
      const opts = { ...Texture.defaultCopyExternalImageOptions, ...size, ...options };
      const { image, depth, mipLevel, x: x3, y: y3, z: z2, flipY } = opts;
      let { width, height } = opts;
      const { dimension, glTarget, glFormat, glInternalFormat, glType } = this;
      width = Math.min(width, this.width - x3);
      height = Math.min(height, this.height - y3);
      if (options.sourceX || options.sourceY) {
        throw new Error("WebGL does not support sourceX/sourceY)");
      }
      copyExternalImageToMipLevel(this.device.gl, this.handle, image, {
        dimension,
        mipLevel,
        x: x3,
        y: y3,
        z: z2,
        width,
        height,
        depth,
        glFormat,
        glInternalFormat,
        glType,
        glTarget,
        flipY
      });
      return { width: opts.width, height: opts.height };
    }
    setTexture1DData(data) {
      throw new Error("setTexture1DData not supported in WebGL.");
    }
    /** Set a simple texture */
    setTexture2DData(lodData, depth = 0) {
      this.bind();
      const lodArray = Texture.normalizeTextureData(lodData, this);
      if (lodArray.length > 1 && this.props.mipmaps !== false) {
        log2.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
      }
      for (let lodLevel = 0; lodLevel < lodArray.length; lodLevel++) {
        const imageData = lodArray[lodLevel];
        this._setMipLevel(depth, lodLevel, imageData);
      }
      this.unbind();
    }
    /**
     * Sets a 3D texture
     * @param data
     */
    setTexture3DData(data) {
      if (this.props.dimension !== "3d") {
        throw new Error(this.id);
      }
      if (ArrayBuffer.isView(data)) {
        this.bind();
        copyCPUDataToMipLevel(this.device.gl, data, this);
        this.unbind();
      }
    }
    /**
     * Set a Texture Cube Data
     * @todo - could support TextureCubeArray with depth
     * @param data
     * @param index
     */
    setTextureCubeData(data, depth = 0) {
      if (this.props.dimension !== "cube") {
        throw new Error(this.id);
      }
      for (const face of Texture.CubeFaces) {
        this.setTextureCubeFaceData(data[face], face);
      }
    }
    /**
     * Sets an entire texture array
     * @param data
     */
    setTextureArrayData(data) {
      if (this.props.dimension !== "2d-array") {
        throw new Error(this.id);
      }
      throw new Error("setTextureArrayData not implemented.");
    }
    /**
     * Sets an entire texture cube array
     * @param data
     */
    setTextureCubeArrayData(data) {
      throw new Error("setTextureCubeArrayData not supported in WebGL2.");
    }
    setTextureCubeFaceData(lodData, face, depth = 0) {
      if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {
        log2.warn(`${this.id} has mipmap and multiple LODs.`)();
      }
      const faceDepth = Texture.CubeFaces.indexOf(face);
      this.setTexture2DData(lodData, faceDepth);
    }
    // DEPRECATED METHODS
    /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */
    update() {
      throw new Error("Texture.update() not implemented. Use ExternalTexture");
    }
    // INTERNAL METHODS
    /** @todo update this method to accept LODs */
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        format = 6408,
        type = 5121
        // generateMipmap = false // TODO
      } = options;
      const { gl } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
    }
    _getImageDataMap(faceData) {
      for (let i5 = 0; i5 < Texture.CubeFaces.length; ++i5) {
        const faceName = Texture.CubeFaces[i5];
        if (faceData[faceName]) {
          faceData[34069 + i5] = faceData[faceName];
          delete faceData[faceName];
        }
      }
      return faceData;
    }
    // RESOURCE METHODS
    /**
     * Sets sampler parameters on texture
     */
    _setSamplerParameters(parameters2) {
      log2.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters2))();
      this.gl.bindTexture(this.glTarget, this.handle);
      for (const [pname, pvalue] of Object.entries(parameters2)) {
        const param = Number(pname);
        const value = pvalue;
        switch (param) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.glTarget, param, value);
            break;
          case 10241:
            this.gl.texParameteri(this.glTarget, param, value);
            break;
          case 10242:
          case 10243:
            this.gl.texParameteri(this.glTarget, param, value);
            break;
          case 34046:
            if (this.device.features.has("texture-filterable-anisotropic-webgl")) {
              this.gl.texParameteri(this.glTarget, param, value);
            }
            break;
          default:
            this.gl.texParameteri(this.glTarget, param, value);
            break;
        }
      }
      this.gl.bindTexture(this.glTarget, null);
    }
    // INTERNAL SETTERS
    /**
     * Copy a region of data from a CPU memory buffer into this texture.
     * @todo -   GLUnpackParameters parameters
     */
    _setMipLevel(depth, mipLevel, textureData, glTarget = this.glTarget) {
      if (Texture.isExternalImage(textureData)) {
        copyExternalImageToMipLevel(this.device.gl, this.handle, textureData, {
          ...this,
          depth,
          mipLevel,
          glTarget,
          flipY: this.props.flipY
        });
        return;
      }
      if (Texture.isTextureLevelData(textureData)) {
        copyCPUDataToMipLevel(this.device.gl, textureData.data, {
          ...this,
          depth,
          mipLevel,
          glTarget
        });
        return;
      }
      throw new Error("Texture: invalid image data");
    }
    // HELPERS
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind(textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.glTarget, this.handle);
      return textureUnit;
    }
    unbind(textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.glTarget, null);
      return textureUnit;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js
  var COLOR_CHANNELS = [1, 2, 4, 8];
  var WEBGLRenderPass = class extends RenderPass {
    device;
    /** Parameters that should be applied before each draw call */
    glParameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      let viewport;
      if (!props?.parameters?.viewport) {
        if (props?.framebuffer) {
          const { width, height } = props.framebuffer;
          viewport = [0, 0, width, height];
        } else {
          const [width, height] = device.getCanvasContext().getDrawingBufferSize();
          viewport = [0, 0, width, height];
        }
      }
      this.device.pushState();
      this.setParameters({ viewport, ...this.props.parameters });
      const webglFramebuffer = this.props.framebuffer;
      if (webglFramebuffer?.handle) {
        if (this.props.framebuffer) {
          const drawBuffers = this.props.framebuffer.colorAttachments.map((_2, i5) => 36064 + i5);
          this.device.gl.drawBuffers(drawBuffers);
        } else {
          this.device.gl.drawBuffers([1029]);
        }
      }
      this.clear();
    }
    end() {
      this.device.popState();
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    // beginOcclusionQuery(queryIndex: number): void;
    // endOcclusionQuery(): void;
    // executeBundles(bundles: Iterable<GPURenderBundle>): void;
    /**
     * Maps RenderPass parameters to GL parameters
     */
    setParameters(parameters2 = {}) {
      const glParameters = { ...this.glParameters };
      glParameters.framebuffer = this.props.framebuffer || null;
      if (this.props.depthReadOnly) {
        glParameters.depthMask = !this.props.depthReadOnly;
      }
      glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
      glParameters[35977] = this.props.discard;
      if (parameters2.viewport) {
        if (parameters2.viewport.length >= 6) {
          glParameters.viewport = parameters2.viewport.slice(0, 4);
          glParameters.depthRange = [parameters2.viewport[4], parameters2.viewport[5]];
        } else {
          glParameters.viewport = parameters2.viewport;
        }
      }
      if (parameters2.scissorRect) {
        glParameters.scissorTest = true;
        glParameters.scissor = parameters2.scissorRect;
      }
      if (parameters2.blendConstant) {
        glParameters.blendColor = parameters2.blendConstant;
      }
      if (parameters2.stencilReference) {
        console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
        parameters2[2967] = parameters2.stencilReference;
      }
      if (parameters2.colorMask) {
        glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters2.colorMask));
      }
      this.glParameters = glParameters;
      setGLParameters(this.device.gl, glParameters);
    }
    beginOcclusionQuery(queryIndex) {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.beginOcclusionQuery();
    }
    endOcclusionQuery() {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.endOcclusionQuery();
    }
    // PRIVATE
    /**
     * Optionally clears depth, color and stencil buffers based on parameters
     */
    clear() {
      const glParameters = { ...this.glParameters };
      let clearMask = 0;
      if (this.props.clearColors) {
        this.props.clearColors.forEach((color, drawBufferIndex) => {
          if (color) {
            this.clearColorBuffer(drawBufferIndex, color);
          }
        });
      }
      if (this.props.clearColor !== false && this.props.clearColors === void 0) {
        clearMask |= 16384;
        glParameters.clearColor = this.props.clearColor;
      }
      if (this.props.clearDepth !== false) {
        clearMask |= 256;
        glParameters.clearDepth = this.props.clearDepth;
      }
      if (this.props.clearStencil !== false) {
        clearMask |= 1024;
        glParameters.clearStencil = this.props.clearStencil;
      }
      if (clearMask !== 0) {
        withGLParameters(this.device.gl, glParameters, () => {
          this.device.gl.clear(clearMask);
        });
      }
    }
    /**
     * WebGL2 - clear a specific color buffer
     */
    clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
      withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
        switch (value.constructor) {
          case Int8Array:
          case Int16Array:
          case Int32Array:
            this.device.gl.clearBufferiv(6144, drawBuffer, value);
            break;
          case Uint8Array:
          case Uint8ClampedArray:
          case Uint16Array:
          case Uint32Array:
            this.device.gl.clearBufferuiv(6144, drawBuffer, value);
            break;
          case Float32Array:
            this.device.gl.clearBufferfv(6144, drawBuffer, value);
            break;
          default:
            throw new Error("clearColorBuffer: color must be typed array");
        }
      });
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/decode-webgl-types.js
  function isSamplerUniform(type) {
    return SAMPLER_TYPES.includes(type);
  }
  var SAMPLER_TYPES = [
    35678,
    35680,
    35679,
    35682,
    36289,
    36292,
    36293,
    36298,
    36299,
    36300,
    36303,
    36306,
    36307,
    36308,
    36311
  ];
  var COMPOSITE_GL_TYPES = {
    [5126]: [5126, 1, "float", "f32", "float32"],
    [35664]: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
    [35665]: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
    [35666]: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
    [5124]: [5124, 1, "int", "i32", "sint32"],
    [35667]: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
    [35668]: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
    [35669]: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
    [5125]: [5125, 1, "uint", "u32", "uint32"],
    [36294]: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
    [36295]: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
    [36296]: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
    [35670]: [5126, 1, "bool", "f32", "float32"],
    [35671]: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
    [35672]: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
    [35673]: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
    // TODO - are sizes/components below correct?
    [35674]: [5126, 8, "mat2", "mat2x2<f32>"],
    // 4
    [35685]: [5126, 8, "mat2x3", "mat2x3<f32>"],
    // 6
    [35686]: [5126, 8, "mat2x4", "mat2x4<f32>"],
    // 8
    [35687]: [5126, 12, "mat3x2", "mat3x2<f32>"],
    // 6
    [35675]: [5126, 12, "mat3", "mat3x3<f32>"],
    // 9
    [35688]: [5126, 12, "mat3x4", "mat3x4<f32>"],
    // 12
    [35689]: [5126, 16, "mat4x2", "mat4x2<f32>"],
    // 8
    [35690]: [5126, 16, "mat4x3", "mat4x3<f32>"],
    // 12
    [35676]: [5126, 16, "mat4", "mat4x4<f32>"]
    // 16
  };
  function decodeGLUniformType(glUniformType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
    if (!typeAndSize) {
      throw new Error("uniform");
    }
    const [glType, components, , format] = typeAndSize;
    return { format, components, glType };
  }
  function decodeGLAttributeType(glAttributeType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
    if (!typeAndSize) {
      throw new Error("attribute");
    }
    const [, components, , shaderType, vertexFormat] = typeAndSize;
    const attributeType = shaderType;
    return { attributeType, vertexFormat, components };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout.js
  function getShaderLayoutFromGLSL(gl, program) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock36 of uniformBlocks) {
      const uniforms2 = uniformBlock36.uniforms.map((uniform) => ({
        name: uniform.name,
        format: uniform.format,
        byteOffset: uniform.byteOffset,
        byteStride: uniform.byteStride,
        arrayLength: uniform.arrayLength
      }));
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniformBlock36.name,
        group: 0,
        location: uniformBlock36.location,
        visibility: (uniformBlock36.vertex ? 1 : 0) & (uniformBlock36.fragment ? 2 : 0),
        minBindingSize: uniformBlock36.byteLength,
        uniforms: uniforms2
      });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms) {
      if (isSamplerUniform(uniform.type)) {
        const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
        shaderLayout.bindings.push({
          type: "texture",
          name: uniform.name,
          group: 0,
          location: textureUnit,
          viewDimension,
          sampleType
        });
        uniform.textureUnit = textureUnit;
        textureUnit += 1;
      }
    }
    if (uniforms.length) {
      shaderLayout.uniforms = uniforms;
    }
    const varyings = readVaryings(gl, program);
    if (varyings?.length) {
      shaderLayout.varyings = varyings;
    }
    return shaderLayout;
  }
  function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count3 = gl.getProgramParameter(program, 35721);
    for (let index = 0; index < count3; index++) {
      const activeInfo = gl.getActiveAttrib(program, index);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name: name13,
        type: compositeType
        /* , size*/
      } = activeInfo;
      const location = gl.getAttribLocation(program, name13);
      if (location >= 0) {
        const { attributeType } = decodeGLAttributeType(compositeType);
        const stepMode = /instance/i.test(name13) ? "instance" : "vertex";
        attributes.push({
          name: name13,
          location,
          stepMode,
          type: attributeType
          // size - for arrays, size is the number of elements in the array
        });
      }
    }
    attributes.sort((a3, b2) => a3.location - b2.location);
    return attributes;
  }
  function readVaryings(gl, program) {
    const varyings = [];
    const count3 = gl.getProgramParameter(program, 35971);
    for (let location = 0; location < count3; location++) {
      const activeInfo = gl.getTransformFeedbackVarying(program, location);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: name13, type: compositeType, size } = activeInfo;
      const { glType, components } = decodeGLUniformType(compositeType);
      const varying = { location, name: name13, type: glType, size: size * components };
      varyings.push(varying);
    }
    varyings.sort((a3, b2) => a3.location - b2.location);
    return varyings;
  }
  function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718);
    for (let i5 = 0; i5 < uniformCount; i5++) {
      const activeInfo = gl.getActiveUniform(program, i5);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: rawName, size, type } = activeInfo;
      const { name: name13, isArray: isArray10 } = parseUniformName(rawName);
      let webglLocation = gl.getUniformLocation(program, name13);
      const uniformInfo = {
        // WebGL locations are uniquely typed but just numbers
        location: webglLocation,
        name: name13,
        size,
        type,
        isArray: isArray10
      };
      uniforms.push(uniformInfo);
      if (uniformInfo.size > 1) {
        for (let j2 = 0; j2 < uniformInfo.size; j2++) {
          const elementName = `${name13}[${j2}]`;
          webglLocation = gl.getUniformLocation(program, elementName);
          const arrayElementUniformInfo = {
            ...uniformInfo,
            name: elementName,
            location: webglLocation
          };
          uniforms.push(arrayElementUniformInfo);
        }
      }
    }
    return uniforms;
  }
  function readUniformBlocks(gl, program) {
    const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl.getProgramParameter(program, 35382);
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      const blockInfo = {
        name: gl.getActiveUniformBlockName(program, blockIndex) || "",
        location: getBlockParameter(blockIndex, 35391),
        byteLength: getBlockParameter(blockIndex, 35392),
        vertex: getBlockParameter(blockIndex, 35396),
        fragment: getBlockParameter(blockIndex, 35398),
        uniformCount: getBlockParameter(blockIndex, 35394),
        uniforms: []
      };
      const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
      const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
      const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
      const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
      const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
      for (let i5 = 0; i5 < blockInfo.uniformCount; ++i5) {
        const activeInfo = gl.getActiveUniform(program, uniformIndices[i5]);
        if (!activeInfo) {
          throw new Error("activeInfo");
        }
        blockInfo.uniforms.push({
          name: activeInfo.name,
          format: decodeGLUniformType(uniformType[i5]).format,
          type: uniformType[i5],
          arrayLength: uniformArrayLength[i5],
          byteOffset: uniformOffset[i5],
          byteStride: uniformStride[i5]
          // matrixStride: uniformStride[i],
          // rowMajor: uniformRowMajor[i]
        });
      }
      uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a3, b2) => a3.location - b2.location);
    return uniformBlocks;
  }
  var SAMPLER_UNIFORMS_GL_TO_GPU = {
    [35678]: ["2d", "float"],
    [35680]: ["cube", "float"],
    [35679]: ["3d", "float"],
    [35682]: ["3d", "depth"],
    [36289]: ["2d-array", "float"],
    [36292]: ["2d-array", "depth"],
    [36293]: ["cube", "float"],
    [36298]: ["2d", "sint"],
    [36299]: ["3d", "sint"],
    [36300]: ["cube", "sint"],
    [36303]: ["2d-array", "uint"],
    [36306]: ["2d", "uint"],
    [36307]: ["3d", "uint"],
    [36308]: ["cube", "uint"],
    [36311]: ["2d-array", "uint"]
  };
  function getSamplerInfo(type) {
    const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
    if (!sampler) {
      throw new Error("sampler");
    }
    const [viewDimension, sampleType] = sampler;
    return { viewDimension, sampleType };
  }
  function parseUniformName(name13) {
    if (name13[name13.length - 1] !== "]") {
      return {
        name: name13,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = UNIFORM_NAME_REGEXP.exec(name13);
    if (!matches3 || matches3.length < 2) {
      throw new Error(`Failed to parse GLSL uniform name ${name13}`);
    }
    return {
      name: matches3[1],
      length: matches3[2] ? 1 : 0,
      isArray: Boolean(matches3[2])
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js
  function setUniform(gl, location, type, value) {
    const gl2 = gl;
    let uniformValue = value;
    if (uniformValue === true) {
      uniformValue = 1;
    }
    if (uniformValue === false) {
      uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
    switch (type) {
      case 35678:
      case 35680:
      case 35679:
      case 35682:
      case 36289:
      case 36292:
      case 36293:
      case 36298:
      case 36299:
      case 36300:
      case 36303:
      case 36306:
      case 36307:
      case 36308:
      case 36311:
        if (typeof value !== "number") {
          throw new Error("samplers must be set to integers");
        }
        return gl.uniform1i(location, value);
      case 5126:
        return gl.uniform1fv(location, arrayValue);
      case 35664:
        return gl.uniform2fv(location, arrayValue);
      case 35665:
        return gl.uniform3fv(location, arrayValue);
      case 35666:
        return gl.uniform4fv(location, arrayValue);
      case 5124:
        return gl.uniform1iv(location, arrayValue);
      case 35667:
        return gl.uniform2iv(location, arrayValue);
      case 35668:
        return gl.uniform3iv(location, arrayValue);
      case 35669:
        return gl.uniform4iv(location, arrayValue);
      case 35670:
        return gl.uniform1iv(location, arrayValue);
      case 35671:
        return gl.uniform2iv(location, arrayValue);
      case 35672:
        return gl.uniform3iv(location, arrayValue);
      case 35673:
        return gl.uniform4iv(location, arrayValue);
      case 5125:
        return gl2.uniform1uiv(location, arrayValue, 1);
      case 36294:
        return gl2.uniform2uiv(location, arrayValue, 2);
      case 36295:
        return gl2.uniform3uiv(location, arrayValue, 3);
      case 36296:
        return gl2.uniform4uiv(location, arrayValue, 4);
      case 35674:
        return gl.uniformMatrix2fv(location, false, arrayValue);
      case 35675:
        return gl.uniformMatrix3fv(location, false, arrayValue);
      case 35676:
        return gl.uniformMatrix4fv(location, false, arrayValue);
      case 35685:
        return gl2.uniformMatrix2x3fv(location, false, arrayValue);
      case 35686:
        return gl2.uniformMatrix2x4fv(location, false, arrayValue);
      case 35687:
        return gl2.uniformMatrix3x2fv(location, false, arrayValue);
      case 35688:
        return gl2.uniformMatrix3x4fv(location, false, arrayValue);
      case 35689:
        return gl2.uniformMatrix4x2fv(location, false, arrayValue);
      case 35690:
        return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error("Illegal uniform");
  }

  // ../../node_modules/@luma.gl/webgl/dist/utils/split-uniforms-and-bindings.js
  function isUniformValue2(value) {
    return isNumericArray(value) !== null || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings2(uniforms) {
    const result = { bindings: {}, uniforms: {} };
    Object.keys(uniforms).forEach((name13) => {
      const uniform = uniforms[name13];
      if (isUniformValue2(uniform)) {
        result.uniforms[name13] = uniform;
      } else {
        result.bindings[name13] = uniform;
      }
    });
    return result;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js
  function getGLDrawMode(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 3;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 5;
      default:
        throw new Error(topology);
    }
  }
  function getGLPrimitive(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 1;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 4;
      default:
        throw new Error(topology);
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var WEBGLRenderPipeline = class extends RenderPipeline {
    /** The WebGL device that created this render pipeline */
    device;
    /** Handle to underlying WebGL program */
    handle;
    /** vertex shader */
    vs;
    /** fragment shader */
    fs;
    /** The layout extracted from shader by WebGL introspection APIs */
    introspectedLayout;
    /** Uniforms set on this model */
    uniforms = {};
    /** Bindings set on this model */
    bindings = {};
    /** WebGL varyings */
    varyings = null;
    _uniformCount = 0;
    _uniformSetters = {};
    // TODO are these used?
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.props.handle || this.device.gl.createProgram();
      this.device.setSpectorMetadata(this.handle, { id: this.props.id });
      this.vs = props.vs;
      this.fs = props.fs;
      const { varyings, bufferMode = 35981 } = props;
      if (varyings && varyings.length > 0) {
        this.varyings = varyings;
        this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._linkShaders();
      log2.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);
      log2.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteProgram(this.handle);
        this.destroyed = true;
      }
    }
    /**
     * Bindings include: textures, samplers and uniform buffers
     * @todo needed for portable model
     */
    setBindings(bindings, options) {
      for (const [name13, value] of Object.entries(bindings)) {
        const binding = this.shaderLayout.bindings.find((binding_) => binding_.name === name13) || this.shaderLayout.bindings.find((binding_) => binding_.name === `${name13}Uniforms`);
        if (!binding) {
          const validBindings = this.shaderLayout.bindings.map((binding_) => `"${binding_.name}"`).join(", ");
          if (!options?.disableWarnings) {
            log2.warn(`No binding "${name13}" in render pipeline "${this.id}", expected one of ${validBindings}`, value)();
          }
          continue;
        }
        if (!value) {
          log2.warn(`Unsetting binding "${name13}" in render pipeline "${this.id}"`)();
        }
        switch (binding.type) {
          case "uniform":
            if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
              throw new Error("buffer value");
            }
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture value");
            }
            break;
          case "sampler":
            log2.warn(`Ignoring sampler ${name13}`)();
            break;
          default:
            throw new Error(binding.type);
        }
        this.bindings[name13] = value;
      }
    }
    /** @todo needed for portable model
     * @note The WebGL API is offers many ways to draw things
     * This function unifies those ways into a single call using common parameters with sane defaults
     */
    draw(options) {
      const {
        renderPass,
        parameters: parameters2 = this.props.parameters,
        topology = this.props.topology,
        vertexArray,
        vertexCount,
        // indexCount,
        instanceCount,
        isInstanced = false,
        firstVertex = 0,
        // firstIndex,
        // firstInstance,
        // baseVertex,
        transformFeedback
      } = options;
      const glDrawMode = getGLDrawMode(topology);
      const isIndexed = Boolean(vertexArray.indexBuffer);
      const glIndexType = vertexArray.indexBuffer?.glIndexType;
      if (this.linkStatus !== "success") {
        log2.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
        return false;
      }
      if (!this._areTexturesRenderable()) {
        log2.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
        return false;
      }
      this.device.gl.useProgram(this.handle);
      vertexArray.bindBeforeRender(renderPass);
      if (transformFeedback) {
        transformFeedback.begin(this.props.topology);
      }
      this._applyBindings();
      this._applyUniforms();
      const webglRenderPass = renderPass;
      withDeviceAndGLParameters(this.device, parameters2, webglRenderPass.glParameters, () => {
        if (isIndexed && isInstanced) {
          this.device.gl.drawElementsInstanced(
            glDrawMode,
            vertexCount || 0,
            // indexCount?
            glIndexType,
            firstVertex,
            instanceCount || 0
          );
        } else if (isIndexed) {
          this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
        } else if (isInstanced) {
          this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
        } else {
          this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
        }
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      vertexArray.unbindAfterRender(renderPass);
      return true;
    }
    // DEPRECATED METHODS
    setUniformsWebGL(uniforms) {
      const { bindings } = splitUniformsAndBindings2(uniforms);
      Object.keys(bindings).forEach((name13) => {
        log2.warn(`Unsupported value "${JSON.stringify(bindings[name13])}" used in setUniforms() for key ${name13}. Use setBindings() instead?`)();
      });
      Object.assign(this.uniforms, uniforms);
    }
    // PRIVATE METHODS
    // setAttributes(attributes: Record<string, Buffer>): void {}
    // setBindings(bindings: Record<string, Binding>): void {}
    async _linkShaders() {
      const { gl } = this.device;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log2.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      gl.linkProgram(this.handle);
      log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      if (log2.level === 0) {
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        const status2 = this._getLinkStatus();
        this._reportLinkStatus(status2);
        return;
      }
      log2.once(1, "RenderPipeline linking is asynchronous")();
      await this._waitForLinkComplete();
      log2.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
      const status = this._getLinkStatus();
      this._reportLinkStatus(status);
    }
    /** Report link status. First, check for shader compilation failures if linking fails */
    async _reportLinkStatus(status) {
      switch (status) {
        case "success":
          return;
        default:
          switch (this.vs.compilationStatus) {
            case "error":
              this.vs.debugShader();
              throw new Error(`Error during compilation of shader ${this.vs.id}`);
            case "pending":
              this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
              break;
            case "success":
              break;
          }
          switch (this.fs?.compilationStatus) {
            case "error":
              this.fs.debugShader();
              throw new Error(`Error during compilation of shader ${this.fs.id}`);
            case "pending":
              this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
              break;
            case "success":
              break;
          }
          const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);
          throw new Error(`Error during ${status}: ${linkErrorLog}`);
      }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */
    _getLinkStatus() {
      const { gl } = this.device;
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        this.linkStatus = "error";
        return "linking";
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        this.linkStatus = "error";
        return "validation";
      }
      this.linkStatus = "success";
      return "success";
    }
    /** Use KHR_parallel_shader_compile extension if available */
    async _waitForLinkComplete() {
      const waitMs = async (ms) => await new Promise((resolve2) => setTimeout(resolve2, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getProgramParameter(this.handle, 37297);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    /**
     * Checks if all texture-values uniforms are renderable (i.e. loaded)
     * Update a texture if needed (e.g. from video)
     * Note: This is currently done before every draw call
     */
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const bindingInfo of this.shaderLayout.bindings) {
        if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, "")]) {
          log2.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();
          texturesRenderable = false;
        }
      }
      return texturesRenderable;
    }
    /** Apply any bindings (before each draw call) */
    _applyBindings() {
      if (this.linkStatus !== "success") {
        return;
      }
      const { gl } = this.device;
      gl.useProgram(this.handle);
      let textureUnit = 0;
      let uniformBufferIndex = 0;
      for (const binding of this.shaderLayout.bindings) {
        const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
        if (!value) {
          throw new Error(`No value for binding ${binding.name} in ${this.id}`);
        }
        switch (binding.type) {
          case "uniform":
            const { name: name13 } = binding;
            const location = gl.getUniformBlockIndex(this.handle, name13);
            if (location === 4294967295) {
              throw new Error(`Invalid uniform block name ${name13}`);
            }
            gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
            if (value instanceof WEBGLBuffer) {
              gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
            } else {
              gl.bindBufferRange(
                35345,
                uniformBufferIndex,
                // @ts-expect-error
                value.buffer.handle,
                // @ts-expect-error
                value.offset || 0,
                // @ts-expect-error
                value.size || value.buffer.byteLength - value.offset
              );
            }
            uniformBufferIndex += 1;
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture");
            }
            let texture;
            if (value instanceof WEBGLTextureView) {
              texture = value.texture;
            } else if (value instanceof WEBGLTexture) {
              texture = value;
            } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
              log2.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
              texture = value.colorAttachments[0].texture;
            } else {
              throw new Error("No texture");
            }
            gl.activeTexture(33984 + textureUnit);
            gl.bindTexture(texture.glTarget, texture.handle);
            textureUnit += 1;
            break;
          case "sampler":
            break;
          case "storage":
          case "read-only-storage":
            throw new Error(`binding type '${binding.type}' not supported in WebGL`);
        }
      }
    }
    /**
     * Due to program sharing, uniforms need to be reset before every draw call
     * (though caching will avoid redundant WebGL calls)
     */
    _applyUniforms() {
      for (const uniformLayout of this.shaderLayout.uniforms || []) {
        const { name: name13, location, type, textureUnit } = uniformLayout;
        const value = this.uniforms[name13] ?? textureUnit;
        if (value !== void 0) {
          setUniform(this.device.gl, location, type, value);
        }
      }
    }
  };
  function mergeShaderLayout(baseLayout, overrideLayout) {
    const mergedLayout = {
      ...baseLayout,
      attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
    };
    for (const attribute of overrideLayout?.attributes || []) {
      const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
      if (!baseAttribute) {
        log2.warn(`shader layout attribute ${attribute.name} not present in shader`);
      } else {
        baseAttribute.type = attribute.type || baseAttribute.type;
        baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
      }
    }
    return mergedLayout;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js
  var WEBGLCommandBuffer = class extends CommandBuffer {
    device;
    commands = [];
    constructor(device) {
      super(device, {});
      this.device = device;
    }
    submitCommands(commands = this.commands) {
      for (const command of commands) {
        switch (command.name) {
          case "copy-buffer-to-buffer":
            _copyBufferToBuffer(this.device, command.options);
            break;
          case "copy-buffer-to-texture":
            _copyBufferToTexture(this.device, command.options);
            break;
          case "copy-texture-to-buffer":
            _copyTextureToBuffer(this.device, command.options);
            break;
          case "copy-texture-to-texture":
            _copyTextureToTexture(this.device, command.options);
            break;
          default:
            throw new Error(command.name);
        }
      }
    }
  };
  function _copyBufferToBuffer(device, options) {
    const source3 = options.sourceBuffer;
    const destination = options.destinationBuffer;
    device.gl.bindBuffer(36662, source3.handle);
    device.gl.bindBuffer(36663, destination.handle);
    device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
    device.gl.bindBuffer(36662, null);
    device.gl.bindBuffer(36663, null);
  }
  function _copyBufferToTexture(device, options) {
    throw new Error("Not implemented");
  }
  function _copyTextureToBuffer(device, options) {
    const {
      /** Texture to copy to/from. */
      sourceTexture,
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      mipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      aspect = "all",
      /** Width to copy */
      width = options.sourceTexture.width,
      /** Height to copy */
      height = options.sourceTexture.height,
      depthOrArrayLayers = 0,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      origin = [0, 0],
      /** Destination buffer */
      destinationBuffer,
      /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
      byteOffset = 0,
      /**
       * The stride, in bytes, between the beginning of each block row and the subsequent block row.
       * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
       */
      bytesPerRow,
      /**
       * Number of block rows per single image of the texture.
       * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
       * Required if there are multiple images (i.e. the copy depth is more than one).
       */
      rowsPerImage
    } = options;
    if (aspect !== "all") {
      throw new Error("aspect not supported in WebGL");
    }
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
      throw new Error("not implemented");
    }
    const { framebuffer, destroyFramebuffer } = getFramebuffer2(sourceTexture);
    let prevHandle;
    try {
      const webglBuffer = destinationBuffer;
      const sourceWidth = width || framebuffer.width;
      const sourceHeight = height || framebuffer.height;
      const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);
      const sourceFormat = sourceParams.format;
      const sourceType = sourceParams.type;
      device.gl.bindBuffer(35051, webglBuffer.handle);
      prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
      device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
    } finally {
      device.gl.bindBuffer(35051, null);
      if (prevHandle !== void 0) {
        device.gl.bindFramebuffer(36160, prevHandle);
      }
      if (destroyFramebuffer) {
        framebuffer.destroy();
      }
    }
  }
  function _copyTextureToTexture(device, options) {
    const {
      /** Texture to copy to/from. */
      sourceTexture,
      /**  Mip-map level of the texture to copy to (Default 0) */
      destinationMipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      // aspect = 'all',
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
      origin = [0, 0],
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
      destinationOrigin = [0, 0],
      /** Texture to copy to/from. */
      destinationTexture
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      // destinationMipLevel = options.mipLevel,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      // destinationOrigin = [0, 0],
      /** Defines which aspects of the texture to copy to/from. */
      // destinationAspect = options.aspect,
    } = options;
    let {
      width = options.destinationTexture.width,
      height = options.destinationTexture.height
      // depthOrArrayLayers = 0
    } = options;
    const { framebuffer, destroyFramebuffer } = getFramebuffer2(sourceTexture);
    const [sourceX, sourceY] = origin;
    const [destinationX, destinationY, destinationZ] = destinationOrigin;
    const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    let texture = null;
    let textureTarget;
    if (destinationTexture instanceof WEBGLTexture) {
      texture = destinationTexture;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      textureTarget = texture.glTarget;
    } else {
      throw new Error("invalid destination");
    }
    switch (textureTarget) {
      case 3553:
      case 34067:
        device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
        break;
      default:
    }
    if (texture) {
      texture.unbind();
    }
    device.gl.bindFramebuffer(36160, prevHandle);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
  function getFramebuffer2(source3) {
    if (source3 instanceof Texture) {
      const { width, height, id } = source3;
      const framebuffer = source3.device.createFramebuffer({
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [source3]
      });
      return { framebuffer, destroyFramebuffer: true };
    }
    return { framebuffer: source3, destroyFramebuffer: false };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js
  var WEBGLCommandEncoder = class extends CommandEncoder {
    device;
    commandBuffer;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.commandBuffer = new WEBGLCommandBuffer(device);
    }
    destroy() {
    }
    finish() {
      this.commandBuffer.submitCommands();
    }
    // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
    // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
    // finish(options?: {id?: string}): GPUCommandBuffer;
    copyBufferToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
    }
    copyBufferToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
    }
    copyTextureToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
    }
    copyTextureToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
    }
    // clearTexture(options: ClearTextureOptions): void {
    //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
    // }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    resolveQuerySet(querySet, destination, options) {
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/utils/fill-array.js
  function fillArray2(options) {
    const { target: target2, source: source3, start = 0, count: count3 = 1 } = options;
    const length16 = source3.length;
    const total = count3 * length16;
    let copied = 0;
    for (let i5 = start; copied < length16; copied++) {
      target2[i5++] = source3[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target2.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target2.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return options.target;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js
  var WEBGLVertexArray = class extends VertexArray {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    device;
    handle;
    /** Attribute 0 buffer constant */
    buffer = null;
    bufferValue = null;
    /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
    static isConstantAttributeZeroSupported(device) {
      return getBrowser() === "Chrome";
    }
    // Create a VertexArray
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.device.gl.createVertexArray();
    }
    destroy() {
      super.destroy();
      if (this.buffer) {
        this.buffer?.destroy();
      }
      if (this.handle) {
        this.device.gl.deleteVertexArray(this.handle);
        this.handle = void 0;
      }
    }
    /**
    // Set (bind/unbind) an elements buffer, for indexed rendering.
    // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
     *
     * @param elementBuffer
     */
    setIndexBuffer(indexBuffer) {
      const buffer = indexBuffer;
      if (buffer && buffer.glTarget !== 34963) {
        throw new Error("Use .setBuffer()");
      }
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
      this.indexBuffer = buffer;
      this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
    setBuffer(location, attributeBuffer) {
      const buffer = attributeBuffer;
      if (buffer.glTarget === 34963) {
        throw new Error("Use .setIndexBuffer()");
      }
      const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      this.device.gl.bindBuffer(34962, null);
      this.device.gl.enableVertexAttribArray(location);
      this.device.gl.vertexAttribDivisor(location, divisor || 0);
      this.attributes[location] = buffer;
      this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a constant value, disables the location */
    setConstantWebGL(location, value) {
      this._enable(location, false);
      this.attributes[location] = value;
    }
    bindBeforeRender() {
      this.device.gl.bindVertexArray(this.handle);
      this._applyConstantAttributes();
    }
    unbindAfterRender() {
      this.device.gl.bindVertexArray(null);
    }
    // Internal methods
    /**
     * Constant attributes need to be reset before every draw call
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @note Constant attributes are only supported in WebGL, not in WebGPU
     */
    _applyConstantAttributes() {
      for (let location = 0; location < this.maxVertexAttributes; ++location) {
        const constant = this.attributes[location];
        if (ArrayBuffer.isView(constant)) {
          this.device.setConstantAttributeWebGL(location, constant);
        }
      }
    }
    /**
     * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
     * @note requires vertex array to be bound
     */
    // protected _setAttributeLayout(location: number): void {
    //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
    //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
    //   if (integer) {
    //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
    //   } else {
    //     // Attaches ARRAY_BUFFER with specified buffer format to location
    //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    //   }
    //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
    // }
    /** Get an accessor from the  */
    _getAccessor(location) {
      const attributeInfo = this.attributeInfos[location];
      if (!attributeInfo) {
        throw new Error(`Unknown attribute location ${location}`);
      }
      const glType = getGLFromVertexType(attributeInfo.bufferDataType);
      return {
        size: attributeInfo.bufferComponents,
        type: glType,
        stride: attributeInfo.byteStride,
        offset: attributeInfo.byteOffset,
        normalized: attributeInfo.normalized,
        // it is the shader attribute declaration, not the vertex memory format,
        // that determines if the data in the buffer will be treated as integers.
        //
        // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
        // but as far as we can tell, WebGPU does not.
        integer: attributeInfo.integer,
        divisor: attributeInfo.stepMode === "instance" ? 1 : 0
      };
    }
    /**
     * Enabling an attribute location makes it reference the currently bound buffer
     * Disabling an attribute location makes it reference the global constant value
     * TODO - handle single values for size 1 attributes?
     * TODO - convert classic arrays based on known type?
     */
    _enable(location, enable2 = true) {
      const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
      const canDisableAttribute = canDisableAttributeZero || location !== 0;
      if (enable2 || canDisableAttribute) {
        location = Number(location);
        this.device.gl.bindVertexArray(this.handle);
        if (enable2) {
          this.device.gl.enableVertexAttribArray(location);
        } else {
          this.device.gl.disableVertexAttribArray(location);
        }
        this.device.gl.bindVertexArray(null);
      }
    }
    /**
     * Provide a means to create a buffer that is equivalent to a constant.
     * NOTE: Desktop OpenGL cannot disable attribute 0.
     * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
     * this-has-significant-performance-penalty
     */
    getConstantBuffer(elementCount, value) {
      const constantValue = normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length16 = constantValue.length * elementCount;
      if (this.buffer && byteLength !== this.buffer.byteLength) {
        throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
      }
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || this.device.createBuffer({ byteLength });
      updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length16);
        fillArray2({ target: typedArray, source: constantValue, start: 0, count: length16 });
        this.buffer.write(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
  };
  function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i5 = 0; i5 < v1.length; ++i5) {
      if (v1[i5] !== v2[i5]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js
  var WEBGLTransformFeedback = class extends TransformFeedback {
    device;
    gl;
    handle;
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    layout;
    buffers = {};
    unusedBuffers = {};
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    bindOnUse = true;
    _bound = false;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || this.gl.createTransformFeedback();
      this.layout = this.props.layout;
      if (props.buffers) {
        this.setBuffers(props.buffers);
      }
      Object.seal(this);
    }
    destroy() {
      this.gl.deleteTransformFeedback(this.handle);
      super.destroy();
    }
    begin(topology = "point-list") {
      this.gl.bindTransformFeedback(36386, this.handle);
      if (this.bindOnUse) {
        this._bindBuffers();
      }
      this.gl.beginTransformFeedback(getGLPrimitive(topology));
    }
    end() {
      this.gl.endTransformFeedback();
      if (this.bindOnUse) {
        this._unbindBuffers();
      }
      this.gl.bindTransformFeedback(36386, null);
    }
    // SUBCLASS
    setBuffers(buffers) {
      this.buffers = {};
      this.unusedBuffers = {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
    }
    setBuffer(locationOrName, bufferOrRange) {
      const location = this._getVaryingIndex(locationOrName);
      const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
      if (location < 0) {
        this.unusedBuffers[locationOrName] = buffer;
        log2.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
        return;
      }
      this.buffers[location] = { buffer, byteLength, byteOffset };
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteLength);
      }
    }
    getBuffer(locationOrName) {
      if (isIndex(locationOrName)) {
        return this.buffers[locationOrName] || null;
      }
      const location = this._getVaryingIndex(locationOrName);
      return location >= 0 ? this.buffers[location] : null;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this.gl.bindTransformFeedback(36386, funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this.gl.bindTransformFeedback(36386, null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    // PRIVATE METHODS
    /** Extract offsets for bindBufferRange */
    _getBufferRange(bufferOrRange) {
      if (bufferOrRange instanceof WEBGLBuffer) {
        return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
      }
      const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
      return { buffer, byteOffset, byteLength };
    }
    _getVaryingIndex(locationOrName) {
      if (isIndex(locationOrName)) {
        return Number(locationOrName);
      }
      for (const varying of this.layout.varyings) {
        if (locationOrName === varying.name) {
          return varying.location;
        }
      }
      return -1;
    }
    /**
     * Need to avoid chrome bug where buffer that is already bound to a different target
     * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     */
    _bindBuffers() {
      for (const bufferIndex in this.buffers) {
        const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
        this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
      }
    }
    _unbindBuffers() {
      for (const bufferIndex in this.buffers) {
        this.gl.bindBufferBase(35982, Number(bufferIndex), null);
      }
    }
    _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
      const handle = buffer && buffer.handle;
      if (!handle || byteLength === void 0) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);
      }
    }
  };
  function isIndex(value) {
    if (typeof value === "number") {
      return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js
  var WEBGLQuerySet = class extends QuerySet {
    device;
    handle;
    target = null;
    _queryPending = false;
    _pollingPromise = null;
    get [Symbol.toStringTag]() {
      return "Query";
    }
    // Create a query class
    constructor(device, props) {
      super(device, props);
      this.device = device;
      if (props.count > 1) {
        throw new Error("WebGL QuerySet can only have one value");
      }
      this.handle = this.device.gl.createQuery();
      Object.seal(this);
    }
    destroy() {
      this.device.gl.deleteQuery(this.handle);
    }
    // FOR RENDER PASS AND COMMAND ENCODER
    /**
     * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
     * Measures GPU time delta between this call and a matching `end` call in the
     * GPU instruction stream.
     */
    beginTimestampQuery() {
      return this._begin(35007);
    }
    endTimestampQuery() {
      this._end();
    }
    // Shortcut for occlusion queries
    beginOcclusionQuery(options) {
      return this._begin(options?.conservative ? 36202 : 35887);
    }
    endOcclusionQuery() {
      this._end();
    }
    // Shortcut for transformFeedbackQuery
    beginTransformFeedbackQuery() {
      return this._begin(35976);
    }
    endTransformFeedbackQuery() {
      this._end();
    }
    async resolveQuery() {
      const value = await this.pollQuery();
      return [value];
    }
    // PRIVATE METHODS
    /**
     * Due to OpenGL API limitations, after calling `begin()` on one Query
     * instance, `end()` must be called on that same instance before
     * calling `begin()` on another query. While there can be multiple
     * outstanding queries representing disjoint `begin()`/`end()` intervals.
     * It is not possible to interleave or overlap `begin` and `end` calls.
     */
    _begin(target2) {
      if (this._queryPending) {
        return;
      }
      this.target = target2;
      this.device.gl.beginQuery(this.target, this.handle);
      return;
    }
    // ends the current query
    _end() {
      if (this._queryPending) {
        return;
      }
      if (this.target) {
        this.device.gl.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return;
    }
    // Returns true if the query result is available
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    // Timing query is disjoint, i.e. results are invalid
    isTimerDisjoint() {
      return this.device.gl.getParameter(36795);
    }
    // Returns query result.
    getResult() {
      return this.device.gl.getQueryParameter(this.handle, 34918);
    }
    // Returns the query result, converted to milliseconds to match JavaScript conventions.
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    // Polls the query
    pollQuery(limit = Number.POSITIVE_INFINITY) {
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter2 = 0;
      this._pollingPromise = new Promise((resolve2, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve2(this.getResult());
            this._pollingPromise = null;
          } else if (counter2++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js
  var WebGLDevice = class extends Device {
    //
    // Public `Device` API
    //
    /** type of this device */
    type = "webgl";
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */
    handle;
    features;
    limits;
    info;
    canvasContext;
    lost;
    _resolveContextLost;
    /** WebGL2 context. */
    gl;
    debug = false;
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
    /** State used by luma.gl classes - TODO - not used? */
    _extensions = {};
    _polyfilled = false;
    /** Instance of Spector.js (if initialized) */
    spectorJS;
    //
    // Public API
    //
    constructor(props) {
      super({ ...props, id: props.id || uid3("webgl-device") });
      const canvasContextProps = Device._getCanvasContextProps(props);
      if (!canvasContextProps) {
        throw new Error("WebGLDevice requires props.createCanvasContext to be set");
      }
      let device = canvasContextProps.canvas?.gl?.device;
      if (device) {
        throw new Error(`WebGL context already attached to device ${device.id}`);
      }
      this.canvasContext = new WebGLCanvasContext(this, canvasContextProps);
      this.lost = new Promise((resolve2) => {
        this._resolveContextLost = resolve2;
      });
      const webglContextAttributes = { ...props.webgl };
      if (canvasContextProps.alphaMode === "premultiplied") {
        webglContextAttributes.premultipliedAlpha = true;
      }
      if (props.powerPreference !== void 0) {
        webglContextAttributes.powerPreference = props.powerPreference;
      }
      const externalGLContext = this.props._handle;
      const gl = externalGLContext || createBrowserContext(this.canvasContext.canvas, {
        onContextLost: (event) => this._resolveContextLost?.({
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        }),
        // eslint-disable-next-line no-console
        onContextRestored: (event) => console.log("WebGL context restored")
      }, webglContextAttributes);
      if (!gl) {
        throw new Error("WebGL context creation failed");
      }
      device = gl.device;
      if (device) {
        if (props._reuseDevices) {
          log2.log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();
          device._reused = true;
          return device;
        }
        throw new Error(`WebGL context already attached to device ${device.id}`);
      }
      this.handle = gl;
      this.gl = gl;
      this.spectorJS = initializeSpectorJS({ ...this.props, gl: this.handle });
      this.gl.device = this;
      this.gl._version = 2;
      this.info = getDeviceInfo(this.gl, this._extensions);
      this.limits = new WebGLDeviceLimits(this.gl);
      this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props._disabledFeatures);
      if (this.props._initializeFeatures) {
        this.features.initializeFeatures();
      }
      if (canvasContextProps.autoResize !== false) {
        this.canvasContext.resize();
      }
      const glState = new WebGLStateTracker(this.gl, {
        log: (...args) => log2.log(1, ...args)()
      });
      glState.trackState(this.gl, { copyState: false });
      const debugWebGL = props.debugWebGL || props.debug;
      const traceWebGL = props.debugWebGL;
      if (debugWebGL) {
        this.gl = makeDebugContext(this.gl, { debugWebGL, traceWebGL });
        log2.warn("WebGL debug mode activated. Performance reduced.")();
        if (props.debugWebGL) {
          log2.level = Math.max(log2.level, 1);
        }
      }
    }
    /**
     * Destroys the device
     *
     * @note "Detaches" from the WebGL context unless _reuseDevices is true.
     *
     * @note The underlying WebGL context is not immediately destroyed,
     * but may be destroyed later through normal JavaScript garbage collection.
     * This is a fundamental limitation since WebGL does not offer any
     * browser API for destroying WebGL contexts.
     */
    destroy() {
      if (!this.props._reuseDevices && !this._reused) {
        delete this.gl.device;
      }
    }
    get isLost() {
      return this.gl.isContextLost();
    }
    // IMPLEMENTATION OF ABSTRACT DEVICE
    createCanvasContext(props) {
      throw new Error("WebGL only supports a single canvas");
    }
    createBuffer(props) {
      const newProps = this._normalizeBufferProps(props);
      return new WEBGLBuffer(this, newProps);
    }
    createTexture(props) {
      return new WEBGLTexture(this, props);
    }
    createExternalTexture(props) {
      throw new Error("createExternalTexture() not implemented");
    }
    createSampler(props) {
      return new WEBGLSampler(this, props);
    }
    createShader(props) {
      return new WEBGLShader(this, props);
    }
    createFramebuffer(props) {
      return new WEBGLFramebuffer(this, props);
    }
    createVertexArray(props) {
      return new WEBGLVertexArray(this, props);
    }
    createTransformFeedback(props) {
      return new WEBGLTransformFeedback(this, props);
    }
    createQuerySet(props) {
      return new WEBGLQuerySet(this, props);
    }
    createRenderPipeline(props) {
      return new WEBGLRenderPipeline(this, props);
    }
    beginRenderPass(props) {
      return new WEBGLRenderPass(this, props);
    }
    createComputePipeline(props) {
      throw new Error("ComputePipeline not supported in WebGL");
    }
    beginComputePass(props) {
      throw new Error("ComputePass not supported in WebGL");
    }
    renderPass = null;
    createCommandEncoder(props = {}) {
      return new WEBGLCommandEncoder(this, props);
    }
    /**
     * Offscreen Canvas Support: Commit the frame
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
     * Chrome's offscreen canvas does not require gl.commit
     */
    submit() {
      this.renderPass?.end();
      this.renderPass = null;
    }
    //
    // TEMPORARY HACKS - will be removed in v9.1
    //
    /** @deprecated - should use command encoder */
    readPixelsToArrayWebGL(source3, options) {
      return readPixelsToArray(source3, options);
    }
    /** @deprecated - should use command encoder */
    readPixelsToBufferWebGL(source3, options) {
      return readPixelsToBuffer(source3, options);
    }
    setParametersWebGL(parameters2) {
      setGLParameters(this.gl, parameters2);
    }
    getParametersWebGL(parameters2) {
      return getGLParameters(this.gl, parameters2);
    }
    withParametersWebGL(parameters2, func) {
      return withGLParameters(this.gl, parameters2, func);
    }
    resetWebGL() {
      log2.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
      resetGLParameters(this.gl);
    }
    _getDeviceSpecificTextureFormatCapabilities(capabilities) {
      return getTextureFormatCapabilitiesWebGL(this.gl, capabilities, this._extensions);
    }
    //
    // WebGL-only API (not part of `Device` API)
    //
    /**
     * Triggers device (or WebGL context) loss.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice() {
      let deviceLossTriggered = false;
      const extensions = this.getExtension("WEBGL_lose_context");
      const ext = extensions.WEBGL_lose_context;
      if (ext) {
        deviceLossTriggered = true;
        ext.loseContext();
      }
      this._resolveContextLost?.({
        reason: "destroyed",
        message: "Application triggered context loss"
      });
      return deviceLossTriggered;
    }
    /** Save current WebGL context state onto an internal stack */
    pushState() {
      const webglState = WebGLStateTracker.get(this.gl);
      webglState.push();
    }
    /** Restores previously saved context state */
    popState() {
      const webglState = WebGLStateTracker.get(this.gl);
      webglState.pop();
    }
    /**
     * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
     * luma.gl ids and props can be inspected
     */
    setSpectorMetadata(handle, props) {
      handle.__SPECTOR_Metadata = props;
    }
    /**
     * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
     * Be aware that there are some duplicates especially for constants that are 0,
     * so this isn't guaranteed to return the right key in all cases.
     */
    getGLKey(value, options) {
      const number = Number(value);
      for (const key in this.gl) {
        if (this.gl[key] === number) {
          return `GL.${key}`;
        }
      }
      return options?.emptyIfUnknown ? "" : String(value);
    }
    /**
     * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
     */
    getGLKeys(glParameters) {
      const opts = { emptyIfUnknown: true };
      return Object.entries(glParameters).reduce((keys, [key, value]) => {
        keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;
        return keys;
      }, {});
    }
    /** Store constants */
    _constants;
    /**
     * Set a constant value for a location. Disabled attributes at that location will read from this value
     * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
     * so they need to be updated before every render
     * @todo - remember/cache values to avoid setting them unnecessarily?
     */
    setConstantAttributeWebGL(location, constant) {
      const maxVertexAttributes = this.limits.maxVertexAttributes;
      this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
      const currentConstant = this._constants[location];
      if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
        log2.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
      }
      this._constants[location] = constant;
      switch (constant.constructor) {
        case Float32Array:
          setConstantFloatArray(this, location, constant);
          break;
        case Int32Array:
          setConstantIntArray(this, location, constant);
          break;
        case Uint32Array:
          setConstantUintArray(this, location, constant);
          break;
        default:
          throw new Error("constant");
      }
    }
    /** Ensure extensions are only requested once */
    getExtension(name13) {
      getWebGLExtension(this.gl, name13, this._extensions);
      return this._extensions;
    }
  };
  function setConstantFloatArray(device, location, array) {
    switch (array.length) {
      case 1:
        device.gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        device.gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        device.gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        device.gl.vertexAttrib4fv(location, array);
        break;
      default:
    }
  }
  function setConstantIntArray(device, location, array) {
    device.gl.vertexAttribI4iv(location, array);
  }
  function setConstantUintArray(device, location, array) {
    device.gl.vertexAttribI4uiv(location, array);
  }
  function compareConstantArrayValues2(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i5 = 0; i5 < v1.length; ++i5) {
      if (v1[i5] !== v2[i5]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/polyfills/polyfill-webgl1-extensions.js
  var WEBGL1_STATIC_EXTENSIONS = {
    WEBGL_depth_texture: {
      UNSIGNED_INT_24_8_WEBGL: 34042
    },
    OES_element_index_uint: {},
    OES_texture_float: {},
    OES_texture_half_float: {
      // @ts-expect-error different numbers?
      HALF_FLOAT_OES: 5131
    },
    EXT_color_buffer_float: {},
    OES_standard_derivatives: {
      FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
    },
    EXT_frag_depth: {},
    EXT_blend_minmax: {
      MIN_EXT: 32775,
      MAX_EXT: 32776
    },
    EXT_shader_texture_lod: {}
  };
  var getWEBGL_draw_buffers = (gl) => ({
    drawBuffersWEBGL(buffers) {
      return gl.drawBuffers(buffers);
    },
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067
  });
  var getOES_vertex_array_object = (gl) => ({
    VERTEX_ARRAY_BINDING_OES: 34229,
    createVertexArrayOES() {
      return gl.createVertexArray();
    },
    deleteVertexArrayOES(vertexArray) {
      return gl.deleteVertexArray(vertexArray);
    },
    isVertexArrayOES(vertexArray) {
      return gl.isVertexArray(vertexArray);
    },
    bindVertexArrayOES(vertexArray) {
      return gl.bindVertexArray(vertexArray);
    }
  });
  var getANGLE_instanced_arrays = (gl) => ({
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    drawArraysInstancedANGLE(...args) {
      return gl.drawArraysInstanced(...args);
    },
    drawElementsInstancedANGLE(...args) {
      return gl.drawElementsInstanced(...args);
    },
    vertexAttribDivisorANGLE(...args) {
      return gl.vertexAttribDivisor(...args);
    }
  });
  function enforceWebGL2(enforce = true) {
    const prototype = HTMLCanvasElement.prototype;
    if (!enforce && prototype.originalGetContext) {
      prototype.getContext = prototype.originalGetContext;
      prototype.originalGetContext = void 0;
      return;
    }
    prototype.originalGetContext = prototype.getContext;
    prototype.getContext = function(contextId, options) {
      if (contextId === "webgl" || contextId === "experimental-webgl") {
        const context = this.originalGetContext("webgl2", options);
        if (context instanceof HTMLElement) {
          polyfillWebGL1Extensions(context);
        }
        return context;
      }
      return this.originalGetContext(contextId, options);
    };
  }
  function polyfillWebGL1Extensions(gl) {
    gl.getExtension("EXT_color_buffer_float");
    const boundExtensions = {
      ...WEBGL1_STATIC_EXTENSIONS,
      WEBGL_disjoint_timer_query: gl.getExtension("EXT_disjoint_timer_query_webgl2"),
      WEBGL_draw_buffers: getWEBGL_draw_buffers(gl),
      OES_vertex_array_object: getOES_vertex_array_object(gl),
      ANGLE_instanced_arrays: getANGLE_instanced_arrays(gl)
    };
    const originalGetExtension = gl.getExtension;
    gl.getExtension = function(extensionName) {
      const ext = originalGetExtension.call(gl, extensionName);
      if (ext) {
        return ext;
      }
      if (extensionName in boundExtensions) {
        return boundExtensions[extensionName];
      }
      return null;
    };
    const originalGetSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function() {
      const extensions = originalGetSupportedExtensions.apply(gl) || [];
      return extensions?.concat(Object.keys(boundExtensions));
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-adapter.js
  var LOG_LEVEL2 = 1;
  var WebGLAdapter = class extends Adapter {
    /** type of device's created by this adapter */
    type = "webgl";
    constructor() {
      super();
      Device.defaultProps = { ...Device.defaultProps, ...DEFAULT_SPECTOR_PROPS };
      WebGLDevice.adapter = this;
    }
    /** Check if WebGL 2 is available */
    isSupported() {
      return typeof WebGL2RenderingContext !== "undefined";
    }
    /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
    enforceWebGL2(enable2) {
      enforceWebGL2(enable2);
    }
    /**
     * Get a device instance from a GL context
     * Creates a WebGLCanvasContext against the contexts canvas
     * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
     * @param gl
     * @returns
     */
    async attach(gl) {
      if (gl instanceof WebGLDevice) {
        return gl;
      }
      if (gl?.device instanceof Device) {
        return gl.device;
      }
      if (!isWebGL(gl)) {
        throw new Error("Invalid WebGL2RenderingContext");
      }
      return new WebGLDevice({
        _handle: gl,
        createCanvasContext: { canvas: gl.canvas, autoResize: false }
      });
    }
    async create(props = {}) {
      log2.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
      const promises = [];
      if (props.debugWebGL || props.debug) {
        promises.push(loadWebGLDeveloperTools());
      }
      if (props.debugSpectorJS) {
        promises.push(loadSpectorJS(props));
      }
      const results = await Promise.allSettled(promises);
      for (const result of results) {
        if (result.status === "rejected") {
          log2.error(`Failed to initialize debug libraries ${result.reason}`)();
        }
      }
      const device = new WebGLDevice(props);
      const message2 = `${device._reused ? "Reusing" : "Created"} device with WebGL2 ${device.debug ? "debug " : ""}context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
      log2.probe(LOG_LEVEL2, message2)();
      log2.table(LOG_LEVEL2, device.info)();
      log2.groupEnd(LOG_LEVEL2)();
      return device;
    }
  };
  function isWebGL(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  var webgl2Adapter = new WebGLAdapter();

  // ../core/src/lib/deck.ts
  function noop3() {
  }
  var getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
  var defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    parameters: {},
    parent: null,
    device: null,
    deviceProps: {},
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    // Rely on external controller, e.g. react-map-gl
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    widgets: [],
    onDeviceInitialized: noop3,
    onWebGLInitialized: noop3,
    onResize: noop3,
    onViewStateChange: noop3,
    onInteractionStateChange: noop3,
    onBeforeRender: noop3,
    onAfterRender: noop3,
    onLoad: noop3,
    onError: (error) => log_default.error(error.message, error.cause)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  var Deck = class {
    constructor(props) {
      this.width = 0;
      this.height = 0;
      // Allows attaching arbitrary data to the instance
      this.userData = {};
      this.device = null;
      this.canvas = null;
      this.viewManager = null;
      this.layerManager = null;
      this.effectManager = null;
      this.deckRenderer = null;
      this.deckPicker = null;
      this.eventManager = null;
      this.widgetManager = null;
      this.tooltip = null;
      this.animationLoop = null;
      this.cursorState = {
        isHovering: false,
        isDragging: false
      };
      this.stats = new Stats({ id: "deck.gl" });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this._needsRedraw = "Initial render";
      this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      };
      /**
       * Pick and store the object under the pointer on `pointerdown`.
       * This object is reused for subsequent `onClick` and `onDrag*` callbacks.
       */
      this._lastPointerDownInfo = null;
      // The `pointermove` event may fire multiple times in between two animation frames,
      // it's a waste of time to run picking without rerender. Instead we save the last pick
      // request and only do it once on the next animation frame.
      /** Internal use only: event handler for pointerdown */
      this._onPointerMove = (event) => {
        const { _pickRequest } = this;
        if (event.type === "pointerleave") {
          _pickRequest.x = -1;
          _pickRequest.y = -1;
          _pickRequest.radius = 0;
        } else if (event.leftButton || event.rightButton) {
          return;
        } else {
          const pos = event.offsetCenter;
          if (!pos) {
            return;
          }
          _pickRequest.x = pos.x;
          _pickRequest.y = pos.y;
          _pickRequest.radius = this.props.pickingRadius;
        }
        if (this.layerManager) {
          this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };
        }
        _pickRequest.event = event;
      };
      /** Internal use only: event handler for click & drag */
      this._onEvent = (event) => {
        const eventHandlerProp = EVENT_HANDLERS[event.type];
        const pos = event.offsetCenter;
        if (!eventHandlerProp || !pos || !this.layerManager) {
          return;
        }
        const layers = this.layerManager.getLayers();
        const info = this.deckPicker.getLastPickedObject(
          {
            x: pos.x,
            y: pos.y,
            layers,
            viewports: this.getViewports(pos)
          },
          this._lastPointerDownInfo
        );
        const { layer } = info;
        const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);
        const rootHandler = this.props[eventHandlerProp];
        let handled = false;
        if (layerHandler) {
          handled = layerHandler.call(layer, info, event);
        }
        if (!handled) {
          rootHandler?.(info, event);
          this.widgetManager.onEvent(info, event);
        }
      };
      /** Internal use only: evnet handler for pointerdown */
      this._onPointerDown = (event) => {
        if (this.device?.type === "webgpu") {
          return;
        }
        const pos = event.offsetCenter;
        const pickedInfo = this._pick("pickObject", "pickObject Time", {
          x: pos.x,
          y: pos.y,
          radius: this.props.pickingRadius
        });
        this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
      };
      this.props = { ...defaultProps, ...props };
      props = this.props;
      if (props.viewState && props.initialViewState) {
        log_default.warn(
          "View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update."
        )();
      }
      this.viewState = this.props.initialViewState;
      if (props.device) {
        this.device = props.device;
      }
      let deviceOrPromise = this.device;
      if (!deviceOrPromise && props.gl) {
        if (props.gl instanceof WebGLRenderingContext) {
          log_default.error("WebGL1 context not supported.")();
        }
        deviceOrPromise = webgl2Adapter.attach(props.gl);
      }
      if (!deviceOrPromise) {
        deviceOrPromise = luma.createDevice({
          type: "best-available",
          // luma by default throws if a device is already attached
          // asynchronous device creation could happen after finalize() is called
          // TODO - createDevice should support AbortController?
          _reuseDevices: true,
          adapters: [webgl2Adapter],
          ...props.deviceProps,
          createCanvasContext: {
            canvas: this._createCanvas(props),
            useDevicePixels: this.props.useDevicePixels,
            // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`
            autoResize: false
          }
        });
      }
      this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setOptions(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    /** Stop rendering and dispose all resources */
    finalize() {
      this.animationLoop?.stop();
      this.animationLoop?.destroy();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;
      this.layerManager?.finalize();
      this.layerManager = null;
      this.viewManager?.finalize();
      this.viewManager = null;
      this.effectManager?.finalize();
      this.effectManager = null;
      this.deckRenderer?.finalize();
      this.deckRenderer = null;
      this.deckPicker?.finalize();
      this.deckPicker = null;
      this.eventManager?.destroy();
      this.eventManager = null;
      this.widgetManager?.finalize();
      this.widgetManager = null;
      if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {
        this.canvas.parentElement?.removeChild(this.canvas);
        this.canvas = null;
      }
    }
    /** Partially update props */
    setProps(props) {
      this.stats.get("setProps Time").timeStart();
      if ("onLayerHover" in props) {
        log_default.removed("onLayerHover", "onHover")();
      }
      if ("onLayerClick" in props) {
        log_default.removed("onLayerClick", "onClick")();
      }
      if (props.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
      !deepEqual2(this.props.initialViewState, props.initialViewState, 3)) {
        this.viewState = props.initialViewState;
      }
      Object.assign(this.props, props);
      this._setCanvasSize(this.props);
      const resolvedProps = Object.create(this.props);
      Object.assign(resolvedProps, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      });
      this.animationLoop?.setProps(resolvedProps);
      if (this.layerManager) {
        this.viewManager.setProps(resolvedProps);
        this.layerManager.activateViewport(this.getViewports()[0]);
        this.layerManager.setProps(resolvedProps);
        this.effectManager.setProps(resolvedProps);
        this.deckRenderer.setProps(resolvedProps);
        this.deckPicker.setProps(resolvedProps);
        this.widgetManager.setProps(resolvedProps);
      }
      this.stats.get("setProps Time").timeEnd();
    }
    // Public API
    /**
     * Check if a redraw is needed
     * @returns `false` or a string summarizing the redraw reason
     */
    needsRedraw(opts = { clearRedrawFlags: false }) {
      if (!this.layerManager) {
        return false;
      }
      if (this.props._animate) {
        return "Deck._animate";
      }
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
    /**
     * Redraw the GL context
     * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
     * @returns
     */
    redraw(reason) {
      if (!this.layerManager) {
        return;
      }
      let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
      redrawReason = reason || redrawReason;
      if (!redrawReason) {
        return;
      }
      this.stats.get("Redraw Count").incrementCount();
      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
    /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
    get isInitialized() {
      return this.viewManager !== null;
    }
    /** Get a list of views that are currently rendered */
    getViews() {
      assert8(this.viewManager);
      return this.viewManager.views;
    }
    /** Get a list of viewports that are currently rendered.
     * @param rect If provided, only returns viewports within the given bounding box.
     */
    getViewports(rect) {
      assert8(this.viewManager);
      return this.viewManager.getViewports(rect);
    }
    /** Get the current canvas element. */
    getCanvas() {
      return this.canvas;
    }
    /** Query the object rendered on top at a given point */
    pickObject(opts) {
      const infos = this._pick("pickObject", "pickObject Time", opts).result;
      return infos.length ? infos[0] : null;
    }
    /* Query all rendered objects at a given point */
    pickMultipleObjects(opts) {
      opts.depth = opts.depth || 10;
      return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    /* Query all objects rendered on top within a bounding box */
    pickObjects(opts) {
      return this._pick("pickObjects", "pickObjects Time", opts);
    }
    /** Experimental
     * Add a global resource for sharing among layers
     */
    _addResources(resources, forceUpdate = false) {
      for (const id in resources) {
        this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });
      }
    }
    /** Experimental
     * Remove a global resource
     */
    _removeResources(resourceIds) {
      for (const id of resourceIds) {
        this.layerManager.resourceManager.remove(id);
      }
    }
    /** Experimental
     * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
     */
    _addDefaultEffect(effect) {
      this.effectManager.addDefaultEffect(effect);
    }
    _addDefaultShaderModule(module) {
      this.layerManager.addDefaultShaderModule(module);
    }
    _removeDefaultShaderModule(module) {
      this.layerManager?.removeDefaultShaderModule(module);
    }
    _pick(method, statKey, opts) {
      assert8(this.deckPicker);
      const { stats: stats2 } = this;
      stats2.get("Pick Count").incrementCount();
      stats2.get(statKey).timeStart();
      const infos = this.deckPicker[method]({
        // layerManager, viewManager and effectManager are always defined if deckPicker is
        layers: this.layerManager.getLayers(opts),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(opts),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...opts
      });
      stats2.get(statKey).timeEnd();
      return infos;
    }
    /** Resolve props.canvas to element */
    _createCanvas(props) {
      let canvas2 = props.canvas;
      if (typeof canvas2 === "string") {
        canvas2 = document.getElementById(canvas2);
        assert8(canvas2);
      }
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.id = props.id || "deckgl-overlay";
        const parent = props.parent || document.body;
        parent.appendChild(canvas2);
      }
      Object.assign(canvas2.style, props.style);
      return canvas2;
    }
    /** Updates canvas width and/or height, if provided as props */
    _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }
      const { width, height } = props;
      if (width || width === 0) {
        const cssWidth = Number.isFinite(width) ? `${width}px` : width;
        this.canvas.style.width = cssWidth;
      }
      if (height || height === 0) {
        const cssHeight = Number.isFinite(height) ? `${height}px` : height;
        this.canvas.style.position = props.style?.position || "absolute";
        this.canvas.style.height = cssHeight;
      }
    }
    /** If canvas size has changed, reads out the new size and update */
    _updateCanvasSize() {
      const { canvas: canvas2 } = this;
      if (!canvas2) {
        return;
      }
      const newWidth = canvas2.clientWidth ?? canvas2.width;
      const newHeight = canvas2.clientHeight ?? canvas2.height;
      if (newWidth !== this.width || newHeight !== this.height) {
        this.width = newWidth;
        this.height = newHeight;
        this.viewManager?.setProps({ width: newWidth, height: newHeight });
        this.layerManager?.activateViewport(this.getViewports()[0]);
        this.props.onResize({ width: newWidth, height: newHeight });
      }
    }
    _createAnimationLoop(deviceOrPromise, props) {
      const {
        // width,
        // height,
        gl,
        // debug,
        onError,
        // onBeforeRender,
        // onAfterRender,
        useDevicePixels
      } = props;
      return new AnimationLoop({
        device: deviceOrPromise,
        useDevicePixels,
        // TODO v9
        autoResizeDrawingBuffer: !gl,
        // do not auto resize external context
        autoResizeViewport: false,
        // @ts-expect-error luma.gl needs to accept Promise<void> return value
        onInitialize: (context) => this._setDevice(context.device),
        onRender: this._onRenderFrame.bind(this),
        // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
        onError
        // onBeforeRender,
        // onAfterRender,
      });
    }
    // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
    // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    // Get the view descriptor list
    _getViews() {
      const { views } = this.props;
      const normalizedViews = Array.isArray(views) ? views : (
        // If null, default to a full screen map view port
        views ? [views] : [new MapView({ id: "default-view" })]
      );
      if (normalizedViews.length && this.props.controller) {
        normalizedViews[0].props.controller = this.props.controller;
      }
      return normalizedViews;
    }
    _onContextLost() {
      const { onError } = this.props;
      if (this.animationLoop && onError) {
        onError(new Error("WebGL context is lost"));
      }
    }
    /** Actually run picking */
    _pickAndCallback() {
      if (this.device?.type === "webgpu") {
        return;
      }
      const { _pickRequest } = this;
      if (_pickRequest.event) {
        const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
        this.cursorState.isHovering = result.length > 0;
        let pickedInfo = emptyInfo;
        let handled = false;
        for (const info of result) {
          pickedInfo = info;
          handled = info.layer?.onHover(info, _pickRequest.event) || handled;
        }
        if (!handled) {
          this.props.onHover?.(pickedInfo, _pickRequest.event);
          this.widgetManager.onHover(pickedInfo, _pickRequest.event);
        }
        _pickRequest.event = null;
      }
    }
    _updateCursor() {
      const container = this.props.parent || this.canvas;
      if (container) {
        container.style.cursor = this.props.getCursor(this.cursorState);
      }
    }
    _setDevice(device) {
      this.device = device;
      if (!this.animationLoop) {
        return;
      }
      if (!this.canvas) {
        this.canvas = this.device.canvasContext?.canvas;
      }
      if (this.device.type === "webgl") {
        this.device.setParametersWebGL({
          blend: true,
          blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
          polygonOffsetFill: true,
          depthTest: true,
          depthFunc: GLEnum.LEQUAL
        });
      }
      this.props.onDeviceInitialized(this.device);
      if (this.device.type === "webgl") {
        this.props.onWebGLInitialized(this.device.gl);
      }
      const timeline = new Timeline();
      timeline.play();
      this.animationLoop.attachTimeline(timeline);
      this.eventManager = new EventManager(this.props.parent || this.canvas, {
        touchAction: this.props.touchAction,
        recognizers: Object.keys(RECOGNIZERS).map((eventName) => {
          const [RecognizerConstructor, defaultOptions3, recognizeWith, requestFailure] = RECOGNIZERS[eventName];
          const optionsOverride = this.props.eventRecognizerOptions?.[eventName];
          const options = { ...defaultOptions3, ...optionsOverride, event: eventName };
          return {
            recognizer: new RecognizerConstructor(options),
            recognizeWith,
            requestFailure
          };
        }),
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const eventType in EVENT_HANDLERS) {
        this.eventManager.on(eventType, this._onEvent);
      }
      this.viewManager = new ViewManager({
        timeline,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const viewport = this.viewManager.getViewports()[0];
      this.layerManager = new LayerManager(this.device, {
        deck: this,
        stats: this.stats,
        viewport,
        timeline
      });
      this.effectManager = new EffectManager({
        deck: this,
        device: this.device
      });
      this.deckRenderer = new DeckRenderer(this.device);
      this.deckPicker = new DeckPicker(this.device);
      this.widgetManager = new WidgetManager({
        deck: this,
        parentElement: this.canvas?.parentElement
      });
      this.widgetManager.addDefault(new Tooltip());
      this.setProps(this.props);
      this._updateCanvasSize();
      this.props.onLoad();
    }
    /** Internal only: default render function (redraw all layers and views) */
    _drawLayers(redrawReason, renderOptions) {
      const { device, gl } = this.layerManager.context;
      this.props.onBeforeRender({ device, gl });
      const opts = {
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...renderOptions
      };
      this.deckRenderer?.renderLayers(opts);
      if (opts.pass === "screen") {
        this.widgetManager.onRedraw({
          viewports: opts.viewports,
          layers: opts.layers
        });
      }
      this.props.onAfterRender({ device, gl });
    }
    // Callbacks
    _onRenderFrame() {
      this._getFrameStats();
      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();
        this.stats.reset();
        log_default.table(4, this.metrics)();
        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }
      this._updateCanvasSize();
      this._updateCursor();
      this.layerManager.updateLayers();
      if (this.device?.type !== "webgpu") {
        this._pickAndCallback();
      }
      this.redraw();
      if (this.viewManager) {
        this.viewManager.updateViewStates();
      }
    }
    // Callbacks
    _onViewStateChange(params) {
      const viewState = this.props.onViewStateChange(params) || params.viewState;
      if (this.viewState) {
        this.viewState = { ...this.viewState, [params.viewId]: viewState };
        if (!this.props.viewState) {
          if (this.viewManager) {
            this.viewManager.setProps({ viewState: this.viewState });
          }
        }
      }
    }
    _onInteractionStateChange(interactionState) {
      this.cursorState.isDragging = interactionState.isDragging || false;
      this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
      const { stats: stats2 } = this;
      stats2.get("frameRate").timeEnd();
      stats2.get("frameRate").timeStart();
      const animationLoopStats = this.animationLoop.stats;
      stats2.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
      stats2.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const { metrics, stats: stats2 } = this;
      metrics.fps = stats2.get("frameRate").getHz();
      metrics.setPropsTime = stats2.get("setProps Time").time;
      metrics.updateAttributesTime = stats2.get("Update Attributes").time;
      metrics.framesRedrawn = stats2.get("Redraw Count").count;
      metrics.pickTime = stats2.get("pickObject Time").time + stats2.get("pickMultipleObjects Time").time + stats2.get("pickObjects Time").time;
      metrics.pickCount = stats2.get("Pick Count").count;
      metrics.gpuTime = stats2.get("GPU Time").time;
      metrics.cpuTime = stats2.get("CPU Time").time;
      metrics.gpuTimePerFrame = stats2.get("GPU Time").getAverageTime();
      metrics.cpuTimePerFrame = stats2.get("CPU Time").getAverageTime();
      const memoryStats = luma.stats.get("Memory Usage");
      metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
      metrics.textureMemory = memoryStats.get("Texture Memory").count;
      metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
      metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
  };
  Deck.defaultProps = defaultProps;
  // This is used to defeat tree shaking of init.js
  // https://github.com/visgl/deck.gl/issues/3213
  Deck.VERSION = VERSION4;

  // ../core/src/lib/attribute/gl-utils.ts
  function typedArrayFromDataType(type) {
    switch (type) {
      case "float64":
        return Float64Array;
      case "uint8":
      case "unorm8":
        return Uint8ClampedArray;
      default:
        return getTypedArrayFromDataType(type);
    }
  }
  var dataTypeFromTypedArray = getDataTypeFromTypedArray2;
  function getBufferAttributeLayout(name13, accessor, deviceType) {
    const type = deviceType === "webgpu" && accessor.type === "uint8" ? "unorm8" : accessor.type;
    return {
      attribute: name13,
      // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
      format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,
      byteOffset: accessor.offset || 0
      // Note stride is set on the top level
    };
  }
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function bufferLayoutEqual(accessor1, accessor2) {
    return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
  }

  // ../core/src/lib/attribute/data-column.ts
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    const stride = getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = (
      // offsets defined by the attribute
      vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + // offsets defined by external buffers if any
      (baseAccessor.offset || 0)
    );
    return {
      ...shaderAttributeOptions,
      offset,
      stride
    };
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: {
        ...resolvedOptions,
        offset: resolvedOptions.offset + baseAccessor.size * 4
      }
    };
  }
  var DataColumn = class {
    /* eslint-disable max-statements */
    constructor(device, opts, state) {
      this._buffer = null;
      this.device = device;
      this.id = opts.id || "";
      this.size = opts.size || 1;
      const logicalType = opts.logicalType || opts.type;
      const doublePrecision = logicalType === "float64";
      let { defaultValue: defaultValue2 } = opts;
      defaultValue2 = Number.isFinite(defaultValue2) ? [defaultValue2] : defaultValue2 || new Array(this.size).fill(0);
      let bufferType;
      if (doublePrecision) {
        bufferType = "float32";
      } else if (!logicalType && opts.isIndexed) {
        bufferType = "uint32";
      } else {
        bufferType = logicalType || "float32";
      }
      let defaultType = typedArrayFromDataType(logicalType || bufferType);
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      this.value = null;
      this.settings = {
        ...opts,
        defaultType,
        defaultValue: defaultValue2,
        logicalType,
        type: bufferType,
        normalized: bufferType.includes("norm"),
        size: this.size,
        bytesPerElement: defaultType.BYTES_PER_ELEMENT
      };
      this.state = {
        ...state,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
    }
    /* eslint-enable max-statements */
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      return this._buffer;
    }
    get byteOffset() {
      const accessor = this.getAccessor();
      if (accessor.vertexOffset) {
        return accessor.vertexOffset * getStride(accessor);
      }
      return 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(n3) {
      this.state.numInstances = n3;
    }
    delete() {
      if (this._buffer) {
        this._buffer.delete();
        this._buffer = null;
      }
      typed_array_manager_default.release(this.state.allocatedValue);
    }
    getBuffer() {
      if (this.state.constant) {
        return null;
      }
      return this.state.externalBuffer || this._buffer;
    }
    getValue(attributeName = this.id, options = null) {
      const result = {};
      if (this.state.constant) {
        const value = this.value;
        if (options) {
          const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
          const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
          const size = shaderAttributeDef.size || this.size;
          result[attributeName] = value.subarray(offset, offset + size);
        } else {
          result[attributeName] = value;
        }
      } else {
        result[attributeName] = this.getBuffer();
      }
      if (this.doublePrecision) {
        if (this.value instanceof Float64Array) {
          result[`${attributeName}64Low`] = result[attributeName];
        } else {
          result[`${attributeName}64Low`] = new Float32Array(this.size);
        }
      }
      return result;
    }
    _getBufferLayout(attributeName = this.id, options = null) {
      const accessor = this.getAccessor();
      const attributes = [];
      const result = {
        name: this.id,
        byteStride: getStride(accessor),
        attributes
      };
      if (this.doublePrecision) {
        const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(
          accessor,
          options || {}
        );
        attributes.push(
          getBufferAttributeLayout(
            attributeName,
            { ...accessor, ...doubleShaderAttributeDefs.high },
            this.device.type
          ),
          getBufferAttributeLayout(
            `${attributeName}64Low`,
            {
              ...accessor,
              ...doubleShaderAttributeDefs.low
            },
            this.device.type
          )
        );
      } else if (options) {
        const shaderAttributeDef = resolveShaderAttribute(accessor, options);
        attributes.push(
          getBufferAttributeLayout(
            attributeName,
            { ...accessor, ...shaderAttributeDef },
            this.device.type
          )
        );
      } else {
        attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));
      }
      return result;
    }
    setAccessor(accessor) {
      this.state.bufferAccessor = accessor;
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    // Returns [min: Array(size), max: Array(size)]
    /* eslint-disable max-depth */
    getBounds() {
      if (this.state.bounds) {
        return this.state.bounds;
      }
      let result = null;
      if (this.state.constant && this.value) {
        const min6 = Array.from(this.value);
        result = [min6, min6];
      } else {
        const { value, numInstances, size } = this;
        const len8 = numInstances * size;
        if (value && len8 && value.length >= len8) {
          const min6 = new Array(size).fill(Infinity);
          const max6 = new Array(size).fill(-Infinity);
          for (let i5 = 0; i5 < len8; ) {
            for (let j2 = 0; j2 < size; j2++) {
              const v2 = value[i5++];
              if (v2 < min6[j2])
                min6[j2] = v2;
              if (v2 > max6[j2])
                max6[j2] = v2;
            }
          }
          result = [min6, max6];
        }
      }
      this.state.bounds = result;
      return result;
    }
    // returns true if success
    // eslint-disable-next-line max-statements
    setData(data) {
      const { state } = this;
      let opts;
      if (ArrayBuffer.isView(data)) {
        opts = { value: data };
      } else if (data instanceof Buffer2) {
        opts = { buffer: data };
      } else {
        opts = data;
      }
      const accessor = { ...this.settings, ...opts };
      if (ArrayBuffer.isView(opts.value)) {
        if (!opts.type) {
          const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;
          if (is64Bit) {
            accessor.type = "float32";
          } else {
            const type = dataTypeFromTypedArray(opts.value);
            accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
          }
        }
        accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
        accessor.stride = getStride(accessor);
      }
      state.bounds = null;
      if (opts.constant) {
        let value = opts.value;
        value = this._normalizeValue(value, [], 0);
        if (this.settings.normalized) {
          value = this.normalizeConstant(value);
        }
        const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
        if (!hasChanged) {
          return false;
        }
        state.externalBuffer = null;
        state.constant = true;
        this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
      } else if (opts.buffer) {
        const buffer = opts.buffer;
        state.externalBuffer = buffer;
        state.constant = false;
        this.value = opts.value || null;
      } else if (opts.value) {
        this._checkExternalBuffer(opts);
        let value = opts.value;
        state.externalBuffer = null;
        state.constant = false;
        this.value = value;
        let { buffer } = this;
        const stride = getStride(accessor);
        const byteOffset = (accessor.vertexOffset || 0) * stride;
        if (this.doublePrecision && value instanceof Float64Array) {
          value = toDoublePrecisionArray(value, accessor);
        }
        if (this.settings.isIndexed) {
          const ArrayType2 = this.settings.defaultType;
          if (value.constructor !== ArrayType2) {
            value = new ArrayType2(value);
          }
        }
        const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
        if (!buffer || buffer.byteLength < requiredBufferSize) {
          buffer = this._createBuffer(requiredBufferSize);
        }
        buffer.write(value, byteOffset);
      }
      this.setAccessor(accessor);
      return true;
    }
    updateSubBuffer(opts = {}) {
      this.state.bounds = null;
      const value = this.value;
      const { startOffset = 0, endOffset } = opts;
      this.buffer.write(
        this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
          size: this.size,
          startIndex: startOffset,
          endIndex: endOffset
        }) : value.subarray(startOffset, endOffset),
        startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
      );
    }
    allocate(numInstances, copy12 = false) {
      const { state } = this;
      const oldValue = state.allocatedValue;
      const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy: copy12
      });
      this.value = value;
      const { byteOffset } = this;
      let { buffer } = this;
      if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
        buffer = this._createBuffer(value.byteLength + byteOffset);
        if (copy12 && oldValue) {
          buffer.write(
            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
            byteOffset
          );
        }
      }
      state.allocatedValue = value;
      state.constant = false;
      state.externalBuffer = null;
      this.setAccessor(this.settings);
      return true;
    }
    // PRIVATE HELPER METHODS
    _checkExternalBuffer(opts) {
      const { value } = opts;
      if (!ArrayBuffer.isView(value)) {
        throw new Error(`Attribute ${this.id} value is not TypedArray`);
      }
      const ArrayType2 = this.settings.defaultType;
      let illegalArrayType = false;
      if (this.doublePrecision) {
        illegalArrayType = value.BYTES_PER_ELEMENT < 4;
      }
      if (illegalArrayType) {
        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
      }
      if (!(value instanceof ArrayType2) && this.settings.normalized && !("normalized" in opts)) {
        log_default.warn(`Attribute ${this.id} is normalized`)();
      }
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
    normalizeConstant(value) {
      switch (this.settings.type) {
        case "snorm8":
          return new Float32Array(value).map((x3) => (x3 + 128) / 255 * 2 - 1);
        case "snorm16":
          return new Float32Array(value).map((x3) => (x3 + 32768) / 65535 * 2 - 1);
        case "unorm8":
          return new Float32Array(value).map((x3) => x3 / 255);
        case "unorm16":
          return new Float32Array(value).map((x3) => x3 / 65535);
        default:
          return value;
      }
    }
    /* check user supplied values and apply fallback */
    _normalizeValue(value, out, start) {
      const { defaultValue: defaultValue2, size } = this.settings;
      if (Number.isFinite(value)) {
        out[start] = value;
        return out;
      }
      if (!value) {
        let i5 = size;
        while (--i5 >= 0) {
          out[start + i5] = defaultValue2[i5];
        }
        return out;
      }
      switch (size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue2[3];
        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue2[2];
        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue2[1];
        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue2[0];
          break;
        default:
          let i5 = size;
          while (--i5 >= 0) {
            out[start + i5] = Number.isFinite(value[i5]) ? value[i5] : defaultValue2[i5];
          }
      }
      return out;
    }
    _areValuesEqual(value1, value2) {
      if (!value1 || !value2) {
        return false;
      }
      const { size } = this;
      for (let i5 = 0; i5 < size; i5++) {
        if (value1[i5] !== value2[i5]) {
          return false;
        }
      }
      return true;
    }
    _createBuffer(byteLength) {
      if (this._buffer) {
        this._buffer.destroy();
      }
      const { isIndexed, type } = this.settings;
      this._buffer = this.device.createBuffer({
        ...this._buffer?.props,
        id: this.id,
        // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
        usage: (isIndexed ? Buffer2.INDEX : Buffer2.VERTEX) | Buffer2.COPY_DST,
        indexType: isIndexed ? type : void 0,
        byteLength
      });
      return this._buffer;
    }
  };

  // ../core/src/utils/iterable-utils.ts
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data, startRow = 0, endRow = Infinity) {
    let iterable = EMPTY_ARRAY;
    const objectInfo = {
      index: -1,
      data,
      // visitor can optionally utilize this to avoid constructing a new array for every object
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return { iterable, objectInfo };
  }
  function isAsyncIterable2(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, options) {
    const { size, stride, offset, startIndices, nested } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_2, { index, target: target2 }) => {
      if (!startIndices) {
        const sourceIndex = index * elementStride + elementOffset;
        for (let j2 = 0; j2 < size; j2++) {
          target2[j2] = typedArray[sourceIndex + j2];
        }
        return target2;
      }
      const startIndex = startIndices[index];
      const endIndex = startIndices[index + 1] || vertexCount;
      let result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          const sourceIndex = i5 * elementStride + elementOffset;
          target2 = new Array(size);
          for (let j2 = 0; j2 < size; j2++) {
            target2[j2] = typedArray[sourceIndex + j2];
          }
          result[i5 - startIndex] = target2;
        }
      } else if (elementStride === size) {
        result = typedArray.subarray(
          startIndex * size + elementOffset,
          endIndex * size + elementOffset
        );
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size);
        let targetIndex = 0;
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          const sourceIndex = i5 * elementStride + elementOffset;
          for (let j2 = 0; j2 < size; j2++) {
            result[targetIndex++] = typedArray[sourceIndex + j2];
          }
        }
      }
      return result;
    };
  }

  // ../core/src/utils/range.ts
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add6(rangeList, range) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    if (range[0] >= range[1]) {
      return rangeList;
    }
    const newRangeList = [];
    const len8 = rangeList.length;
    let insertPosition = 0;
    for (let i5 = 0; i5 < len8; i5++) {
      const range0 = rangeList[i5];
      if (range0[1] < range[0]) {
        newRangeList.push(range0);
        insertPosition = i5 + 1;
      } else if (range0[0] > range[1]) {
        newRangeList.push(range0);
      } else {
        range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
  }

  // ../core/src/lib/attribute/transition-settings.ts
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: (t3) => t3
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = { type: "interpolation", duration: userSettings };
    }
    const type = userSettings.type || "interpolation";
    return {
      ...DEFAULT_TRANSITION_SETTINGS[type],
      ...layerSettings,
      ...userSettings,
      type
    };
  }

  // ../core/src/lib/attribute/attribute.ts
  var Attribute2 = class extends DataColumn {
    constructor(device, opts) {
      super(device, opts, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        layoutChanged: false,
        updateRanges: FULL
      });
      /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */
      this.constant = false;
      this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
      Object.seal(this.settings);
      Object.seal(this.state);
      this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(layout) {
      this.state.startIndices = layout;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags = false } = {}) {
      const needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
    layoutChanged() {
      return this.state.layoutChanged;
    }
    setAccessor(accessor) {
      this.state.layoutChanged ||= !bufferLayoutEqual(accessor, this.getAccessor());
      super.setAccessor(accessor);
    }
    getUpdateTriggers() {
      const { accessor } = this.settings;
      return [this.id].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    // Resolve transition settings object if transition is enabled, otherwise `null`
    getTransitionSetting(opts) {
      if (!opts || !this.supportsTransition()) {
        return null;
      }
      const { accessor } = this.settings;
      const layerSettings = this.settings.transition;
      const userSettings = Array.isArray(accessor) ? (
        // @ts-ignore
        opts[accessor.find((a3) => opts[a3])]
      ) : (
        // @ts-ignore
        opts[accessor]
      );
      return normalizeTransitionSettings(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
      this.state.needsUpdate = this.state.needsUpdate || reason;
      this.setNeedsRedraw(reason);
      if (dataRange) {
        const { startRow = 0, endRow = Infinity } = dataRange;
        this.state.updateRanges = add6(this.state.updateRanges, [startRow, endRow]);
      } else {
        this.state.updateRanges = FULL;
      }
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false;
      this.state.updateRanges = EMPTY;
    }
    setNeedsRedraw(reason = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
      const { state, settings } = this;
      if (settings.noAlloc) {
        return false;
      }
      if (settings.update) {
        super.allocate(numInstances, state.updateRanges !== FULL);
        return true;
      }
      return false;
    }
    updateBuffer({
      numInstances,
      data,
      props,
      context
    }) {
      if (!this.needsUpdate()) {
        return false;
      }
      const {
        state: { updateRanges },
        settings: { update, noAlloc }
      } = this;
      let updated = true;
      if (update) {
        for (const [startRow, endRow] of updateRanges) {
          update.call(context, this, { data, startRow, endRow, props, numInstances });
        }
        if (!this.value) {
        } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
          this.setData({
            value: this.value,
            constant: this.constant
          });
          this.constant = false;
        } else {
          for (const [startRow, endRow] of updateRanges) {
            const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
            const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
            super.updateSubBuffer({ startOffset, endOffset });
          }
        }
        this._checkAttributeArray();
      } else {
        updated = false;
      }
      this.clearNeedsUpdate();
      this.setNeedsRedraw();
      return updated;
    }
    // Use generic value
    // Returns true if successful
    setConstantValue(value) {
      const isWebGPU = this.device.type === "webgpu";
      if (isWebGPU || value === void 0 || typeof value === "function") {
        return false;
      }
      const hasChanged = this.setData({ constant: true, value });
      if (hasChanged) {
        this.setNeedsRedraw();
      }
      this.clearNeedsUpdate();
      return true;
    }
    // Use external buffer
    // Returns true if successful
    // eslint-disable-next-line max-statements
    setExternalBuffer(buffer) {
      const { state } = this;
      if (!buffer) {
        state.lastExternalBuffer = null;
        return false;
      }
      this.clearNeedsUpdate();
      if (state.lastExternalBuffer === buffer) {
        return true;
      }
      state.lastExternalBuffer = buffer;
      this.setNeedsRedraw();
      this.setData(buffer);
      return true;
    }
    // Binary value is a typed array packed from mapping the source data with the accessor
    // If the returned value from the accessor is the same as the attribute value, set it directly
    // Otherwise use the auto updater for transform/normalization
    setBinaryValue(buffer, startIndices = null) {
      const { state, settings } = this;
      if (!buffer) {
        state.binaryValue = null;
        state.binaryAccessor = null;
        return false;
      }
      if (settings.noAlloc) {
        return false;
      }
      if (state.binaryValue === buffer) {
        this.clearNeedsUpdate();
        return true;
      }
      state.binaryValue = buffer;
      this.setNeedsRedraw();
      const needsUpdate = settings.transform || startIndices !== this.startIndices;
      if (needsUpdate) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = { value: buffer };
        }
        const binaryValue = buffer;
        assert8(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
        const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
        state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
          size: binaryValue.size || this.size,
          stride: binaryValue.stride,
          offset: binaryValue.offset,
          startIndices,
          nested: needsNormalize
        });
        return false;
      }
      this.clearNeedsUpdate();
      this.setData(buffer);
      return true;
    }
    getVertexOffset(row) {
      const { startIndices } = this;
      const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
      return vertexIndex * this.size;
    }
    getValue() {
      const shaderAttributeDefs = this.settings.shaderAttributes;
      const result = super.getValue();
      if (!shaderAttributeDefs) {
        return result;
      }
      for (const shaderAttributeName in shaderAttributeDefs) {
        Object.assign(
          result,
          super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])
        );
      }
      return result;
    }
    /** Generate WebGPU-style buffer layout descriptor from this attribute */
    getBufferLayout(modelInfo) {
      this.state.layoutChanged = false;
      const shaderAttributeDefs = this.settings.shaderAttributes;
      const result = super._getBufferLayout();
      const { stepMode } = this.settings;
      if (stepMode === "dynamic") {
        result.stepMode = modelInfo ? modelInfo.isInstanced ? "instance" : "vertex" : "instance";
      } else {
        result.stepMode = stepMode ?? "vertex";
      }
      if (!shaderAttributeDefs) {
        return result;
      }
      for (const shaderAttributeName in shaderAttributeDefs) {
        const map6 = super._getBufferLayout(
          shaderAttributeName,
          shaderAttributeDefs[shaderAttributeName]
        );
        result.attributes.push(...map6.attributes);
      }
      return result;
    }
    /* eslint-disable max-depth, max-statements */
    _autoUpdater(attribute, {
      data,
      startRow,
      endRow,
      props,
      numInstances
    }) {
      if (attribute.constant) {
        if (this.context.device.type !== "webgpu") {
          return;
        }
      }
      const { settings, state, value, size, startIndices } = attribute;
      const { accessor, transform: transform2 } = settings;
      let accessorFunc = state.binaryAccessor || // @ts-ignore
      (typeof accessor === "function" ? accessor : props[accessor]);
      if (typeof accessorFunc !== "function") {
        accessorFunc = () => accessorFunc;
      }
      assert8(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
      let i5 = attribute.getVertexOffset(startRow);
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let objectValue = accessorFunc(object, objectInfo);
        if (transform2) {
          objectValue = transform2.call(this, objectValue);
        }
        if (startIndices) {
          const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
          if (objectValue && Array.isArray(objectValue[0])) {
            let startIndex = i5;
            for (const item of objectValue) {
              attribute._normalizeValue(item, value, startIndex);
              startIndex += size;
            }
          } else if (objectValue && objectValue.length > size) {
            value.set(objectValue, i5);
          } else {
            attribute._normalizeValue(objectValue, objectInfo.target, 0);
            fillArray({
              target: value,
              source: objectInfo.target,
              start: i5,
              count: numVertices
            });
          }
          i5 += numVertices * size;
        } else {
          attribute._normalizeValue(objectValue, value, i5);
          i5 += size;
        }
      }
    }
    /* eslint-enable max-depth, max-statements */
    // Validate deck.gl level fields
    _validateAttributeUpdaters() {
      const { settings } = this;
      const hasUpdater = settings.noAlloc || typeof settings.update === "function";
      if (!hasUpdater) {
        throw new Error(`Attribute ${this.id} missing update or accessor`);
      }
    }
    // check that the first few elements of the attribute are reasonable
    /* eslint-disable no-fallthrough */
    _checkAttributeArray() {
      const { value } = this;
      const limit = Math.min(4, this.size);
      if (value && value.length >= limit) {
        let valid = true;
        switch (limit) {
          case 4:
            valid = valid && Number.isFinite(value[3]);
          case 3:
            valid = valid && Number.isFinite(value[2]);
          case 2:
            valid = valid && Number.isFinite(value[1]);
          case 1:
            valid = valid && Number.isFinite(value[0]);
            break;
          default:
            valid = false;
        }
        if (!valid) {
          throw new Error(`Illegal attribute generated for ${this.id}`);
        }
      }
    }
    /* eslint-enable no-fallthrough */
  };

  // ../core/src/utils/array-utils.ts
  function padArrayChunk(options) {
    const { source: source3, target: target2, start = 0, size, getData } = options;
    const end = options.end || target2.length;
    const sourceLength = source3.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
      target2.set(source3.subarray(0, targetLength), start);
      return;
    }
    target2.set(source3, start);
    if (!getData) {
      return;
    }
    let i5 = sourceLength;
    while (i5 < targetLength) {
      const datum = getData(i5, source3);
      for (let j2 = 0; j2 < size; j2++) {
        target2[start + i5] = datum[j2] || 0;
        i5++;
      }
    }
  }
  function padArray({
    source: source3,
    target: target2,
    size,
    getData,
    sourceStartIndices,
    targetStartIndices
  }) {
    if (!sourceStartIndices || !targetStartIndices) {
      padArrayChunk({
        source: source3,
        target: target2,
        size,
        getData
      });
      return target2;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i5, chunk) => getData(i5 + targetIndex, chunk));
    const n3 = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (let i5 = 1; i5 < n3; i5++) {
      const nextSourceIndex = sourceStartIndices[i5] * size;
      const nextTargetIndex = targetStartIndices[i5] * size;
      padArrayChunk({
        source: source3.subarray(sourceIndex, nextSourceIndex),
        target: target2,
        start: targetIndex,
        end: nextTargetIndex,
        size,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target2.length) {
      padArrayChunk({
        // @ts-ignore
        source: [],
        target: target2,
        start: targetIndex,
        size,
        getData: getChunkData
      });
    }
    return target2;
  }

  // ../core/src/transitions/gpu-transition-utils.ts
  function cloneAttribute(attribute) {
    const { device, settings, value } = attribute;
    const newAttribute = new Attribute2(device, settings);
    newAttribute.setData({
      value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
      normalized: settings.normalized
    });
    return newAttribute;
  }
  function getAttributeTypeFromSize(size) {
    switch (size) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`No defined attribute type for size "${size}"`);
    }
  }
  function getFloat32VertexFormat(size) {
    switch (size) {
      case 1:
        return "float32";
      case 2:
        return "float32x2";
      case 3:
        return "float32x3";
      case 4:
        return "float32x4";
      default:
        throw new Error("invalid type size");
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    const { doublePrecision, settings, value, size } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    let maxVertexOffset = 0;
    const { shaderAttributes } = attribute.settings;
    if (shaderAttributes) {
      for (const shaderAttribute of Object.values(shaderAttributes)) {
        maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
      }
    }
    return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
  }
  function matchBuffer({
    device,
    source: source3,
    target: target2
  }) {
    if (!target2 || target2.byteLength < source3.byteLength) {
      target2?.destroy();
      target2 = device.createBuffer({
        byteLength: source3.byteLength,
        usage: source3.usage
      });
    }
    return target2;
  }
  function padBuffer({
    device,
    buffer,
    attribute,
    fromLength,
    toLength,
    fromStartIndices,
    getData = (x3) => x3
  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && buffer && fromLength >= toLength) {
      return buffer;
    }
    const ArrayType2 = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
    const toData = isConstant ? attribute.value : (
      // TODO(v9.1): Avoid non-portable synchronous reads.
      new ArrayType2(
        attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType2.BYTES_PER_ELEMENT).buffer
      )
    );
    if (attribute.settings.normalized && !isConstant) {
      const getter = getData;
      getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i5, chunk) => getData(toData, chunk) : (i5, chunk) => getData(toData.subarray(i5 + byteOffset, i5 + byteOffset + size), chunk);
    const source3 = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
    const target2 = new Float32Array(toLength);
    padArray({
      source: source3,
      target: target2,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size,
      getData: getMissingData
    });
    if (!buffer || buffer.byteLength < target2.byteLength + targetByteOffset) {
      buffer?.destroy();
      buffer = device.createBuffer({
        byteLength: target2.byteLength + targetByteOffset,
        usage: GLEnum.DYNAMIC_COPY
      });
    }
    buffer.write(target2, targetByteOffset);
    return buffer;
  }

  // ../core/src/transitions/gpu-transition.ts
  var GPUTransitionBase = class {
    constructor({
      device,
      attribute,
      timeline
    }) {
      this.buffers = [];
      /** The vertex count of the last buffer.
       * Buffer may be larger than the actual length we want to use
       * because we only reallocate buffers when they grow, not when they shrink,
       * due to performance costs */
      this.currentLength = 0;
      this.device = device;
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = cloneAttribute(attribute);
      this.currentStartIndices = attribute.startIndices;
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances, duration = Infinity) {
      this.settings = transitionSettings;
      this.currentStartIndices = this.attribute.startIndices;
      this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
      this.transition.start({ ...transitionSettings, duration });
    }
    update() {
      const updated = this.transition.update();
      if (updated) {
        this.onUpdate();
      }
      return updated;
    }
    setBuffer(buffer) {
      this.attributeInTransition.setData({
        buffer,
        normalized: this.attribute.settings.normalized,
        // Retain placeholder value to generate correct shader layout
        value: this.attributeInTransition.value
      });
    }
    cancel() {
      this.transition.cancel();
    }
    delete() {
      this.cancel();
      for (const buffer of this.buffers) {
        buffer.destroy();
      }
      this.buffers.length = 0;
    }
  };

  // ../core/src/transitions/gpu-interpolation-transition.ts
  var GPUInterpolationTransition = class extends GPUTransitionBase {
    constructor({
      device,
      attribute,
      timeline
    }) {
      super({ device, attribute, timeline });
      this.type = "interpolation";
      this.transform = getTransform(device, attribute);
    }
    start(transitionSettings, numInstances) {
      const prevLength = this.currentLength;
      const prevStartIndices = this.currentStartIndices;
      super.start(transitionSettings, numInstances, transitionSettings.duration);
      if (transitionSettings.duration <= 0) {
        this.transition.cancel();
        return;
      }
      const { buffers, attribute } = this;
      cycleBuffers(buffers);
      buffers[0] = padBuffer({
        device: this.device,
        buffer: buffers[0],
        attribute,
        fromLength: prevLength,
        toLength: this.currentLength,
        fromStartIndices: prevStartIndices,
        getData: transitionSettings.enter
      });
      buffers[1] = matchBuffer({
        device: this.device,
        source: buffers[0],
        target: buffers[1]
      });
      this.setBuffer(buffers[1]);
      const { transform: transform2 } = this;
      const model = transform2.model;
      let vertexCount = Math.floor(this.currentLength / attribute.size);
      if (useFp64(attribute)) {
        vertexCount /= 2;
      }
      model.setVertexCount(vertexCount);
      if (attribute.isConstant) {
        model.setAttributes({ aFrom: buffers[0] });
        model.setConstantAttributes({ aTo: attribute.value });
      } else {
        model.setAttributes({
          aFrom: buffers[0],
          aTo: attribute.getBuffer()
        });
      }
      transform2.transformFeedback.setBuffers({ vCurrent: buffers[1] });
    }
    onUpdate() {
      const { duration, easing } = this.settings;
      const { time } = this.transition;
      let t3 = time / duration;
      if (easing) {
        t3 = easing(t3);
      }
      const { model } = this.transform;
      const interpolationProps = { time: t3 };
      model.shaderInputs.setProps({ interpolation: interpolationProps });
      this.transform.run({ discard: true });
    }
    delete() {
      super.delete();
      this.transform.destroy();
    }
  };
  var uniformBlock5 = `uniform interpolationUniforms {
  float time;
} interpolation;
`;
  var interpolationUniforms = {
    name: "interpolation",
    vs: uniformBlock5,
    uniformTypes: {
      time: "f32"
    }
  };
  var vs6 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`;
  var vs64 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
  function useFp64(attribute) {
    return attribute.doublePrecision && attribute.value instanceof Float64Array;
  }
  function getTransform(device, attribute) {
    const attributeSize = attribute.size;
    const attributeType = getAttributeTypeFromSize(attributeSize);
    const inputFormat = getFloat32VertexFormat(attributeSize);
    const bufferLayout = attribute.getBufferLayout();
    if (useFp64(attribute)) {
      return new BufferTransform(device, {
        vs: vs64,
        bufferLayout: [
          {
            name: "aFrom",
            byteStride: 8 * attributeSize,
            attributes: [
              { attribute: "aFrom", format: inputFormat, byteOffset: 0 },
              { attribute: "aFrom64Low", format: inputFormat, byteOffset: 4 * attributeSize }
            ]
          },
          {
            name: "aTo",
            byteStride: 8 * attributeSize,
            attributes: [
              { attribute: "aTo", format: inputFormat, byteOffset: 0 },
              { attribute: "aTo64Low", format: inputFormat, byteOffset: 4 * attributeSize }
            ]
          }
        ],
        // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
        modules: [fp64arithmetic, interpolationUniforms],
        defines: {
          ATTRIBUTE_TYPE: attributeType,
          ATTRIBUTE_SIZE: attributeSize
        },
        // Default uniforms are not set without this
        moduleSettings: {},
        varyings: ["vCurrent", "vCurrent64Low"],
        bufferMode: GLEnum.INTERLEAVED_ATTRIBS,
        disableWarnings: true
      });
    }
    return new BufferTransform(device, {
      vs: vs6,
      bufferLayout: [
        { name: "aFrom", format: inputFormat },
        { name: "aTo", format: bufferLayout.attributes[0].format }
      ],
      modules: [interpolationUniforms],
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"],
      // TODO investigate why this is needed
      disableWarnings: true
    });
  }

  // ../core/src/transitions/gpu-spring-transition.ts
  var GPUSpringTransition = class extends GPUTransitionBase {
    constructor({
      device,
      attribute,
      timeline
    }) {
      super({ device, attribute, timeline });
      this.type = "spring";
      this.texture = getTexture(device);
      this.framebuffer = getFramebuffer3(device, this.texture);
      this.transform = getTransform2(device, attribute);
    }
    start(transitionSettings, numInstances) {
      const prevLength = this.currentLength;
      const prevStartIndices = this.currentStartIndices;
      super.start(transitionSettings, numInstances);
      const { buffers, attribute } = this;
      for (let i5 = 0; i5 < 2; i5++) {
        buffers[i5] = padBuffer({
          device: this.device,
          buffer: buffers[i5],
          attribute,
          fromLength: prevLength,
          toLength: this.currentLength,
          fromStartIndices: prevStartIndices,
          getData: transitionSettings.enter
        });
      }
      buffers[2] = matchBuffer({
        device: this.device,
        source: buffers[0],
        target: buffers[2]
      });
      this.setBuffer(buffers[1]);
      const { model } = this.transform;
      model.setVertexCount(Math.floor(this.currentLength / attribute.size));
      if (attribute.isConstant) {
        model.setConstantAttributes({ aTo: attribute.value });
      } else {
        model.setAttributes({ aTo: attribute.getBuffer() });
      }
    }
    onUpdate() {
      const { buffers, transform: transform2, framebuffer, transition } = this;
      const settings = this.settings;
      transform2.model.setAttributes({
        aPrev: buffers[0],
        aCur: buffers[1]
      });
      transform2.transformFeedback.setBuffers({ vNext: buffers[2] });
      const springProps = {
        stiffness: settings.stiffness,
        damping: settings.damping
      };
      transform2.model.shaderInputs.setProps({ spring: springProps });
      transform2.run({
        framebuffer,
        discard: false,
        parameters: { viewport: [0, 0, 1, 1] },
        clearColor: [0, 0, 0, 0]
      });
      cycleBuffers(buffers);
      this.setBuffer(buffers[1]);
      const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;
      if (!isTransitioning) {
        transition.end();
      }
    }
    delete() {
      super.delete();
      this.transform.destroy();
      this.texture.destroy();
      this.framebuffer.destroy();
    }
  };
  var uniformBlock6 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`;
  var springUniforms = {
    name: "spring",
    vs: uniformBlock6,
    uniformTypes: {
      damping: "f32",
      stiffness: "f32"
    }
  };
  var vs7 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
  var fs5 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
  function getTransform2(device, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    const format = getFloat32VertexFormat(attribute.size);
    return new BufferTransform(device, {
      vs: vs7,
      fs: fs5,
      bufferLayout: [
        { name: "aPrev", format },
        { name: "aCur", format },
        { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
      ],
      varyings: ["vNext"],
      modules: [springUniforms],
      defines: { ATTRIBUTE_TYPE: attributeType },
      parameters: {
        depthCompare: "always",
        blendColorOperation: "max",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      }
    });
  }
  function getTexture(device) {
    return device.createTexture({
      data: new Uint8Array(4),
      format: "rgba8unorm",
      mipmaps: false,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer3(device, texture) {
    return device.createFramebuffer({
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      colorAttachments: [texture]
    });
  }

  // ../core/src/lib/attribute/attribute-transition-manager.ts
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = class {
    constructor(device, {
      id,
      timeline
    }) {
      if (!device)
        throw new Error("AttributeTransitionManager is constructed without device");
      this.id = id;
      this.device = device;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
    }
    finalize() {
      for (const attributeName in this.transitions) {
        this._removeTransition(attributeName);
      }
    }
    /* Public methods */
    // Called when attribute manager updates
    // Check the latest attributes for updates.
    update({
      attributes,
      transitions,
      numInstances
    }) {
      this.numInstances = numInstances || 1;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const settings = attribute.getTransitionSetting(transitions);
        if (!settings)
          continue;
        this._updateAttribute(attributeName, attribute, settings);
      }
      for (const attributeName in this.transitions) {
        const attribute = attributes[attributeName];
        if (!attribute || !attribute.getTransitionSetting(transitions)) {
          this._removeTransition(attributeName);
        }
      }
    }
    // Returns `true` if attribute is transition-enabled
    hasAttribute(attributeName) {
      const transition = this.transitions[attributeName];
      return transition && transition.inProgress;
    }
    // Get all the animated attributes
    getAttributes() {
      const animatedAttributes = {};
      for (const attributeName in this.transitions) {
        const transition = this.transitions[attributeName];
        if (transition.inProgress) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }
      return animatedAttributes;
    }
    /* eslint-disable max-statements */
    // Called every render cycle, run transform feedback
    // Returns `true` if anything changes
    run() {
      if (this.numInstances === 0) {
        return false;
      }
      for (const attributeName in this.transitions) {
        const updated = this.transitions[attributeName].update();
        if (updated) {
          this.needsRedraw = true;
        }
      }
      const needsRedraw = this.needsRedraw;
      this.needsRedraw = false;
      return needsRedraw;
    }
    /* eslint-enable max-statements */
    /* Private methods */
    _removeTransition(attributeName) {
      this.transitions[attributeName].delete();
      delete this.transitions[attributeName];
    }
    // Check an attributes for updates
    // Returns a transition object if a new transition is triggered.
    _updateAttribute(attributeName, attribute, settings) {
      const transition = this.transitions[attributeName];
      let isNew = !transition || transition.type !== settings.type;
      if (isNew) {
        if (transition) {
          this._removeTransition(attributeName);
        }
        const TransitionType = TRANSITION_TYPES[settings.type];
        if (TransitionType) {
          this.transitions[attributeName] = new TransitionType({
            attribute,
            timeline: this.timeline,
            device: this.device
          });
        } else {
          log_default.error(`unsupported transition type '${settings.type}'`)();
          isNew = false;
        }
      }
      if (isNew || attribute.needsRedraw()) {
        this.needsRedraw = true;
        this.transitions[attributeName].start(settings, this.numInstances);
      }
    }
  };

  // ../core/src/lib/attribute/attribute-manager.ts
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = class {
    constructor(device, {
      id = "attribute-manager",
      stats: stats2,
      timeline
    } = {}) {
      this.mergeBoundsMemoized = memoize(mergeBounds);
      this.id = id;
      this.device = device;
      this.attributes = {};
      this.updateTriggers = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats2;
      this.attributeTransitionManager = new AttributeTransitionManager(device, {
        id: `${id}-transitions`,
        timeline
      });
      Object.seal(this);
    }
    finalize() {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }
      this.attributeTransitionManager.finalize();
    }
    // Returns the redraw flag, optionally clearing it.
    // Redraw flag will be set if any attributes attributes changed since
    // flag was last cleared.
    //
    // @param {String} [clearRedrawFlags=false] - whether to clear the flag
    // @return {false|String} - reason a redraw is needed.
    getNeedsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
    // Sets the redraw flag.
    // @param {Boolean} redraw=true
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    // Adds attributes
    add(attributes) {
      this._add(attributes);
    }
    // Adds attributes
    addInstanced(attributes) {
      this._add(attributes, { stepMode: "instance" });
    }
    /**
     * Removes attributes
     * Takes an array of attribute names and delete them from
     * the attribute map if they exists
     *
     * @example
     * attributeManager.remove(['position']);
     *
     * @param {Object} attributeNameArray - attribute name array (see above)
     */
    remove(attributeNameArray) {
      for (const name13 of attributeNameArray) {
        if (this.attributes[name13] !== void 0) {
          this.attributes[name13].delete();
          delete this.attributes[name13];
        }
      }
    }
    // Marks an attribute for update
    invalidate(triggerName, dataRange) {
      const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }
      debug(TRACE_INVALIDATE, this, "all");
    }
    // Ensure all attribute buffers are updated from props or data.
    // eslint-disable-next-line complexity
    update({
      data,
      numInstances,
      startIndices = null,
      transitions,
      props = {},
      buffers = {},
      context = {}
    }) {
      let updated = false;
      debug(TRACE_UPDATE_START, this);
      if (this.stats) {
        this.stats.get("Update Attributes").timeStart();
      }
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        const accessorName = attribute.settings.accessor;
        attribute.startIndices = startIndices;
        attribute.numInstances = numInstances;
        if (props[attributeName]) {
          log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
        }
        if (attribute.setExternalBuffer(buffers[attributeName])) {
        } else if (attribute.setBinaryValue(
          typeof accessorName === "string" ? buffers[accessorName] : void 0,
          data.startIndices
        )) {
        } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
        } else if (attribute.needsUpdate()) {
          updated = true;
          this._updateAttribute({
            attribute,
            numInstances,
            data,
            props,
            context
          });
        }
        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
      }
      if (updated) {
        debug(TRACE_UPDATE_END, this, numInstances);
      }
      if (this.stats) {
        this.stats.get("Update Attributes").timeEnd();
      }
      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances,
        transitions
      });
    }
    // Update attribute transition to the current timestamp
    // Returns `true` if any transition is in progress
    updateTransition() {
      const { attributeTransitionManager } = this;
      const transitionUpdated = attributeTransitionManager.run();
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */
    getAttributes() {
      return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
    }
    /**
     * Computes the spatial bounds of a given set of attributes
     */
    getBounds(attributeNames) {
      const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
      return this.mergeBoundsMemoized(bounds);
    }
    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuffers need to be updated
     * @return {Object} attributes - descriptors
     */
    getChangedAttributes(opts = { clearChangedFlags: false }) {
      const { attributes, attributeTransitionManager } = this;
      const changedAttributes = { ...attributeTransitionManager.getAttributes() };
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }
    /** Generate WebGPU-style buffer layout descriptors from all attributes */
    getBufferLayouts(modelInfo) {
      return Object.values(this.getAttributes()).map(
        (attribute) => attribute.getBufferLayout(modelInfo)
      );
    }
    // PRIVATE METHODS
    /** Register new attributes */
    _add(attributes, overrideOptions) {
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const props = {
          ...attribute,
          id: attributeName,
          size: attribute.isIndexed && 1 || attribute.size || 1,
          ...overrideOptions
        };
        this.attributes[attributeName] = new Attribute2(this.device, props);
      }
      this._mapUpdateTriggersToAttributes();
    }
    // build updateTrigger name to attribute name mapping
    _mapUpdateTriggersToAttributes() {
      const triggers = {};
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach((triggerName) => {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }
          triggers[triggerName].push(attributeName);
        });
      }
      this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
      const { attributes, updateTriggers } = this;
      const invalidatedAttributes = updateTriggers[triggerName];
      if (invalidatedAttributes) {
        invalidatedAttributes.forEach((name13) => {
          const attribute = attributes[name13];
          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      }
      return invalidatedAttributes;
    }
    _updateAttribute(opts) {
      const { attribute, numInstances } = opts;
      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
      if (attribute.constant) {
        attribute.setConstantValue(attribute.value);
        return;
      }
      if (attribute.allocate(numInstances)) {
        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
      }
      const updated = attribute.updateBuffer(opts);
      if (updated) {
        this.needsRedraw = true;
        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
      }
    }
  };

  // ../core/src/transitions/cpu-interpolation-transition.ts
  var CPUInterpolationTransition = class extends Transition {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const {
        time,
        settings: { fromValue: fromValue2, toValue, duration, easing }
      } = this;
      const t3 = easing(time / duration);
      this._value = lerp(fromValue2, toValue, t3);
    }
  };

  // ../core/src/transitions/cpu-spring-transition.ts
  var EPSILON23 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      const next = [];
      for (let i5 = 0; i5 < dest.length; i5++) {
        next[i5] = updateSpringElement(prev[i5], cur[i5], dest[i5], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance4(value1, value2) {
    if (Array.isArray(value1)) {
      let distanceSquare = 0;
      for (let i5 = 0; i5 < value1.length; i5++) {
        const d2 = value1[i5] - value2[i5];
        distanceSquare += d2 * d2;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
  }
  var CPUSpringTransition = class extends Transition {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const { fromValue: fromValue2, toValue, damping, stiffness } = this.settings;
      const { _prevValue = fromValue2, _currValue = fromValue2 } = this;
      let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
      const delta = distance4(nextValue, toValue);
      const velocity = distance4(nextValue, _currValue);
      if (delta < EPSILON23 && velocity < EPSILON23) {
        nextValue = toValue;
        this.end();
      }
      this._prevValue = _currValue;
      this._currValue = nextValue;
    }
  };

  // ../core/src/lib/uniform-transition-manager.ts
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = class {
    constructor(timeline) {
      this.transitions = /* @__PURE__ */ new Map();
      this.timeline = timeline;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(key, fromValue2, toValue, settings) {
      const { transitions } = this;
      if (transitions.has(key)) {
        const transition2 = transitions.get(key);
        const { value = transition2.settings.fromValue } = transition2;
        fromValue2 = value;
        this.remove(key);
      }
      settings = normalizeTransitionSettings(settings);
      if (!settings) {
        return;
      }
      const TransitionType = TRANSITION_TYPES2[settings.type];
      if (!TransitionType) {
        log_default.error(`unsupported transition type '${settings.type}'`)();
        return;
      }
      const transition = new TransitionType(this.timeline);
      transition.start({
        ...settings,
        fromValue: fromValue2,
        toValue
      });
      transitions.set(key, transition);
    }
    remove(key) {
      const { transitions } = this;
      if (transitions.has(key)) {
        transitions.get(key).cancel();
        transitions.delete(key);
      }
    }
    update() {
      const propsInTransition = {};
      for (const [key, transition] of this.transitions) {
        transition.update();
        propsInTransition[key] = transition.value;
        if (!transition.inProgress) {
          this.remove(key);
        }
      }
      return propsInTransition;
    }
    clear() {
      for (const key of this.transitions.keys()) {
        this.remove(key);
      }
    }
  };

  // ../core/src/lifecycle/props.ts
  function validateProps(props) {
    const propTypes = props[PROP_TYPES_SYMBOL];
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const { validate: validate2 } = propType;
      if (validate2 && !validate2(props[propName], propType)) {
        throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
      }
    }
  }
  function diffProps(props, oldProps) {
    const propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: props[PROP_TYPES_SYMBOL],
      ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
    });
    const dataChangedReason = diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return false;
    }
    const result = {};
    const propTypes = props[PROP_TYPES_SYMBOL];
    let changed = false;
    for (const key in props.transitions) {
      const propType = propTypes[key];
      const type = propType && propType.type;
      const isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
        changed = true;
      }
    }
    return changed ? result : false;
  }
  function compareProps({
    newProps,
    oldProps,
    ignoreProps = {},
    propTypes = {},
    triggerName = "props"
  }) {
    if (oldProps === newProps) {
      return false;
    }
    if (typeof newProps !== "object" || newProps === null) {
      return `${triggerName} changed shallowly`;
    }
    if (typeof oldProps !== "object" || oldProps === null) {
      return `${triggerName} changed shallowly`;
    }
    for (const key of Object.keys(newProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return `${triggerName}.${key} added`;
        }
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
    for (const key of Object.keys(oldProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in newProps)) {
          return `${triggerName}.${key} dropped`;
        }
        if (!Object.hasOwnProperty.call(newProps, key)) {
          const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
          if (changed) {
            return `${triggerName}.${key} ${changed}`;
          }
        }
      }
    }
    return false;
  }
  function comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal) {
      equal = newProp && oldProp && newProp.equals;
      if (equal && !equal.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    let dataChanged = false;
    const { dataComparator, _dataDiff } = props;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return { all: true };
    }
    if ("all" in props.updateTriggers) {
      const diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return { all: true };
      }
    }
    const reason = {};
    let changed = false;
    for (const triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
          reason[triggerName] = true;
          changed = true;
        }
      }
    }
    return changed ? reason : false;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return true;
    }
    const oldExtensions = oldProps.extensions;
    const { extensions } = props;
    if (extensions === oldExtensions) {
      return false;
    }
    if (!oldExtensions || !extensions) {
      return true;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (let i5 = 0; i5 < extensions.length; i5++) {
      if (!extensions[i5].equals(oldExtensions[i5])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    const diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }

  // ../core/src/utils/count.ts
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count(container) {
    if (!isObject2(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
  }
  function isObject2(value) {
    return value !== null && typeof value === "object";
  }

  // ../core/src/utils/shader.ts
  function mergeShaders(target2, source3) {
    if (!source3) {
      return target2;
    }
    const result = { ...target2, ...source3 };
    if ("defines" in source3) {
      result.defines = { ...target2.defines, ...source3.defines };
    }
    if ("modules" in source3) {
      result.modules = (target2.modules || []).concat(source3.modules);
      if (source3.modules.some((module) => module.name === "project64")) {
        const index = result.modules.findIndex((module) => module.name === "project32");
        if (index >= 0) {
          result.modules.splice(index, 1);
        }
      }
    }
    if ("inject" in source3) {
      if (!target2.inject) {
        result.inject = source3.inject;
      } else {
        const mergedInjection = { ...target2.inject };
        for (const key in source3.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source3.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // ../core/src/utils/texture.ts
  var DEFAULT_TEXTURE_PARAMETERS = {
    minFilter: "linear",
    mipmapFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  };
  var internalTextures = {};
  function createTexture(owner, device, image, sampler) {
    if (image instanceof Texture) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = { data: image };
    }
    let samplerParameters = null;
    if (image.compressed) {
      samplerParameters = {
        minFilter: "linear",
        mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
      };
    }
    const texture = device.createTexture({
      ...image,
      sampler: {
        ...DEFAULT_TEXTURE_PARAMETERS,
        ...samplerParameters,
        ...sampler
      },
      mipmaps: true
    });
    internalTextures[texture.id] = owner;
    return texture;
  }
  function destroyTexture(owner, texture) {
    if (!texture || !(texture instanceof Texture)) {
      return;
    }
    if (internalTextures[texture.id] === owner) {
      texture.delete();
      delete internalTextures[texture.id];
    }
  }

  // ../core/src/lifecycle/prop-types.ts
  var TYPE_DEFINITIONS = {
    boolean: {
      validate(value, propType) {
        return true;
      },
      equal(value1, value2, propType) {
        return Boolean(value1) === Boolean(value2);
      }
    },
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    color: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
      },
      equal(value1, value2, propType) {
        return deepEqual2(value1, value2, 1);
      }
    },
    accessor: {
      validate(value, propType) {
        const valueType = getTypeOf2(value);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal(value1, value2, propType) {
        if (typeof value2 === "function") {
          return true;
        }
        return deepEqual2(value1, value2, 1);
      }
    },
    array: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value);
      },
      equal(value1, value2, propType) {
        const { compare: compare2 } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual2(value1, value2, depth) : value1 === value2;
      }
    },
    object: {
      equal(value1, value2, propType) {
        if (propType.ignore) {
          return true;
        }
        const { compare: compare2 } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual2(value1, value2, depth) : value1 === value2;
      }
    },
    function: {
      validate(value, propType) {
        return propType.optional && !value || typeof value === "function";
      },
      equal(value1, value2, propType) {
        const shouldIgnore = !propType.compare && propType.ignore !== false;
        return shouldIgnore || value1 === value2;
      }
    },
    data: {
      transform: (value, propType, component) => {
        if (!value) {
          return value;
        }
        const { dataTransform } = component.props;
        if (dataTransform) {
          return dataTransform(value);
        }
        if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) {
          return value.data;
        }
        return value;
      }
    },
    image: {
      transform: (value, propType, component) => {
        const context = component.context;
        if (!context || !context.device) {
          return null;
        }
        return createTexture(component.id, context.device, value, {
          ...propType.parameters,
          ...component.props.textureParameters
        });
      },
      release: (value, propType, component) => {
        destroyTexture(component.id, value);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes = {};
    const defaultProps48 = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)) {
      const deprecated = propDef?.deprecatedFor;
      if (deprecated) {
        deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
      } else {
        const propType = parsePropType(propName, propDef);
        propTypes[propName] = propType;
        defaultProps48[propName] = propType.value;
      }
    }
    return { propTypes, defaultProps: defaultProps48, deprecatedProps };
  }
  function parsePropType(name13, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name13, propDef);
      case "array":
        return normalizePropDefinition(name13, { type: "array", value: propDef, compare: false });
      case "boolean":
        return normalizePropDefinition(name13, { type: "boolean", value: propDef });
      case "number":
        return normalizePropDefinition(name13, { type: "number", value: propDef });
      case "function":
        return normalizePropDefinition(name13, { type: "function", value: propDef, compare: true });
      default:
        return { name: name13, type: "unknown", value: propDef };
    }
  }
  function normalizePropDefinition(name13, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return { name: name13, type: "object", value: propDef };
      }
      return { name: name13, type: getTypeOf2(propDef.value), ...propDef };
    }
    return { name: name13, ...TYPE_DEFINITIONS[propDef.type], ...propDef };
  }
  function isArray3(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
  }
  function getTypeOf2(value) {
    if (isArray3(value)) {
      return "array";
    }
    if (value === null) {
      return "null";
    }
    return typeof value;
  }

  // ../core/src/lifecycle/create-props.ts
  function createProps(component, propObjects) {
    let extensions;
    for (let i5 = propObjects.length - 1; i5 >= 0; i5--) {
      const props = propObjects[i5];
      if ("extensions" in props) {
        extensions = props.extensions;
      }
    }
    const propsPrototype = getPropsPrototype(component.constructor, extensions);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT_SYMBOL] = component;
    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
    for (let i5 = 0; i5 < propObjects.length; ++i5) {
      const props = propObjects[i5];
      for (const key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  function getPropsPrototype(componentClass, extensions) {
    if (!(componentClass instanceof Component.constructor))
      return {};
    let cacheKey = MergedDefaultPropsCacheKey;
    if (extensions) {
      for (const extension of extensions) {
        const ExtensionClass = extension.constructor;
        if (ExtensionClass) {
          cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
        }
      }
    }
    const defaultProps48 = getOwnProperty(componentClass, cacheKey);
    if (!defaultProps48) {
      return componentClass[cacheKey] = createPropsPrototypeAndTypes(
        componentClass,
        extensions || []
      );
    }
    return defaultProps48;
  }
  function createPropsPrototypeAndTypes(componentClass, extensions) {
    const parent = componentClass.prototype;
    if (!parent) {
      return null;
    }
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = getPropsPrototype(parentClass);
    const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = parsePropTypes(componentDefaultProps);
    const defaultProps48 = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps,
      componentPropDefs.defaultProps
    );
    const propTypes = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps?.[PROP_TYPES_SYMBOL],
      componentPropDefs.propTypes
    );
    const deprecatedProps = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL],
      componentPropDefs.deprecatedProps
    );
    for (const extension of extensions) {
      const extensionDefaultProps = getPropsPrototype(extension.constructor);
      if (extensionDefaultProps) {
        Object.assign(defaultProps48, extensionDefaultProps);
        Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
        Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
      }
    }
    createPropsPrototype(defaultProps48, componentClass);
    addAsyncPropsToPropPrototype(defaultProps48, propTypes);
    addDeprecatedPropsToPropPrototype(defaultProps48, deprecatedProps);
    defaultProps48[PROP_TYPES_SYMBOL] = propTypes;
    defaultProps48[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
    if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
      componentClass._propTypes = propTypes;
    }
    return defaultProps48;
  }
  function createPropsPrototype(defaultProps48, componentClass) {
    const id = getComponentName(componentClass);
    Object.defineProperties(defaultProps48, {
      // `id` is treated specially because layer might need to override it
      id: {
        writable: true,
        value: id
      }
    });
  }
  function addDeprecatedPropsToPropPrototype(defaultProps48, deprecatedProps) {
    for (const propName in deprecatedProps) {
      Object.defineProperty(defaultProps48, propName, {
        enumerable: false,
        set(newValue) {
          const nameStr = `${this.id}: ${propName}`;
          for (const newPropName of deprecatedProps[propName]) {
            if (!hasOwnProperty(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
          log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
      });
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps48, propTypes) {
    const defaultValues = {};
    const descriptors = {};
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const { name: name13, value } = propType;
      if (propType.async) {
        defaultValues[name13] = value;
        descriptors[name13] = getDescriptorForAsyncProp(name13);
      }
    }
    defaultProps48[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
    defaultProps48[ASYNC_ORIGINAL_SYMBOL] = {};
    Object.defineProperties(defaultProps48, descriptors);
  }
  function getDescriptorForAsyncProp(name13) {
    return {
      enumerable: true,
      // Save the provided value for async props in a special map
      set(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
          this[ASYNC_ORIGINAL_SYMBOL][name13] = newValue;
        } else {
          this[ASYNC_RESOLVED_SYMBOL][name13] = newValue;
        }
      },
      // Only the component's state knows the true value of async prop
      get() {
        if (this[ASYNC_RESOLVED_SYMBOL]) {
          if (name13 in this[ASYNC_RESOLVED_SYMBOL]) {
            const value = this[ASYNC_RESOLVED_SYMBOL][name13];
            return value || this[ASYNC_DEFAULTS_SYMBOL][name13];
          }
          if (name13 in this[ASYNC_ORIGINAL_SYMBOL]) {
            const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
            if (state && state.hasAsyncProp(name13)) {
              return state.getAsyncProp(name13) || this[ASYNC_DEFAULTS_SYMBOL][name13];
            }
          }
        }
        return this[ASYNC_DEFAULTS_SYMBOL][name13];
      }
    };
  }
  function hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  function getOwnProperty(object, prop) {
    return hasOwnProperty(object, prop) && object[prop];
  }
  function getComponentName(componentClass) {
    const componentName = componentClass.componentName;
    if (!componentName) {
      log_default.warn(`${componentClass.name}.componentName not specified`)();
    }
    return componentName || componentClass.name;
  }

  // ../core/src/lifecycle/component.ts
  var counter = 0;
  var Component = class {
    constructor(...propObjects) {
      this.props = createProps(this, propObjects);
      this.id = this.props.id;
      this.count = counter++;
    }
    // clone this layer with modified props
    clone(newProps) {
      const { props } = this;
      const asyncProps = {};
      for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
        if (key in props[ASYNC_RESOLVED_SYMBOL]) {
          asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
        } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
          asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
        }
      }
      return new this.constructor({ ...props, ...asyncProps, ...newProps });
    }
  };
  Component.componentName = "Component";
  Component.defaultProps = {};

  // ../core/src/lifecycle/component-state.ts
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = class {
    constructor(component) {
      this.component = component;
      this.asyncProps = {};
      this.onAsyncPropUpdated = () => {
      };
      this.oldProps = null;
      this.oldAsyncProps = null;
    }
    finalize() {
      for (const propName in this.asyncProps) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && asyncProp.type && asyncProp.type.release) {
          asyncProp.type.release(
            asyncProp.resolvedValue,
            asyncProp.type,
            this.component
          );
        }
      }
      this.asyncProps = {};
      this.component = null;
      this.resetOldProps();
    }
    /* Layer-facing props API */
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
    }
    resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component ? this.component.props : null;
    }
    // Checks if a prop is overridden
    hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
    // Returns value of an overriden prop
    getAsyncProp(propName) {
      const asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
      if (propName) {
        const asyncProp = this.asyncProps[propName];
        return Boolean(
          asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount
        );
      }
      for (const key in this.asyncProps) {
        if (this.isAsyncPropLoading(key)) {
          return true;
        }
      }
      return false;
    }
    // Without changing the original prop value, swap out the data resolution under the hood
    reloadAsyncProp(propName, value) {
      this._watchPromise(propName, Promise.resolve(value));
    }
    // Updates all async/overridden props (when new props come in)
    // Checks if urls have changed, starts loading, or removes override
    setAsyncProps(props) {
      this.component = props[COMPONENT_SYMBOL] || this.component;
      const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
      const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
      const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
      for (const propName in resolvedValues) {
        const value = resolvedValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
        resolvedValues[propName] = this.getAsyncProp(propName);
      }
      for (const propName in originalValues) {
        const value = originalValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
      }
    }
    /* Placeholder methods for subclassing */
    _fetch(propName, url) {
      return null;
    }
    _onResolve(propName, value) {
    }
    // eslint-disable-line @typescript-eslint/no-empty-function
    _onError(propName, error) {
    }
    // eslint-disable-line @typescript-eslint/no-empty-function
    // Intercept strings (URLs) and Promises and activates loading and prop rewriting
    _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }
      if (typeof value === "string") {
        value = this._fetch(propName, value);
      }
      if (value instanceof Promise) {
        this._watchPromise(propName, value);
        return;
      }
      if (isAsyncIterable2(value)) {
        this._resolveAsyncIterable(propName, value);
        return;
      }
      this._setPropValue(propName, value);
    }
    // Whenever async props are changing, we need to make a copy of oldProps
    // otherwise the prop rewriting will affect the value both in props and oldProps.
    // While the copy is relatively expensive, this only happens on load completion.
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
    // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
    _didAsyncInputValueChange(propName, value) {
      const asyncProp = this.asyncProps[propName];
      if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
        return false;
      }
      asyncProp.lastValue = value;
      return true;
    }
    // Set normal, non-async value
    _setPropValue(propName, value) {
      this._freezeAsyncOldProps();
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        value = this._postProcessValue(asyncProp, value);
        asyncProp.resolvedValue = value;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }
    // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
    _setAsyncPropValue(propName, value, loadCount) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
        this._freezeAsyncOldProps();
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
    // Tracks a promise, sets the prop when loaded, handles load count
    _watchPromise(propName, promise) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        promise.then((data) => {
          if (!this.component) {
            return;
          }
          data = this._postProcessValue(asyncProp, data);
          this._setAsyncPropValue(propName, data, loadCount);
          this._onResolve(propName, data);
        }).catch((error) => {
          this._onError(propName, error);
        });
      }
    }
    async _resolveAsyncIterable(propName, iterable) {
      if (propName !== "data") {
        this._setPropValue(propName, iterable);
        return;
      }
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        return;
      }
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      let data = [];
      let count3 = 0;
      for await (const chunk of iterable) {
        if (!this.component) {
          return;
        }
        const { dataTransform } = this.component.props;
        if (dataTransform) {
          data = dataTransform(chunk, data);
        } else {
          data = data.concat(chunk);
        }
        Object.defineProperty(data, "__diff", {
          enumerable: false,
          value: [{ startRow: count3, endRow: data.length }]
        });
        count3 = data.length;
        this._setAsyncPropValue(propName, data, loadCount);
      }
      this._onResolve(propName, data);
    }
    // Give the app a chance to post process the loaded data
    _postProcessValue(asyncProp, value) {
      const propType = asyncProp.type;
      if (propType && this.component) {
        if (propType.release) {
          propType.release(asyncProp.resolvedValue, propType, this.component);
        }
        if (propType.transform) {
          return propType.transform(value, propType, this.component);
        }
      }
      return value;
    }
    // Creating an asyncProp record if needed
    _createAsyncPropData(propName, defaultValue2) {
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
        this.asyncProps[propName] = {
          type: propTypes && propTypes[propName],
          lastValue: null,
          resolvedValue: defaultValue2,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  };

  // ../core/src/lib/layer-state.ts
  var LayerState = class extends ComponentState {
    constructor({
      attributeManager,
      layer
    }) {
      super(layer);
      this.attributeManager = attributeManager;
      this.needsRedraw = true;
      this.needsUpdate = true;
      this.subLayers = null;
      this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    /* Override base Component methods with Layer-specific handling */
    _fetch(propName, url) {
      const layer = this.layer;
      const fetch2 = layer?.props.fetch;
      if (fetch2) {
        return fetch2(url, { propName, layer });
      }
      return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
      const layer = this.layer;
      if (layer) {
        const onDataLoad = layer.props.onDataLoad;
        if (propName === "data" && onDataLoad) {
          onDataLoad(value, { propName, layer });
        }
      }
    }
    _onError(propName, error) {
      const layer = this.layer;
      if (layer) {
        layer.raiseError(error, `loading ${propName} of ${this.layer}`);
      }
    }
  };

  // ../core/src/lib/layer.ts
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(
    ({ oldViewport, viewport }) => {
      return oldViewport.equals(viewport);
    }
  );
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    // data: Special handling for null, see below
    data: { type: "data", value: EMPTY_ARRAY2, async: true },
    dataComparator: { type: "function", value: null, optional: true },
    _dataDiff: {
      type: "function",
      // @ts-ignore __diff is not defined on data
      value: (data) => data && data.__diff,
      optional: true
    },
    dataTransform: { type: "function", value: null, optional: true },
    onDataLoad: { type: "function", value: null, optional: true },
    onError: { type: "function", value: null, optional: true },
    fetch: {
      type: "function",
      value: (url, {
        propName,
        layer,
        loaders,
        loadOptions,
        signal
      }) => {
        const { resourceManager } = layer.context;
        loadOptions = loadOptions || layer.getLoadOptions();
        loaders = loaders || layer.props.loaders;
        if (signal) {
          loadOptions = {
            ...loadOptions,
            fetch: {
              ...loadOptions?.fetch,
              signal
            }
          };
        }
        let inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({ resourceId: url, data: load(url, loaders), persistent: false });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      }
    },
    updateTriggers: {},
    // Update triggers: a core change detection mechanism in deck.gl
    visible: true,
    pickable: false,
    opacity: { type: "number", min: 0, max: 1, value: 1 },
    operation: "draw",
    onHover: { type: "function", value: null, optional: true },
    onClick: { type: "function", value: null, optional: true },
    onDragStart: { type: "function", value: null, optional: true },
    onDrag: { type: "function", value: null, optional: true },
    onDragEnd: { type: "function", value: null, optional: true },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true },
    modelMatrix: { type: "array", value: null, compare: true, optional: true },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: { type: "object", value: {}, optional: true, compare: 2 },
    loadOptions: { type: "object", value: null, optional: true, ignore: true },
    transitions: null,
    extensions: [],
    loaders: { type: "array", value: [], optional: true, ignore: true },
    // Offset depth based on layer index to avoid z-fighting.
    // Negative values pull layer towards the camera
    // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
    getPolygonOffset: {
      type: "function",
      value: ({ layerIndex }) => [0, -layerIndex * 100]
    },
    // Selection/Highlighting
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
  };
  var Layer = class extends Component {
    constructor() {
      super(...arguments);
      this.internalState = null;
      this.lifecycle = LIFECYCLE.NO_STATE;
      // Will be set to the shared layer state object during layer matching
      this.parent = null;
    }
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    get root() {
      let layer = this;
      while (layer.parent) {
        layer = layer.parent;
      }
      return layer;
    }
    toString() {
      const className = this.constructor.layerName || this.constructor.name;
      return `${className}({id: '${this.props.id}'})`;
    }
    // Public API for users
    /** Projects a point with current view state from the current layer's coordinate system to screen */
    project(xyz) {
      assert8(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      const worldPosition = getWorldPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
      const [x3, y3, z2] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
      return xyz.length === 2 ? [x3, y3] : [x3, y3, z2];
    }
    /** Unprojects a screen pixel to the current view's default coordinate system
        Note: this does not reverse `project`. */
    unproject(xy) {
      assert8(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return viewport.unproject(xy);
    }
    /** Projects a point with current view state from the current layer's coordinate system to the world space */
    projectPosition(xyz, params) {
      assert8(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return projectPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...params
      });
    }
    // Public API for custom layer implementation
    /** `true` if this layer renders other layers */
    get isComposite() {
      return false;
    }
    /** `true` if the layer renders to screen */
    get isDrawable() {
      return true;
    }
    /** Updates selected state members and marks the layer for redraw */
    setState(partialState) {
      this.setChangeFlags({ stateChanged: true });
      Object.assign(this.state, partialState);
      this.setNeedsRedraw();
    }
    /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
    setNeedsRedraw() {
      if (this.internalState) {
        this.internalState.needsRedraw = true;
      }
    }
    /** Mark this layer as needs a deep update */
    setNeedsUpdate() {
      if (this.internalState) {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }
    /** Returns true if all async resources are loaded */
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    /** Returns true if using shader-based WGS84 longitude wrapping */
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    /** @deprecated Returns true if the layer is visible in the picking pass */
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    /** Returns an array of models used by this layer, can be overriden by layer subclass */
    getModels() {
      const state = this.state;
      return state && (state.models || state.model && [state.model]) || [];
    }
    /** Update shader input parameters */
    setShaderModuleProps(...props) {
      for (const model of this.getModels()) {
        model.shaderInputs.setProps(...props);
      }
    }
    /** Returns the attribute manager of this layer */
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    /** Returns the most recent layer that matched to this state
      (When reacting to an async event, this layer may no longer be the latest) */
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    /** Returns the default parse options for async props */
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const { coordinateSystem } = this.props;
      return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
    }
    // Event handling
    onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent) || false;
      }
      return false;
    }
    onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent) || false;
      }
      return false;
    }
    // Returns the picking color that doesn't match any subfeature
    // Use if some graphics do not belong to any pickable subfeature
    // @return {Array} - a black color
    nullPickingColor() {
      return [0, 0, 0];
    }
    // Returns the picking color that doesn't match any subfeature
    // Use if some graphics do not belong to any pickable subfeature
    encodePickingColor(i5, target2 = []) {
      target2[0] = i5 + 1 & 255;
      target2[1] = i5 + 1 >> 8 & 255;
      target2[2] = i5 + 1 >> 8 >> 8 & 255;
      return target2;
    }
    // Returns the index corresponding to a picking color that doesn't match any subfeature
    // @param {Uint8Array} color - color array to be decoded
    // @return {Array} - the decoded picking color
    decodePickingColor(color) {
      assert8(color instanceof Uint8Array);
      const [i1, i22, i32] = color;
      const index = i1 + i22 * 256 + i32 * 65536 - 1;
      return index;
    }
    /** Deduces number of instances. Intention is to support:
      - Explicit setting of numInstances
      - Auto-deduction for ES6 containers that define a size member
      - Auto-deduction for Classic Arrays via the built-in length attribute
      - Auto-deduction via arrays */
    getNumInstances() {
      if (Number.isFinite(this.props.numInstances)) {
        return this.props.numInstances;
      }
      if (this.state && this.state.numInstances !== void 0) {
        return this.state.numInstances;
      }
      return count(this.props.data);
    }
    /** Buffer layout describes how many attribute values are packed for each data object
        The default (null) is one value each object.
        Some data formats (e.g. paths, polygons) have various length. Their buffer layout
        is in the form of [L0, L1, L2, ...] */
    getStartIndices() {
      if (this.props.startIndices) {
        return this.props.startIndices;
      }
      if (this.state && this.state.startIndices) {
        return this.state.startIndices;
      }
      return null;
    }
    // Default implementation
    getBounds() {
      return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
    }
    getShaders(shaders) {
      shaders = mergeShaders(shaders, {
        disableWarnings: true,
        modules: this.context.defaultShaderModules
      });
      for (const extension of this.props.extensions) {
        shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
      }
      return shaders;
    }
    /** Controls if updateState should be called. By default returns true if any prop has changed */
    shouldUpdateState(params) {
      return params.changeFlags.propsOrDataChanged;
    }
    /** Default implementation, all attributes will be invalidated and updated when data changes */
    // eslint-disable-next-line complexity
    updateState(params) {
      const attributeManager = this.getAttributeManager();
      const { dataChanged } = params.changeFlags;
      if (dataChanged && attributeManager) {
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            attributeManager.invalidateAll(dataRange);
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
      if (attributeManager) {
        const { props } = params;
        const hasPickingBuffer = this.internalState.hasPickingBuffer;
        const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
        if (hasPickingBuffer !== needsPickingBuffer) {
          this.internalState.hasPickingBuffer = needsPickingBuffer;
          const { pickingColors, instancePickingColors } = attributeManager.attributes;
          const pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needsPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needsPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }
    /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
    finalizeState(context) {
      for (const model of this.getModels()) {
        model.destroy();
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.finalize();
      }
      if (this.context) {
        this.context.resourceManager.unsubscribe({ consumerId: this.id });
      }
      if (this.internalState) {
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }
    // If state has a model, draw it with supplied uniforms
    draw(opts) {
      for (const model of this.getModels()) {
        model.draw(opts.renderPass);
      }
    }
    // called to populate the info object that is passed to the event handler
    // @return null to cancel event
    getPickingInfo({ info, mode, sourceLayer }) {
      const { index } = info;
      if (index >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }
      return info;
    }
    // END LIFECYCLE METHODS
    // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
    /** (Internal) Propagate an error event through the system */
    raiseError(error, message2) {
      if (message2) {
        error = new Error(`${message2}: ${error.message}`, { cause: error });
      }
      if (!this.props.onError?.(error)) {
        this.context?.onError?.(error, this);
      }
    }
    /** (Internal) Checks if this layer needs redraw */
    getNeedsRedraw(opts = { clearRedrawFlags: false }) {
      return this._getNeedsRedraw(opts);
    }
    /** (Internal) Checks if this layer needs a deep update */
    needsUpdate() {
      if (!this.internalState) {
        return false;
      }
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    /** Checks if this layer has ongoing uniform transition */
    hasUniformTransition() {
      return this.internalState?.uniformTransitions.active || false;
    }
    /** Called when this layer is rendered into the given viewport */
    activateViewport(viewport) {
      if (!this.internalState) {
        return;
      }
      const oldViewport = this.internalState.viewport;
      this.internalState.viewport = viewport;
      if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {
        this.setChangeFlags({ viewportChanged: true });
        if (this.isComposite) {
          if (this.needsUpdate()) {
            this.setNeedsUpdate();
          }
        } else {
          this._update();
        }
      }
    }
    /** Default implementation of attribute invalidation, can be redefined */
    invalidateAttribute(name13 = "all") {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      if (name13 === "all") {
        attributeManager.invalidateAll();
      } else {
        attributeManager.invalidate(name13);
      }
    }
    /** Send updated attributes to the WebGL model */
    updateAttributes(changedAttributes) {
      let bufferLayoutChanged = false;
      for (const id in changedAttributes) {
        if (changedAttributes[id].layoutChanged()) {
          bufferLayoutChanged = true;
        }
      }
      for (const model of this.getModels()) {
        this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
      }
    }
    /** Recalculate any attributes if needed */
    _updateAttributes() {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      const props = this.props;
      const numInstances = this.getNumInstances();
      const startIndices = this.getStartIndices();
      attributeManager.update({
        data: props.data,
        numInstances,
        startIndices,
        props,
        transitions: props.transitions,
        // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
        buffers: props.data.attributes,
        context: this
      });
      const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
      this.updateAttributes(changedAttributes);
    }
    /** Update attribute transitions. This is called in drawLayer, no model updates required. */
    _updateAttributeTransition() {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
    /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
    _updateUniformTransition() {
      const { uniformTransitions } = this.internalState;
      if (uniformTransitions.active) {
        const propsInTransition = uniformTransitions.update();
        const props = Object.create(this.props);
        for (const key in propsInTransition) {
          Object.defineProperty(props, key, { value: propsInTransition[key] });
        }
        return props;
      }
      return this.props;
    }
    /** Updater for the automatically populated instancePickingColors attribute */
    calculateInstancePickingColors(attribute, { numInstances }) {
      if (attribute.constant) {
        return;
      }
      const cacheSize = Math.floor(pickingColorCache.length / 4);
      this.internalState.usesPickingColorCache = true;
      if (cacheSize < numInstances) {
        if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
          log_default.warn(
            "Layer has too many data objects. Picking might not be able to distinguish all objects."
          )();
        }
        pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
          size: 4,
          copy: true,
          maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
        });
        const newCacheSize = Math.floor(pickingColorCache.length / 4);
        const pickingColor = [0, 0, 0];
        for (let i5 = cacheSize; i5 < newCacheSize; i5++) {
          this.encodePickingColor(i5, pickingColor);
          pickingColorCache[i5 * 4 + 0] = pickingColor[0];
          pickingColorCache[i5 * 4 + 1] = pickingColor[1];
          pickingColorCache[i5 * 4 + 2] = pickingColor[2];
          pickingColorCache[i5 * 4 + 3] = 0;
        }
      }
      attribute.value = pickingColorCache.subarray(0, numInstances * 4);
    }
    /** Apply changed attributes to model */
    _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
      if (!Object.keys(changedAttributes).length) {
        return;
      }
      if (bufferLayoutChanged) {
        const attributeManager = this.getAttributeManager();
        model.setBufferLayout(attributeManager.getBufferLayouts(model));
        changedAttributes = attributeManager.getAttributes();
      }
      const excludeAttributes = model.userData?.excludeAttributes || {};
      const attributeBuffers = {};
      const constantAttributes = {};
      for (const name13 in changedAttributes) {
        if (excludeAttributes[name13]) {
          continue;
        }
        const values = changedAttributes[name13].getValue();
        for (const attributeName in values) {
          const value = values[attributeName];
          if (value instanceof Buffer2) {
            if (changedAttributes[name13].settings.isIndexed) {
              model.setIndexBuffer(value);
            } else {
              attributeBuffers[attributeName] = value;
            }
          } else if (value) {
            constantAttributes[attributeName] = value;
          }
        }
      }
      model.setAttributes(attributeBuffers);
      model.setConstantAttributes(constantAttributes);
    }
    /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
       This method may be overriden by layer implementations */
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (!("attributes" in data)) {
        this._disablePickingIndex(objectIndex);
        return;
      }
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
      if (externalColorAttribute && externalColorAttribute.value) {
        const values = externalColorAttribute.value;
        const objectColor = this.encodePickingColor(objectIndex);
        for (let index = 0; index < data.length; index++) {
          const i5 = colors.getVertexOffset(index);
          if (values[i5] === objectColor[0] && values[i5 + 1] === objectColor[1] && values[i5 + 2] === objectColor[2]) {
            this._disablePickingIndex(index);
          }
        }
      } else {
        this._disablePickingIndex(objectIndex);
      }
    }
    // TODO - simplify subclassing interface
    _disablePickingIndex(objectIndex) {
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      const start = colors.getVertexOffset(objectIndex);
      const end = colors.getVertexOffset(objectIndex + 1);
      colors.buffer.write(new Uint8Array(end - start), start);
    }
    /** (Internal) Re-enable all picking indices after multi-depth picking */
    restorePickingColors() {
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      if (
        // @ts-ignore (TS2531) this method is only called internally with internalState defined
        this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer
      ) {
        colors.value = pickingColorCache.subarray(0, colors.value.length);
      }
      colors.updateSubBuffer({ startOffset: 0 });
    }
    /* eslint-disable max-statements */
    /* (Internal) Called by layer manager when a new layer is found */
    _initialize() {
      assert8(!this.internalState);
      assert8(Number.isFinite(this.props.coordinateSystem));
      debug(TRACE_INITIALIZE, this);
      const attributeManager = this._getAttributeManager();
      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: "uint8",
            size: 4,
            noAlloc: true,
            // Updaters are always called with `this` pointing to the layer
            // eslint-disable-next-line @typescript-eslint/unbound-method
            update: this.calculateInstancePickingColors
          }
        });
      }
      this.internalState = new LayerState({
        attributeManager,
        layer: this
      });
      this._clearChangeFlags();
      this.state = {};
      Object.defineProperty(this.state, "attributeManager", {
        get: () => {
          log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
          return attributeManager;
        }
      });
      this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
      this.initializeState(this.context);
      for (const extension of this.props.extensions) {
        extension.initializeState.call(this, this.context, extension);
      }
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      });
      this._update();
    }
    /** (Internal) Called by layer manager to transfer state from an old layer */
    _transferState(oldLayer) {
      debug(TRACE_MATCHED, this, this === oldLayer);
      const { state, internalState } = oldLayer;
      if (this === oldLayer) {
        return;
      }
      this.internalState = internalState;
      this.state = state;
      this.internalState.setAsyncProps(this.props);
      this._diffProps(this.props, this.internalState.getOldProps());
    }
    /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
    _update() {
      const stateNeedsUpdate = this.needsUpdate();
      debug(TRACE_UPDATE, this, stateNeedsUpdate);
      if (!stateNeedsUpdate) {
        return;
      }
      const currentProps = this.props;
      const context = this.context;
      const internalState = this.internalState;
      const currentViewport = context.viewport;
      const propsInTransition = this._updateUniformTransition();
      internalState.propsInTransition = propsInTransition;
      context.viewport = internalState.viewport || currentViewport;
      this.props = propsInTransition;
      try {
        const updateParams = this._getUpdateParams();
        const oldModels = this.getModels();
        if (context.device) {
          this.updateState(updateParams);
        } else {
          try {
            this.updateState(updateParams);
          } catch (error) {
          }
        }
        for (const extension of this.props.extensions) {
          extension.updateState.call(this, updateParams, extension);
        }
        this.setNeedsRedraw();
        this._updateAttributes();
        const modelChanged = this.getModels()[0] !== oldModels[0];
        this._postUpdate(updateParams, modelChanged);
      } finally {
        context.viewport = currentViewport;
        this.props = currentProps;
        this._clearChangeFlags();
        internalState.needsUpdate = false;
        internalState.resetOldProps();
      }
    }
    /* eslint-enable max-statements */
    /** (Internal) Called by manager when layer is about to be disposed 
        Note: not guaranteed to be called on application shutdown */
    _finalize() {
      debug(TRACE_FINALIZE, this);
      this.finalizeState(this.context);
      for (const extension of this.props.extensions) {
        extension.finalizeState.call(this, this.context, extension);
      }
    }
    // Calculates uniforms
    _drawLayer({
      renderPass,
      shaderModuleProps = null,
      uniforms = {},
      parameters: parameters2 = {}
    }) {
      this._updateAttributeTransition();
      const currentProps = this.props;
      const context = this.context;
      this.props = this.internalState.propsInTransition || currentProps;
      try {
        if (shaderModuleProps) {
          this.setShaderModuleProps(shaderModuleProps);
        }
        const { getPolygonOffset } = this.props;
        const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
        if (context.device instanceof WebGLDevice) {
          context.device.setParametersWebGL({ polygonOffset: offsets });
        }
        for (const model of this.getModels()) {
          if (model.device.type === "webgpu") {
            model.setParameters({ ...model.parameters, ...parameters2 });
          } else {
            model.setParameters(parameters2);
          }
        }
        if (context.device instanceof WebGLDevice) {
          context.device.withParametersWebGL(parameters2, () => {
            const opts = { renderPass, shaderModuleProps, uniforms, parameters: parameters2, context };
            for (const extension of this.props.extensions) {
              extension.draw.call(this, opts, extension);
            }
            this.draw(opts);
          });
        } else {
          const opts = { renderPass, shaderModuleProps, uniforms, parameters: parameters2, context };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        }
      } finally {
        this.props = currentProps;
      }
    }
    // Helper methods
    /** Returns the current change flags */
    getChangeFlags() {
      return this.internalState?.changeFlags;
    }
    /* eslint-disable complexity */
    /** Dirty some change flags, will be handled by updateLayer */
    setChangeFlags(flags) {
      if (!this.internalState) {
        return;
      }
      const { changeFlags } = this.internalState;
      for (const key in flags) {
        if (flags[key]) {
          let flagChanged = false;
          switch (key) {
            case "dataChanged":
              const dataChangedReason = flags[key];
              const prevDataChangedReason = changeFlags[key];
              if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                flagChanged = true;
              }
            default:
              if (!changeFlags[key]) {
                changeFlags[key] = flags[key];
                flagChanged = true;
              }
          }
          if (flagChanged) {
            debug(TRACE_CHANGE_FLAG, this, key, flags);
          }
        }
      }
      const propsOrDataChanged = Boolean(
        changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged
      );
      changeFlags.propsOrDataChanged = propsOrDataChanged;
      changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    /* eslint-enable complexity */
    /** Clear all changeFlags, typically after an update */
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    /** Compares the layers props with old props from a matched older layer
        and extracts change flags that describe what has change so that state
        can be update correctly with minimal effort */
    _diffProps(newProps, oldProps) {
      const changeFlags = diffProps(newProps, oldProps);
      if (changeFlags.updateTriggersChanged) {
        for (const key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this.invalidateAttribute(key);
          }
        }
      }
      if (changeFlags.transitionsChanged) {
        for (const key in changeFlags.transitionsChanged) {
          this.internalState.uniformTransitions.add(
            key,
            oldProps[key],
            newProps[key],
            newProps.transitions?.[key]
          );
        }
      }
      return this.setChangeFlags(changeFlags);
    }
    /** (Internal) called by layer manager to perform extra props validation (in development only) */
    validateProps() {
      validateProps(this.props);
    }
    /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
    updateAutoHighlight(info) {
      if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
        this._updateAutoHighlight(info);
      }
    }
    // May be overriden by subclasses
    // TODO - simplify subclassing interface
    /** Update picking module parameters to highlight the hovered object */
    _updateAutoHighlight(info) {
      const picking2 = {
        // @ts-ignore
        highlightedObjectColor: info.picked ? info.color : null
      };
      const { highlightColor } = this.props;
      if (info.picked && typeof highlightColor === "function") {
        picking2.highlightColor = highlightColor(info);
      }
      this.setShaderModuleProps({ picking: picking2 });
      this.setNeedsRedraw();
    }
    /** Create new attribute manager */
    _getAttributeManager() {
      const context = this.context;
      return new AttributeManager(context.device, {
        id: this.props.id,
        stats: context.stats,
        timeline: context.timeline
      });
    }
    // Private methods
    /** Called after updateState to perform common tasks */
    _postUpdate(updateParams, forceUpdate) {
      const { props, oldProps } = updateParams;
      const model = this.state.model;
      if (model?.isInstanced) {
        model.setInstanceCount(this.getNumInstances());
      }
      const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
        const picking2 = {};
        if (Array.isArray(highlightColor)) {
          picking2.highlightColor = highlightColor;
        }
        if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
          picking2.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
        }
        this.setShaderModuleProps({ picking: picking2 });
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        // @ts-ignore TS2531 this method can only be called internally with internalState assigned
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        // @ts-ignore TS2531 this method can only be called internally with internalState assigned
        changeFlags: this.internalState.changeFlags
      };
    }
    /** Checks state of attributes and model */
    _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }
      let redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      const attributeManager = this.getAttributeManager();
      const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
      redraw = redraw || attributeManagerNeedsRedraw;
      if (redraw) {
        for (const extension of this.props.extensions) {
          extension.onNeedsRedraw.call(this, extension);
        }
      }
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      return redraw;
    }
    /** Callback when asyn prop is loaded */
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps());
      this.setNeedsUpdate();
    }
  };
  Layer.defaultProps = defaultProps2;
  Layer.layerName = "Layer";

  // ../core/src/lib/composite-layer.ts
  var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
  var CompositeLayer = class extends Layer {
    /** `true` if this layer renders other layers */
    get isComposite() {
      return true;
    }
    /** `true` if the layer renders to screen */
    get isDrawable() {
      return false;
    }
    /** Returns true if all async resources are loaded */
    get isLoaded() {
      return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
    }
    /** Return last rendered sub layers */
    getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
    // initializeState is usually not needed for composite layers
    // Provide empty definition to disable check for missing definition
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    initializeState(context) {
    }
    /** Updates selected state members and marks the composite layer to need rerender */
    setState(updateObject) {
      super.setState(updateObject);
      this.setNeedsUpdate();
    }
    /** called to augment the info object that is bubbled up from a sublayer
        override Layer.getPickingInfo() because decoding / setting uniform do
        not apply to a composite layer. */
    getPickingInfo({ info }) {
      const { object } = info;
      const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
      if (!isDataWrapped) {
        return info;
      }
      info.object = object.__source.object;
      info.index = object.__source.index;
      return info;
    }
    /**
     * Filters sub layers at draw time. Return true if the sub layer should be drawn.
     */
    filterSubLayer(context) {
      return true;
    }
    /** Returns true if sub layer needs to be rendered */
    shouldRenderSubLayer(subLayerId, data) {
      return data && data.length;
    }
    /** Returns sub layer class for a specific sublayer */
    getSubLayerClass(subLayerId, DefaultLayerClass) {
      const { _subLayerProps: overridingProps } = this.props;
      return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
    }
    /** When casting user data into another format to pass to sublayers,
        add reference to the original object and object index */
    getSubLayerRow(row, sourceObject, sourceObjectIndex) {
      row.__source = {
        parent: this,
        object: sourceObject,
        index: sourceObjectIndex
      };
      return row;
    }
    /** Some composite layers cast user data into another format before passing to sublayers
      We need to unwrap them before calling the accessor so that they see the original data
      objects */
    getSubLayerAccessor(accessor) {
      if (typeof accessor === "function") {
        const objectInfo = {
          index: -1,
          // @ts-ignore accessing resolved data
          data: this.props.data,
          target: []
        };
        return (x3, i5) => {
          if (x3 && x3.__source) {
            objectInfo.index = x3.__source.index;
            return accessor(x3.__source.object, objectInfo);
          }
          return accessor(x3, i5);
        };
      }
      return accessor;
    }
    /** Returns sub layer props for a specific sublayer */
    // eslint-disable-next-line complexity
    getSubLayerProps(sublayerProps = {}) {
      const {
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation,
        _subLayerProps: overridingProps
      } = this.props;
      const newProps = {
        id: "",
        updateTriggers: {},
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation
      };
      const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
      const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
      const sublayerId = sublayerProps.id || "sublayer";
      if (overridingSublayerProps) {
        const propTypes = this.props[PROP_TYPES_SYMBOL];
        const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
        for (const key in overridingSublayerProps) {
          const propType = subLayerPropTypes[key] || propTypes[key];
          if (propType && propType.type === "accessor") {
            overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
          }
        }
      }
      Object.assign(
        newProps,
        sublayerProps,
        // experimental feature that allows users to override sublayer props via parent layer prop
        overridingSublayerProps
      );
      newProps.id = `${this.props.id}-${sublayerId}`;
      newProps.updateTriggers = {
        all: this.props.updateTriggers?.all,
        ...sublayerProps.updateTriggers,
        ...overridingSublayerTriggers
      };
      for (const extension of extensions) {
        const passThroughProps = extension.getSubLayerProps.call(this, extension);
        if (passThroughProps) {
          Object.assign(newProps, passThroughProps, {
            updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
          });
        }
      }
      return newProps;
    }
    /** Update sub layers to highlight the hovered object */
    _updateAutoHighlight(info) {
      for (const layer of this.getSubLayers()) {
        layer.updateAutoHighlight(info);
      }
    }
    /** Override base Layer method */
    _getAttributeManager() {
      return null;
    }
    /** (Internal) Called after an update to rerender sub layers */
    _postUpdate(updateParams, forceUpdate) {
      let subLayers = this.internalState.subLayers;
      const shouldUpdate = !subLayers || this.needsUpdate();
      if (shouldUpdate) {
        const subLayersList = this.renderLayers();
        subLayers = flatten(subLayersList, Boolean);
        this.internalState.subLayers = subLayers;
      }
      debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
      for (const layer of subLayers) {
        layer.parent = this;
      }
    }
  };
  CompositeLayer.layerName = "CompositeLayer";

  // ../core/src/viewports/globe-viewport.ts
  var DEGREES_TO_RADIANS6 = Math.PI / 180;
  var RADIANS_TO_DEGREES3 = 180 / Math.PI;
  var EARTH_RADIUS = 6370972;
  var GLOBE_RADIUS = 256;
  function getDistanceScales2() {
    const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
    const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
    return {
      unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
      unitsPerMeter2: [0, 0, 0],
      metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
      unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
      unitsPerDegree2: [0, 0, 0],
      degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
    };
  }
  var GlobeViewport = class extends Viewport {
    constructor(opts = {}) {
      const {
        longitude = 0,
        zoom = 0,
        // Matches Maplibre defaults
        // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
        nearZMultiplier = 0.5,
        farZMultiplier = 1,
        resolution = 10
      } = opts;
      let { latitude = 0, height, altitude = 1.5, fovy } = opts;
      latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);
      height = height || 1;
      if (fovy) {
        altitude = fovyToAltitude(fovy);
      } else {
        fovy = altitudeToFovy(altitude);
      }
      const scaleAdjust = 1 / Math.PI / Math.cos(latitude * Math.PI / 180);
      const scale22 = Math.pow(2, zoom) * scaleAdjust;
      const nearZ = opts.nearZ ?? nearZMultiplier;
      const farZ = opts.farZ ?? (altitude + GLOBE_RADIUS * 2 * scale22 / height) * farZMultiplier;
      const viewMatrix2 = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });
      viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS6);
      viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS6);
      viewMatrix2.scale(scale22 / height);
      super({
        ...opts,
        // x, y, width,
        height,
        // view matrix
        viewMatrix: viewMatrix2,
        longitude,
        latitude,
        zoom,
        // projection matrix parameters
        distanceScales: getDistanceScales2(),
        fovy,
        focalDistance: altitude,
        near: nearZ,
        far: farZ
      });
      this.scale = scale22;
      this.latitude = latitude;
      this.longitude = longitude;
      this.resolution = resolution;
    }
    get projectionMode() {
      return PROJECTION_MODE.GLOBE;
    }
    getDistanceScales() {
      return this.distanceScales;
    }
    getBounds(options = {}) {
      const unprojectOption = { targetZ: options.z || 0 };
      const left = this.unproject([0, this.height / 2], unprojectOption);
      const top = this.unproject([this.width / 2, 0], unprojectOption);
      const right = this.unproject([this.width, this.height / 2], unprojectOption);
      const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
      if (right[0] < this.longitude)
        right[0] += 360;
      if (left[0] > this.longitude)
        left[0] -= 360;
      return [
        Math.min(left[0], right[0], top[0], bottom[0]),
        Math.min(left[1], right[1], top[1], bottom[1]),
        Math.max(left[0], right[0], top[0], bottom[0]),
        Math.max(left[1], right[1], top[1], bottom[1])
      ];
    }
    unproject(xyz, { topLeft = true, targetZ } = {}) {
      const [x3, y3, z2] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const { pixelUnprojectionMatrix } = this;
      let coord;
      if (Number.isFinite(z2)) {
        coord = transformVector2(pixelUnprojectionMatrix, [x3, y22, z2, 1]);
      } else {
        const coord0 = transformVector2(pixelUnprojectionMatrix, [x3, y22, -1, 1]);
        const coord1 = transformVector2(pixelUnprojectionMatrix, [x3, y22, 1, 1]);
        const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
        const lSqr = vec3_exports.sqrLen(vec3_exports.sub([], coord0, coord1));
        const l0Sqr = vec3_exports.sqrLen(coord0);
        const l1Sqr = vec3_exports.sqrLen(coord1);
        const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
        const dSqr = 4 * sSqr / lSqr;
        const r0 = Math.sqrt(l0Sqr - dSqr);
        const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
        const t3 = (r0 - dr) / Math.sqrt(lSqr);
        coord = vec3_exports.lerp([], coord0, coord1, t3);
      }
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z2)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [lng, lat, Z = 0] = xyz;
      const lambda = lng * DEGREES_TO_RADIANS6;
      const phi = lat * DEGREES_TO_RADIANS6;
      const cosPhi = Math.cos(phi);
      const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
    }
    unprojectPosition(xyz) {
      const [x3, y3, z2] = xyz;
      const D = vec3_exports.len(xyz);
      const phi = Math.asin(z2 / D);
      const lambda = Math.atan2(x3, -y3);
      const lng = lambda * RADIANS_TO_DEGREES3;
      const lat = phi * RADIANS_TO_DEGREES3;
      const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
      return [lng, lat, Z];
    }
    projectFlat(xyz) {
      return xyz;
    }
    unprojectFlat(xyz) {
      return xyz;
    }
    panByPosition(coords, pixel) {
      const fromPosition = this.unproject(pixel);
      return {
        longitude: coords[0] - fromPosition[0] + this.longitude,
        latitude: coords[1] - fromPosition[1] + this.latitude
      };
    }
  };
  function transformVector2(matrix, vector) {
    const result = vec4_exports.transformMat4([], vector, matrix);
    vec4_exports.scale(result, result, 1 / result[3]);
    return result;
  }

  // ../core/src/viewports/orbit-viewport.ts
  var DEGREES_TO_RADIANS7 = Math.PI / 180;
  function getViewMatrix2({
    height,
    focalDistance,
    orbitAxis,
    rotationX,
    rotationOrbit,
    zoom
  }) {
    const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
    const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
    const viewMatrix2 = new Matrix4().lookAt({ eye, up });
    viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS7);
    if (orbitAxis === "Z") {
      viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS7);
    } else {
      viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS7);
    }
    const projectionScale = Math.pow(2, zoom) / height;
    viewMatrix2.scale(projectionScale);
    return viewMatrix2;
  }
  var OrbitViewport = class extends Viewport {
    constructor(props) {
      const {
        height,
        projectionMatrix,
        fovy = 50,
        // For setting camera position
        orbitAxis = "Z",
        // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'
        target: target2 = [0, 0, 0],
        // Which point is camera looking at, default origin
        rotationX = 0,
        // Rotating angle around X axis
        rotationOrbit = 0,
        // Rotating angle around orbit axis
        zoom = 0
      } = props;
      const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
      super({
        ...props,
        // in case viewState contains longitude/latitude values,
        // make sure that the base Viewport class does not treat this as a geospatial viewport
        longitude: void 0,
        viewMatrix: getViewMatrix2({
          height: height || 1,
          focalDistance,
          orbitAxis,
          rotationX,
          rotationOrbit,
          zoom
        }),
        fovy,
        focalDistance,
        position: target2,
        zoom
      });
      this.projectedCenter = this.project(this.center);
    }
    unproject(xyz, { topLeft = true } = {}) {
      const [x3, y3, z2 = this.projectedCenter[2]] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const [X, Y, Z] = pixelsToWorld([x3, y22, z2], this.pixelUnprojectionMatrix);
      return [X, Y, Z];
    }
    panByPosition(coords, pixel) {
      const p0 = this.project(coords);
      const nextCenter = [
        this.width / 2 + p0[0] - pixel[0],
        this.height / 2 + p0[1] - pixel[1],
        this.projectedCenter[2]
      ];
      return {
        target: this.unproject(nextCenter)
      };
    }
  };

  // ../core/src/viewports/orthographic-viewport.ts
  var viewMatrix = new Matrix4().lookAt({ eye: [0, 0, 1] });
  function getProjectionMatrix2({
    width,
    height,
    near,
    far,
    padding
  }) {
    let left = -width / 2;
    let right = width / 2;
    let bottom = -height / 2;
    let top = height / 2;
    if (padding) {
      const { left: l3 = 0, right: r3 = 0, top: t3 = 0, bottom: b2 = 0 } = padding;
      const offsetX = clamp((l3 + width - r3) / 2, 0, width) - width / 2;
      const offsetY = clamp((t3 + height - b2) / 2, 0, height) - height / 2;
      left -= offsetX;
      right -= offsetX;
      bottom += offsetY;
      top += offsetY;
    }
    return new Matrix4().ortho({
      left,
      right,
      bottom,
      top,
      near,
      far
    });
  }
  var OrthographicViewport = class extends Viewport {
    constructor(props) {
      const {
        width,
        height,
        near = 0.1,
        far = 1e3,
        zoom = 0,
        target: target2 = [0, 0, 0],
        padding = null,
        flipY = true
      } = props;
      const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
      const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
      const zoom_ = Math.min(zoomX, zoomY);
      const scale22 = Math.pow(2, zoom_);
      let distanceScales;
      if (zoomX !== zoomY) {
        const scaleX2 = Math.pow(2, zoomX);
        const scaleY2 = Math.pow(2, zoomY);
        distanceScales = {
          unitsPerMeter: [scaleX2 / scale22, scaleY2 / scale22, 1],
          metersPerUnit: [scale22 / scaleX2, scale22 / scaleY2, 1]
        };
      }
      super({
        ...props,
        // in case viewState contains longitude/latitude values,
        // make sure that the base Viewport class does not treat this as a geospatial viewport
        longitude: void 0,
        position: target2,
        viewMatrix: viewMatrix.clone().scale([scale22, scale22 * (flipY ? -1 : 1), scale22]),
        projectionMatrix: getProjectionMatrix2({
          width: width || 1,
          height: height || 1,
          padding,
          near,
          far
        }),
        zoom: zoom_,
        distanceScales
      });
    }
    projectFlat([X, Y]) {
      const { unitsPerMeter: unitsPerMeter2 } = this.distanceScales;
      return [X * unitsPerMeter2[0], Y * unitsPerMeter2[1]];
    }
    unprojectFlat([x3, y3]) {
      const { metersPerUnit } = this.distanceScales;
      return [x3 * metersPerUnit[0], y3 * metersPerUnit[1]];
    }
    /* Needed by LinearInterpolator */
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate11 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
      const newCenter = vec2_exports.add([], this.center, translate11);
      return { target: this.unprojectFlat(newCenter) };
    }
  };

  // ../core/src/viewports/first-person-viewport.ts
  var FirstPersonViewport = class extends Viewport {
    constructor(props) {
      const { longitude, latitude, modelMatrix: modelMatrix2, bearing = 0, pitch = 0, up = [0, 0, 1] } = props;
      const spherical = new SphericalCoordinates({
        bearing,
        // Avoid "pixel project matrix not invertible" error
        pitch: pitch === -90 ? 1e-4 : 90 + pitch
      });
      const dir = spherical.toVector3().normalize();
      const center = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(dir) : dir;
      const zoom = Number.isFinite(latitude) ? getMeterZoom({ latitude }) : 0;
      const scale22 = Math.pow(2, zoom);
      const viewMatrix2 = new Matrix4().lookAt({ eye: [0, 0, 0], center, up }).scale(scale22);
      super({
        ...props,
        zoom,
        viewMatrix: viewMatrix2
      });
      this.latitude = latitude;
      this.longitude = longitude;
    }
  };

  // ../core/src/controllers/first-person-controller.ts
  var MOVEMENT_SPEED = 20;
  var PAN_SPEED = 500;
  var FirstPersonState = class extends ViewState {
    constructor(options) {
      const {
        /* Viewport arguments */
        width,
        // Width of viewport
        height,
        // Height of viewport
        // Position and orientation
        position = [0, 0, 0],
        // typically in meters from anchor point
        bearing = 0,
        // Rotation around y axis
        pitch = 0,
        // Rotation around x axis
        // Geospatial anchor
        longitude = null,
        latitude = null,
        maxPitch = 90,
        minPitch = -90,
        // Model state when the rotate operation first started
        startRotatePos,
        startBearing,
        startPitch,
        startZoomPosition,
        startPanPos,
        startPanPosition
      } = options;
      super(
        {
          width,
          height,
          position,
          bearing,
          pitch,
          longitude,
          latitude,
          maxPitch,
          minPitch
        },
        {
          startRotatePos,
          startBearing,
          startPitch,
          startZoomPosition,
          startPanPos,
          startPanPosition
        }
      );
      this.makeViewport = options.makeViewport;
    }
    /* Public API */
    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    panStart({ pos }) {
      const { position } = this.getViewportProps();
      return this._getUpdatedState({
        startPanPos: pos,
        startPanPosition: position
      });
    }
    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    pan({ pos }) {
      if (!pos) {
        return this;
      }
      const { startPanPos = [0, 0], startPanPosition = [0, 0] } = this.getState();
      const { width, height, bearing, pitch } = this.getViewportProps();
      const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;
      const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;
      const up = new SphericalCoordinates({ bearing, pitch });
      const forward = new SphericalCoordinates({ bearing, pitch: -90 });
      const yDirection = up.toVector3().normalize();
      const xDirection = forward.toVector3().cross(yDirection).normalize();
      return this._getUpdatedState({
        position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY))
      });
    }
    /**
     * End panning
     * Must call if `panStart()` was called
     */
    panEnd() {
      return this._getUpdatedState({
        startPanPos: null,
        startPanPosition: null
      });
    }
    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startBearing, startPitch } = this.getState();
      const { width, height } = this.getViewportProps();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        newRotation = {
          bearing: startBearing - deltaScaleX * 180,
          pitch: startPitch - deltaScaleY * 90
        };
      } else {
        newRotation = {
          bearing: startBearing - deltaAngleX,
          pitch: startPitch - deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */
    rotateEnd() {
      return this._getUpdatedState({
        startRotatePos: null,
        startBearing: null,
        startPitch: null
      });
    }
    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    zoomStart() {
      return this._getUpdatedState({
        startZoomPosition: this.getViewportProps().position
      });
    }
    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */
    zoom({ pos, scale: scale22 }) {
      const viewportProps = this.getViewportProps();
      const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;
      const viewport = this.makeViewport(viewportProps);
      const { projectionMatrix, width } = viewport;
      const fovxRadians = 2 * Math.atan(1 / projectionMatrix[0]);
      const angle9 = fovxRadians * (pos[0] / width - 0.5);
      const direction = this.getDirection(true);
      return this._move(
        direction.rotateZ({ radians: -angle9 }),
        Math.log2(scale22) * MOVEMENT_SPEED,
        startZoomPosition
      );
    }
    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null
      });
    }
    moveLeft(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({ radians: Math.PI / 2 }), speed);
    }
    moveRight(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({ radians: -Math.PI / 2 }), speed);
    }
    // forward
    moveUp(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction, speed);
    }
    // backward
    moveDown(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.negate(), speed);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    zoomIn(speed = MOVEMENT_SPEED) {
      return this._move(new Vector3(0, 0, 1), speed);
    }
    zoomOut(speed = MOVEMENT_SPEED) {
      return this._move(new Vector3(0, 0, -1), speed);
    }
    // shortest path between two view states
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { bearing, longitude } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    /* Private methods */
    _move(direction, speed, fromPosition = this.getViewportProps().position) {
      const delta = direction.scale(speed);
      return this._getUpdatedState({
        position: new Vector3(fromPosition).add(delta)
      });
    }
    getDirection(use2D = false) {
      const spherical = new SphericalCoordinates({
        bearing: this.getViewportProps().bearing,
        pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
      });
      const direction = spherical.toVector3().normalize();
      return direction;
    }
    _getUpdatedState(newProps) {
      return new FirstPersonState({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    // Apply any constraints (mathematical or defined by _viewportProps) to map state
    applyConstraints(props) {
      const { pitch, maxPitch, minPitch, longitude, bearing } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      if (longitude !== null && (longitude < -180 || longitude > 180)) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      if (bearing < -180 || bearing > 180) {
        props.bearing = mod2(bearing + 180, 360) - 180;
      }
      return props;
    }
  };
  var FirstPersonController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = FirstPersonState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["position", "pitch", "bearing"])
      };
    }
  };

  // ../core/src/views/first-person-view.ts
  var FirstPersonView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    getViewportType() {
      return FirstPersonViewport;
    }
    get ControllerType() {
      return FirstPersonController;
    }
  };
  FirstPersonView.displayName = "FirstPersonView";

  // ../core/src/controllers/orbit-controller.ts
  var OrbitState = class extends ViewState {
    constructor(options) {
      const {
        /* Viewport arguments */
        width,
        // Width of viewport
        height,
        // Height of viewport
        rotationX = 0,
        // Rotation around x axis
        rotationOrbit = 0,
        // Rotation around orbit axis
        target: target2 = [0, 0, 0],
        zoom = 0,
        /* Viewport constraints */
        minRotationX = -90,
        maxRotationX = 90,
        minZoom = -Infinity,
        maxZoom = Infinity,
        /** Interaction states, required to calculate change during transform */
        // Model state when the pan operation first started
        startPanPosition,
        // Model state when the rotate operation first started
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        // Model state when the zoom operation first started
        startZoomPosition,
        startZoom
      } = options;
      super(
        {
          width,
          height,
          rotationX,
          rotationOrbit,
          target: target2,
          zoom,
          minRotationX,
          maxRotationX,
          minZoom,
          maxZoom
        },
        {
          startPanPosition,
          startRotatePos,
          startRotationX,
          startRotationOrbit,
          startZoomPosition,
          startZoom
        }
      );
      this.makeViewport = options.makeViewport;
    }
    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    panStart({ pos }) {
      return this._getUpdatedState({
        startPanPosition: this._unproject(pos)
      });
    }
    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    pan({ pos, startPosition }) {
      const startPanPosition = this.getState().startPanPosition || startPosition;
      if (!startPanPosition) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanPosition, pos);
      return this._getUpdatedState(newProps);
    }
    /**
     * End panning
     * Must call if `panStart()` was called
     */
    panEnd() {
      return this._getUpdatedState({
        startPanPosition: null
      });
    }
    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startRotationX: this.getViewportProps().rotationX,
        startRotationOrbit: this.getViewportProps().rotationOrbit
      });
    }
    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startRotationX, startRotationOrbit } = this.getState();
      const { width, height } = this.getViewportProps();
      if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        if (startRotationX < -90 || startRotationX > 90) {
          deltaScaleX *= -1;
        }
        newRotation = {
          rotationX: startRotationX + deltaScaleY * 180,
          rotationOrbit: startRotationOrbit + deltaScaleX * 180
        };
      } else {
        newRotation = {
          rotationX: startRotationX + deltaAngleY,
          rotationOrbit: startRotationOrbit + deltaAngleX
        };
      }
      return this._getUpdatedState(newRotation);
    }
    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */
    rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
    // shortest path between two view states
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { rotationOrbit } = props;
      if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
        props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
      }
      return props;
    }
    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    zoomStart({ pos }) {
      return this._getUpdatedState({
        startZoomPosition: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current target is
     * @param {[Number, Number]} startPos - the target position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */
    zoom({
      pos,
      startPos,
      scale: scale22
    }) {
      let { startZoom, startZoomPosition } = this.getState();
      if (!startZoomPosition) {
        startZoom = this.getViewportProps().zoom;
        startZoomPosition = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomPosition) {
        return this;
      }
      const newZoom = this._calculateNewZoom({ scale: scale22, startZoom });
      const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom: newZoom });
      return this._getUpdatedState({
        zoom: newZoom,
        ...zoomedViewport.panByPosition(startZoomPosition, pos)
      });
    }
    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({ scale: speed })
      });
    }
    zoomOut(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({ scale: 1 / speed })
      });
    }
    moveLeft(speed = 50) {
      return this._panFromCenter([-speed, 0]);
    }
    moveRight(speed = 50) {
      return this._panFromCenter([speed, 0]);
    }
    moveUp(speed = 50) {
      return this._panFromCenter([0, -speed]);
    }
    moveDown(speed = 50) {
      return this._panFromCenter([0, speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX - speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX + speed
      });
    }
    /* Private methods */
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    // Calculates new zoom
    _calculateNewZoom({
      scale: scale22,
      startZoom
    }) {
      const { maxZoom, minZoom } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      const zoom = startZoom + Math.log2(scale22);
      return clamp(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
      const { width, height, target: target2 } = this.getViewportProps();
      return this.pan({
        startPosition: target2,
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    // Apply any constraints (mathematical or defined by _viewportProps) to map state
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit } = props;
      props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
      props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
      if (rotationOrbit < -180 || rotationOrbit > 180) {
        props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
      }
      return props;
    }
  };
  var OrbitController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = OrbitState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["target", "zoom", "rotationX", "rotationOrbit"],
            required: ["target", "zoom"]
          }
        })
      };
    }
  };

  // ../core/src/views/orbit-view.ts
  var OrbitView = class extends View {
    constructor(props = {}) {
      super(props);
      this.props.orbitAxis = props.orbitAxis || "Z";
    }
    getViewportType() {
      return OrbitViewport;
    }
    get ControllerType() {
      return OrbitController;
    }
  };
  OrbitView.displayName = "OrbitView";

  // ../core/src/controllers/orthographic-controller.ts
  var OrthographicState = class extends OrbitState {
    constructor(props) {
      super(props);
      this.zoomAxis = props.zoomAxis || "all";
    }
    _calculateNewZoom({ scale: scale22, startZoom }) {
      const { maxZoom, minZoom } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      let deltaZoom = Math.log2(scale22);
      if (Array.isArray(startZoom)) {
        let [newZoomX, newZoomY] = startZoom;
        switch (this.zoomAxis) {
          case "X":
            newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
            break;
          case "Y":
            newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
            break;
          default:
            let z2 = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z2 < minZoom) {
              deltaZoom += minZoom - z2;
            }
            z2 = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z2 > maxZoom) {
              deltaZoom += maxZoom - z2;
            }
            newZoomX += deltaZoom;
            newZoomY += deltaZoom;
        }
        return [newZoomX, newZoomY];
      }
      return clamp(startZoom + deltaZoom, minZoom, maxZoom);
    }
  };
  var OrthographicController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = OrthographicState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["target", "zoom"])
      };
      this.dragMode = "pan";
    }
    _onPanRotate() {
      return false;
    }
  };

  // ../core/src/views/orthographic-view.ts
  var OrthographicView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    getViewportType() {
      return OrthographicViewport;
    }
    get ControllerType() {
      return OrthographicController;
    }
  };
  OrthographicView.displayName = "OrthographicView";

  // ../core/src/controllers/globe-controller.ts
  var GlobeState = class extends MapState {
    // Apply any constraints (mathematical or defined by _viewportProps) to map state
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const { longitude, latitude } = props;
      if (longitude < -180 || longitude > 180) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      props.latitude = clamp(latitude, -MAX_LATITUDE, MAX_LATITUDE);
      return props;
    }
  };
  var GlobeController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = GlobeState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"])
      };
      this.dragMode = "pan";
    }
    setProps(props) {
      super.setProps(props);
      this.dragRotate = false;
      this.touchRotate = false;
    }
  };

  // ../core/src/views/globe-view.ts
  var GlobeView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    getViewportType(viewState) {
      return viewState.zoom > 12 ? WebMercatorViewport2 : GlobeViewport;
    }
    get ControllerType() {
      return GlobeController;
    }
  };
  GlobeView.displayName = "GlobeView";

  // ../core/src/lib/layer-extension.ts
  var LayerExtension = class {
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
    }
    constructor(opts) {
      if (opts) {
        this.opts = opts;
      }
    }
    /** Returns true if two extensions are equivalent */
    equals(extension) {
      if (this === extension) {
        return true;
      }
      return this.constructor === extension.constructor && deepEqual2(this.opts, extension.opts, 1);
    }
    /** Only called if attached to a primitive layer */
    getShaders(extension) {
      return null;
    }
    /** Only called if attached to a CompositeLayer */
    getSubLayerProps(extension) {
      const { defaultProps: defaultProps48 } = extension.constructor;
      const newProps = {
        updateTriggers: {}
      };
      for (const key in defaultProps48) {
        if (key in this.props) {
          const propDef = defaultProps48[key];
          const propValue = this.props[key];
          newProps[key] = propValue;
          if (propDef && propDef.type === "accessor") {
            newProps.updateTriggers[key] = this.props.updateTriggers[key];
            if (typeof propValue === "function") {
              newProps[key] = this.getSubLayerAccessor(propValue);
            }
          }
        }
      }
      return newProps;
    }
    /* eslint-disable @typescript-eslint/no-empty-function */
    initializeState(context, extension) {
    }
    updateState(params, extension) {
    }
    onNeedsRedraw(extension) {
    }
    getNeedsPickingBuffer(extension) {
      return false;
    }
    draw(params, extension) {
    }
    finalizeState(context, extension) {
    }
  };
  LayerExtension.defaultProps = {};
  LayerExtension.extensionName = "LayerExtension";

  // ../core/src/transitions/fly-to-interpolator.ts
  var LINEARLY_INTERPOLATED_PROPS = {
    bearing: 0,
    pitch: 0,
    position: [0, 0, 0]
  };
  var DEFAULT_OPTS2 = {
    speed: 1.2,
    curve: 1.414
  };
  var FlyToInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      super({
        compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        required: ["width", "height", "latitude", "longitude", "zoom"]
      });
      this.opts = { ...DEFAULT_OPTS2, ...opts };
    }
    interpolateProps(startProps, endProps, t3) {
      const viewport = flyToViewport(startProps, endProps, t3, this.opts);
      for (const key in LINEARLY_INTERPOLATED_PROPS) {
        viewport[key] = lerp(
          startProps[key] || LINEARLY_INTERPOLATED_PROPS[key],
          endProps[key] || LINEARLY_INTERPOLATED_PROPS[key],
          t3
        );
      }
      return viewport;
    }
    // computes the transition duration
    getDuration(startProps, endProps) {
      let { transitionDuration } = endProps;
      if (transitionDuration === "auto") {
        transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
      }
      return transitionDuration;
    }
  };

  // ../core/src/utils/tesselator.ts
  var Tesselator = class {
    constructor(opts) {
      this.indexStarts = [0];
      this.vertexStarts = [0];
      this.vertexCount = 0;
      this.instanceCount = 0;
      const { attributes = {} } = opts;
      this.typedArrayManager = typed_array_manager_default;
      this.attributes = {};
      this._attributeDefs = attributes;
      this.opts = opts;
      this.updateGeometry(opts);
    }
    /* Public methods */
    updateGeometry(opts) {
      Object.assign(this.opts, opts);
      const {
        data,
        buffers = {},
        getGeometry: getGeometry2,
        geometryBuffer,
        positionFormat,
        dataChanged,
        normalize: normalize16 = true
      } = this.opts;
      this.data = data;
      this.getGeometry = getGeometry2;
      this.positionSize = // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat
      geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
      this.buffers = buffers;
      this.normalize = normalize16;
      if (geometryBuffer) {
        assert8(data.startIndices);
        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
        if (!normalize16) {
          buffers.vertexPositions = geometryBuffer;
        }
      }
      this.geometryBuffer = buffers.vertexPositions;
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          this._rebuildGeometry(dataRange);
        }
      } else {
        this._rebuildGeometry();
      }
    }
    updatePartialGeometry({ startRow, endRow }) {
      this._rebuildGeometry({ startRow, endRow });
    }
    getGeometryFromBuffer(geometryBuffer) {
      const value = geometryBuffer.value || geometryBuffer;
      if (!ArrayBuffer.isView(value)) {
        return null;
      }
      return getAccessorFromBuffer(value, {
        size: this.positionSize,
        offset: geometryBuffer.offset,
        stride: geometryBuffer.stride,
        startIndices: this.data.startIndices
      });
    }
    /* Private utility methods */
    _allocate(instanceCount, copy12) {
      const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
      for (const name13 in _attributeDefs) {
        if (name13 in buffers) {
          typedArrayManager.release(attributes[name13]);
          attributes[name13] = null;
        } else {
          const def = _attributeDefs[name13];
          def.copy = copy12;
          attributes[name13] = typedArrayManager.allocate(attributes[name13], instanceCount, def);
        }
      }
    }
    /**
     * Visit all objects
     * `data` is expected to be an iterable consistent with the base Layer expectation
     */
    _forEachGeometry(visitor, startRow, endRow) {
      const { data, getGeometry: getGeometry2 } = this;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        const geometry = getGeometry2 ? getGeometry2(object, objectInfo) : null;
        visitor(geometry, objectInfo.index);
      }
    }
    /* eslint-disable complexity,max-statements */
    _rebuildGeometry(dataRange) {
      if (!this.data) {
        return;
      }
      let { indexStarts, vertexStarts, instanceCount } = this;
      const { data, geometryBuffer } = this;
      const { startRow = 0, endRow = Infinity } = dataRange || {};
      const normalizedData = {};
      if (!dataRange) {
        indexStarts = [0];
        vertexStarts = [0];
      }
      if (this.normalize || !geometryBuffer) {
        this._forEachGeometry(
          (geometry, dataIndex) => {
            const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
            normalizedData[dataIndex] = normalizedGeometry;
            vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
          },
          startRow,
          endRow
        );
        instanceCount = vertexStarts[vertexStarts.length - 1];
      } else {
        vertexStarts = data.startIndices;
        instanceCount = vertexStarts[data.length] || 0;
        if (ArrayBuffer.isView(geometryBuffer)) {
          instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
        } else if (geometryBuffer instanceof Buffer2) {
          const byteStride = this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
        } else if (geometryBuffer.buffer) {
          const byteStride = geometryBuffer.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
        } else if (geometryBuffer.value) {
          const bufferValue = geometryBuffer.value;
          const elementStride = (
            // @ts-ignore (2339) if stride is not specified, will fall through to positionSize
            geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize
          );
          instanceCount = instanceCount || bufferValue.length / elementStride;
        }
      }
      this._allocate(instanceCount, Boolean(dataRange));
      this.indexStarts = indexStarts;
      this.vertexStarts = vertexStarts;
      this.instanceCount = instanceCount;
      const context = {};
      this._forEachGeometry(
        (geometry, dataIndex) => {
          const normalizedGeometry = normalizedData[dataIndex] || geometry;
          context.vertexStart = vertexStarts[dataIndex];
          context.indexStart = indexStarts[dataIndex];
          const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
          context.geometrySize = vertexEnd - vertexStarts[dataIndex];
          context.geometryIndex = dataIndex;
          this.updateGeometryAttributes(normalizedGeometry, context);
        },
        startRow,
        endRow
      );
      this.vertexCount = indexStarts[indexStarts.length - 1];
    }
  };

  // ../core/src/utils/apply-styles.ts
  function applyStyles(element, style) {
    if (style) {
      Object.entries(style).map(([key, value]) => {
        if (key.startsWith("--")) {
          element.style.setProperty(key, value);
        } else {
          element.style[key] = value;
        }
      });
    }
  }
  function removeStyles(element, style) {
    if (style) {
      Object.keys(style).map((key) => {
        if (key.startsWith("--")) {
          element.style.removeProperty(key);
        } else {
          element.style[key] = "";
        }
      });
    }
  }

  // ../layers/src/arc-layer/arc-layer-uniforms.ts
  var uniformBlock7 = `uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`;
  var arcUniforms = {
    name: "arc",
    vs: uniformBlock7,
    fs: uniformBlock7,
    uniformTypes: {
      greatCircle: "f32",
      useShortestPath: "f32",
      numSegments: "f32",
      widthScale: "f32",
      widthMinPixels: "f32",
      widthMaxPixels: "f32",
      widthUnits: "i32"
    }
  };

  // ../layers/src/arc-layer/arc-layer-vertex.glsl.ts
  var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader

in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;

out vec4 vColor;
out vec2 uv;
out float isValid;

float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
  // d: distance on the xy plane
  // r: ratio of the current point
  // p: ratio of the peak of the arc
  // h: height multiplier
  // z = f(r) = sqrt(r * (p * 2 - r)) * d * h
  // f(0) = 0
  // f(1) = dz

  float deltaZ = targetZ - sourceZ;
  float dh = distance * instanceHeights;
  if (dh == 0.0) {
    return sourceZ + deltaZ * ratio;
  }
  float unitZ = deltaZ / dh;
  float p2 = unitZ * unitZ + 1.0;

  // sqrt does not deal with negative values, manually flip source and target if delta.z < 0
  float dir = step(deltaZ, 0.0);
  float z0 = mix(sourceZ, targetZ, dir);
  float r = mix(ratio, 1.0 - ratio, dir);
  return sqrt(r * (p2 - r)) * dh + z0;
}

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

float getSegmentRatio(float index) {
  return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}

vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
  float distance = length(source.xy - target.xy);
  float z = paraboloid(distance, source.z, target.z, segmentRatio);

  float tiltAngle = radians(instanceTilts);
  vec2 tiltDirection = normalize(target.xy - source.xy);
  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);

  return vec3(
    mix(source.xy, target.xy, segmentRatio) + tilt,
    z * cos(tiltAngle)
  );
}

/* Great circle interpolation
 * http://www.movable-type.co.uk/scripts/latlong.html
 */
float getAngularDist (vec2 source, vec2 target) {
  vec2 sourceRadians = radians(source);
  vec2 targetRadians = radians(target);
  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
  vec2 shd_sq = sin_half_delta * sin_half_delta;

  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
  return 2.0 * asin(sqrt(a));
}

vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
  vec2 lngLat;

  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation
  if(abs(angularDist - PI) < 0.001) {
    lngLat = (1.0 - t) * source.xy + t * target.xy;
  } else {
    float a = sin((1.0 - t) * angularDist);
    float b = sin(t * angularDist);
    vec3 p = source3D.yxz * a + target3D.yxz * b;
    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
  }

  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);

  return vec3(lngLat, z);
}

/* END GREAT CIRCLE */

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  /*
  *  --(i, -1)-----------_(i+1, -1)--
  *       |          _,-"  |
  *       o      _,-"      o
  *       |  _,-"          |
  *  --(i, 1)"-------------(i+1, 1)--
  */
  float segmentIndex = float(gl_VertexID / 2);
  float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
  float segmentRatio = getSegmentRatio(segmentIndex);
  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
  float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));

  // if it's the first point, use next - current as direction
  // otherwise use current - prev
  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
  isValid = 1.0;

  uv = vec2(segmentRatio, segmentSide);
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  vec4 curr;
  vec4 next;
  vec3 source;
  vec3 target;

  if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);

    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);

    if (abs(currPos.x - prevPos.x) > 180.0) {
      indexDir = -1.0;
      isValid = 0.0;
    } else if (abs(currPos.x - nextPos.x) > 180.0) {
      indexDir = 1.0;
      isValid = 0.0;
    }
    nextPos = indexDir < 0.0 ? prevPos : nextPos;
    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;

    if (isValid == 0.0) {
      // split at the 180th meridian
      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
      currPos = mix(currPos, nextPos, t);
      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
    }

    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
  
    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
  
  } else {
    vec3 source_world = instanceSourcePositions;
    vec3 target_world = instanceTargetPositions;
    if (arc.useShortestPath) {
      source_world.x = mod(source_world.x + 180., 360.0) - 180.;
      target_world.x = mod(target_world.x + 180., 360.0) - 180.;

      float deltaLng = target_world.x - source_world.x;
      if (deltaLng > 180.) target_world.x -= 360.;
      if (deltaLng < -180.) source_world.x -= 360.;
    }
    source = project_position(source_world, instanceSourcePositions64Low);
    target = project_position(target_world, instanceTargetPositions64Low);

    // common x at longitude=-180
    float antiMeridianX = 0.0;

    if (arc.useShortestPath) {
      if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
        antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
      }
      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);

      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
        isValid = 0.0;
        indexDir = sign(segmentRatio - thresholdRatio);
        segmentRatio = thresholdRatio;
      }
    }

    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
    vec3 currPos = interpolateFlat(source, target, segmentRatio);
    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);

    if (arc.useShortestPath) {
      if (nextPos.x < antiMeridianX) {
        currPos.x += TILE_SIZE;
        nextPos.x += TILE_SIZE;
      }
    }

    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
    geometry.position = vec4(currPos, 1.0);
  }

  // Multiply out width and clamp to limits
  // mercator pixels are interpreted as screen pixels
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
    arc.widthMinPixels, arc.widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(curr, geometry);
  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
  vColor = vec4(color.rgb, color.a * layer.opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer-fragment.glsl.ts
  var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 uv;
in float isValid;

out vec4 fragColor;

void main(void) {
  if (isValid == 0.0) {
    discard;
  }

  fragColor = vColor;
  geometry.uv = uv;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer.ts
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps3 = {
    getSourcePosition: { type: "accessor", value: (x3) => x3.sourcePosition },
    getTargetPosition: { type: "accessor", value: (x3) => x3.targetPosition },
    getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
    getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
    getWidth: { type: "accessor", value: 1 },
    getHeight: { type: "accessor", value: 1 },
    getTilt: { type: "accessor", value: 0 },
    greatCircle: false,
    numSegments: { type: "number", value: 50, min: 1 },
    widthUnits: "pixels",
    widthScale: { type: "number", value: 1, min: 0 },
    widthMinPixels: { type: "number", value: 0, min: 0 },
    widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
  };
  var ArcLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds([
        "instanceSourcePositions",
        "instanceTargetPositions"
      ]);
    }
    getShaders() {
      return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default, arcUniforms] });
    }
    // This layer has its own wrapLongitude logic
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceSourceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getSourceColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceTargetColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getTargetColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        },
        instanceHeights: {
          size: 1,
          transition: true,
          accessor: "getHeight",
          defaultValue: 1
        },
        instanceTilts: {
          size: 1,
          transition: true,
          accessor: "getTilt",
          defaultValue: 0
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const {
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        greatCircle,
        wrapLongitude,
        numSegments
      } = this.props;
      const arcProps = {
        numSegments,
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        greatCircle,
        useShortestPath: wrapLongitude
      };
      const model = this.state.model;
      model.shaderInputs.setProps({ arc: arcProps });
      model.setVertexCount(numSegments * 2);
      model.draw(this.context.renderPass);
    }
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        topology: "triangle-strip",
        isInstanced: true
      });
    }
  };
  ArcLayer.layerName = "ArcLayer";
  ArcLayer.defaultProps = defaultProps3;

  // ../layers/src/bitmap-layer/create-mesh.ts
  var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
  var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  function createMesh(bounds, resolution) {
    if (!resolution) {
      return createQuad(bounds);
    }
    const maxXSpan = Math.max(
      Math.abs(bounds[0][0] - bounds[3][0]),
      Math.abs(bounds[1][0] - bounds[2][0])
    );
    const maxYSpan = Math.max(
      Math.abs(bounds[1][1] - bounds[0][1]),
      Math.abs(bounds[2][1] - bounds[3][1])
    );
    const uCount = Math.ceil(maxXSpan / resolution) + 1;
    const vCount = Math.ceil(maxYSpan / resolution) + 1;
    const vertexCount = (uCount - 1) * (vCount - 1) * 6;
    const indices = new Uint32Array(vertexCount);
    const texCoords = new Float32Array(uCount * vCount * 2);
    const positions = new Float64Array(uCount * vCount * 3);
    let vertex5 = 0;
    let index = 0;
    for (let u3 = 0; u3 < uCount; u3++) {
      const ut = u3 / (uCount - 1);
      for (let v2 = 0; v2 < vCount; v2++) {
        const vt = v2 / (vCount - 1);
        const p3 = interpolateQuad(bounds, ut, vt);
        positions[vertex5 * 3 + 0] = p3[0];
        positions[vertex5 * 3 + 1] = p3[1];
        positions[vertex5 * 3 + 2] = p3[2] || 0;
        texCoords[vertex5 * 2 + 0] = ut;
        texCoords[vertex5 * 2 + 1] = 1 - vt;
        if (u3 > 0 && v2 > 0) {
          indices[index++] = vertex5 - vCount;
          indices[index++] = vertex5 - vCount - 1;
          indices[index++] = vertex5 - 1;
          indices[index++] = vertex5 - vCount;
          indices[index++] = vertex5 - 1;
          indices[index++] = vertex5;
        }
        vertex5++;
      }
    }
    return {
      vertexCount,
      positions,
      indices,
      texCoords
    };
  }
  function createQuad(bounds) {
    const positions = new Float64Array(12);
    for (let i5 = 0; i5 < bounds.length; i5++) {
      positions[i5 * 3 + 0] = bounds[i5][0];
      positions[i5 * 3 + 1] = bounds[i5][1];
      positions[i5 * 3 + 2] = bounds[i5][2] || 0;
    }
    return {
      vertexCount: 6,
      positions,
      indices: DEFAULT_INDICES,
      texCoords: DEFAULT_TEX_COORDS
    };
  }
  function interpolateQuad(quad, ut, vt) {
    return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
  }

  // ../layers/src/bitmap-layer/bitmap-layer-uniforms.ts
  var uniformBlock8 = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
  var bitmapUniforms = {
    name: "bitmap",
    vs: uniformBlock8,
    fs: uniformBlock8,
    uniformTypes: {
      bounds: "vec4<f32>",
      coordinateConversion: "f32",
      desaturate: "f32",
      tintColor: "vec3<f32>",
      transparentColor: "vec4<f32>"
    }
  };

  // ../layers/src/bitmap-layer/bitmap-layer-vertex.ts
  var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer-fragment.ts
  var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
  var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer.ts
  var defaultProps4 = {
    image: { type: "image", value: null, async: true },
    bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
    _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    desaturate: { type: "number", min: 0, max: 1, value: 0 },
    // More context: because of the blending mode we're using for ground imagery,
    // alpha is not effective when blending the bitmap layers with the base map.
    // Instead we need to manually dim/blend rgb values with a background color.
    transparentColor: { type: "color", value: [0, 0, 0, 0] },
    tintColor: { type: "color", value: [255, 255, 255] },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var BitmapLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default, bitmapUniforms] });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.remove(["instancePickingColors"]);
      const noAlloc = true;
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: (attribute) => attribute.value = this.state.mesh.indices,
          noAlloc
        },
        positions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          update: (attribute) => attribute.value = this.state.mesh.positions,
          noAlloc
        },
        texCoords: {
          size: 2,
          update: (attribute) => attribute.value = this.state.mesh.texCoords,
          noAlloc
        }
      });
    }
    updateState({ props, oldProps, changeFlags }) {
      const attributeManager = this.getAttributeManager();
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
      if (props.bounds !== oldProps.bounds) {
        const oldMesh = this.state.mesh;
        const mesh = this._createMesh();
        this.state.model.setVertexCount(mesh.vertexCount);
        for (const key in mesh) {
          if (oldMesh && oldMesh[key] !== mesh[key]) {
            attributeManager.invalidate(key);
          }
        }
        this.setState({ mesh, ...this._getCoordinateUniforms() });
      } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
        this.setState(this._getCoordinateUniforms());
      }
    }
    getPickingInfo(params) {
      const { image } = this.props;
      const info = params.info;
      if (!info.color || !image) {
        info.bitmap = null;
        return info;
      }
      const { width, height } = image;
      info.index = 0;
      const uv = unpackUVsFromRGB(info.color);
      info.bitmap = {
        size: { width, height },
        uv,
        pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
      };
      return info;
    }
    // Override base Layer multi-depth picking logic
    disablePickingIndex() {
      this.setState({ disablePicking: true });
    }
    restorePickingColors() {
      this.setState({ disablePicking: false });
    }
    _updateAutoHighlight(info) {
      super._updateAutoHighlight({
        ...info,
        color: this.encodePickingColor(0)
      });
    }
    _createMesh() {
      const { bounds } = this.props;
      let normalizedBounds = bounds;
      if (isRectangularBounds(bounds)) {
        normalizedBounds = [
          [bounds[0], bounds[1]],
          [bounds[0], bounds[3]],
          [bounds[2], bounds[3]],
          [bounds[2], bounds[1]]
        ];
      }
      return createMesh(normalizedBounds, this.context.viewport.resolution);
    }
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        topology: "triangle-list",
        isInstanced: false
      });
    }
    draw(opts) {
      const { shaderModuleProps } = opts;
      const { model, coordinateConversion, bounds, disablePicking } = this.state;
      const { image, desaturate, transparentColor, tintColor } = this.props;
      if (shaderModuleProps.picking.isActive && disablePicking) {
        return;
      }
      if (image && model) {
        const bitmapProps = {
          bitmapTexture: image,
          bounds,
          coordinateConversion,
          desaturate,
          tintColor: tintColor.slice(0, 3).map((x3) => x3 / 255),
          transparentColor: transparentColor.map((x3) => x3 / 255)
        };
        model.shaderInputs.setProps({ bitmap: bitmapProps });
        model.draw(this.context.renderPass);
      }
    }
    _getCoordinateUniforms() {
      const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
      let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
      if (imageCoordinateSystem !== DEFAULT) {
        const { bounds } = this.props;
        if (!isRectangularBounds(bounds)) {
          throw new Error("_imageCoordinateSystem only supports rectangular bounds");
        }
        const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
        imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
        if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
          return { coordinateConversion: -1, bounds };
        }
        if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
          const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
          const topRight = lngLatToWorld([bounds[2], bounds[3]]);
          return {
            coordinateConversion: 1,
            bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
          };
        }
      }
      return {
        coordinateConversion: 0,
        bounds: [0, 0, 0, 0]
      };
    }
  };
  BitmapLayer.layerName = "BitmapLayer";
  BitmapLayer.defaultProps = defaultProps4;
  function unpackUVsFromRGB(color) {
    const [u3, v2, fracUV] = color;
    const vFrac = (fracUV & 240) / 256;
    const uFrac = (fracUV & 15) / 16;
    return [(u3 + uFrac) / 256, (v2 + vFrac) / 256];
  }
  function isRectangularBounds(bounds) {
    return Number.isFinite(bounds[0]);
  }

  // ../layers/src/icon-layer/icon-layer-uniforms.ts
  var uniformBlock9 = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
  var iconUniforms = {
    name: "icon",
    vs: uniformBlock9,
    fs: uniformBlock9,
    uniformTypes: {
      sizeScale: "f32",
      iconsTextureDim: "vec2<f32>",
      sizeMinPixels: "f32",
      sizeMaxPixels: "f32",
      billboard: "f32",
      sizeUnits: "i32",
      alphaCutoff: "f32"
    }
  };

  // ../layers/src/icon-layer/icon-layer-vertex.glsl.ts
  var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader

in vec2 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;

out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;

  vec2 iconSize = instanceIconFrames.zw;
  // convert size in meters to pixels, then scaled and clamp
 
  // project meters to pixels and clamp to limits 
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
    icon.sizeMinPixels, icon.sizeMaxPixels
  );

  // scale icon height to match instanceSize
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;

  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
  pixelOffset += instancePixelOffset;
  pixelOffset.y *= -1.0;

  if (icon.billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); 
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / icon.iconsTextureDim;

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);

  vColorMode = instanceColorModes;
}
`;

  // ../layers/src/icon-layer/icon-layer-fragment.glsl.ts
  var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader

precision highp float;

uniform sampler2D iconsTexture;

in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  vec4 texColor = texture(iconsTexture, vTextureCoords);

  // if colorMode == 0, use pixel color from the texture
  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask
  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
  // Take the global opacity and the alpha from vColor into account for the alpha component
  float a = texColor.a * layer.opacity * vColor.a;

  if (a < icon.alphaCutoff) {
    discard;
  }

  fragColor = vec4(color, a);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/icon-layer/icon-manager.ts
  var DEFAULT_CANVAS_WIDTH = 1024;
  var DEFAULT_BUFFER = 4;
  var noop4 = () => {
  };
  var DEFAULT_SAMPLER_PARAMETERS = {
    minFilter: "linear",
    mipmapFilter: "linear",
    // LINEAR is the default value but explicitly set it here
    magFilter: "linear",
    // minimize texture boundary artifacts
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  };
  var MISSING_ICON = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  function nextPowOfTwo(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function resizeImage(ctx2, imageData, maxWidth, maxHeight) {
    const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
    const width = Math.floor(imageData.width * resizeRatio);
    const height = Math.floor(imageData.height * resizeRatio);
    if (resizeRatio === 1) {
      return { image: imageData, width, height };
    }
    ctx2.canvas.height = height;
    ctx2.canvas.width = width;
    ctx2.clearRect(0, 0, width, height);
    ctx2.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
    return { image: ctx2.canvas, width, height };
  }
  function getIconId(icon) {
    return icon && (icon.id || icon.url);
  }
  function resizeTexture(texture, width, height, sampler) {
    const { width: oldWidth, height: oldHeight, device } = texture;
    const newTexture = device.createTexture({
      format: "rgba8unorm",
      width,
      height,
      sampler,
      mipmaps: true
    });
    const commandEncoder = device.createCommandEncoder();
    commandEncoder.copyTextureToTexture({
      sourceTexture: texture,
      destinationTexture: newTexture,
      width: oldWidth,
      height: oldHeight
    });
    commandEncoder.finish();
    texture.destroy();
    return newTexture;
  }
  function buildRowMapping(mapping, columns, yOffset) {
    for (let i5 = 0; i5 < columns.length; i5++) {
      const { icon, xOffset } = columns[i5];
      const id = getIconId(icon);
      mapping[id] = {
        ...icon,
        x: xOffset,
        y: yOffset
      };
    }
  }
  function buildMapping({
    icons,
    buffer,
    mapping = {},
    xOffset = 0,
    yOffset = 0,
    rowHeight = 0,
    canvasWidth
  }) {
    let columns = [];
    for (let i5 = 0; i5 < icons.length; i5++) {
      const icon = icons[i5];
      const id = getIconId(icon);
      if (!mapping[id]) {
        const { height, width } = icon;
        if (xOffset + width + buffer > canvasWidth) {
          buildRowMapping(mapping, columns, yOffset);
          xOffset = 0;
          yOffset = rowHeight + yOffset + buffer;
          rowHeight = 0;
          columns = [];
        }
        columns.push({
          icon,
          xOffset
        });
        xOffset = xOffset + width + buffer;
        rowHeight = Math.max(rowHeight, height);
      }
    }
    if (columns.length > 0) {
      buildRowMapping(mapping, columns, yOffset);
    }
    return {
      mapping,
      rowHeight,
      xOffset,
      yOffset,
      canvasWidth,
      canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
    };
  }
  function getDiffIcons(data, getIcon, cachedIcons) {
    if (!data || !getIcon) {
      return null;
    }
    cachedIcons = cachedIcons || {};
    const icons = {};
    const { iterable, objectInfo } = createIterable(data);
    for (const object of iterable) {
      objectInfo.index++;
      const icon = getIcon(object, objectInfo);
      const id = getIconId(icon);
      if (!icon) {
        throw new Error("Icon is missing.");
      }
      if (!icon.url) {
        throw new Error("Icon url is missing.");
      }
      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
        icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
      }
    }
    return icons;
  }
  var IconManager = class {
    constructor(device, {
      onUpdate = noop4,
      onError = noop4
    }) {
      this._loadOptions = null;
      this._texture = null;
      this._externalTexture = null;
      this._mapping = {};
      this._samplerParameters = null;
      /** count of pending requests to fetch icons */
      this._pendingCount = 0;
      this._autoPacking = false;
      // / internal state used for autoPacking
      this._xOffset = 0;
      this._yOffset = 0;
      this._rowHeight = 0;
      this._buffer = DEFAULT_BUFFER;
      this._canvasWidth = DEFAULT_CANVAS_WIDTH;
      this._canvasHeight = 0;
      this._canvas = null;
      this.device = device;
      this.onUpdate = onUpdate;
      this.onError = onError;
    }
    finalize() {
      this._texture?.delete();
    }
    getTexture() {
      return this._texture || this._externalTexture;
    }
    getIconMapping(icon) {
      const id = this._autoPacking ? getIconId(icon) : icon;
      return this._mapping[id] || MISSING_ICON;
    }
    setProps({
      loadOptions,
      autoPacking,
      iconAtlas,
      iconMapping,
      textureParameters
    }) {
      if (loadOptions) {
        this._loadOptions = loadOptions;
      }
      if (autoPacking !== void 0) {
        this._autoPacking = autoPacking;
      }
      if (iconMapping) {
        this._mapping = iconMapping;
      }
      if (iconAtlas) {
        this._texture?.delete();
        this._texture = null;
        this._externalTexture = iconAtlas;
      }
      if (textureParameters) {
        this._samplerParameters = textureParameters;
      }
    }
    get isLoaded() {
      return this._pendingCount === 0;
    }
    packIcons(data, getIcon) {
      if (!this._autoPacking || typeof document === "undefined") {
        return;
      }
      const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
      if (icons.length > 0) {
        const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
          icons,
          buffer: this._buffer,
          canvasWidth: this._canvasWidth,
          mapping: this._mapping,
          rowHeight: this._rowHeight,
          xOffset: this._xOffset,
          yOffset: this._yOffset
        });
        this._rowHeight = rowHeight;
        this._mapping = mapping;
        this._xOffset = xOffset;
        this._yOffset = yOffset;
        this._canvasHeight = canvasHeight;
        if (!this._texture) {
          this._texture = this.device.createTexture({
            format: "rgba8unorm",
            width: this._canvasWidth,
            height: this._canvasHeight,
            sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
            mipmaps: true
          });
        }
        if (this._texture.height !== this._canvasHeight) {
          this._texture = resizeTexture(
            this._texture,
            this._canvasWidth,
            this._canvasHeight,
            this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS
          );
        }
        this.onUpdate();
        this._canvas = this._canvas || document.createElement("canvas");
        this._loadIcons(icons);
      }
    }
    _loadIcons(icons) {
      const ctx2 = this._canvas.getContext("2d", {
        willReadFrequently: true
      });
      for (const icon of icons) {
        this._pendingCount++;
        load(icon.url, this._loadOptions).then((imageData) => {
          const id = getIconId(icon);
          const iconDef = this._mapping[id];
          const { x: x3, y: y3, width: maxWidth, height: maxHeight } = iconDef;
          const { image, width, height } = resizeImage(
            ctx2,
            imageData,
            maxWidth,
            maxHeight
          );
          this._texture?.copyExternalImage({
            image,
            x: x3 + (maxWidth - width) / 2,
            y: y3 + (maxHeight - height) / 2,
            width,
            height
          });
          iconDef.width = width;
          iconDef.height = height;
          this._texture.generateMipmap();
          this.onUpdate();
        }).catch((error) => {
          this.onError({
            url: icon.url,
            source: icon.source,
            sourceIndex: icon.sourceIndex,
            loadOptions: this._loadOptions,
            error
          });
        }).finally(() => {
          this._pendingCount--;
        });
      }
    }
  };

  // ../layers/src/icon-layer/icon-layer.ts
  var DEFAULT_COLOR2 = [0, 0, 0, 255];
  var defaultProps5 = {
    iconAtlas: { type: "image", value: null, async: true },
    iconMapping: { type: "object", value: {}, async: true },
    sizeScale: { type: "number", value: 1, min: 0 },
    billboard: true,
    sizeUnits: "pixels",
    sizeMinPixels: { type: "number", min: 0, value: 0 },
    //  min point radius in pixels
    sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    // max point radius in pixels
    alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getIcon: { type: "accessor", value: (x3) => x3.icon },
    getColor: { type: "accessor", value: DEFAULT_COLOR2 },
    getSize: { type: "accessor", value: 1 },
    getAngle: { type: "accessor", value: 0 },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    onIconError: { type: "function", value: null, optional: true },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var IconLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default, iconUniforms] });
    }
    initializeState() {
      this.state = {
        iconManager: new IconManager(this.context.device, {
          onUpdate: this._onUpdate.bind(this),
          onError: this._onError.bind(this)
        })
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceOffsets: {
          size: 2,
          accessor: "getIcon",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          transform: this.getInstanceOffset
        },
        instanceIconFrames: {
          size: 4,
          accessor: "getIcon",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          transform: this.getInstanceIconFrame
        },
        instanceColorModes: {
          size: 1,
          type: "uint8",
          accessor: "getIcon",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          transform: this.getInstanceColorMode
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR2
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instancePixelOffset: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        }
      });
    }
    /* eslint-disable max-statements, complexity */
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const attributeManager = this.getAttributeManager();
      const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
      const { iconManager } = this.state;
      if (typeof iconAtlas === "string") {
        return;
      }
      const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
      iconManager.setProps({
        loadOptions: props.loadOptions,
        autoPacking: !prePacked,
        iconAtlas,
        iconMapping: prePacked ? iconMapping : null,
        textureParameters
      });
      if (prePacked) {
        if (oldProps.iconMapping !== props.iconMapping) {
          attributeManager.invalidate("getIcon");
        }
      } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
        iconManager.packIcons(data, getIcon);
      }
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
    }
    /* eslint-enable max-statements, complexity */
    get isLoaded() {
      return super.isLoaded && this.state.iconManager.isLoaded;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.iconManager.finalize();
    }
    draw({ uniforms }) {
      const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        const model = this.state.model;
        const iconProps = {
          iconsTexture,
          iconsTextureDim: [iconsTexture.width, iconsTexture.height],
          sizeUnits: UNIT[sizeUnits],
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          billboard,
          alphaCutoff
        };
        model.shaderInputs.setProps({ icon: iconProps });
        model.draw(this.context.renderPass);
      }
    }
    _getModel() {
      const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // The size must be explicitly passed here otherwise luma.gl
            // will default to assuming that positions are 3D (x,y,z)
            positions: {
              size: 2,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true
      });
    }
    _onUpdate() {
      this.setNeedsRedraw();
    }
    _onError(evt) {
      const onIconError = this.getCurrentLayer()?.props.onIconError;
      if (onIconError) {
        onIconError(evt);
      } else {
        log_default.error(evt.error.message)();
      }
    }
    getInstanceOffset(icon) {
      const {
        width,
        height,
        anchorX = width / 2,
        anchorY = height / 2
      } = this.state.iconManager.getIconMapping(icon);
      return [width / 2 - anchorX, height / 2 - anchorY];
    }
    getInstanceColorMode(icon) {
      const mapping = this.state.iconManager.getIconMapping(icon);
      return mapping.mask ? 1 : 0;
    }
    getInstanceIconFrame(icon) {
      const { x: x3, y: y3, width, height } = this.state.iconManager.getIconMapping(icon);
      return [x3, y3, width, height];
    }
  };
  IconLayer.defaultProps = defaultProps5;
  IconLayer.layerName = "IconLayer";

  // ../layers/src/line-layer/line-layer-uniforms.ts
  var uniformBlockWGSL = (
    /* wgsl */
    `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
  );
  var uniformBlockGLSL = (
    /* glsl */
    `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
  );
  var lineUniforms = {
    name: "line",
    source: uniformBlockWGSL,
    vs: uniformBlockGLSL,
    fs: uniformBlockGLSL,
    uniformTypes: {
      widthScale: "f32",
      widthMinPixels: "f32",
      widthMaxPixels: "f32",
      useShortestPath: "f32",
      widthUnits: "i32"
    }
  };

  // ../layers/src/line-layer/line-layer.wgsl.ts
  var shaderWGSL = (
    /* wgsl */
    `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)
struct LayerUniforms {
  opacity: f32,
};
var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90\xB0: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, layer, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct LayerUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> layer: LayerUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * layer.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  return fragColor;
}
`
  );

  // ../layers/src/line-layer/line-layer-vertex.glsl.ts
  var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader

in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;

out vec4 vColor;
out vec2 uv;

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

vec3 splitLine(vec3 a, vec3 b, float x) {
  float t = (x - a.x) / (b.x - a.x);
  return vec3(x, mix(a.yz, b.yz, t));
}

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  vec3 source_world = instanceSourcePositions;
  vec3 target_world = instanceTargetPositions;
  vec3 source_world_64low = instanceSourcePositions64Low;
  vec3 target_world_64low = instanceTargetPositions64Low;

  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = mod(source_world.x + 180., 360.0) - 180.;
    target_world.x = mod(target_world.x + 180., 360.0) - 180.;
    float deltaLng = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.) {
      source_world.x += 360. * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
      source_world_64low = vec3(0.0);
    } else if (deltaLng * line.useShortestPath < -180.) {
      target_world.x += 360. * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
      target_world_64low = vec3(0.0);
    } else if (line.useShortestPath < 0.) {
      // Line is not split, abort
      gl_Position = vec4(0.);
      return;
    }
  }

  // Position
  vec4 source_commonspace;
  vec4 target_commonspace;
  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
  
  // linear interpolation of source & target to pick right coord
  float segmentIndex = positions.x;
  vec4 p = mix(source, target, segmentIndex);
  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
  uv = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Multiply out width and clamp to limits
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(p, geometry);
  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  // Color
  vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer-fragment.glsl.ts
  var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer.ts
  var DEFAULT_COLOR3 = [0, 0, 0, 255];
  var defaultProps6 = {
    getSourcePosition: { type: "accessor", value: (x3) => x3.sourcePosition },
    getTargetPosition: { type: "accessor", value: (x3) => x3.targetPosition },
    getColor: { type: "accessor", value: DEFAULT_COLOR3 },
    getWidth: { type: "accessor", value: 1 },
    widthUnits: "pixels",
    widthScale: { type: "number", value: 1, min: 0 },
    widthMinPixels: { type: "number", value: 0, min: 0 },
    widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
  };
  var LineLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds([
        "instanceSourcePositions",
        "instanceTargetPositions"
      ]);
    }
    getShaders() {
      return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, source: shaderWGSL, modules: [project32_default, picking_default, lineUniforms] });
    }
    // This layer has its own wrapLongitude logic
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
      const model = this.state.model;
      const lineProps = {
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude ? 1 : 0
      };
      model.shaderInputs.setProps({ line: lineProps });
      model.draw(this.context.renderPass);
      if (wrapLongitude) {
        model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });
        model.draw(this.context.renderPass);
      }
    }
    _getModel() {
      const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: { size: 3, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  LineLayer.layerName = "LineLayer";
  LineLayer.defaultProps = defaultProps6;

  // ../layers/src/point-cloud-layer/point-cloud-layer-uniforms.ts
  var uniformBlock10 = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`;
  var pointCloudUniforms = {
    name: "pointCloud",
    vs: uniformBlock10,
    fs: uniformBlock10,
    uniformTypes: {
      radiusPixels: "f32",
      sizeUnits: "i32"
    }
  };

  // ../layers/src/point-cloud-layer/point-cloud-layer-vertex.glsl.ts
  var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader

in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;

out vec4 vColor;
out vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  // Find the center of the point and add the current vertex
  vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  // Apply lighting
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(lightColor, instanceColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer-fragment.glsl.ts
  var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 unitPosition;

out vec4 fragColor;

void main(void) {
  geometry.uv = unitPosition.xy;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  fragColor = vColor;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer.ts
  var DEFAULT_COLOR4 = [0, 0, 0, 255];
  var DEFAULT_NORMAL = [0, 0, 1];
  var defaultProps7 = {
    sizeUnits: "pixels",
    pointSize: { type: "number", min: 0, value: 10 },
    //  point radius in pixels
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getNormal: { type: "accessor", value: DEFAULT_NORMAL },
    getColor: { type: "accessor", value: DEFAULT_COLOR4 },
    material: true,
    // Depreated
    radiusPixels: { deprecatedFor: "pointSize" }
  };
  function normalizeData(data) {
    const { header, attributes } = data;
    if (!header || !attributes) {
      return;
    }
    data.length = header.vertexCount;
    if (attributes.POSITION) {
      attributes.instancePositions = attributes.POSITION;
    }
    if (attributes.NORMAL) {
      attributes.instanceNormals = attributes.NORMAL;
    }
    if (attributes.COLOR_0) {
      const { size, value } = attributes.COLOR_0;
      attributes.instanceColors = { size, type: "unorm8", value };
    }
  }
  var PointCloudLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: point_cloud_layer_vertex_glsl_default,
        fs: point_cloud_layer_fragment_glsl_default,
        modules: [project32_default, gouraudMaterial, picking_default, pointCloudUniforms]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceNormals: {
          size: 3,
          transition: true,
          accessor: "getNormal",
          defaultValue: DEFAULT_NORMAL
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR4
        }
      });
    }
    updateState(params) {
      const { changeFlags, props } = params;
      super.updateState(params);
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
      if (changeFlags.dataChanged) {
        normalizeData(props.data);
      }
    }
    draw({ uniforms }) {
      const { pointSize, sizeUnits } = this.props;
      const model = this.state.model;
      const pointCloudProps = {
        sizeUnits: UNIT[sizeUnits],
        radiusPixels: pointSize
      };
      model.shaderInputs.setProps({ pointCloud: pointCloudProps });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [];
      for (let i5 = 0; i5 < 3; i5++) {
        const angle9 = i5 / 3 * Math.PI * 2;
        positions.push(Math.cos(angle9) * 2, Math.sin(angle9) * 2, 0);
      }
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-list",
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  PointCloudLayer.layerName = "PointCloudLayer";
  PointCloudLayer.defaultProps = defaultProps7;

  // ../layers/src/scatterplot-layer/scatterplot-layer-uniforms.ts
  var glslUniformBlock = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
  var scatterplotUniforms = {
    name: "scatterplot",
    vs: glslUniformBlock,
    fs: glslUniformBlock,
    source: "",
    uniformTypes: {
      radiusScale: "f32",
      radiusMinPixels: "f32",
      radiusMaxPixels: "f32",
      lineWidthScale: "f32",
      lineWidthMinPixels: "f32",
      lineWidthMaxPixels: "f32",
      stroked: "f32",
      filled: "f32",
      antialiasing: "f32",
      billboard: "f32",
      radiusUnits: "i32",
      lineWidthUnits: "i32"
    }
  };

  // ../layers/src/scatterplot-layer/scatterplot-layer-vertex.glsl.ts
  var scatterplot_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader

in vec3 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;

out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;


void main(void) {
  geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  outerRadiusPixels = clamp(
    project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );
  
  // Multiply out line width and clamp to limits
  float lineWidthPixels = clamp(
    project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accomodate edge smoothing
  float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;

  // position on the containing square in [-1, 1] space
  unitPosition = edgePadding * positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
  
  if (scatterplot.billboard) {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = edgePadding * positions * outerRadiusPixels;
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
  );

  // ../layers/src/scatterplot-layer/scatterplot-layer-fragment.glsl.ts
  var scatterplot_layer_fragment_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader

precision highp float;

in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;

out vec4 fragColor;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition) * outerRadiusPixels;
  float inCircle = scatterplot.antialiasing ?
    smoothedge(distToCenter, outerRadiusPixels) : 
    step(distToCenter, outerRadiusPixels);

  if (inCircle == 0.0) {
    discard;
  }

  if (scatterplot.stroked > 0.5) {
    float isLine = scatterplot.antialiasing ? 
      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
      step(innerUnitRadius * outerRadiusPixels, distToCenter);

    if (scatterplot.filled > 0.5) {
      fragColor = mix(vFillColor, vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
    }
  } else if (scatterplot.filled < 0.5) {
    discard;
  } else {
    fragColor = vFillColor;
  }

  fragColor.a *= inCircle;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
  );

  // ../layers/src/scatterplot-layer/scatterplot-layer.wgsl.ts
  var scatterplot_layer_wgsl_default = (
    /* wgsl */
    `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
  );

  // ../layers/src/scatterplot-layer/scatterplot-layer.ts
  var DEFAULT_COLOR5 = [0, 0, 0, 255];
  var defaultProps8 = {
    radiusUnits: "meters",
    radiusScale: { type: "number", min: 0, value: 1 },
    radiusMinPixels: { type: "number", min: 0, value: 0 },
    //  min point radius in pixels
    radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    // max point radius in pixels
    lineWidthUnits: "meters",
    lineWidthScale: { type: "number", min: 0, value: 1 },
    lineWidthMinPixels: { type: "number", min: 0, value: 0 },
    lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getRadius: { type: "accessor", value: 1 },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
    getLineWidth: { type: "accessor", value: 1 },
    // deprecated
    strokeWidth: { deprecatedFor: "getLineWidth" },
    outline: { deprecatedFor: "stroked" },
    getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
  };
  var ScatterplotLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: scatterplot_layer_vertex_glsl_default,
        fs: scatterplot_layer_fragment_glsl_default,
        source: scatterplot_layer_wgsl_default,
        modules: [project32_default, picking_default, scatterplotUniforms]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceRadius: {
          size: 1,
          transition: true,
          accessor: "getRadius",
          defaultValue: 1
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const {
        radiusUnits,
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        stroked,
        filled,
        billboard,
        antialiasing,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      } = this.props;
      const scatterplotProps = {
        stroked,
        filled,
        billboard,
        antialiasing,
        radiusUnits: UNIT[radiusUnits],
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        lineWidthUnits: UNIT[lineWidthUnits],
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      };
      const model = this.state.model;
      model.shaderInputs.setProps({ scatterplot: scatterplotProps });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: { size: 3, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  ScatterplotLayer.defaultProps = defaultProps8;
  ScatterplotLayer.layerName = "ScatterplotLayer";

  // ../layers/node_modules/@math.gl/polygon/dist/polygon-utils.js
  var WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
  };
  function modifyPolygonWindingDirection(points, direction, options = {}) {
    const windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
      reversePolygon(points, options);
      return true;
    }
    return false;
  }
  function getPolygonWindingDirection(points, options = {}) {
    return Math.sign(getPolygonSignedArea(points, options));
  }
  var DimIndex = {
    x: 0,
    y: 1,
    z: 2
  };
  function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = "xy" } = options;
    const dim = options.size || 2;
    let area2 = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for (let i5 = start, j2 = end - dim; i5 < end; i5 += dim) {
      area2 += (points[i5 + i0] - points[j2 + i0]) * (points[i5 + i1] + points[j2 + i1]);
      j2 = i5;
    }
    return area2 / 2;
  }
  function reversePolygon(points, options) {
    const { start = 0, end = points.length, size = 2 } = options;
    const numPoints = (end - start) / size;
    const numSwaps = Math.floor(numPoints / 2);
    for (let i5 = 0; i5 < numSwaps; ++i5) {
      const b1 = start + i5 * size;
      const b2 = start + (numPoints - 1 - i5) * size;
      for (let j2 = 0; j2 < size; ++j2) {
        const tmp = points[b1 + j2];
        points[b1 + j2] = points[b2 + j2];
        points[b2 + j2] = tmp;
      }
    }
  }

  // ../layers/node_modules/@math.gl/polygon/dist/utils.js
  function push(target2, source3) {
    const size = source3.length;
    const startIndex = target2.length;
    if (startIndex > 0) {
      let isDuplicate = true;
      for (let i5 = 0; i5 < size; i5++) {
        if (target2[startIndex - size + i5] !== source3[i5]) {
          isDuplicate = false;
          break;
        }
      }
      if (isDuplicate) {
        return false;
      }
    }
    for (let i5 = 0; i5 < size; i5++) {
      target2[startIndex + i5] = source3[i5];
    }
    return true;
  }
  function copy5(target2, source3) {
    const size = source3.length;
    for (let i5 = 0; i5 < size; i5++) {
      target2[i5] = source3[i5];
    }
  }
  function getPointAtIndex(positions, index, size, offset, out = []) {
    const startI = offset + index * size;
    for (let i5 = 0; i5 < size; i5++) {
      out[i5] = positions[startI + i5];
    }
    return out;
  }

  // ../layers/node_modules/@math.gl/polygon/dist/lineclip.js
  function intersect(a3, b2, edge, bbox, out = []) {
    let t3;
    let snap;
    if (edge & 8) {
      t3 = (bbox[3] - a3[1]) / (b2[1] - a3[1]);
      snap = 3;
    } else if (edge & 4) {
      t3 = (bbox[1] - a3[1]) / (b2[1] - a3[1]);
      snap = 1;
    } else if (edge & 2) {
      t3 = (bbox[2] - a3[0]) / (b2[0] - a3[0]);
      snap = 2;
    } else if (edge & 1) {
      t3 = (bbox[0] - a3[0]) / (b2[0] - a3[0]);
      snap = 0;
    } else {
      return null;
    }
    for (let i5 = 0; i5 < a3.length; i5++) {
      out[i5] = (snap & 1) === i5 ? bbox[snap] : t3 * (b2[i5] - a3[i5]) + a3[i5];
    }
    return out;
  }
  function bitCode(p3, bbox) {
    let code = 0;
    if (p3[0] < bbox[0])
      code |= 1;
    else if (p3[0] > bbox[2])
      code |= 2;
    if (p3[1] < bbox[1])
      code |= 4;
    else if (p3[1] > bbox[3])
      code |= 8;
    return code;
  }

  // ../layers/node_modules/@math.gl/polygon/dist/cut-by-grid.js
  function cutPolylineByGrid(positions, options) {
    const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    let part = [];
    const result = [part];
    const a3 = getPointAtIndex(positions, 0, size, startIndex);
    let b2;
    let codeB;
    const cell = getGridCell(a3, gridResolution, gridOffset, []);
    const scratchPoint2 = [];
    push(part, a3);
    for (let i5 = 1; i5 < numPoints; i5++) {
      b2 = getPointAtIndex(positions, i5, size, startIndex, b2);
      codeB = bitCode(b2, cell);
      while (codeB) {
        intersect(a3, b2, codeB, cell, scratchPoint2);
        const codeAlt = bitCode(scratchPoint2, cell);
        if (codeAlt) {
          intersect(a3, scratchPoint2, codeAlt, cell, scratchPoint2);
          codeB = codeAlt;
        }
        push(part, scratchPoint2);
        copy5(a3, scratchPoint2);
        moveToNeighborCell(cell, gridResolution, codeB);
        if (broken && part.length > size) {
          part = [];
          result.push(part);
          push(part, a3);
        }
        codeB = bitCode(b2, cell);
      }
      push(part, b2);
      copy5(a3, b2);
    }
    return broken ? result : result[0];
  }
  var TYPE_INSIDE = 0;
  var TYPE_BORDER = 1;
  function cutPolygonByGrid(positions, holeIndices = null, options) {
    if (!positions.length) {
      return [];
    }
    const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
    const result = [];
    const queue = [
      {
        pos: positions,
        types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
        holes: holeIndices || []
      }
    ];
    const bbox = [[], []];
    let cell = [];
    while (queue.length) {
      const { pos, types, holes } = queue.shift();
      getBoundingBox(pos, size, holes[0] || pos.length, bbox);
      cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
      const code = bitCode(bbox[1], cell);
      if (code) {
        let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
        const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
        const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
        queue.push(polygonLow, polygonHigh);
        for (let i5 = 0; i5 < holes.length; i5++) {
          parts = bisectPolygon(pos, types, size, holes[i5], holes[i5 + 1] || pos.length, cell, code);
          if (parts[0]) {
            polygonLow.holes.push(polygonLow.pos.length);
            polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
            if (edgeTypes) {
              polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
            }
          }
          if (parts[1]) {
            polygonHigh.holes.push(polygonHigh.pos.length);
            polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
            if (edgeTypes) {
              polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
            }
          }
        }
      } else {
        const polygon = { positions: pos };
        if (edgeTypes) {
          polygon.edgeTypes = types;
        }
        if (holes.length) {
          polygon.holeIndices = holes;
        }
        result.push(polygon);
      }
    }
    return result;
  }
  function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    const numPoints = (endIndex - startIndex) / size;
    const resultLow = [];
    const resultHigh = [];
    const typesLow = [];
    const typesHigh = [];
    const scratchPoint2 = [];
    let p3;
    let side;
    let type;
    const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
    let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    let prevType = edgeTypes && edgeTypes[numPoints - 1];
    let lowPointCount = 0;
    let highPointCount = 0;
    for (let i5 = 0; i5 < numPoints; i5++) {
      p3 = getPointAtIndex(positions, i5, size, startIndex, p3);
      side = Math.sign(edge & 8 ? p3[1] - bbox[3] : p3[0] - bbox[2]);
      type = edgeTypes && edgeTypes[startIndex / size + i5];
      if (side && prevSide && prevSide !== side) {
        intersect(prev, p3, edge, bbox, scratchPoint2);
        push(resultLow, scratchPoint2) && typesLow.push(prevType);
        push(resultHigh, scratchPoint2) && typesHigh.push(prevType);
      }
      if (side <= 0) {
        push(resultLow, p3) && typesLow.push(type);
        lowPointCount -= side;
      } else if (typesLow.length) {
        typesLow[typesLow.length - 1] = TYPE_INSIDE;
      }
      if (side >= 0) {
        push(resultHigh, p3) && typesHigh.push(type);
        highPointCount += side;
      } else if (typesHigh.length) {
        typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
      }
      copy5(prev, p3);
      prevSide = side;
      prevType = type;
    }
    return [
      lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
      highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
    ];
  }
  function getGridCell(p3, gridResolution, gridOffset, out) {
    const left = Math.floor((p3[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom = Math.floor((p3[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
  }
  function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
      cell[1] += gridResolution;
      cell[3] += gridResolution;
    } else if (edge & 4) {
      cell[1] -= gridResolution;
      cell[3] -= gridResolution;
    } else if (edge & 2) {
      cell[0] += gridResolution;
      cell[2] += gridResolution;
    } else if (edge & 1) {
      cell[0] -= gridResolution;
      cell[2] -= gridResolution;
    }
  }
  function getBoundingBox(positions, size, endIndex, out) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i5 = 0; i5 < endIndex; i5 += size) {
      const x3 = positions[i5];
      const y3 = positions[i5 + 1];
      minX = x3 < minX ? x3 : minX;
      maxX = x3 > maxX ? x3 : maxX;
      minY = y3 < minY ? y3 : minY;
      maxY = y3 > maxY ? y3 : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
  }
  function concatInPlace(arr1, arr2) {
    for (let i5 = 0; i5 < arr2.length; i5++) {
      arr1.push(arr2[i5]);
    }
    return arr1;
  }

  // ../layers/node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
  var DEFAULT_MAX_LATITUDE = 85.051129;
  function cutPolylineByMercatorBounds(positions, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize16 = true } = options || {};
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    const parts = cutPolylineByGrid(newPositions, {
      size,
      broken: true,
      gridResolution: 360,
      gridOffset: [-180, -180]
    });
    if (normalize16) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part, size);
      }
    }
    return parts;
  }
  function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
    const { size = 2, normalize: normalize16 = true, edgeTypes = false } = options || {};
    holeIndices = holeIndices || [];
    const newPositions = [];
    const newHoleIndices = [];
    let srcStartIndex = 0;
    let targetIndex = 0;
    for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
      const srcEndIndex = holeIndices[ringIndex] || positions.length;
      const targetStartIndex = targetIndex;
      const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
      for (let i5 = splitIndex; i5 < srcEndIndex; i5++) {
        newPositions[targetIndex++] = positions[i5];
      }
      for (let i5 = srcStartIndex; i5 < splitIndex; i5++) {
        newPositions[targetIndex++] = positions[i5];
      }
      wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
      insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
      srcStartIndex = srcEndIndex;
      newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
      size,
      gridResolution: 360,
      gridOffset: [-180, -180],
      edgeTypes
    });
    if (normalize16) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part.positions, size);
      }
    }
    return parts;
  }
  function findSplitIndex(positions, size, startIndex, endIndex) {
    let maxLat = -1;
    let pointIndex = -1;
    for (let i5 = startIndex + 1; i5 < endIndex; i5 += size) {
      const lat = Math.abs(positions[i5]);
      if (lat > maxLat) {
        maxLat = lat;
        pointIndex = i5 - 1;
      }
    }
    return pointIndex;
  }
  function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
    const firstLng = positions[startIndex];
    const lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
      const p3 = getPointAtIndex(positions, 0, size, startIndex);
      p3[0] += Math.round((lastLng - firstLng) / 360) * 360;
      push(positions, p3);
      p3[1] = Math.sign(p3[1]) * maxLatitude;
      push(positions, p3);
      p3[0] = firstLng;
      push(positions, p3);
    }
  }
  function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng;
    for (let i5 = startIndex; i5 < endIndex; i5 += size) {
      lng = positions[i5];
      const delta = lng - prevLng;
      if (delta > 180 || delta < -180) {
        lng -= Math.round(delta / 360) * 360;
      }
      positions[i5] = prevLng = lng;
    }
  }
  function shiftLongitudesIntoRange(positions, size) {
    let refLng;
    const pointCount = positions.length / size;
    for (let i5 = 0; i5 < pointCount; i5++) {
      refLng = positions[i5 * size];
      if ((refLng + 180) % 360 !== 0) {
        break;
      }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
      return;
    }
    for (let i5 = 0; i5 < pointCount; i5++) {
      positions[i5 * size] += delta;
    }
  }

  // ../layers/src/column-layer/column-geometry.ts
  var ColumnGeometry = class extends Geometry {
    constructor(props) {
      const { indices, attributes } = tesselateColumn(props);
      super({
        ...props,
        indices,
        // @ts-expect-error
        attributes
      });
    }
  };
  function tesselateColumn(props) {
    const { radius, height = 1, nradial = 10 } = props;
    let { vertices } = props;
    if (vertices) {
      log_default.assert(vertices.length >= nradial);
      vertices = vertices.flatMap((v2) => [v2[0], v2[1]]);
      modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
    }
    const isExtruded = height > 0;
    const vertsAroundEdge = nradial + 1;
    const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
    const stepAngle = Math.PI * 2 / nradial;
    const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    let i5 = 0;
    if (isExtruded) {
      for (let j2 = 0; j2 < vertsAroundEdge; j2++) {
        const a3 = j2 * stepAngle;
        const vertexIndex = j2 % nradial;
        const sin6 = Math.sin(a3);
        const cos6 = Math.cos(a3);
        for (let k2 = 0; k2 < 2; k2++) {
          positions[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos6 * radius;
          positions[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin6 * radius;
          positions[i5 + 2] = (1 / 2 - k2) * height;
          normals[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos6;
          normals[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin6;
          i5 += 3;
        }
      }
      positions[i5 + 0] = positions[i5 - 3];
      positions[i5 + 1] = positions[i5 - 2];
      positions[i5 + 2] = positions[i5 - 1];
      i5 += 3;
    }
    for (let j2 = isExtruded ? 0 : 1; j2 < vertsAroundEdge; j2++) {
      const v2 = Math.floor(j2 / 2) * Math.sign(0.5 - j2 % 2);
      const a3 = v2 * stepAngle;
      const vertexIndex = (v2 + nradial) % nradial;
      const sin6 = Math.sin(a3);
      const cos6 = Math.cos(a3);
      positions[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos6 * radius;
      positions[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin6 * radius;
      positions[i5 + 2] = height / 2;
      normals[i5 + 2] = 1;
      i5 += 3;
    }
    if (isExtruded) {
      let index = 0;
      for (let j2 = 0; j2 < nradial; j2++) {
        indices[index++] = j2 * 2 + 0;
        indices[index++] = j2 * 2 + 2;
        indices[index++] = j2 * 2 + 0;
        indices[index++] = j2 * 2 + 1;
        indices[index++] = j2 * 2 + 1;
        indices[index++] = j2 * 2 + 3;
      }
    }
    return {
      indices,
      attributes: {
        POSITION: { size: 3, value: positions },
        NORMAL: { size: 3, value: normals }
      }
    };
  }

  // ../layers/src/column-layer/column-layer-uniforms.ts
  var uniformBlock11 = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`;
  var columnUniforms = {
    name: "column",
    vs: uniformBlock11,
    fs: uniformBlock11,
    uniformTypes: {
      radius: "f32",
      angle: "f32",
      offset: "vec2<f32>",
      extruded: "f32",
      stroked: "f32",
      isStroke: "f32",
      coverage: "f32",
      elevationScale: "f32",
      edgeDistance: "f32",
      widthScale: "f32",
      widthMinPixels: "f32",
      widthMaxPixels: "f32",
      radiusUnits: "i32",
      widthUnits: "i32"
    }
  };

  // ../layers/src/column-layer/column-layer-vertex.glsl.ts
  var column_layer_vertex_glsl_default = `#version 300 es

#define SHADER_NAME column-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;

in vec3 instancePickingColors;

// Result
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif

void main(void) {
  geometry.worldPosition = instancePositions;

  vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
  // rotate primitive position and normal
  mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));

  // calculate elevation, if 3d not enabled set to 0
  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
  float elevation = 0.0;
  // calculate stroke offset
  float strokeOffsetRatio = 1.0;

  if (column.extruded) {
    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
  } else if (column.stroked) {
    float widthPixels = clamp(
      project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
      column.widthMinPixels, column.widthMaxPixels) / 2.0;
    float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
    if (column.isStroke) {
      strokeOffsetRatio -= sign(positions.z) * halfOffset;
    } else {
      strokeOffsetRatio -= halfOffset;
    }
  }

  // if alpha == 0.0 or z < 0.0, do not render element
  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
  float dotRadius = column.radius * column.coverage * shouldRender;

  geometry.pickingColor = instancePickingColors;

  // project center of column
  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
  vec3 centroidPosition64Low = instancePositions64Low;
  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
  if (column.radiusUnits == UNIT_METERS) {
    offset = project_size(offset);
  }
  vec3 pos = vec3(offset, 0.);
  DECKGL_FILTER_SIZE(pos, geometry);

  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  // Light calculations
  if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
    cameraPosition = project.cameraPosition;
    position_commonspace = geometry.position;
    vColor = vec4(color.rgb, color.a * layer.opacity);
#else
    vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, color.a * layer.opacity);
#endif
  } else {
    vColor = vec4(color.rgb, color.a * layer.opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer-fragment.glsl.ts
  var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader

precision highp float;

out vec4 fragColor;

in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif

void main(void) {
  fragColor = vColor;
  // Fails to compile on some Android devices if geometry is never assigned (#8411)
  geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
  if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
    fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
  }
#endif
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer.ts
  var DEFAULT_COLOR6 = [0, 0, 0, 255];
  var defaultProps9 = {
    diskResolution: { type: "number", min: 4, value: 20 },
    vertices: null,
    radius: { type: "number", min: 0, value: 1e3 },
    angle: { type: "number", value: 0 },
    offset: { type: "array", value: [0, 0] },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    elevationScale: { type: "number", min: 0, value: 1 },
    radiusUnits: "meters",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    extruded: true,
    wireframe: false,
    filled: true,
    stroked: false,
    flatShading: false,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
    getLineWidth: { type: "accessor", value: 1 },
    getElevation: { type: "accessor", value: 1e3 },
    material: true,
    getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
  };
  var ColumnLayer = class extends Layer {
    getShaders() {
      const defines2 = {};
      const { flatShading } = this.props;
      if (flatShading) {
        defines2.FLAT_SHADING = 1;
      }
      return super.getShaders({
        vs: column_layer_vertex_glsl_default,
        fs: column_layer_fragment_glsl_default,
        defines: defines2,
        modules: [project32_default, flatShading ? phongMaterial : gouraudMaterial, picking_default, columnUniforms]
      });
    }
    /**
     * DeckGL calls initializeState when GL context is available
     * Essentially a deferred constructor
     */
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: "getElevation"
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getLineWidth",
          transition: true
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
      if (regenerateModels) {
        this.state.models?.forEach((model) => model.destroy());
        this.setState(this._getModels());
        this.getAttributeManager().invalidateAll();
      }
      const instanceCount = this.getNumInstances();
      this.state.fillModel.setInstanceCount(instanceCount);
      this.state.wireframeModel.setInstanceCount(instanceCount);
      if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
        this._updateGeometry(props);
      }
    }
    getGeometry(diskResolution, vertices, hasThinkness) {
      const geometry = new ColumnGeometry({
        radius: 1,
        height: hasThinkness ? 2 : 0,
        vertices,
        nradial: diskResolution
      });
      let meanVertexDistance = 0;
      if (vertices) {
        for (let i5 = 0; i5 < diskResolution; i5++) {
          const p3 = vertices[i5];
          const d2 = Math.sqrt(p3[0] * p3[0] + p3[1] * p3[1]);
          meanVertexDistance += d2 / diskResolution;
        }
      } else {
        meanVertexDistance = 1;
      }
      this.setState({
        edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
      });
      return geometry;
    }
    _getModels() {
      const shaders = this.getShaders();
      const bufferLayout = this.getAttributeManager().getBufferLayouts();
      const fillModel = new Model(this.context.device, {
        ...shaders,
        id: `${this.props.id}-fill`,
        bufferLayout,
        isInstanced: true
      });
      const wireframeModel = new Model(this.context.device, {
        ...shaders,
        id: `${this.props.id}-wireframe`,
        bufferLayout,
        isInstanced: true
      });
      return {
        fillModel,
        wireframeModel,
        models: [wireframeModel, fillModel]
      };
    }
    _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
      const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
      this.setState({
        fillVertexCount: geometry.attributes.POSITION.value.length / 3
      });
      const fillModel = this.state.fillModel;
      const wireframeModel = this.state.wireframeModel;
      fillModel.setGeometry(geometry);
      fillModel.setTopology("triangle-strip");
      fillModel.setIndexBuffer(null);
      wireframeModel.setGeometry(geometry);
      wireframeModel.setTopology("line-list");
    }
    draw({ uniforms }) {
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        radiusUnits,
        elevationScale,
        extruded,
        filled,
        stroked,
        wireframe,
        offset,
        coverage,
        radius,
        angle: angle9
      } = this.props;
      const fillModel = this.state.fillModel;
      const wireframeModel = this.state.wireframeModel;
      const { fillVertexCount, edgeDistance } = this.state;
      const columnProps = {
        radius,
        angle: angle9 / 180 * Math.PI,
        offset,
        extruded,
        stroked,
        coverage,
        elevationScale,
        edgeDistance,
        radiusUnits: UNIT[radiusUnits],
        widthUnits: UNIT[lineWidthUnits],
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      };
      if (extruded && wireframe) {
        wireframeModel.shaderInputs.setProps({
          column: {
            ...columnProps,
            isStroke: true
          }
        });
        wireframeModel.draw(this.context.renderPass);
      }
      if (filled) {
        fillModel.setVertexCount(fillVertexCount);
        fillModel.shaderInputs.setProps({
          column: {
            ...columnProps,
            isStroke: false
          }
        });
        fillModel.draw(this.context.renderPass);
      }
      if (!extruded && stroked) {
        fillModel.setVertexCount(fillVertexCount * 2 / 3);
        fillModel.shaderInputs.setProps({
          column: {
            ...columnProps,
            isStroke: true
          }
        });
        fillModel.draw(this.context.renderPass);
      }
    }
  };
  ColumnLayer.layerName = "ColumnLayer";
  ColumnLayer.defaultProps = defaultProps9;

  // ../layers/src/column-layer/grid-cell-layer.ts
  var defaultProps10 = {
    cellSize: { type: "number", min: 0, value: 1e3 },
    offset: { type: "array", value: [1, 1] }
  };
  var GridCellLayer = class extends ColumnLayer {
    _updateGeometry() {
      const geometry = new CubeGeometry();
      this.state.fillModel.setGeometry(geometry);
    }
    draw({ uniforms }) {
      const { elevationScale, extruded, offset, coverage, cellSize, angle: angle9, radiusUnits } = this.props;
      const fillModel = this.state.fillModel;
      const columnProps = {
        radius: cellSize / 2,
        radiusUnits: UNIT[radiusUnits],
        angle: angle9,
        offset,
        extruded,
        stroked: false,
        coverage,
        elevationScale,
        edgeDistance: 1,
        isStroke: false,
        widthUnits: 0,
        widthScale: 0,
        widthMinPixels: 0,
        widthMaxPixels: 0
      };
      fillModel.shaderInputs.setProps({ column: columnProps });
      fillModel.draw(this.context.renderPass);
    }
  };
  GridCellLayer.layerName = "GridCellLayer";
  GridCellLayer.defaultProps = defaultProps10;

  // ../layers/src/path-layer/path.ts
  function normalizePath(path, size, gridResolution, wrapLongitude) {
    let flatPath;
    if (Array.isArray(path[0])) {
      const length16 = path.length * size;
      flatPath = new Array(length16);
      for (let i5 = 0; i5 < path.length; i5++) {
        for (let j2 = 0; j2 < size; j2++) {
          flatPath[i5 * size + j2] = path[i5][j2] || 0;
        }
      }
    } else {
      flatPath = path;
    }
    if (gridResolution) {
      return cutPolylineByGrid(flatPath, { size, gridResolution });
    }
    if (wrapLongitude) {
      return cutPolylineByMercatorBounds(flatPath, { size });
    }
    return flatPath;
  }

  // ../layers/src/path-layer/path-tesselator.ts
  var START_CAP = 1;
  var END_CAP = 2;
  var INVALID = 4;
  var PathTesselator = class extends Tesselator {
    constructor(opts) {
      super({
        ...opts,
        attributes: {
          // Padding covers shaderAttributes for last segment in largest case fp64
          // additional vertex + hi & low parts, 3 * 6
          positions: {
            size: 3,
            padding: 18,
            initialize: true,
            type: opts.fp64 ? Float64Array : Float32Array
          },
          segmentTypes: { size: 1, type: Uint8ClampedArray }
        }
      });
    }
    /** Get packed attribute by name */
    get(attributeName) {
      return this.attributes[attributeName];
    }
    /* Implement base Tesselator interface */
    getGeometryFromBuffer(buffer) {
      if (this.normalize) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    /* Implement base Tesselator interface */
    normalizeGeometry(path) {
      if (this.normalize) {
        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
      }
      return path;
    }
    /* Implement base Tesselator interface */
    getGeometrySize(path) {
      if (isCut(path)) {
        let size = 0;
        for (const subPath of path) {
          size += this.getGeometrySize(subPath);
        }
        return size;
      }
      const numPoints = this.getPathLength(path);
      if (numPoints < 2) {
        return 0;
      }
      if (this.isClosed(path)) {
        return numPoints < 3 ? 0 : numPoints + 2;
      }
      return numPoints;
    }
    /* Implement base Tesselator interface */
    updateGeometryAttributes(path, context) {
      if (context.geometrySize === 0) {
        return;
      }
      if (path && isCut(path)) {
        for (const subPath of path) {
          const geometrySize = this.getGeometrySize(subPath);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPath, context);
          context.vertexStart += geometrySize;
        }
      } else {
        this._updateSegmentTypes(path, context);
        this._updatePositions(path, context);
      }
    }
    _updateSegmentTypes(path, context) {
      const segmentTypes = this.attributes.segmentTypes;
      const isPathClosed = path ? this.isClosed(path) : false;
      const { vertexStart, geometrySize } = context;
      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
      if (isPathClosed) {
        segmentTypes[vertexStart] = INVALID;
        segmentTypes[vertexStart + geometrySize - 2] = INVALID;
      } else {
        segmentTypes[vertexStart] += START_CAP;
        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
      }
      segmentTypes[vertexStart + geometrySize - 1] = INVALID;
    }
    _updatePositions(path, context) {
      const { positions } = this.attributes;
      if (!positions || !path) {
        return;
      }
      const { vertexStart, geometrySize } = context;
      const p3 = new Array(3);
      for (let i5 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i5++, ptIndex++) {
        this.getPointOnPath(path, ptIndex, p3);
        positions[i5 * 3] = p3[0];
        positions[i5 * 3 + 1] = p3[1];
        positions[i5 * 3 + 2] = p3[2];
      }
    }
    // Utilities
    /** Returns the number of points in the path */
    getPathLength(path) {
      return path.length / this.positionSize;
    }
    /** Returns a point on the path at the specified index */
    getPointOnPath(path, index, target2 = []) {
      const { positionSize } = this;
      if (index * positionSize >= path.length) {
        index += 1 - path.length / positionSize;
      }
      const i5 = index * positionSize;
      target2[0] = path[i5];
      target2[1] = path[i5 + 1];
      target2[2] = positionSize === 3 && path[i5 + 2] || 0;
      return target2;
    }
    // Returns true if the first and last points are identical
    isClosed(path) {
      if (!this.normalize) {
        return Boolean(this.opts.loop);
      }
      const { positionSize } = this;
      const lastPointIndex = path.length - positionSize;
      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
    }
  };
  function isCut(path) {
    return Array.isArray(path[0]);
  }

  // ../layers/src/path-layer/path-layer-uniforms.ts
  var uniformBlock12 = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
  var pathUniforms = {
    name: "path",
    vs: uniformBlock12,
    fs: uniformBlock12,
    uniformTypes: {
      widthScale: "f32",
      widthMinPixels: "f32",
      widthMaxPixels: "f32",
      jointType: "f32",
      capType: "f32",
      miterLimit: "f32",
      billboard: "f32",
      widthUnits: "i32"
    }
  };

  // ../layers/src/path-layer/path-layer-vertex.glsl.ts
  var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader

in vec2 positions;

in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;

uniform float opacity;

out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;

const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}

// calculate line join positions
vec3 getLineJoinOffset(
  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
  vec2 width
) {
  bool isEnd = positions.x > 0.0;
  // side of the segment - -1: left, 0: center, 1: right
  float sideOfPath = positions.y;
  float isJoint = float(sideOfPath == 0.0);

  vec3 deltaA3 = (currPoint - prevPoint);
  vec3 deltaB3 = (nextPoint - currPoint);

  mat3 rotationMatrix;
  bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
  if (needsRotation) {
    deltaA3 = deltaA3 * rotationMatrix;
    deltaB3 = deltaB3 * rotationMatrix;
  }
  vec2 deltaA = deltaA3.xy / width;
  vec2 deltaB = deltaB3.xy / width;

  float lenA = length(deltaA);
  float lenB = length(deltaB);

  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);

  // tangent of the corner
  vec2 tangent = dirA + dirB;
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  // direction of the corner
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  // direction of the segment
  vec2 dir = isEnd ? dirA : dirB;
  // direction of the extrusion
  vec2 perp = isEnd ? perpA : perpB;
  // length of the segment
  float L = isEnd ? lenA : lenB;

  // A = angle of the corner
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));

  // -1: right, 1: left
  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);

  // relative position to the corner:
  // -1: inside (smaller side of the angle)
  // 0: center
  // 1: outside (bigger side of the angle)
  float cornerPosition = sideOfPath * turnDirection;

  float miterSize = 1.0 / max(sinHalfA, EPSILON);
  // trim if inside corner extends further than the line segment
  miterSize = mix(
    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
    miterSize,
    step(0.0, cornerPosition)
  );

  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
    * (sideOfPath + isJoint * turnDirection);

  // special treatment for start cap and end cap
  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
  bool isCap = isStartCap || isEndCap;

  // extend out a triangle to envelope the round cap
  if (isCap) {
    offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
    vJointType = path.capType;
  } else {
    vJointType = path.jointType;
  }

  // Generate variables for fragment shader
  vPathLength = L;
  vCornerOffset = offsetVec;
  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
  vMiterLength = isCap ? isJoint : vMiterLength;

  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
  vPathPosition = vec2(
    dot(offsetFromStartOfPath, perp),
    dot(offsetFromStartOfPath, dir)
  );
  geometry.uv = vPathPosition;

  float isValid = step(instanceTypes, 3.5);
  vec3 offset = vec3(offsetVec * width * isValid, 0.0);

  if (needsRotation) {
    offset = rotationMatrix * offset;
  }
  return offset;
}

// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts
void clipLine(inout vec4 position, vec4 refPosition) {
  if (position.w < EPSILON) {
    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
    position = refPosition + (position - refPosition) * r;
  }
}

void main() {
  geometry.pickingColor = instancePickingColors;

  vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);

  float isEnd = positions.x;

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);

  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);

  geometry.worldPosition = currPosition;
  vec2 widthPixels = vec2(clamp(
    project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
    path.widthMinPixels, path.widthMaxPixels) / 2.0);
  vec3 width;

  if (path.billboard) {
    // Extrude in clipspace
    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);

    clipLine(prevPositionScreen, currPositionScreen);
    clipLine(nextPositionScreen, currPositionScreen);
    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));

    width = vec3(widthPixels, 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(
      prevPositionScreen.xyz / prevPositionScreen.w,
      currPositionScreen.xyz / currPositionScreen.w,
      nextPositionScreen.xyz / nextPositionScreen.w,
      project_pixel_size_to_clipspace(width.xy)
    );

    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
  } else {
    // Extrude in commonspace
    prevPosition = project_position(prevPosition, prevPosition64Low);
    currPosition = project_position(currPosition, currPosition64Low);
    nextPosition = project_position(nextPosition, nextPosition64Low);

    width = vec3(project_pixel_size(widthPixels), 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
    geometry.position = vec4(currPosition + offset, 1.0);
    gl_Position = project_common_position_to_clipspace(geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer-fragment.glsl.ts
  var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
/*
 * vPathPosition represents the relative coordinates of the current fragment on the path segment.
 * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.
 * vPathPosition.y - position along the length of the path, between [0, L / width].
 */
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;

out vec4 fragColor;

void main(void) {
  geometry.uv = vPathPosition;

  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
    // if joint is rounded, test distance from the corner
    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
      discard;
    }
    // trim miter
    if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
      discard;
    }
  }
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer.ts
  var DEFAULT_COLOR7 = [0, 0, 0, 255];
  var defaultProps11 = {
    widthUnits: "meters",
    widthScale: { type: "number", min: 0, value: 1 },
    widthMinPixels: { type: "number", min: 0, value: 0 },
    widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    jointRounded: false,
    capRounded: false,
    miterLimit: { type: "number", min: 0, value: 4 },
    billboard: false,
    _pathType: null,
    getPath: { type: "accessor", value: (object) => object.path },
    getColor: { type: "accessor", value: DEFAULT_COLOR7 },
    getWidth: { type: "accessor", value: 1 },
    // deprecated props
    rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
  };
  var ATTRIBUTE_TRANSITION = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var PathLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default, pathUniforms] });
    }
    get wrapLongitude() {
      return false;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["vertexPositions"]);
    }
    initializeState() {
      const noAlloc = true;
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        vertexPositions: {
          size: 3,
          // Start filling buffer from 1 vertex in
          vertexOffset: 1,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION,
          accessor: "getPath",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            instanceLeftPositions: {
              vertexOffset: 0
            },
            instanceStartPositions: {
              vertexOffset: 1
            },
            instanceEndPositions: {
              vertexOffset: 2
            },
            instanceRightPositions: {
              vertexOffset: 3
            }
          }
        },
        instanceTypes: {
          size: 1,
          type: "uint8",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateSegmentTypes,
          noAlloc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getWidth",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: 1
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          accessor: "getColor",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: DEFAULT_COLOR7
        },
        instancePickingColors: {
          size: 4,
          type: "uint8",
          accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
        }
      });
      this.setState({
        pathTesselator: new PathTesselator({
          fp64: this.use64bitPositions()
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, changeFlags } = params;
      const attributeManager = this.getAttributeManager();
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
      if (geometryChanged) {
        const { pathTesselator } = this.state;
        const buffers = props.data.attributes || {};
        pathTesselator.updateGeometry({
          data: props.data,
          geometryBuffer: buffers.getPath,
          buffers,
          normalize: !props._pathType,
          loop: props._pathType === "loop",
          getGeometry: props.getPath,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          // TODO - move the flag out of the viewport
          resolution: this.context.viewport.resolution,
          dataChanged: changeFlags.dataChanged
        });
        this.setState({
          numInstances: pathTesselator.instanceCount,
          startIndices: pathTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          attributeManager.invalidateAll();
        }
      }
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index } = info;
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        info.object = data.find((d2) => d2.__source.index === index);
      }
      return info;
    }
    /** Override base Layer method */
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        for (let i5 = 0; i5 < data.length; i5++) {
          if (data[i5].__source.index === objectIndex) {
            this._disablePickingIndex(i5);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({ uniforms }) {
      const {
        jointRounded,
        capRounded,
        billboard,
        miterLimit,
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels
      } = this.props;
      const model = this.state.model;
      const pathProps = {
        jointType: Number(jointRounded),
        capType: Number(capRounded),
        billboard,
        widthUnits: UNIT[widthUnits],
        widthScale,
        miterLimit,
        widthMinPixels,
        widthMaxPixels
      };
      model.shaderInputs.setProps({ path: pathProps });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const SEGMENT_INDICES = [
        // start corner
        0,
        1,
        2,
        // body
        1,
        4,
        2,
        1,
        3,
        4,
        // end corner
        3,
        5,
        4
      ];
      const SEGMENT_POSITIONS = [
        // bevel start corner
        0,
        0,
        // start inner corner
        0,
        -1,
        // start outer corner
        0,
        1,
        // end inner corner
        1,
        -1,
        // end outer corner
        1,
        1,
        // bevel end corner
        1,
        0
      ];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-list",
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
          }
        }),
        isInstanced: true
      });
    }
    calculatePositions(attribute) {
      const { pathTesselator } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("positions");
    }
    calculateSegmentTypes(attribute) {
      const { pathTesselator } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("segmentTypes");
    }
  };
  PathLayer.defaultProps = defaultProps11;
  PathLayer.layerName = "PathLayer";

  // ../layers/src/solid-polygon-layer/polygon.ts
  var import_earcut2 = __toESM(require_earcut(), 1);
  var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
  var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
  var windingOptions = {
    isClosed: true
  };
  function validate(polygon) {
    polygon = polygon && polygon.positions || polygon;
    if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
      throw new Error("invalid polygon");
    }
  }
  function getPositions(polygon) {
    return "positions" in polygon ? polygon.positions : polygon;
  }
  function getHoleIndices(polygon) {
    return "holeIndices" in polygon ? polygon.holeIndices : null;
  }
  function isNested(polygon) {
    return Array.isArray(polygon[0]);
  }
  function isSimple(polygon) {
    return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
  }
  function isNestedRingClosed(simplePolygon) {
    const p0 = simplePolygon[0];
    const p1 = simplePolygon[simplePolygon.length - 1];
    return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
  }
  function isFlatRingClosed(positions, size, startIndex, endIndex) {
    for (let i5 = 0; i5 < size; i5++) {
      if (positions[startIndex + i5] !== positions[endIndex - size + i5]) {
        return false;
      }
    }
    return true;
  }
  function copyNestedRing(target2, targetStartIndex, simplePolygon, size, windingDirection) {
    let targetIndex = targetStartIndex;
    const len8 = simplePolygon.length;
    for (let i5 = 0; i5 < len8; i5++) {
      for (let j2 = 0; j2 < size; j2++) {
        target2[targetIndex++] = simplePolygon[i5][j2] || 0;
      }
    }
    if (!isNestedRingClosed(simplePolygon)) {
      for (let j2 = 0; j2 < size; j2++) {
        target2[targetIndex++] = simplePolygon[0][j2] || 0;
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target2, windingDirection, windingOptions);
    return targetIndex;
  }
  function copyFlatRing(target2, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
    srcEndIndex = srcEndIndex || positions.length;
    const srcLength = srcEndIndex - srcStartIndex;
    if (srcLength <= 0) {
      return targetStartIndex;
    }
    let targetIndex = targetStartIndex;
    for (let i5 = 0; i5 < srcLength; i5++) {
      target2[targetIndex++] = positions[srcStartIndex + i5];
    }
    if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
      for (let i5 = 0; i5 < size; i5++) {
        target2[targetIndex++] = positions[srcStartIndex + i5];
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target2, windingDirection, windingOptions);
    return targetIndex;
  }
  function normalize5(polygon, positionSize) {
    validate(polygon);
    const positions = [];
    const holeIndices = [];
    if ("positions" in polygon) {
      const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
      if (srcHoleIndices) {
        let targetIndex = 0;
        for (let i5 = 0; i5 <= srcHoleIndices.length; i5++) {
          targetIndex = copyFlatRing(
            positions,
            targetIndex,
            srcPositions,
            positionSize,
            srcHoleIndices[i5 - 1],
            srcHoleIndices[i5],
            i5 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING
          );
          holeIndices.push(targetIndex);
        }
        holeIndices.pop();
        return { positions, holeIndices };
      }
      polygon = srcPositions;
    }
    if (!isNested(polygon)) {
      copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
      return positions;
    }
    if (!isSimple(polygon)) {
      let targetIndex = 0;
      for (const [polygonIndex, simplePolygon] of polygon.entries()) {
        targetIndex = copyNestedRing(
          positions,
          targetIndex,
          simplePolygon,
          positionSize,
          polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING
        );
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
    return positions;
  }
  function getPlaneArea(positions, xIndex, yIndex) {
    const numVerts = positions.length / 3;
    let area2 = 0;
    for (let i5 = 0; i5 < numVerts; i5++) {
      const j2 = (i5 + 1) % numVerts;
      area2 += positions[i5 * 3 + xIndex] * positions[j2 * 3 + yIndex];
      area2 -= positions[j2 * 3 + xIndex] * positions[i5 * 3 + yIndex];
    }
    return Math.abs(area2 / 2);
  }
  function permutePositions(positions, xIndex, yIndex, zIndex) {
    const numVerts = positions.length / 3;
    for (let i5 = 0; i5 < numVerts; i5++) {
      const o3 = i5 * 3;
      const x3 = positions[o3 + 0];
      const y3 = positions[o3 + 1];
      const z2 = positions[o3 + 2];
      positions[o3 + xIndex] = x3;
      positions[o3 + yIndex] = y3;
      positions[o3 + zIndex] = z2;
    }
  }
  function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
    let holeIndices = getHoleIndices(polygon);
    if (holeIndices) {
      holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
    }
    let positions = getPositions(polygon);
    const is3d = full3d && positionSize === 3;
    if (preproject) {
      const n3 = positions.length;
      positions = positions.slice();
      const p3 = [];
      for (let i5 = 0; i5 < n3; i5 += positionSize) {
        p3[0] = positions[i5];
        p3[1] = positions[i5 + 1];
        if (is3d) {
          p3[2] = positions[i5 + 2];
        }
        const xy = preproject(p3);
        positions[i5] = xy[0];
        positions[i5 + 1] = xy[1];
        if (is3d) {
          positions[i5 + 2] = xy[2];
        }
      }
    }
    if (is3d) {
      const xyArea = getPlaneArea(positions, 0, 1);
      const xzArea = getPlaneArea(positions, 0, 2);
      const yzArea = getPlaneArea(positions, 1, 2);
      if (!xyArea && !xzArea && !yzArea) {
        return [];
      }
      if (xyArea > xzArea && xyArea > yzArea) {
      } else if (xzArea > yzArea) {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 0, 2, 1);
      } else {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 2, 0, 1);
      }
    }
    return (0, import_earcut2.default)(positions, holeIndices, positionSize);
  }

  // ../layers/src/solid-polygon-layer/polygon-tesselator.ts
  var PolygonTesselator = class extends Tesselator {
    constructor(opts) {
      const { fp64: fp642, IndexType = Uint32Array } = opts;
      super({
        ...opts,
        attributes: {
          positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
          vertexValid: { type: Uint16Array, size: 1 },
          indices: { type: IndexType, size: 1 }
        }
      });
    }
    /** Get attribute by name */
    get(attributeName) {
      const { attributes } = this;
      if (attributeName === "indices") {
        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
      }
      return attributes[attributeName];
    }
    /** Override base Tesselator method */
    updateGeometry(opts) {
      super.updateGeometry(opts);
      const externalIndices = this.buffers.indices;
      if (externalIndices) {
        this.vertexCount = (externalIndices.value || externalIndices).length;
      } else if (this.data && !this.getGeometry) {
        throw new Error("missing indices buffer");
      }
    }
    /** Implement base Tesselator interface */
    normalizeGeometry(polygon) {
      if (this.normalize) {
        const normalizedPolygon = normalize5(polygon, this.positionSize);
        if (this.opts.resolution) {
          return cutPolygonByGrid(
            getPositions(normalizedPolygon),
            getHoleIndices(normalizedPolygon),
            {
              size: this.positionSize,
              gridResolution: this.opts.resolution,
              edgeTypes: true
            }
          );
        }
        if (this.opts.wrapLongitude) {
          return cutPolygonByMercatorBounds(
            getPositions(normalizedPolygon),
            getHoleIndices(normalizedPolygon),
            {
              size: this.positionSize,
              maxLatitude: 86,
              edgeTypes: true
            }
          );
        }
        return normalizedPolygon;
      }
      return polygon;
    }
    /** Implement base Tesselator interface */
    getGeometrySize(polygon) {
      if (isCut2(polygon)) {
        let size = 0;
        for (const subPolygon of polygon) {
          size += this.getGeometrySize(subPolygon);
        }
        return size;
      }
      return getPositions(polygon).length / this.positionSize;
    }
    /** Override base Tesselator method */
    getGeometryFromBuffer(buffer) {
      if (this.normalize || !this.buffers.indices) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    /** Implement base Tesselator interface */
    updateGeometryAttributes(polygon, context) {
      if (polygon && isCut2(polygon)) {
        for (const subPolygon of polygon) {
          const geometrySize = this.getGeometrySize(subPolygon);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPolygon, context);
          context.vertexStart += geometrySize;
          context.indexStart = this.indexStarts[context.geometryIndex + 1];
        }
      } else {
        const normalizedPolygon = polygon;
        this._updateIndices(normalizedPolygon, context);
        this._updatePositions(normalizedPolygon, context);
        this._updateVertexValid(normalizedPolygon, context);
      }
    }
    // Flatten the indices array
    _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
      const { attributes, indexStarts, typedArrayManager } = this;
      let target2 = attributes.indices;
      if (!target2 || !polygon) {
        return;
      }
      let i5 = indexStart;
      const indices = getSurfaceIndices(
        polygon,
        this.positionSize,
        this.opts.preproject,
        this.opts.full3d
      );
      target2 = typedArrayManager.allocate(target2, indexStart + indices.length, {
        copy: true
      });
      for (let j2 = 0; j2 < indices.length; j2++) {
        target2[i5++] = indices[j2] + offset;
      }
      indexStarts[geometryIndex + 1] = indexStart + indices.length;
      attributes.indices = target2;
    }
    // Flatten out all the vertices of all the sub subPolygons
    _updatePositions(polygon, { vertexStart, geometrySize }) {
      const {
        attributes: { positions },
        positionSize
      } = this;
      if (!positions || !polygon) {
        return;
      }
      const polygonPositions = getPositions(polygon);
      for (let i5 = vertexStart, j2 = 0; j2 < geometrySize; i5++, j2++) {
        const x3 = polygonPositions[j2 * positionSize];
        const y3 = polygonPositions[j2 * positionSize + 1];
        const z2 = positionSize > 2 ? polygonPositions[j2 * positionSize + 2] : 0;
        positions[i5 * 3] = x3;
        positions[i5 * 3 + 1] = y3;
        positions[i5 * 3 + 2] = z2;
      }
    }
    _updateVertexValid(polygon, { vertexStart, geometrySize }) {
      const { positionSize } = this;
      const vertexValid = this.attributes.vertexValid;
      const holeIndices = polygon && getHoleIndices(polygon);
      if (polygon && polygon.edgeTypes) {
        vertexValid.set(polygon.edgeTypes, vertexStart);
      } else {
        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
      }
      if (holeIndices) {
        for (let j2 = 0; j2 < holeIndices.length; j2++) {
          vertexValid[vertexStart + holeIndices[j2] / positionSize - 1] = 0;
        }
      }
      vertexValid[vertexStart + geometrySize - 1] = 0;
    }
  };
  function isCut2(polygon) {
    return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
  }

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-uniforms.ts
  var uniformBlock13 = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
  var solidPolygonUniforms = {
    name: "solidPolygon",
    vs: uniformBlock13,
    fs: uniformBlock13,
    uniformTypes: {
      extruded: "f32",
      isWireframe: "f32",
      elevationScale: "f32"
    }
  };

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.ts
  var solid_polygon_layer_vertex_main_glsl_default = `
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;

out vec4 vColor;

struct PolygonProps {
  vec3 positions;
  vec3 positions64Low;
  vec3 normal;
  float elevations;
};

vec3 project_offset_normal(vec3 vector) {
  if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
    // normals generated by the polygon tesselator are in lnglat offsets instead of meters
    return normalize(vector * project.commonUnitsPerWorldUnit);
  }
  return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
  vec3 pos = props.positions;
  vec3 pos64Low = props.positions64Low;
  vec3 normal = props.normal;
  vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;

  geometry.worldPosition = props.positions;
  geometry.pickingColor = pickingColors;

  if (solidPolygon.extruded) {
    pos.z += props.elevations * solidPolygon.elevationScale;
  }
  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  if (solidPolygon.extruded) {
  #ifdef IS_SIDE_VERTEX
    normal = project_offset_normal(normal);
  #else
    normal = project_normal(normal);
  #endif
    geometry.normal = normal;
    vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, colors.a * layer.opacity);
  } else {
    vColor = vec4(colors.rgb, colors.a * layer.opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.ts
  var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader

in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  PolygonProps props;

  props.positions = vertexPositions;
  props.positions64Low = vertexPositions64Low;
  props.elevations = elevations;
  props.normal = vec3(0.0, 0.0, 1.0);

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.ts
  var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX

in vec2 positions;

in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  if(instanceVertexValid < 0.5){
    gl_Position = vec4(0.);
    return;
  }

  PolygonProps props;

  vec3 pos;
  vec3 pos64Low;
  vec3 nextPos;
  vec3 nextPos64Low;

  #if RING_WINDING_ORDER_CW == 1
    pos = vertexPositions;
    pos64Low = vertexPositions64Low;
    nextPos = nextVertexPositions;
    nextPos64Low = nextVertexPositions64Low;
  #else
    pos = nextVertexPositions;
    pos64Low = nextVertexPositions64Low;
    nextPos = vertexPositions;
    nextPos64Low = vertexPositions64Low;
  #endif

  props.positions = mix(pos, nextPos, positions.x);
  props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);

  props.normal = vec3(
    pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
    nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
    0.0);

  props.elevations = elevations * positions.y;

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.ts
  var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;
  // Fails to compile on some Android devices if geometry is never assigned (#8411)
  geometry.uv = vec2(0.);

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer.ts
  var DEFAULT_COLOR8 = [0, 0, 0, 255];
  var defaultProps12 = {
    filled: true,
    extruded: false,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    _full3d: false,
    elevationScale: { type: "number", min: 0, value: 1 },
    getPolygon: { type: "accessor", value: (f4) => f4.polygon },
    getElevation: { type: "accessor", value: 1e3 },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
    material: true
  };
  var ATTRIBUTE_TRANSITION2 = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var SolidPolygonLayer = class extends Layer {
    getShaders(type) {
      return super.getShaders({
        vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
        fs: solid_polygon_layer_fragment_glsl_default,
        defines: {
          RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
        },
        modules: [project32_default, gouraudMaterial, picking_default, solidPolygonUniforms]
      });
    }
    get wrapLongitude() {
      return false;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["vertexPositions"]);
    }
    initializeState() {
      const { viewport } = this.context;
      let { coordinateSystem } = this.props;
      const { _full3d } = this.props;
      if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
      }
      let preproject;
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        if (_full3d) {
          preproject = viewport.projectPosition.bind(viewport);
        } else {
          preproject = viewport.projectFlat.bind(viewport);
        }
      }
      this.setState({
        numInstances: 0,
        polygonTesselator: new PolygonTesselator({
          // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
          // Provide a preproject function if the coordinates are in lnglat
          preproject,
          fp64: this.use64bitPositions(),
          IndexType: Uint32Array
        })
      });
      const attributeManager = this.getAttributeManager();
      const noAlloc = true;
      attributeManager.remove(["instancePickingColors"]);
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateIndices,
          noAlloc
        },
        vertexPositions: {
          size: 3,
          type: "float64",
          stepMode: "dynamic",
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getPolygon",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            nextVertexPositions: {
              vertexOffset: 1
            }
          }
        },
        instanceVertexValid: {
          size: 1,
          type: "uint16",
          stepMode: "instance",
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateVertexValid,
          noAlloc
        },
        elevations: {
          size: 1,
          stepMode: "dynamic",
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getElevation"
        },
        fillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          stepMode: "dynamic",
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR8
        },
        lineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          stepMode: "dynamic",
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR8
        },
        pickingColors: {
          size: 4,
          type: "uint8",
          stepMode: "dynamic",
          accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
        }
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index } = info;
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        info.object = data.find((d2) => d2.__source.index === index);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        for (let i5 = 0; i5 < data.length; i5++) {
          if (data[i5].__source.index === objectIndex) {
            this._disablePickingIndex(i5);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({ uniforms }) {
      const { extruded, filled, wireframe, elevationScale } = this.props;
      const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
      const renderUniforms = {
        extruded: Boolean(extruded),
        elevationScale,
        isWireframe: false
      };
      if (wireframeModel && wireframe) {
        wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        wireframeModel.shaderInputs.setProps({ solidPolygon: { ...renderUniforms, isWireframe: true } });
        wireframeModel.draw(this.context.renderPass);
      }
      if (sideModel && filled) {
        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
        sideModel.draw(this.context.renderPass);
      }
      if (topModel && filled) {
        topModel.setVertexCount(polygonTesselator.vertexCount);
        topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
        topModel.draw(this.context.renderPass);
      }
    }
    updateState(updateParams) {
      super.updateState(updateParams);
      this.updateGeometry(updateParams);
      const { props, oldProps, changeFlags } = updateParams;
      const attributeManager = this.getAttributeManager();
      const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
      if (regenerateModels) {
        this.state.models?.forEach((model) => model.destroy());
        this.setState(this._getModels());
        attributeManager.invalidateAll();
      }
    }
    updateGeometry({ props, oldProps, changeFlags }) {
      const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryConfigChanged) {
        const { polygonTesselator } = this.state;
        const buffers = props.data.attributes || {};
        polygonTesselator.updateGeometry({
          data: props.data,
          normalize: props._normalize,
          geometryBuffer: buffers.getPolygon,
          buffers,
          getGeometry: props.getPolygon,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          // TODO - move the flag out of the viewport
          resolution: this.context.viewport.resolution,
          fp64: this.use64bitPositions(),
          dataChanged: changeFlags.dataChanged,
          full3d: props._full3d
        });
        this.setState({
          numInstances: polygonTesselator.instanceCount,
          startIndices: polygonTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          this.getAttributeManager().invalidateAll();
        }
      }
    }
    _getModels() {
      const { id, filled, extruded } = this.props;
      let topModel;
      let sideModel;
      let wireframeModel;
      if (filled) {
        const shaders = this.getShaders("top");
        shaders.defines.NON_INSTANCED_MODEL = 1;
        const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
        topModel = new Model(this.context.device, {
          ...shaders,
          id: `${id}-top`,
          topology: "triangle-list",
          bufferLayout,
          isIndexed: true,
          userData: {
            excludeAttributes: { instanceVertexValid: true }
          }
        });
      }
      if (extruded) {
        const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
        sideModel = new Model(this.context.device, {
          ...this.getShaders("side"),
          id: `${id}-side`,
          bufferLayout,
          geometry: new Geometry({
            topology: "triangle-strip",
            attributes: {
              // top right - top left - bottom right - bottom left
              positions: {
                size: 2,
                value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
              }
            }
          }),
          isInstanced: true,
          userData: {
            excludeAttributes: { indices: true }
          }
        });
        wireframeModel = new Model(this.context.device, {
          ...this.getShaders("side"),
          id: `${id}-wireframe`,
          bufferLayout,
          geometry: new Geometry({
            topology: "line-strip",
            attributes: {
              // top right - top left - bottom left - bottom right
              positions: {
                size: 2,
                value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
              }
            }
          }),
          isInstanced: true,
          userData: {
            excludeAttributes: { indices: true }
          }
        });
      }
      return {
        models: [sideModel, wireframeModel, topModel].filter(Boolean),
        topModel,
        sideModel,
        wireframeModel
      };
    }
    calculateIndices(attribute) {
      const { polygonTesselator } = this.state;
      attribute.startIndices = polygonTesselator.indexStarts;
      attribute.value = polygonTesselator.get("indices");
    }
    calculatePositions(attribute) {
      const { polygonTesselator } = this.state;
      attribute.startIndices = polygonTesselator.vertexStarts;
      attribute.value = polygonTesselator.get("positions");
    }
    calculateVertexValid(attribute) {
      attribute.value = this.state.polygonTesselator.get("vertexValid");
    }
  };
  SolidPolygonLayer.defaultProps = defaultProps12;
  SolidPolygonLayer.layerName = "SolidPolygonLayer";

  // ../layers/src/utils.ts
  function replaceInRange({
    data,
    getIndex,
    dataRange,
    replace
  }) {
    const { startRow = 0, endRow = Infinity } = dataRange;
    const count3 = data.length;
    let replaceStart = count3;
    let replaceEnd = count3;
    for (let i5 = 0; i5 < count3; i5++) {
      const row = getIndex(data[i5]);
      if (replaceStart > i5 && row >= startRow) {
        replaceStart = i5;
      }
      if (row >= endRow) {
        replaceEnd = i5;
        break;
      }
    }
    let index = replaceStart;
    const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
    const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
    for (let i5 = 0; i5 < replace.length; i5++) {
      data[index++] = replace[i5];
    }
    if (endChunk) {
      for (let i5 = 0; i5 < endChunk.length; i5++) {
        data[index++] = endChunk[i5];
      }
      data.length = index;
    }
    return {
      startRow: replaceStart,
      endRow: replaceStart + replace.length
    };
  }

  // ../layers/src/polygon-layer/polygon-layer.ts
  var defaultLineColor = [0, 0, 0, 255];
  var defaultFillColor = [0, 0, 0, 255];
  var defaultProps13 = {
    stroked: true,
    filled: true,
    extruded: false,
    elevationScale: 1,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    lineJointRounded: false,
    lineMiterLimit: 4,
    getPolygon: { type: "accessor", value: (f4) => f4.polygon },
    // Polygon fill color
    getFillColor: { type: "accessor", value: defaultFillColor },
    // Point, line and polygon outline color
    getLineColor: { type: "accessor", value: defaultLineColor },
    // Line and polygon outline accessors
    getLineWidth: { type: "accessor", value: 1 },
    // Polygon extrusion accessor
    getElevation: { type: "accessor", value: 1e3 },
    // Optional material for 'lighting' shader module
    material: true
  };
  var PolygonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        paths: [],
        pathsDiff: null
      };
      if (this.props.getLineDashArray) {
        log_default.removed("getLineDashArray", "PathStyleExtension")();
      }
    }
    updateState({ changeFlags }) {
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
        const paths = this.state.paths.slice();
        const pathsDiff = changeFlags.dataChanged.map(
          (dataRange) => replaceInRange({
            data: paths,
            getIndex: (p3) => p3.__source.index,
            dataRange,
            replace: this._getPaths(dataRange)
          })
        );
        this.setState({ paths, pathsDiff });
      } else if (geometryChanged) {
        this.setState({
          paths: this._getPaths(),
          pathsDiff: null
        });
      }
    }
    _getPaths(dataRange = {}) {
      const { data, getPolygon, positionFormat, _normalize } = this.props;
      const paths = [];
      const positionSize = positionFormat === "XY" ? 2 : 3;
      const { startRow, endRow } = dataRange;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let polygon = getPolygon(object, objectInfo);
        if (_normalize) {
          polygon = normalize5(polygon, positionSize);
        }
        const { holeIndices } = polygon;
        const positions = polygon.positions || polygon;
        if (holeIndices) {
          for (let i5 = 0; i5 <= holeIndices.length; i5++) {
            const path = positions.slice(holeIndices[i5 - 1] || 0, holeIndices[i5] || positions.length);
            paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
          }
        } else {
          paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
        }
      }
      return paths;
    }
    /* eslint-disable complexity */
    renderLayers() {
      const {
        data,
        _dataDiff,
        stroked,
        filled,
        extruded,
        wireframe,
        _normalize,
        _windingOrder,
        elevationScale,
        transitions,
        positionFormat
      } = this.props;
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified
      } = this.props;
      const {
        getFillColor,
        getLineColor,
        getLineWidth,
        getLineDashArray,
        getElevation,
        getPolygon,
        updateTriggers,
        material
      } = this.props;
      const { paths, pathsDiff } = this.state;
      const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
      const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
      const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer(
        {
          _dataDiff,
          extruded,
          elevationScale,
          filled,
          wireframe,
          _normalize,
          _windingOrder,
          getElevation,
          getFillColor,
          getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
          material,
          transitions
        },
        this.getSubLayerProps({
          id: "fill",
          updateTriggers: updateTriggers && {
            getPolygon: updateTriggers.getPolygon,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            // using a legacy API to invalid lineColor attributes
            // if (extruded && wireframe) has changed
            lineColors: extruded && wireframe,
            getLineColor: updateTriggers.getLineColor
          }
        }),
        {
          data,
          positionFormat,
          getPolygon
        }
      );
      const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer(
        {
          _dataDiff: pathsDiff && (() => pathsDiff),
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          jointRounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,
          // Already normalized
          _pathType: "loop",
          transitions: transitions && {
            getWidth: transitions.getLineWidth,
            getColor: transitions.getLineColor,
            getPath: transitions.getPolygon
          },
          getColor: this.getSubLayerAccessor(getLineColor),
          getWidth: this.getSubLayerAccessor(getLineWidth),
          getDashArray: this.getSubLayerAccessor(getLineDashArray)
        },
        this.getSubLayerProps({
          id: "stroke",
          updateTriggers: updateTriggers && {
            getWidth: updateTriggers.getLineWidth,
            getColor: updateTriggers.getLineColor,
            getDashArray: updateTriggers.getLineDashArray
          }
        }),
        {
          data: paths,
          positionFormat,
          getPath: (x3) => x3.path
        }
      );
      return [
        // If not extruded: flat fill layer is drawn below outlines
        !extruded && polygonLayer,
        polygonLineLayer,
        // If extruded: draw fill layer last for correct blending behavior
        extruded && polygonLayer
      ];
    }
    /* eslint-enable complexity */
  };
  PolygonLayer.layerName = "PolygonLayer";
  PolygonLayer.defaultProps = defaultProps13;

  // ../layers/src/geojson-layer/geojson-binary.ts
  function binaryToFeatureForAccesor(data, index) {
    if (!data) {
      return null;
    }
    const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
    const geometryIndex = data.featureIds.value[featureIndex];
    if (featureIndex !== -1) {
      return getPropertiesForIndex(data, geometryIndex, featureIndex);
    }
    return null;
  }
  function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
    const feature = {
      properties: { ...data.properties[propertiesIndex] }
    };
    for (const prop in data.numericProps) {
      feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
    }
    return feature;
  }
  function calculatePickingColors(geojsonBinary, encodePickingColor) {
    const pickingColors = {
      points: null,
      lines: null,
      polygons: null
    };
    for (const key in pickingColors) {
      const featureIds = geojsonBinary[key].globalFeatureIds.value;
      pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
      const pickingColor = [];
      for (let i5 = 0; i5 < featureIds.length; i5++) {
        encodePickingColor(featureIds[i5], pickingColor);
        pickingColors[key][i5 * 4 + 0] = pickingColor[0];
        pickingColors[key][i5 * 4 + 1] = pickingColor[1];
        pickingColors[key][i5 * 4 + 2] = pickingColor[2];
        pickingColors[key][i5 * 4 + 3] = 255;
      }
    }
    return pickingColors;
  }

  // ../layers/src/text-layer/multi-icon-layer/sdf-uniforms.ts
  var uniformBlock14 = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
  var sdfUniforms = {
    name: "sdf",
    vs: uniformBlock14,
    fs: uniformBlock14,
    uniformTypes: {
      gamma: "f32",
      enabled: "f32",
      buffer: "f32",
      outlineBuffer: "f32",
      outlineColor: "vec4<f32>"
    }
  };

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.ts
  var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader

precision highp float;

uniform sampler2D iconsTexture;

in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  if (!bool(picking.isActive)) {
    float alpha = texture(iconsTexture, vTextureCoords).a;
    vec4 color = vColor;

    // if enable sdf (signed distance fields)
    if (sdf.enabled) {
      float distance = alpha;
      alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);

      if (sdf.outlineBuffer > 0.0) {
        float inFill = alpha;
        float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
        color = mix(sdf.outlineColor, vColor, inFill);
        alpha = inBorder;
      }
    }

    // Take the global opacity and the alpha from color into account for the alpha component
    float a = alpha * color.a;
    
    if (a < icon.alphaCutoff) {
      discard;
    }

    fragColor = vec4(color.rgb, a * layer.opacity);
  }

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer.ts
  var DEFAULT_BUFFER2 = 192 / 256;
  var EMPTY_ARRAY3 = [];
  var defaultProps14 = {
    getIconOffsets: { type: "accessor", value: (x3) => x3.offsets },
    alphaCutoff: 1e-3,
    smoothing: 0.1,
    outlineWidth: 0,
    outlineColor: { type: "color", value: [0, 0, 0, 255] }
  };
  var MultiIconLayer = class extends IconLayer {
    getShaders() {
      const shaders = super.getShaders();
      return { ...shaders, modules: [...shaders.modules, sdfUniforms], fs: multi_icon_layer_fragment_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceOffsets: {
          size: 2,
          accessor: "getIconOffsets"
        },
        instancePickingColors: {
          type: "uint8",
          size: 3,
          accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      let { outlineColor } = props;
      if (outlineColor !== oldProps.outlineColor) {
        outlineColor = outlineColor.map((x3) => x3 / 255);
        outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
        this.setState({
          outlineColor
        });
      }
      if (!props.sdf && props.outlineWidth) {
        log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
      }
    }
    draw(params) {
      const { sdf, smoothing, outlineWidth } = this.props;
      const { outlineColor } = this.state;
      const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
      const model = this.state.model;
      const sdfProps = {
        buffer: DEFAULT_BUFFER2,
        outlineBuffer,
        gamma: smoothing,
        enabled: Boolean(sdf),
        outlineColor
      };
      model.shaderInputs.setProps({ sdf: sdfProps });
      super.draw(params);
      if (sdf && outlineWidth) {
        const { iconManager } = this.state;
        const iconsTexture = iconManager.getTexture();
        if (iconsTexture) {
          model.shaderInputs.setProps({ sdf: { ...sdfProps, outlineBuffer: DEFAULT_BUFFER2 } });
          model.draw(this.context.renderPass);
        }
      }
    }
    getInstanceOffset(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY3;
    }
    getInstanceColorMode(icons) {
      return 1;
    }
    getInstanceIconFrame(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY3;
    }
  };
  MultiIconLayer.defaultProps = defaultProps14;
  MultiIconLayer.layerName = "MultiIconLayer";

  // ../../node_modules/@mapbox/tiny-sdf/index.js
  var INF = 1e20;
  var TinySDF = class {
    constructor({
      fontSize = 24,
      buffer = 3,
      radius = 8,
      cutoff = 0.25,
      fontFamily = "sans-serif",
      fontWeight = "normal",
      fontStyle = "normal"
    } = {}) {
      this.buffer = buffer;
      this.cutoff = cutoff;
      this.radius = radius;
      const size = this.size = fontSize + buffer * 4;
      const canvas2 = this._createCanvas(size);
      const ctx2 = this.ctx = canvas2.getContext("2d", { willReadFrequently: true });
      ctx2.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
      ctx2.textBaseline = "alphabetic";
      ctx2.textAlign = "left";
      ctx2.fillStyle = "black";
      this.gridOuter = new Float64Array(size * size);
      this.gridInner = new Float64Array(size * size);
      this.f = new Float64Array(size);
      this.z = new Float64Array(size + 1);
      this.v = new Uint16Array(size);
    }
    _createCanvas(size) {
      const canvas2 = document.createElement("canvas");
      canvas2.width = canvas2.height = size;
      return canvas2;
    }
    draw(char) {
      const {
        width: glyphAdvance,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,
        actualBoundingBoxLeft,
        actualBoundingBoxRight
      } = this.ctx.measureText(char);
      const glyphTop = Math.ceil(actualBoundingBoxAscent);
      const glyphLeft = 0;
      const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
      const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
      const width = glyphWidth + 2 * this.buffer;
      const height = glyphHeight + 2 * this.buffer;
      const len8 = Math.max(width * height, 0);
      const data = new Uint8ClampedArray(len8);
      const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
      if (glyphWidth === 0 || glyphHeight === 0)
        return glyph;
      const { ctx: ctx2, buffer, gridInner, gridOuter } = this;
      ctx2.clearRect(buffer, buffer, glyphWidth, glyphHeight);
      ctx2.fillText(char, buffer, buffer + glyphTop);
      const imgData = ctx2.getImageData(buffer, buffer, glyphWidth, glyphHeight);
      gridOuter.fill(INF, 0, len8);
      gridInner.fill(0, 0, len8);
      for (let y3 = 0; y3 < glyphHeight; y3++) {
        for (let x3 = 0; x3 < glyphWidth; x3++) {
          const a3 = imgData.data[4 * (y3 * glyphWidth + x3) + 3] / 255;
          if (a3 === 0)
            continue;
          const j2 = (y3 + buffer) * width + x3 + buffer;
          if (a3 === 1) {
            gridOuter[j2] = 0;
            gridInner[j2] = INF;
          } else {
            const d2 = 0.5 - a3;
            gridOuter[j2] = d2 > 0 ? d2 * d2 : 0;
            gridInner[j2] = d2 < 0 ? d2 * d2 : 0;
          }
        }
      }
      edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
      edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
      for (let i5 = 0; i5 < len8; i5++) {
        const d2 = Math.sqrt(gridOuter[i5]) - Math.sqrt(gridInner[i5]);
        data[i5] = Math.round(255 - 255 * (d2 / this.radius + this.cutoff));
      }
      return glyph;
    }
  };
  function edt(data, x0, y0, width, height, gridSize, f4, v2, z2) {
    for (let x3 = x0; x3 < x0 + width; x3++)
      edt1d(data, y0 * gridSize + x3, gridSize, height, f4, v2, z2);
    for (let y3 = y0; y3 < y0 + height; y3++)
      edt1d(data, y3 * gridSize + x0, 1, width, f4, v2, z2);
  }
  function edt1d(grid, offset, stride, length16, f4, v2, z2) {
    v2[0] = 0;
    z2[0] = -INF;
    z2[1] = INF;
    f4[0] = grid[offset];
    for (let q2 = 1, k2 = 0, s3 = 0; q2 < length16; q2++) {
      f4[q2] = grid[offset + q2 * stride];
      const q22 = q2 * q2;
      do {
        const r3 = v2[k2];
        s3 = (f4[q2] - f4[r3] + q22 - r3 * r3) / (q2 - r3) / 2;
      } while (s3 <= z2[k2] && --k2 > -1);
      k2++;
      v2[k2] = q2;
      z2[k2] = s3;
      z2[k2 + 1] = INF;
    }
    for (let q2 = 0, k2 = 0; q2 < length16; q2++) {
      while (z2[k2 + 1] < q2)
        k2++;
      const r3 = v2[k2];
      const qr = q2 - r3;
      grid[offset + q2 * stride] = f4[r3] + qr * qr;
    }
  }

  // ../layers/src/text-layer/utils.ts
  var MISSING_CHAR_WIDTH = 32;
  var SINGLE_LINE = [];
  function nextPowOfTwo2(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function buildMapping2({
    characterSet,
    getFontWidth,
    fontHeight,
    buffer,
    maxCanvasWidth,
    mapping = {},
    xOffset = 0,
    yOffset = 0
  }) {
    let row = 0;
    let x3 = xOffset;
    const rowHeight = fontHeight + buffer * 2;
    for (const char of characterSet) {
      if (!mapping[char]) {
        const width = getFontWidth(char);
        if (x3 + width + buffer * 2 > maxCanvasWidth) {
          x3 = 0;
          row++;
        }
        mapping[char] = {
          x: x3 + buffer,
          y: yOffset + row * rowHeight + buffer,
          width,
          height: rowHeight,
          layoutWidth: width,
          layoutHeight: fontHeight
        };
        x3 += width + buffer * 2;
      }
    }
    return {
      mapping,
      xOffset: x3,
      yOffset: yOffset + row * rowHeight,
      canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
    };
  }
  function getTextWidth(text, startIndex, endIndex, mapping) {
    let width = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const character = text[i5];
      width += mapping[character]?.layoutWidth || 0;
    }
    return width;
  }
  function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target2) {
    let rowStartCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const textWidth = getTextWidth(text, i5, i5 + 1, iconMapping);
      if (rowOffsetLeft + textWidth > maxWidth) {
        if (rowStartCharIndex < i5) {
          target2.push(i5);
        }
        rowStartCharIndex = i5;
        rowOffsetLeft = 0;
      }
      rowOffsetLeft += textWidth;
    }
    return rowOffsetLeft;
  }
  function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target2) {
    let rowStartCharIndex = startIndex;
    let groupStartCharIndex = startIndex;
    let groupEndCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      if (text[i5] === " ") {
        groupEndCharIndex = i5 + 1;
      } else if (text[i5 + 1] === " " || i5 + 1 === endIndex) {
        groupEndCharIndex = i5 + 1;
      }
      if (groupEndCharIndex > groupStartCharIndex) {
        let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
        if (rowOffsetLeft + groupWidth > maxWidth) {
          if (rowStartCharIndex < groupStartCharIndex) {
            target2.push(groupStartCharIndex);
            rowStartCharIndex = groupStartCharIndex;
            rowOffsetLeft = 0;
          }
          if (groupWidth > maxWidth) {
            groupWidth = breakAll(
              text,
              groupStartCharIndex,
              groupEndCharIndex,
              maxWidth,
              iconMapping,
              target2
            );
            rowStartCharIndex = target2[target2.length - 1];
          }
        }
        groupStartCharIndex = groupEndCharIndex;
        rowOffsetLeft += groupWidth;
      }
    }
    return rowOffsetLeft;
  }
  function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
    if (endIndex === void 0) {
      endIndex = text.length;
    }
    const result = [];
    if (wordBreak === "break-all") {
      breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
    } else {
      breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
    }
    return result;
  }
  function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
    let x3 = 0;
    let rowHeight = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const character = line[i5];
      const frame = iconMapping[character];
      if (frame) {
        if (!rowHeight) {
          rowHeight = frame.layoutHeight;
        }
        leftOffsets[i5] = x3 + frame.layoutWidth / 2;
        x3 += frame.layoutWidth;
      } else {
        log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
        leftOffsets[i5] = x3;
        x3 += MISSING_CHAR_WIDTH;
      }
    }
    rowSize[0] = x3;
    rowSize[1] = rowHeight;
  }
  function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
    const characters = Array.from(paragraph);
    const numCharacters = characters.length;
    const x3 = new Array(numCharacters);
    const y3 = new Array(numCharacters);
    const rowWidth = new Array(numCharacters);
    const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
    const size = [0, 0];
    const rowSize = [0, 0];
    let rowOffsetTop = 0;
    let lineStartIndex = 0;
    let lineEndIndex = 0;
    for (let i5 = 0; i5 <= numCharacters; i5++) {
      const char = characters[i5];
      if (char === "\n" || i5 === numCharacters) {
        lineEndIndex = i5;
      }
      if (lineEndIndex > lineStartIndex) {
        const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
        for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
          const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
          const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
          transformRow(characters, rowStart, rowEnd, iconMapping, x3, rowSize);
          for (let j2 = rowStart; j2 < rowEnd; j2++) {
            const rowOffsetLeft = x3[j2] - rowSize[0] / 2;
            const char2 = characters[j2];
            const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
            y3[j2] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
            rowWidth[j2] = rowSize[0];
          }
          rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
          size[0] = Math.max(size[0], rowSize[0]);
        }
        lineStartIndex = lineEndIndex;
      }
      if (char === "\n") {
        x3[lineStartIndex] = 0;
        y3[lineStartIndex] = 0;
        rowWidth[lineStartIndex] = 0;
        lineStartIndex++;
      }
    }
    size[1] = rowOffsetTop;
    return { x: x3, y: y3, rowWidth, size };
  }
  function getTextFromBuffer({
    value,
    length: length16,
    stride,
    offset,
    startIndices,
    characterSet
  }) {
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : 1;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const characterCount = startIndices[length16] || Math.ceil((value.length - elementOffset) / elementStride);
    const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
    const texts = new Array(length16);
    let codes = value;
    if (elementStride > 1 || elementOffset > 0) {
      const ArrayType2 = value.constructor;
      codes = new ArrayType2(characterCount);
      for (let i5 = 0; i5 < characterCount; i5++) {
        codes[i5] = value[i5 * elementStride + elementOffset];
      }
    }
    for (let index = 0; index < length16; index++) {
      const startIndex = startIndices[index];
      const endIndex = startIndices[index + 1] || characterCount;
      const codesAtIndex = codes.subarray(startIndex, endIndex);
      texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
      if (autoCharacterSet) {
        codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
      }
    }
    if (autoCharacterSet) {
      for (const charCode of autoCharacterSet) {
        characterSet.add(String.fromCodePoint(charCode));
      }
    }
    return { texts, characterCount };
  }

  // ../layers/src/text-layer/lru-cache.ts
  var LRUCache = class {
    constructor(limit = 5) {
      this._cache = {};
      /** access/update order, first item is oldest, last item is newest */
      this._order = [];
      this.limit = limit;
    }
    get(key) {
      const value = this._cache[key];
      if (value) {
        this._deleteOrder(key);
        this._appendOrder(key);
      }
      return value;
    }
    set(key, value) {
      if (!this._cache[key]) {
        if (Object.keys(this._cache).length === this.limit) {
          this.delete(this._order[0]);
        }
        this._cache[key] = value;
        this._appendOrder(key);
      } else {
        this.delete(key);
        this._cache[key] = value;
        this._appendOrder(key);
      }
    }
    delete(key) {
      const value = this._cache[key];
      if (value) {
        delete this._cache[key];
        this._deleteOrder(key);
      }
    }
    _deleteOrder(key) {
      const index = this._order.indexOf(key);
      if (index >= 0) {
        this._order.splice(index, 1);
      }
    }
    _appendOrder(key) {
      this._order.push(key);
    }
  };

  // ../layers/src/text-layer/font-atlas-manager.ts
  function getDefaultCharacterSet() {
    const charSet = [];
    for (let i5 = 32; i5 < 128; i5++) {
      charSet.push(String.fromCharCode(i5));
    }
    return charSet;
  }
  var DEFAULT_FONT_SETTINGS = {
    fontFamily: "Monaco, monospace",
    fontWeight: "normal",
    characterSet: getDefaultCharacterSet(),
    fontSize: 64,
    buffer: 4,
    sdf: false,
    cutoff: 0.25,
    radius: 12,
    smoothing: 0.1
  };
  var MAX_CANVAS_WIDTH = 1024;
  var BASELINE_SCALE = 0.9;
  var HEIGHT_SCALE = 1.2;
  var CACHE_LIMIT = 3;
  var cache2 = new LRUCache(CACHE_LIMIT);
  function getNewChars(cacheKey, characterSet) {
    let newCharSet;
    if (typeof characterSet === "string") {
      newCharSet = new Set(Array.from(characterSet));
    } else {
      newCharSet = new Set(characterSet);
    }
    const cachedFontAtlas = cache2.get(cacheKey);
    if (!cachedFontAtlas) {
      return newCharSet;
    }
    for (const char in cachedFontAtlas.mapping) {
      if (newCharSet.has(char)) {
        newCharSet.delete(char);
      }
    }
    return newCharSet;
  }
  function populateAlphaChannel(alphaChannel, imageData) {
    for (let i5 = 0; i5 < alphaChannel.length; i5++) {
      imageData.data[4 * i5 + 3] = alphaChannel[i5];
    }
  }
  function setTextStyle(ctx2, fontFamily, fontSize, fontWeight) {
    ctx2.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx2.fillStyle = "#000";
    ctx2.textBaseline = "alphabetic";
    ctx2.textAlign = "left";
  }
  function setFontAtlasCacheLimit(limit) {
    log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
    cache2 = new LRUCache(limit);
  }
  var FontAtlasManager = class {
    constructor() {
      /** Font settings */
      this.props = { ...DEFAULT_FONT_SETTINGS };
    }
    get atlas() {
      return this._atlas;
    }
    // TODO - cut during v9 porting as types reveal this is not correct
    // get texture(): Texture | undefined {
    //   return this._atlas;
    // }
    get mapping() {
      return this._atlas && this._atlas.mapping;
    }
    get scale() {
      const { fontSize, buffer } = this.props;
      return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
    }
    setProps(props = {}) {
      Object.assign(this.props, props);
      this._key = this._getKey();
      const charSet = getNewChars(this._key, this.props.characterSet);
      const cachedFontAtlas = cache2.get(this._key);
      if (cachedFontAtlas && charSet.size === 0) {
        if (this._atlas !== cachedFontAtlas) {
          this._atlas = cachedFontAtlas;
        }
        return;
      }
      const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
      this._atlas = fontAtlas;
      cache2.set(this._key, fontAtlas);
    }
    // eslint-disable-next-line max-statements
    _generateFontAtlas(characterSet, cachedFontAtlas) {
      const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
      let canvas2 = cachedFontAtlas && cachedFontAtlas.data;
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.width = MAX_CANVAS_WIDTH;
      }
      const ctx2 = canvas2.getContext("2d", { willReadFrequently: true });
      setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
      const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
        getFontWidth: (char) => ctx2.measureText(char).width,
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer,
        characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH,
        ...cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        }
      });
      if (canvas2.height !== canvasHeight) {
        const imageData = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);
        canvas2.height = canvasHeight;
        ctx2.putImageData(imageData, 0, 0);
      }
      setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
      if (sdf) {
        const tinySDF = new TinySDF({
          fontSize,
          buffer,
          radius,
          cutoff,
          fontFamily,
          fontWeight: `${fontWeight}`
        });
        for (const char of characterSet) {
          const { data, width, height, glyphTop } = tinySDF.draw(char);
          mapping[char].width = width;
          mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
          const imageData = ctx2.createImageData(width, height);
          populateAlphaChannel(data, imageData);
          ctx2.putImageData(imageData, mapping[char].x, mapping[char].y);
        }
      } else {
        for (const char of characterSet) {
          ctx2.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
        }
      }
      return {
        xOffset,
        yOffset,
        mapping,
        data: canvas2,
        width: canvas2.width,
        height: canvas2.height
      };
    }
    _getKey() {
      const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
      if (sdf) {
        return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
      }
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
    }
  };

  // ../layers/src/text-layer/text-background-layer/text-background-layer-uniforms.ts
  var uniformBlock15 = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
  var textBackgroundUniforms = {
    name: "textBackground",
    vs: uniformBlock15,
    fs: uniformBlock15,
    uniformTypes: {
      billboard: "f32",
      sizeScale: "f32",
      sizeMinPixels: "f32",
      sizeMaxPixels: "f32",
      borderRadius: "vec4<f32>",
      padding: "vec4<f32>",
      sizeUnits: "i32",
      stroked: "f32"
    }
  };

  // ../layers/src/text-layer/text-background-layer/text-background-layer-vertex.glsl.ts
  var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader

in vec2 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;

out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = radians(angle);
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;
  vLineWidth = instanceLineWidths;

  // convert size in meters to pixels, then scaled and clamp

  // project meters to pixels and clamp to limits
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
    textBackground.sizeMinPixels, textBackground.sizeMaxPixels
  );

  dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;

  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
  pixelOffset += instancePixelOffsets;
  pixelOffset.y *= -1.0;

  if (textBackground.billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer-fragment.glsl.ts
  var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader

precision highp float;

in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;

out vec4 fragColor;

float round_rect(vec2 p, vec2 size, vec4 radii) {
  // Convert p and size to center-based coordinates [-0.5, 0.5]
  vec2 pixelPositionCB = (p - 0.5) * size;
  vec2 sizeCB = size * 0.5;

  float maxBorderRadius = min(size.x, size.y) * 0.5;
  vec4 borderRadius = vec4(min(radii, maxBorderRadius));

  // from https://www.shadertoy.com/view/4llXD7
  borderRadius.xy =
      (pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
  borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
  vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
  return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}

float rect(vec2 p, vec2 size) {
  vec2 pixelPosition = p * size;
  return min(min(pixelPosition.x, size.x - pixelPosition.x),
             min(pixelPosition.y, size.y - pixelPosition.y));
}

vec4 get_stroked_fragColor(float dist) {
  float isBorder = smoothedge(dist, vLineWidth);
  return mix(vFillColor, vLineColor, isBorder);
}

void main(void) {
  geometry.uv = uv;

  if (textBackground.borderRadius != vec4(0.0)) {
    float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
    if (textBackground.stroked) {
      fragColor = get_stroked_fragColor(distToEdge);
    } else {
      fragColor = vFillColor;
    }
    // add border radius
    float shapeAlpha = smoothedge(-distToEdge, 0.0);
    fragColor.a *= shapeAlpha;
  } else {
    if (textBackground.stroked) {
      float distToEdge = rect(uv, dimensions);
      fragColor = get_stroked_fragColor(distToEdge);
    } else {
      fragColor = vFillColor;
    }
  }
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer.ts
  var defaultProps15 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    borderRadius: { type: "object", value: 0 },
    padding: { type: "array", value: [0, 0, 0, 0] },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getSize: { type: "accessor", value: 1 },
    getAngle: { type: "accessor", value: 0 },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
    getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
    getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
    getLineWidth: { type: "accessor", value: 1 }
  };
  var TextBackgroundLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default, textBackgroundUniforms] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instanceRects: {
          size: 4,
          accessor: "getBoundingRect"
        },
        instancePixelOffsets: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        },
        instanceFillColors: {
          size: 4,
          transition: true,
          type: "unorm8",
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: 4,
          transition: true,
          type: "unorm8",
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { changeFlags } = params;
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
      let { padding, borderRadius } = this.props;
      if (padding.length < 4) {
        padding = [padding[0], padding[1], padding[0], padding[1]];
      }
      if (!Array.isArray(borderRadius)) {
        borderRadius = [borderRadius, borderRadius, borderRadius, borderRadius];
      }
      const model = this.state.model;
      const textBackgroundProps = {
        billboard,
        stroked: Boolean(getLineWidth),
        borderRadius,
        padding,
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels
      };
      model.shaderInputs.setProps({ textBackground: textBackgroundProps });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [0, 0, 1, 0, 0, 1, 1, 1];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          vertexCount: 4,
          attributes: {
            positions: { size: 2, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  TextBackgroundLayer.defaultProps = defaultProps15;
  TextBackgroundLayer.layerName = "TextBackgroundLayer";

  // ../layers/src/text-layer/text-layer.ts
  var TEXT_ANCHOR = {
    start: 1,
    middle: 0,
    end: -1
  };
  var ALIGNMENT_BASELINE = {
    top: 1,
    center: 0,
    bottom: -1
  };
  var DEFAULT_COLOR9 = [0, 0, 0, 255];
  var DEFAULT_LINE_HEIGHT = 1;
  var defaultProps16 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    background: false,
    getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
    getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
    getBorderWidth: { type: "accessor", value: 0 },
    backgroundBorderRadius: { type: "object", value: 0 },
    backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
    characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
    fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
    fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
    lineHeight: DEFAULT_LINE_HEIGHT,
    outlineWidth: { type: "number", value: 0, min: 0 },
    outlineColor: { type: "color", value: DEFAULT_COLOR9 },
    fontSettings: { type: "object", value: {}, compare: 1 },
    // auto wrapping options
    wordBreak: "break-word",
    maxWidth: { type: "number", value: -1 },
    getText: { type: "accessor", value: (x3) => x3.text },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR9 },
    getSize: { type: "accessor", value: 32 },
    getAngle: { type: "accessor", value: 0 },
    getTextAnchor: { type: "accessor", value: "middle" },
    getAlignmentBaseline: { type: "accessor", value: "center" },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    // deprecated
    backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
  };
  var TextLayer = class extends CompositeLayer {
    constructor() {
      super(...arguments);
      /** Returns the x, y, width, height of each text string, relative to pixel size.
       * Used to render the background.
       */
      this.getBoundingRect = (object, objectInfo) => {
        let {
          size: [width, height]
        } = this.transformParagraph(object, objectInfo);
        const { fontSize } = this.state.fontAtlasManager.props;
        width /= fontSize;
        height /= fontSize;
        const { getTextAnchor, getAlignmentBaseline } = this.props;
        const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
        const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
        return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
      };
      /** Returns the x, y offsets of each character in a text string, in texture size.
       * Used to layout characters in the vertex shader.
       */
      this.getIconOffsets = (object, objectInfo) => {
        const { getTextAnchor, getAlignmentBaseline } = this.props;
        const {
          x: x3,
          y: y3,
          rowWidth,
          size: [width, height]
        } = this.transformParagraph(object, objectInfo);
        const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
        const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
        const numCharacters = x3.length;
        const offsets = new Array(numCharacters * 2);
        let index = 0;
        for (let i5 = 0; i5 < numCharacters; i5++) {
          const rowOffset = (1 - anchorX) * (width - rowWidth[i5]) / 2;
          offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x3[i5];
          offsets[index++] = (anchorY - 1) * height / 2 + y3[i5];
        }
        return offsets;
      };
    }
    initializeState() {
      this.state = {
        styleVersion: 0,
        fontAtlasManager: new FontAtlasManager()
      };
      if (this.props.maxWidth > 0) {
        log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
      }
    }
    // eslint-disable-next-line complexity
    updateState(params) {
      const { props, oldProps, changeFlags } = params;
      const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
      if (textChanged) {
        this._updateText();
      }
      const fontChanged = this._updateFontAtlas();
      const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
      if (styleChanged) {
        this.setState({
          styleVersion: this.state.styleVersion + 1
        });
      }
    }
    getPickingInfo({ info }) {
      info.object = info.index >= 0 ? this.props.data[info.index] : null;
      return info;
    }
    /** Returns true if font has changed */
    _updateFontAtlas() {
      const { fontSettings, fontFamily, fontWeight } = this.props;
      const { fontAtlasManager, characterSet } = this.state;
      const fontProps = {
        ...fontSettings,
        characterSet,
        fontFamily,
        fontWeight
      };
      if (!fontAtlasManager.mapping) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
      for (const key in fontProps) {
        if (fontProps[key] !== fontAtlasManager.props[key]) {
          fontAtlasManager.setProps(fontProps);
          return true;
        }
      }
      return false;
    }
    // Text strings are variable width objects
    // Count characters and start offsets
    _updateText() {
      const { data, characterSet } = this.props;
      const textBuffer = data.attributes?.getText;
      let { getText } = this.props;
      let startIndices = data.startIndices;
      let numInstances;
      const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
      if (textBuffer && startIndices) {
        const { texts, characterCount } = getTextFromBuffer({
          ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
          // @ts-ignore if data.attribute is defined then length is expected
          length: data.length,
          startIndices,
          characterSet: autoCharacterSet
        });
        numInstances = characterCount;
        getText = (_2, { index }) => texts[index];
      } else {
        const { iterable, objectInfo } = createIterable(data);
        startIndices = [0];
        numInstances = 0;
        for (const object of iterable) {
          objectInfo.index++;
          const text = Array.from(getText(object, objectInfo) || "");
          if (autoCharacterSet) {
            text.forEach(autoCharacterSet.add, autoCharacterSet);
          }
          numInstances += text.length;
          startIndices.push(numInstances);
        }
      }
      this.setState({
        getText,
        startIndices,
        numInstances,
        characterSet: autoCharacterSet || characterSet
      });
    }
    /** There are two size systems in this layer:
    
        + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
          The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
          in layer props is roughly equivalent to font-size: 24px in CSS.
        + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
          which depends on how large each character is drawn into the font atlas. This is controlled by
          fontSettings.fontSize (default 64) and most users do not set it manually.
          These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
    
        All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
    /** Calculate the size and position of each character in a text string.
     * Values are in texture size */
    transformParagraph(object, objectInfo) {
      const { fontAtlasManager } = this.state;
      const iconMapping = fontAtlasManager.mapping;
      const getText = this.state.getText;
      const { wordBreak, lineHeight, maxWidth } = this.props;
      const paragraph = getText(object, objectInfo) || "";
      return transformParagraph(
        paragraph,
        lineHeight,
        wordBreak,
        maxWidth * fontAtlasManager.props.fontSize,
        iconMapping
      );
    }
    renderLayers() {
      const {
        startIndices,
        numInstances,
        getText,
        fontAtlasManager: { scale: scale22, atlas, mapping },
        styleVersion
      } = this.state;
      const {
        data,
        _dataDiff,
        getPosition: getPosition2,
        getColor: getColor2,
        getSize,
        getAngle,
        getPixelOffset,
        getBackgroundColor,
        getBorderColor,
        getBorderWidth,
        backgroundBorderRadius,
        backgroundPadding,
        background,
        billboard,
        fontSettings,
        outlineWidth,
        outlineColor,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions,
        updateTriggers
      } = this.props;
      const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
      const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
      return [
        background && new BackgroundLayerClass(
          {
            // background props
            getFillColor: getBackgroundColor,
            getLineColor: getBorderColor,
            getLineWidth: getBorderWidth,
            borderRadius: backgroundBorderRadius,
            padding: backgroundPadding,
            // props shared with characters layer
            getPosition: getPosition2,
            getSize,
            getAngle,
            getPixelOffset,
            billboard,
            sizeScale,
            sizeUnits,
            sizeMinPixels,
            sizeMaxPixels,
            transitions: transitions && {
              getPosition: transitions.getPosition,
              getAngle: transitions.getAngle,
              getSize: transitions.getSize,
              getFillColor: transitions.getBackgroundColor,
              getLineColor: transitions.getBorderColor,
              getLineWidth: transitions.getBorderWidth,
              getPixelOffset: transitions.getPixelOffset
            }
          },
          this.getSubLayerProps({
            id: "background",
            updateTriggers: {
              getPosition: updateTriggers.getPosition,
              getAngle: updateTriggers.getAngle,
              getSize: updateTriggers.getSize,
              getFillColor: updateTriggers.getBackgroundColor,
              getLineColor: updateTriggers.getBorderColor,
              getLineWidth: updateTriggers.getBorderWidth,
              getPixelOffset: updateTriggers.getPixelOffset,
              getBoundingRect: {
                getText: updateTriggers.getText,
                getTextAnchor: updateTriggers.getTextAnchor,
                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
                styleVersion
              }
            }
          }),
          {
            data: (
              // @ts-ignore (2339) attribute is not defined on all data types
              data.attributes && data.attributes.background ? (
                // @ts-ignore (2339) attribute is not defined on all data types
                { length: data.length, attributes: data.attributes.background }
              ) : data
            ),
            _dataDiff,
            // Maintain the same background behavior as <=8.3. Remove in v9?
            autoHighlight: false,
            getBoundingRect: this.getBoundingRect
          }
        ),
        new CharactersLayerClass(
          {
            sdf: fontSettings.sdf,
            smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
            outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
            outlineColor,
            iconAtlas: atlas,
            iconMapping: mapping,
            getPosition: getPosition2,
            getColor: getColor2,
            getSize,
            getAngle,
            getPixelOffset,
            billboard,
            sizeScale: sizeScale * scale22,
            sizeUnits,
            sizeMinPixels: sizeMinPixels * scale22,
            sizeMaxPixels: sizeMaxPixels * scale22,
            transitions: transitions && {
              getPosition: transitions.getPosition,
              getAngle: transitions.getAngle,
              getColor: transitions.getColor,
              getSize: transitions.getSize,
              getPixelOffset: transitions.getPixelOffset
            }
          },
          this.getSubLayerProps({
            id: "characters",
            updateTriggers: {
              all: updateTriggers.getText,
              getPosition: updateTriggers.getPosition,
              getAngle: updateTriggers.getAngle,
              getColor: updateTriggers.getColor,
              getSize: updateTriggers.getSize,
              getPixelOffset: updateTriggers.getPixelOffset,
              getIconOffsets: {
                getTextAnchor: updateTriggers.getTextAnchor,
                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
                styleVersion
              }
            }
          }),
          {
            data,
            _dataDiff,
            startIndices,
            numInstances,
            getIconOffsets: this.getIconOffsets,
            getIcon: getText
          }
        )
      ];
    }
    static set fontAtlasCacheLimit(limit) {
      setFontAtlasCacheLimit(limit);
    }
  };
  TextLayer.defaultProps = defaultProps16;
  TextLayer.layerName = "TextLayer";

  // ../layers/src/geojson-layer/sub-layer-map.ts
  var POINT_LAYER = {
    circle: {
      type: ScatterplotLayer,
      props: {
        filled: "filled",
        stroked: "stroked",
        lineWidthMaxPixels: "lineWidthMaxPixels",
        lineWidthMinPixels: "lineWidthMinPixels",
        lineWidthScale: "lineWidthScale",
        lineWidthUnits: "lineWidthUnits",
        pointRadiusMaxPixels: "radiusMaxPixels",
        pointRadiusMinPixels: "radiusMinPixels",
        pointRadiusScale: "radiusScale",
        pointRadiusUnits: "radiusUnits",
        pointAntialiasing: "antialiasing",
        pointBillboard: "billboard",
        getFillColor: "getFillColor",
        getLineColor: "getLineColor",
        getLineWidth: "getLineWidth",
        getPointRadius: "getRadius"
      }
    },
    icon: {
      type: IconLayer,
      props: {
        iconAtlas: "iconAtlas",
        iconMapping: "iconMapping",
        iconSizeMaxPixels: "sizeMaxPixels",
        iconSizeMinPixels: "sizeMinPixels",
        iconSizeScale: "sizeScale",
        iconSizeUnits: "sizeUnits",
        iconAlphaCutoff: "alphaCutoff",
        iconBillboard: "billboard",
        getIcon: "getIcon",
        getIconAngle: "getAngle",
        getIconColor: "getColor",
        getIconPixelOffset: "getPixelOffset",
        getIconSize: "getSize"
      }
    },
    text: {
      type: TextLayer,
      props: {
        textSizeMaxPixels: "sizeMaxPixels",
        textSizeMinPixels: "sizeMinPixels",
        textSizeScale: "sizeScale",
        textSizeUnits: "sizeUnits",
        textBackground: "background",
        textBackgroundPadding: "backgroundPadding",
        textFontFamily: "fontFamily",
        textFontWeight: "fontWeight",
        textLineHeight: "lineHeight",
        textMaxWidth: "maxWidth",
        textOutlineColor: "outlineColor",
        textOutlineWidth: "outlineWidth",
        textWordBreak: "wordBreak",
        textCharacterSet: "characterSet",
        textBillboard: "billboard",
        textFontSettings: "fontSettings",
        getText: "getText",
        getTextAngle: "getAngle",
        getTextColor: "getColor",
        getTextPixelOffset: "getPixelOffset",
        getTextSize: "getSize",
        getTextAnchor: "getTextAnchor",
        getTextAlignmentBaseline: "getAlignmentBaseline",
        getTextBackgroundColor: "getBackgroundColor",
        getTextBorderColor: "getBorderColor",
        getTextBorderWidth: "getBorderWidth"
      }
    }
  };
  var LINE_LAYER = {
    type: PathLayer,
    props: {
      lineWidthUnits: "widthUnits",
      lineWidthScale: "widthScale",
      lineWidthMinPixels: "widthMinPixels",
      lineWidthMaxPixels: "widthMaxPixels",
      lineJointRounded: "jointRounded",
      lineCapRounded: "capRounded",
      lineMiterLimit: "miterLimit",
      lineBillboard: "billboard",
      getLineColor: "getColor",
      getLineWidth: "getWidth"
    }
  };
  var POLYGON_LAYER = {
    type: SolidPolygonLayer,
    props: {
      extruded: "extruded",
      filled: "filled",
      wireframe: "wireframe",
      elevationScale: "elevationScale",
      material: "material",
      _full3d: "_full3d",
      getElevation: "getElevation",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor"
    }
  };
  function getDefaultProps({
    type,
    props
  }) {
    const result = {};
    for (const key in props) {
      result[key] = type.defaultProps[props[key]];
    }
    return result;
  }
  function forwardProps(layer, mapping) {
    const { transitions, updateTriggers } = layer.props;
    const result = {
      updateTriggers: {},
      transitions: transitions && {
        getPosition: transitions.geometry
      }
    };
    for (const sourceKey in mapping) {
      const targetKey = mapping[sourceKey];
      let value = layer.props[sourceKey];
      if (sourceKey.startsWith("get")) {
        value = layer.getSubLayerAccessor(value);
        result.updateTriggers[targetKey] = updateTriggers[sourceKey];
        if (transitions) {
          result.transitions[targetKey] = transitions[sourceKey];
        }
      }
      result[targetKey] = value;
    }
    return result;
  }

  // ../layers/src/geojson-layer/geojson.ts
  function getGeojsonFeatures(geojson) {
    if (Array.isArray(geojson)) {
      return geojson;
    }
    log_default.assert(geojson.type, "GeoJSON does not have type");
    switch (geojson.type) {
      case "Feature":
        return [geojson];
      case "FeatureCollection":
        log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
        return geojson.features;
      default:
        return [{ geometry: geojson }];
    }
  }
  function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
    const separated = {
      pointFeatures: [],
      lineFeatures: [],
      polygonFeatures: [],
      polygonOutlineFeatures: []
    };
    const { startRow = 0, endRow = features.length } = dataRange;
    for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
      const feature = features[featureIndex];
      const { geometry } = feature;
      if (!geometry) {
        continue;
      }
      if (geometry.type === "GeometryCollection") {
        log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
        const { geometries } = geometry;
        for (let i5 = 0; i5 < geometries.length; i5++) {
          const subGeometry = geometries[i5];
          separateGeometry(
            subGeometry,
            separated,
            wrapFeature,
            feature,
            featureIndex
          );
        }
      } else {
        separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
      }
    }
    return separated;
  }
  function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
    const { type, coordinates } = geometry;
    const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
    if (!validateGeometry(type, coordinates)) {
      log_default.warn(`${type} coordinates are malformed`)();
      return;
    }
    switch (type) {
      case "Point":
        pointFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        break;
      case "MultiPoint":
        coordinates.forEach((point) => {
          pointFeatures.push(
            wrapFeature(
              {
                geometry: { type: "Point", coordinates: point }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "LineString":
        lineFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        break;
      case "MultiLineString":
        coordinates.forEach((path) => {
          lineFeatures.push(
            wrapFeature(
              {
                geometry: { type: "LineString", coordinates: path }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "Polygon":
        polygonFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        coordinates.forEach((path) => {
          polygonOutlineFeatures.push(
            wrapFeature(
              {
                geometry: { type: "LineString", coordinates: path }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "MultiPolygon":
        coordinates.forEach((polygon) => {
          polygonFeatures.push(
            wrapFeature(
              {
                geometry: { type: "Polygon", coordinates: polygon }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
          polygon.forEach((path) => {
            polygonOutlineFeatures.push(
              wrapFeature(
                {
                  geometry: { type: "LineString", coordinates: path }
                },
                sourceFeature,
                sourceFeatureIndex
              )
            );
          });
        });
        break;
      default:
    }
  }
  var COORDINATE_NEST_LEVEL = {
    Point: 1,
    MultiPoint: 2,
    LineString: 2,
    MultiLineString: 3,
    Polygon: 3,
    MultiPolygon: 4
  };
  function validateGeometry(type, coordinates) {
    let nestLevel = COORDINATE_NEST_LEVEL[type];
    log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
    while (coordinates && --nestLevel > 0) {
      coordinates = coordinates[0];
    }
    return coordinates && Number.isFinite(coordinates[0]);
  }

  // ../layers/src/geojson-layer/geojson-layer-props.ts
  function createEmptyLayerProps() {
    return {
      points: {},
      lines: {},
      polygons: {},
      polygonsOutline: {}
    };
  }
  function getCoordinates(f4) {
    return f4.geometry.coordinates;
  }
  function createLayerPropsFromFeatures(features, featuresDiff) {
    const layerProps = createEmptyLayerProps();
    const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
    layerProps.points.data = pointFeatures;
    layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
    layerProps.points.getPosition = getCoordinates;
    layerProps.lines.data = lineFeatures;
    layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
    layerProps.lines.getPath = getCoordinates;
    layerProps.polygons.data = polygonFeatures;
    layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
    layerProps.polygons.getPolygon = getCoordinates;
    layerProps.polygonsOutline.data = polygonOutlineFeatures;
    layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
    layerProps.polygonsOutline.getPath = getCoordinates;
    return layerProps;
  }
  function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
    const layerProps = createEmptyLayerProps();
    const { points, lines, polygons } = geojsonBinary;
    const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
    layerProps.points.data = {
      length: points.positions.value.length / points.positions.size,
      attributes: {
        ...points.attributes,
        getPosition: points.positions,
        instancePickingColors: {
          size: 4,
          value: customPickingColors.points
        }
      },
      properties: points.properties,
      numericProps: points.numericProps,
      featureIds: points.featureIds
    };
    layerProps.lines.data = {
      length: lines.pathIndices.value.length - 1,
      startIndices: lines.pathIndices.value,
      attributes: {
        ...lines.attributes,
        getPath: lines.positions,
        instancePickingColors: {
          size: 4,
          value: customPickingColors.lines
        }
      },
      properties: lines.properties,
      numericProps: lines.numericProps,
      featureIds: lines.featureIds
    };
    layerProps.lines._pathType = "open";
    layerProps.polygons.data = {
      length: polygons.polygonIndices.value.length - 1,
      startIndices: polygons.polygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPolygon: polygons.positions,
        pickingColors: {
          size: 4,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygons._normalize = false;
    if (polygons.triangles) {
      layerProps.polygons.data.attributes.indices = polygons.triangles.value;
    }
    layerProps.polygonsOutline.data = {
      length: polygons.primitivePolygonIndices.value.length - 1,
      startIndices: polygons.primitivePolygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPath: polygons.positions,
        instancePickingColors: {
          size: 4,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygonsOutline._pathType = "open";
    return layerProps;
  }

  // ../layers/src/geojson-layer/geojson-layer.ts
  var FEATURE_TYPES = ["points", "linestrings", "polygons"];
  var defaultProps17 = {
    ...getDefaultProps(POINT_LAYER.circle),
    ...getDefaultProps(POINT_LAYER.icon),
    ...getDefaultProps(POINT_LAYER.text),
    ...getDefaultProps(LINE_LAYER),
    ...getDefaultProps(POLYGON_LAYER),
    // Overwrite sub layer defaults
    stroked: true,
    filled: true,
    extruded: false,
    wireframe: false,
    _full3d: false,
    iconAtlas: { type: "object", value: null },
    iconMapping: { type: "object", value: {} },
    getIcon: { type: "accessor", value: (f4) => f4.properties.icon },
    getText: { type: "accessor", value: (f4) => f4.properties.text },
    // Self props
    pointType: "circle",
    // TODO: deprecated, remove in v9
    getRadius: { deprecatedFor: "getPointRadius" }
  };
  var GeoJsonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        layerProps: {},
        features: {},
        featuresDiff: {}
      };
    }
    updateState({ props, changeFlags }) {
      if (!changeFlags.dataChanged) {
        return;
      }
      const { data } = this.props;
      const binary = data && "points" in data && "polygons" in data && "lines" in data;
      this.setState({ binary });
      if (binary) {
        this._updateStateBinary({ props, changeFlags });
      } else {
        this._updateStateJSON({ props, changeFlags });
      }
    }
    _updateStateBinary({ props, changeFlags }) {
      const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
      this.setState({ layerProps });
    }
    _updateStateJSON({ props, changeFlags }) {
      const features = getGeojsonFeatures(props.data);
      const wrapFeature = this.getSubLayerRow.bind(this);
      let newFeatures = {};
      const featuresDiff = {};
      if (Array.isArray(changeFlags.dataChanged)) {
        const oldFeatures = this.state.features;
        for (const key in oldFeatures) {
          newFeatures[key] = oldFeatures[key].slice();
          featuresDiff[key] = [];
        }
        for (const dataRange of changeFlags.dataChanged) {
          const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
          for (const key in oldFeatures) {
            featuresDiff[key].push(
              replaceInRange({
                data: newFeatures[key],
                getIndex: (f4) => f4.__source.index,
                dataRange,
                replace: partialFeatures[key]
              })
            );
          }
        }
      } else {
        newFeatures = separateGeojsonFeatures(features, wrapFeature);
      }
      const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
      this.setState({
        features: newFeatures,
        featuresDiff,
        layerProps
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index, sourceLayer } = info;
      info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
      if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
        info.index = this.props.data.points.globalFeatureIds.value[index];
      }
      return info;
    }
    _updateAutoHighlight(info) {
      const pointLayerIdPrefix = `${this.id}-points-`;
      const sourceIsPoints = info.featureType === "points";
      for (const layer of this.getSubLayers()) {
        if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    _renderPolygonLayer() {
      const { extruded, wireframe } = this.props;
      const { layerProps } = this.state;
      const id = "polygons-fill";
      const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
      if (PolygonFillLayer) {
        const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
        const useLineColor = extruded && wireframe;
        if (!useLineColor) {
          delete forwardedProps.getLineColor;
        }
        forwardedProps.updateTriggers.lineColors = useLineColor;
        return new PolygonFillLayer(
          forwardedProps,
          this.getSubLayerProps({
            id,
            updateTriggers: forwardedProps.updateTriggers
          }),
          layerProps.polygons
        );
      }
      return null;
    }
    _renderLineLayers() {
      const { extruded, stroked } = this.props;
      const { layerProps } = this.state;
      const polygonStrokeLayerId = "polygons-stroke";
      const lineStringsLayerId = "linestrings";
      const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
      const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
      if (PolygonStrokeLayer || LineStringsLayer) {
        const forwardedProps = forwardProps(this, LINE_LAYER.props);
        return [
          PolygonStrokeLayer && new PolygonStrokeLayer(
            forwardedProps,
            this.getSubLayerProps({
              id: polygonStrokeLayerId,
              updateTriggers: forwardedProps.updateTriggers
            }),
            layerProps.polygonsOutline
          ),
          LineStringsLayer && new LineStringsLayer(
            forwardedProps,
            this.getSubLayerProps({
              id: lineStringsLayerId,
              updateTriggers: forwardedProps.updateTriggers
            }),
            layerProps.lines
          )
        ];
      }
      return null;
    }
    _renderPointLayers() {
      const { pointType } = this.props;
      const { layerProps, binary } = this.state;
      let { highlightedObjectIndex } = this.props;
      if (!binary && Number.isFinite(highlightedObjectIndex)) {
        highlightedObjectIndex = layerProps.points.data.findIndex(
          (d2) => d2.__source.index === highlightedObjectIndex
        );
      }
      const types = new Set(pointType.split("+"));
      const pointLayers = [];
      for (const type of types) {
        const id = `points-${type}`;
        const PointLayerMapping = POINT_LAYER[type];
        const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
        if (PointsLayer) {
          const forwardedProps = forwardProps(this, PointLayerMapping.props);
          let pointsLayerProps = layerProps.points;
          if (type === "text" && binary) {
            const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
            pointsLayerProps = {
              ...pointsLayerProps,
              // @ts-expect-error TODO - type binary data
              data: { ...pointsLayerProps.data, attributes: rest }
            };
          }
          pointLayers.push(
            new PointsLayer(
              forwardedProps,
              this.getSubLayerProps({
                id,
                updateTriggers: forwardedProps.updateTriggers,
                highlightedObjectIndex
              }),
              pointsLayerProps
            )
          );
        }
      }
      return pointLayers;
    }
    renderLayers() {
      const { extruded } = this.props;
      const polygonFillLayer = this._renderPolygonLayer();
      const lineLayers = this._renderLineLayers();
      const pointLayers = this._renderPointLayers();
      return [
        // If not extruded: flat fill layer is drawn below outlines
        !extruded && polygonFillLayer,
        lineLayers,
        pointLayers,
        // If extruded: draw fill layer last for correct blending behavior
        extruded && polygonFillLayer
      ];
    }
    getSubLayerAccessor(accessor) {
      const { binary } = this.state;
      if (!binary || typeof accessor !== "function") {
        return super.getSubLayerAccessor(accessor);
      }
      return (object, info) => {
        const { data, index } = info;
        const feature = binaryToFeatureForAccesor(data, index);
        return accessor(feature, info);
      };
    }
  };
  GeoJsonLayer.layerName = "GeoJsonLayer";
  GeoJsonLayer.defaultProps = defaultProps17;

  // ../../node_modules/@loaders.gl/xml/dist/lib/xml-utils/uncapitalize.js
  function uncapitalize(str7) {
    return typeof str7 === "string" ? str7.charAt(0).toLowerCase() + str7.slice(1) : str7;
  }
  function uncapitalizeKeys(object) {
    if (Array.isArray(object)) {
      return object.map((element) => uncapitalizeKeys(element));
    }
    if (object && typeof object === "object") {
      const newObject = {};
      for (const [key, value] of Object.entries(object)) {
        newObject[uncapitalize(key)] = uncapitalizeKeys(value);
      }
      return newObject;
    }
    return object;
  }

  // ../../node_modules/@loaders.gl/xml/dist/lib/parsers/parse-xml.js
  var import_fast_xml_parser = __toESM(require_fxp(), 1);
  function parseXMLSync(text, options) {
    if (options?._parser && options._parser !== "fast-xml-parser") {
      throw new Error(options?._parser);
    }
    const fastXMLOptions = {
      // Default FastXML options
      // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#allowbooleanattributes
      allowBooleanAttributes: true,
      // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#ignoredeclaration
      ignoreDeclaration: true,
      // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#removensprefix
      removeNSPrefix: options?.removeNSPrefix,
      // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#textnodename
      textNodeName: options?.textNodeName,
      // Let's application specify keys that are always arrays
      isArray: (name13, jpath, isLeafNode, isAttribute) => {
        const array = Boolean(options?.arrayPaths?.some((path) => jpath === path));
        return array;
      },
      // Application overrides
      ...options?._fastXML
    };
    const xml = fastParseXML(text, fastXMLOptions);
    return options?.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
  }
  function fastParseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/xml/dist/xml-loader.js
  var VERSION5 = true ? "4.2.1" : "latest";
  var XMLLoader = {
    dataType: null,
    batchType: null,
    name: "XML",
    id: "xml",
    module: "xml",
    version: VERSION5,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/xml", "text/xml"],
    testText: testXMLFile,
    options: {
      xml: {
        _parser: "fast-xml-parser",
        uncapitalizeKeys: false,
        removeNSPrefix: false,
        textNodeName: "value",
        arrayPaths: []
      }
    },
    parse: async (arrayBuffer2, options) => parseXMLSync(new TextDecoder().decode(arrayBuffer2), {
      ...XMLLoader.options.xml,
      ...options?.xml
    }),
    parseTextSync: (text, options) => parseXMLSync(text, { ...XMLLoader.options.xml, ...options?.xml })
  };
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-error.js
  function parseWMSError(text, options) {
    const parsedXML = XMLLoader.parseTextSync?.(text, options);
    const serviceExceptionXML = parsedXML?.ServiceExceptionReport?.ServiceException || parsedXML?.["ogc:ServiceExceptionReport"]?.["ogc:ServiceException"];
    const message2 = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
    return message2;
  }

  // ../../node_modules/@loaders.gl/wms/dist/wms-error-loader.js
  var VERSION6 = true ? "4.2.1" : "latest";
  var WMSErrorLoader = {
    dataType: null,
    batchType: null,
    id: "wms-error",
    name: "WMS Error",
    module: "wms",
    version: VERSION6,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
    testText: testXMLFile2,
    options: {
      wms: {
        throwOnError: false
      }
    },
    parse: async (arrayBuffer2, options) => parseTextSync(new TextDecoder().decode(arrayBuffer2), options),
    parseSync: (arrayBuffer2, options) => parseTextSync(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseTextSync(text, options)
  };
  function testXMLFile2(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    const wmsOptions = { ...WMSErrorLoader.options.wms, ...options?.wms };
    const error = parseWMSError(text, wmsOptions);
    const message2 = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
    if (wmsOptions.throwOnError) {
      throw new Error(message2);
    }
    return message2;
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/xml/parse-xml-helpers.js
  function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function getXMLStringArray(xmlValue) {
    const xmlArray = getXMLArray(xmlValue);
    if (xmlArray.length > 0 && xmlArray.every((_2) => typeof _2 === "string")) {
      return xmlArray;
    }
    return [];
  }
  function getXMLFloat(xmlValue, defaultValue2 = void 0) {
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseFloat(xmlValue);
      default:
        return void 0;
    }
  }
  function getXMLInteger(xmlValue, defaultValue2 = void 0) {
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseInt(xmlValue, 10);
      default:
        return void 0;
    }
  }
  function getXMLBoolean(xmlValue) {
    switch (xmlValue) {
      case "true":
        return true;
      case "false":
        return false;
      case "1":
        return true;
      case "0":
        return false;
      default:
        return false;
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js
  function parseWMSCapabilities(xmlText, options) {
    const parsedXML = XMLLoader.parseTextSync?.(xmlText, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    const capabilities = extractCapabilities(xmlCapabilities);
    if (options?.inheritedLayerProps) {
      for (const layer of capabilities.layers) {
        addInheritedLayerProps(layer, null);
      }
    }
    if (options?.includeRawJSON) {
      capabilities.json = xmlCapabilities;
    }
    if (options?.includeXMLText) {
      capabilities.xml = xmlText;
    }
    return capabilities;
  }
  function extractCapabilities(xml) {
    const capabilities = {
      version: String(xml.version || ""),
      name: String(xml.Service?.Name || "unnamed"),
      title: xml.Service?.Title ? String(xml.Service?.Title) : void 0,
      abstract: xml.Service?.Abstract ? String(xml.Service?.Abstract) : void 0,
      keywords: getXMLStringArray(xml.Service?.KeywordList?.Keyword),
      fees: xml.Service?.Fees ? JSON.stringify(xml.Service?.Fees) : void 0,
      accessConstraints: xml.Service?.AccessConstraints ? JSON.stringify(xml.Service?.AccessConstraints) : void 0,
      layerLimit: getXMLInteger(xml.Service?.LayerLimit),
      maxWidth: getXMLInteger(xml.Service?.maxWidth),
      maxHeight: getXMLInteger(xml.Service?.maxHeight),
      layers: [],
      requests: extractRequests(xml.Capability?.Request),
      exceptions: extractExceptions(xml.Exception)
      // contact field is a mess of largely irrelevant information, put it last
      // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
    };
    const xmlLayers = getXMLArray(xml.Capability?.Layer);
    for (const xmlSubLayer of xmlLayers) {
      capabilities.layers.push(extractLayer(xmlSubLayer));
    }
    for (const [key, value] of Object.entries(capabilities)) {
      if (value === void 0) {
        delete capabilities[key];
      }
    }
    return capabilities;
  }
  function extractRequests(xmlRequests) {
    const requests = {};
    for (const [name13, xmlRequest] of Object.entries(xmlRequests || {})) {
      const mimeTypes = getXMLStringArray(xmlRequest?.Format);
      requests[name13] = { mimeTypes };
    }
    return requests;
  }
  function extractExceptions(xmlException) {
    const xmlExceptionFormats = getXMLArray(xmlException?.Format);
    if (xmlExceptionFormats.length > 0) {
      return {
        mimeTypes: getXMLStringArray(xmlException)
      };
    }
    return void 0;
  }
  function extractLayer(xmlLayer) {
    const layer = {
      // All layers must have a title
      title: String(xmlLayer?.Title || ""),
      // Name is required only if renderable
      name: xmlLayer?.Name && String(xmlLayer?.Name),
      abstract: xmlLayer?.Name && String(xmlLayer?.Abstract),
      keywords: getXMLStringArray(xmlLayer.KeywordList?.Keyword)
    };
    const crs = xmlLayer?.CRS || xmlLayer?.SRS;
    if (crs && Array.isArray(crs) && crs.every((_2) => typeof _2 === "string")) {
      layer.crs = crs;
    }
    let geographicBoundingBox = xmlLayer?.EX_GeographicBoundingBox && extractEXBoundingBox(xmlLayer?.EX_GeographicBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    geographicBoundingBox = xmlLayer?.LatLonBoundingBox && extractLatLonBoundingBox(xmlLayer?.LatLonBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    const boundingBoxes = xmlLayer?.BoundingBox && extractWMSBoundingBoxes(xmlLayer?.BoundingBox);
    if (boundingBoxes && boundingBoxes.length > 0) {
      layer.boundingBoxes = boundingBoxes;
    }
    const xmlDimensions = getXMLArray(xmlLayer?.Dimension);
    const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
    if (dimensions.length) {
      layer.dimensions = dimensions;
    }
    if (xmlLayer?.opaque) {
      layer.opaque = getXMLBoolean(xmlLayer?.opaque);
    }
    if (xmlLayer?.cascaded) {
      layer.cascaded = getXMLBoolean(xmlLayer?.cascaded);
    }
    if (xmlLayer?.queryable) {
      layer.queryable = getXMLBoolean(xmlLayer?.queryable);
    }
    const xmlLayers = getXMLArray(xmlLayer?.Layer);
    const layers = [];
    for (const xmlSubLayer of xmlLayers) {
      layers.push(extractLayer(xmlSubLayer));
    }
    if (layers.length > 0) {
      layer.layers = layers;
    }
    for (const [key, value] of Object.entries(layer)) {
      if (value === void 0) {
        delete layer[key];
      }
    }
    return layer;
  }
  function extractEXBoundingBox(xmlBoundingBox) {
    const { westBoundLongitude: w2, northBoundLatitude: n3, eastBoundLongitude: e3, southBoundLatitude: s3 } = xmlBoundingBox;
    return [
      [w2, s3],
      [e3, n3]
    ];
  }
  function extractLatLonBoundingBox(xmlBoundingBox) {
    const { minx, miny, maxx, maxy } = xmlBoundingBox;
    return [
      [minx, miny],
      [maxx, maxy]
    ];
  }
  function extractWMSBoundingBoxes(xmlBoundingBoxes) {
    const xmlBoxes = getXMLArray(xmlBoundingBoxes);
    return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
  }
  function extractWMSBoundingBox(xmlBoundingBox) {
    const { CRS, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
    const boundingBox = {
      // CRS in 1.3.0, SRS in 1.1.1
      crs: CRS || SRS,
      boundingBox: [
        [getXMLFloat(minx), getXMLFloat(miny)],
        [getXMLFloat(maxx), getXMLFloat(maxy)]
      ]
    };
    if (resx) {
      boundingBox.xResolution = resx;
    }
    if (resy) {
      boundingBox.yResolution = resy;
    }
    return boundingBox;
  }
  function extractDimension(xmlDimension) {
    const { name: name13, units, value: extent } = xmlDimension;
    const dimension = { name: name13, units, extent };
    if (xmlDimension.unitSymbol) {
      dimension.unitSymbol = xmlDimension.unitSymbol;
    }
    if (xmlDimension.default) {
      dimension.defaultValue = xmlDimension.default;
    }
    if (xmlDimension.multipleValues) {
      dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
    }
    if (xmlDimension.nearestValue) {
      dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
    }
    if (xmlDimension.current) {
      dimension.current = getXMLBoolean(xmlDimension.current);
    }
    return dimension;
  }
  function addInheritedLayerProps(layer, parent) {
    if (parent?.geographicBoundingBox && !layer.geographicBoundingBox) {
      layer.geographicBoundingBox = [...parent.geographicBoundingBox];
    }
    if (parent?.crs && !layer.crs) {
      layer.crs = [...parent.crs];
    }
    if (parent?.boundingBoxes && !layer.boundingBoxes) {
      layer.boundingBoxes = [...parent.boundingBoxes];
    }
    if (parent?.dimensions && !layer.dimensions) {
      layer.dimensions = [...parent.dimensions];
    }
    for (const subLayer of layer.layers || []) {
      addInheritedLayerProps(subLayer, layer);
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/wms-capabilities-loader.js
  var VERSION7 = true ? "4.2.1" : "latest";
  var WMSCapabilitiesLoader = {
    dataType: null,
    batchType: null,
    id: "wms-capabilities",
    name: "WMS Capabilities",
    module: "wms",
    version: VERSION7,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
    testText: testXMLFile3,
    options: {
      wms: {}
    },
    parse: async (arrayBuffer2, options) => (
      // TODO pass in XML options
      parseWMSCapabilities(new TextDecoder().decode(arrayBuffer2), options?.wms)
    ),
    parseTextSync: (text, options) => (
      // TODO pass in XML options
      parseWMSCapabilities(text, options?.wms)
    )
  };
  function testXMLFile3(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-features.js
  function parseWMSFeatureInfo(text, options) {
    const parsedXML = XMLLoader.parseTextSync?.(text, options);
    const xmlFeatureInfo = parsedXML.FeatureInfoResponse?.FIELDS || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
      features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
  }
  function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    return {
      attributes: xmlFields,
      type: "",
      bounds: { bottom: 0, top: 0, left: 0, right: 0 }
    };
  }

  // ../../node_modules/@loaders.gl/wms/dist/wip/wms-feature-info-loader.js
  var WMSFeatureInfoLoader = {
    ...WMSCapabilitiesLoader,
    dataType: null,
    id: "wms-feature-info",
    name: "WMS FeatureInfo",
    parse: async (arrayBuffer2, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-layer-description.js
  function parseWMSLayerDescription(text, options) {
    const parsedXML = XMLLoader.parseTextSync?.(text, options);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/wms/dist/wip/wms-layer-description-loader.js
  var WMSLayerDescriptionLoader = {
    ...WMSCapabilitiesLoader,
    dataType: null,
    id: "wms-layer-description",
    name: "WMS DescribeLayer",
    parse: async (arrayBuffer2, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/services/create-image-service.js
  function createImageService(props, services) {
    const { type = "auto" } = props;
    const service = type === "auto" ? guessServiceType(props.url, services) : getServiceOfType(type, services);
    if (!service) {
      throw new Error("Not a valid image source type");
    }
    return service.create(props);
  }
  function getServiceOfType(type, services) {
    for (const service of services) {
      if (service.type === type) {
        return service;
      }
    }
    return null;
  }
  function guessServiceType(url, services) {
    for (const service of services) {
      if (service.testURL && service.testURL(url)) {
        return service;
      }
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/wms/dist/services/ogc/wms-service.js
  var WMSService = {
    type: "wms",
    testURL: (url) => url.toLowerCase().includes("wms"),
    create: (props) => new WMSSource(props)
  };
  var WMSSource = class extends ImageSource {
    /** Base URL to the service */
    url;
    data;
    /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
    substituteCRS84;
    /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
    flipCRS;
    /** Default static WMS parameters */
    wmsParameters;
    /** Default static vendor parameters */
    vendorParameters;
    capabilities = null;
    /** Create a WMSSource */
    constructor(props) {
      super(props);
      this.url = props.url;
      this.data = props.url;
      this.substituteCRS84 = props.substituteCRS84 ?? false;
      this.flipCRS = ["EPSG:4326"];
      this.wmsParameters = {
        layers: void 0,
        query_layers: void 0,
        styles: void 0,
        version: "1.3.0",
        crs: "EPSG:4326",
        format: "image/png",
        info_format: "text/plain",
        transparent: void 0,
        time: void 0,
        elevation: void 0,
        ...props.wmsParameters
      };
      this.vendorParameters = props.vendorParameters || {};
    }
    // ImageService implementation
    async getMetadata() {
      const capabilities = await this.getCapabilities();
      return this.normalizeMetadata(capabilities);
    }
    async getImage(parameters2) {
      const { boundingBox, bbox, ...rest } = parameters2;
      const wmsParameters = {
        bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
        ...rest
      };
      return await this.getMap(wmsParameters);
    }
    normalizeMetadata(capabilities) {
      return capabilities;
    }
    // WMS Service API Stubs
    /** Get Capabilities */
    async getCapabilities(wmsParameters, vendorParameters) {
      const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer2, this.loadOptions);
      this.capabilities = capabilities;
      return capabilities;
    }
    /** Get a map image */
    async getMap(wmsParameters, vendorParameters) {
      const url = this.getMapURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    /** Get Feature Info for a coordinate */
    async getFeatureInfo(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSFeatureInfoLoader.parse(arrayBuffer2, this.loadOptions);
    }
    /** Get Feature Info for a coordinate */
    async getFeatureInfoText(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return new TextDecoder().decode(arrayBuffer2);
    }
    /** Get more information about a layer */
    async describeLayer(wmsParameters, vendorParameters) {
      const url = this.describeLayerURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSLayerDescriptionLoader.parse(arrayBuffer2, this.loadOptions);
    }
    /** Get an image with a semantic legend */
    async getLegendGraphic(wmsParameters, vendorParameters) {
      const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    // Typed URL creators
    // For applications that want full control of fetching and parsing
    /** Generate a URL for the GetCapabilities request */
    getCapabilitiesURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("GetCapabilities", options, vendorParameters);
    }
    /** Generate a URL for the GetMap request */
    getMapURL(wmsParameters, vendorParameters) {
      wmsParameters = this._getWMS130Parameters(wmsParameters);
      const options = {
        version: this.wmsParameters.version,
        format: this.wmsParameters.format,
        transparent: this.wmsParameters.transparent,
        time: this.wmsParameters.time,
        elevation: this.wmsParameters.elevation,
        layers: this.wmsParameters.layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
        // width: 1200,
        // height: 900,
        ...wmsParameters
      };
      return this._getWMSUrl("GetMap", options, vendorParameters);
    }
    /** Generate a URL for the GetFeatureInfo request */
    getFeatureInfoURL(wmsParameters, vendorParameters) {
      wmsParameters = this._getWMS130Parameters(wmsParameters);
      const { boundingBox, bbox } = wmsParameters;
      wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;
      const options = {
        version: this.wmsParameters.version,
        // query_layers: [],
        // format: this.wmsParameters.format,
        info_format: this.wmsParameters.info_format,
        layers: this.wmsParameters.layers,
        query_layers: this.wmsParameters.query_layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
        // width: 1200,
        // height: 900,
        // x: undefined!,
        // y: undefined!,
        ...wmsParameters
      };
      return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
    }
    /** Generate a URL for the GetFeatureInfo request */
    describeLayerURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("DescribeLayer", options, vendorParameters);
    }
    getLegendGraphicURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        // format?
        ...wmsParameters
      };
      return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
    }
    // INTERNAL METHODS
    _parseWMSUrl(url) {
      const [baseUrl, search] = url.split("?");
      const searchParams = search.split("&");
      const parameters2 = {};
      for (const parameter of searchParams) {
        const [key, value] = parameter.split("=");
        parameters2[key] = value;
      }
      return { url: baseUrl, parameters: parameters2 };
    }
    /**
     * Generate a URL with parameters
     * @note case _getWMSUrl may need to be overridden to handle certain backends?
     * @note at the moment, only URLs with parameters are supported (no XML payloads)
     * */
    _getWMSUrl(request, wmsParameters, vendorParameters) {
      let url = this.url;
      let first = true;
      const allParameters = {
        service: "WMS",
        version: wmsParameters.version,
        request,
        ...wmsParameters,
        ...this.vendorParameters,
        ...vendorParameters
      };
      const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
      for (const [key, value] of Object.entries(allParameters)) {
        if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
          url += first ? "?" : "&";
          first = false;
          url += this._getURLParameter(key, value, wmsParameters);
        }
      }
      return encodeURI(url);
    }
    _getWMS130Parameters(wmsParameters) {
      const newParameters = { ...wmsParameters };
      if (newParameters.srs) {
        newParameters.crs = newParameters.crs || newParameters.srs;
        delete newParameters.srs;
      }
      return newParameters;
    }
    // eslint-disable-next-line complexity
    _getURLParameter(key, value, wmsParameters) {
      switch (key) {
        case "crs":
          if (wmsParameters.version !== "1.3.0") {
            key = "srs";
          } else if (this.substituteCRS84 && value === "EPSG:4326") {
            value = "CRS:84";
          }
          break;
        case "srs":
          if (wmsParameters.version === "1.3.0") {
            key = "crs";
          }
          break;
        case "bbox":
          const bbox = this._flipBoundingBox(value, wmsParameters);
          if (bbox) {
            value = bbox;
          }
          break;
        case "x":
          if (wmsParameters.version === "1.3.0") {
            key = "i";
          }
          break;
        case "y":
          if (wmsParameters.version === "1.3.0") {
            key = "j";
          }
          break;
        default:
      }
      key = key.toUpperCase();
      return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
    }
    /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
    _flipBoundingBox(bboxValue, wmsParameters) {
      if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
        return null;
      }
      const flipCoordinates = (
        // Only affects WMS 1.3.0
        wmsParameters.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
        this.flipCRS.includes(wmsParameters.crs || "") && // Don't flip if we are subsituting EPSG:4326 with CRS:84
        !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326")
      );
      const bbox = bboxValue;
      return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
    }
    /** Fetches an array buffer and checks the response (boilerplate reduction) */
    async _fetchArrayBuffer(url) {
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return arrayBuffer2;
    }
    /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
    _checkResponse(response, arrayBuffer2) {
      const contentType = response.headers["content-type"];
      if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
        const loadOptions = mergeLoaderOptions(this.loadOptions, {
          wms: { throwOnError: true }
        });
        const error = WMSErrorLoader.parseSync?.(arrayBuffer2, loadOptions);
        throw new Error(error);
      }
    }
    /** Error situation detected */
    _parseError(arrayBuffer2) {
      const error = WMSErrorLoader.parseSync?.(arrayBuffer2, this.loadOptions);
      return new Error(error);
    }
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/services/image-service.js
  var ImageService = class extends ImageSource {
    constructor(props) {
      super(props);
    }
    // IMAGE SOURCE API
    async getMetadata() {
      throw new Error("ImageSource.getMetadata not implemented");
    }
    async getImage(parameters2) {
      const granularParameters = this.getGranularParameters(parameters2);
      const url = this.getURLFromTemplate(granularParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      return await ImageLoader.parse(arrayBuffer2);
    }
    // HELPERS
    /** Break up bounding box in east, north, south, west */
    getGranularParameters(parameters2) {
      const [[east, north], [west, south]] = parameters2.boundingBox;
      return { ...parameters2, east, north, south, west };
    }
    /** Supports both ${} and {} notations */
    getURLFromTemplate(parameters2) {
      let url = this.props.url;
      for (const [key, value] of Object.entries(parameters2)) {
        url = url.replace(`\${${key}}`, String(value));
        url = url.replace(`{${key}}`, String(value));
      }
      return url;
    }
  };
  __publicField(ImageService, "type", "template");
  __publicField(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));

  // ../../node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-service.js
  var ArcGISImageSource = class extends ImageService {
    data;
    constructor(props) {
      super(props);
      this.data = props.url;
    }
    // ImageSource (normalized endpoints)
    async getMetadata() {
      return await this.metadata();
    }
    async getImage(parameters2) {
      throw new Error("not implemented");
    }
    // ImageServer endpoints
    async metadata() {
      throw new Error("not implemented");
    }
    /**
     * Form a URL to an ESRI ImageServer
     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
     */
    exportImage(options) {
      throw new Error("not implemented");
    }
    // URL creators
    metadataURL(options) {
      return `${this.props.url}?f=pjson`;
    }
    /**
     * Form a URL to an ESRI ImageServer
     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
     //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
     //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
     //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
     //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
     //   f=image
     */
    exportImageURL(options) {
      const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
      const size = `size=${options.width},${options.height}`;
      const arcgisOptions = { ...options, bbox, size };
      delete arcgisOptions.width;
      delete arcgisOptions.height;
      return this.getUrl("exportImage", arcgisOptions);
    }
    // INTERNAL METHODS
    /**
     * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
     * @note if override is common, maybe add a callback prop?
     * */
    getUrl(path, options, extra) {
      let url = `${this.props.url}/${path}`;
      let first = true;
      for (const [key, value] of Object.entries(options)) {
        url += first ? "?" : "&";
        first = false;
        if (Array.isArray(value)) {
          url += `${key.toUpperCase()}=${value.join(",")}`;
        } else {
          url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
        }
      }
      return url;
    }
    /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
    async checkResponse(response) {
      if (!response.ok) {
        throw new Error("error");
      }
    }
  };
  var ArcGISImageService = {
    type: "arcgis-image-server",
    testURL: (url) => url.toLowerCase().includes("ImageServer"),
    create: (props) => new ArcGISImageSource(props)
  };

  // ../../node_modules/@loaders.gl/wms/dist/services/create-image-source.js
  var SERVICES = [WMSService, ArcGISImageService];
  function createImageSource(props) {
    return createImageService(props, SERVICES);
  }

  // ../geo-layers/src/wms-layer/utils.ts
  var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  function WGS84ToPseudoMercator(coord) {
    const mercator = lngLatToWorld(coord);
    mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    return mercator;
  }

  // ../geo-layers/src/wms-layer/wms-layer.ts
  var defaultProps18 = {
    id: "imagery-layer",
    data: "",
    serviceType: "auto",
    srs: "auto",
    layers: { type: "array", compare: true, value: [] },
    onMetadataLoad: { type: "function", value: () => {
    } },
    // eslint-disable-next-line
    onMetadataLoadError: { type: "function", value: console.error },
    onImageLoadStart: { type: "function", value: () => {
    } },
    onImageLoad: { type: "function", value: () => {
    } },
    onImageLoadError: {
      type: "function",
      compare: false,
      // eslint-disable-next-line
      value: (requestId, error) => console.error(error, requestId)
    }
  };
  var WMSLayer = class extends CompositeLayer {
    /** Returns true if all async resources are loaded */
    get isLoaded() {
      return this.state?.loadCounter === 0 && super.isLoaded;
    }
    /** Lets deck.gl know that we want viewport change events */
    shouldUpdateState() {
      return true;
    }
    initializeState() {
      this.state._nextRequestId = 0;
      this.state.lastRequestId = -1;
      this.state.loadCounter = 0;
    }
    updateState({ changeFlags, props, oldProps }) {
      const { viewport } = this.context;
      if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
        this.state.imageSource = this._createImageSource(props);
        this._loadMetadata();
        this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
      } else if (!deepEqual2(props.layers, oldProps.layers, 1)) {
        this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
      } else if (changeFlags.viewportChanged) {
        this.debounce(() => this.loadImage(viewport, "viewport changed"));
      }
    }
    finalizeState() {
    }
    renderLayers() {
      const { bounds, image, lastRequestParameters } = this.state;
      return image && new BitmapLayer({
        ...this.getSubLayerProps({ id: "bitmap" }),
        _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        bounds,
        image
      });
    }
    async getFeatureInfoText(x3, y3) {
      const { lastRequestParameters } = this.state;
      if (lastRequestParameters) {
        const featureInfo = await this.state.imageSource.getFeatureInfoText?.({
          ...lastRequestParameters,
          query_layers: lastRequestParameters.layers,
          x: x3,
          y: y3,
          info_format: "application/vnd.ogc.gml"
        });
        return featureInfo;
      }
      return "";
    }
    _createImageSource(props) {
      if (props.data instanceof ImageSource) {
        return props.data;
      }
      if (typeof props.data === "string") {
        return createImageSource({
          url: props.data,
          loadOptions: props.loadOptions,
          type: props.serviceType
        });
      }
      throw new Error("invalid image source in props.data");
    }
    /** Run a getMetadata on the image service */
    async _loadMetadata() {
      const { imageSource } = this.state;
      try {
        this.state.loadCounter++;
        const metadata = await imageSource.getMetadata();
        if (this.state.imageSource === imageSource) {
          this.getCurrentLayer()?.props.onMetadataLoad(metadata);
        }
      } catch (error) {
        this.getCurrentLayer()?.props.onMetadataLoadError(error);
      } finally {
        this.state.loadCounter--;
      }
    }
    /** Load an image */
    async loadImage(viewport, reason) {
      const { layers, serviceType } = this.props;
      if (serviceType === "wms" && layers.length === 0) {
        return;
      }
      const bounds = viewport.getBounds();
      const { width, height } = viewport;
      const requestId = this.getRequestId();
      let { srs } = this.props;
      if (srs === "auto") {
        srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
      }
      const requestParams = {
        width,
        height,
        boundingBox: [
          [bounds[0], bounds[1]],
          [bounds[2], bounds[3]]
        ],
        layers,
        crs: srs
      };
      if (srs === "EPSG:3857") {
        const min6 = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
        const max6 = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
        requestParams.boundingBox = [min6, max6];
      }
      try {
        this.state.loadCounter++;
        this.props.onImageLoadStart(requestId);
        const image = await this.state.imageSource.getImage(requestParams);
        if (this.state.lastRequestId < requestId) {
          this.getCurrentLayer()?.props.onImageLoad(requestId);
          this.setState({
            image,
            bounds,
            lastRequestParameters: requestParams,
            lastRequestId: requestId
          });
        }
      } catch (error) {
        this.raiseError(error, "Load image");
        this.getCurrentLayer()?.props.onImageLoadError(requestId, error);
      } finally {
        this.state.loadCounter--;
      }
    }
    // HELPERS
    /** Global counter for issuing unique request ids */
    getRequestId() {
      return this.state._nextRequestId++;
    }
    /** Runs an action in the future, cancels it if the new action is issued before it executes */
    debounce(fn, ms = 500) {
      clearTimeout(this.state._timeoutId);
      this.state._timeoutId = setTimeout(() => fn(), ms);
    }
  };
  WMSLayer.layerName = "WMSLayer";
  WMSLayer.defaultProps = defaultProps18;

  // ../geo-layers/src/great-circle-layer/great-circle-layer.ts
  var defaultProps19 = {
    getHeight: { type: "accessor", value: 0 },
    greatCircle: true
  };
  var GreatCircleLayer = class extends ArcLayer {
  };
  GreatCircleLayer.layerName = "GreatCircleLayer";
  GreatCircleLayer.defaultProps = defaultProps19;

  // ../geo-layers/src/geo-cell-layer/GeoCellLayer.ts
  var defaultProps20 = {
    ...PolygonLayer.defaultProps
  };
  var GeoCellLayer = class extends CompositeLayer {
    /** Implement to generate props to create geometry. */
    indexToBounds() {
      return null;
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        wireframe,
        filled,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      const { updateTriggers, material, transitions } = this.props;
      const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
      const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
      return new CellLayer(
        {
          filled,
          wireframe,
          extruded,
          elevationScale,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          material,
          transitions,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        },
        this.getSubLayerProps({
          id: "cell",
          updateTriggers: updateTriggers && {
            ...boundsUpdateTriggers,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        }),
        boundsProps
      );
    }
  };
  GeoCellLayer.layerName = "GeoCellLayer";
  GeoCellLayer.defaultProps = defaultProps20;

  // ../geo-layers/src/s2-layer/s2-geometry.ts
  var import_long = __toESM(require_long(), 1);
  var FACE_BITS = 3;
  var MAX_LEVEL = 30;
  var POS_BITS = 2 * MAX_LEVEL + 1;
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  function IJToST(ij, order, offsets) {
    const maxSize = 1 << order;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV(st) {
    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
  }
  function FaceUVToXYZ(face, [u3, v2]) {
    switch (face) {
      case 0:
        return [1, u3, v2];
      case 1:
        return [-u3, 1, v2];
      case 2:
        return [-u3, -v2, 1];
      case 3:
        return [-1, -v2, -u3];
      case 4:
        return [v2, -1, -u3];
      case 5:
        return [v2, u3, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat([x3, y3, z2]) {
    const lat = Math.atan2(z2, Math.sqrt(x3 * x3 + y3 * y3));
    const lng = Math.atan2(y3, x3);
    return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
  }
  function toHilbertQuadkey(idS) {
    let bin = import_long.default.fromString(idS, true, 10).toString(2);
    while (bin.length < FACE_BITS + POS_BITS) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
    let posS = import_long.default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
    return `${faceS}/${posS}`;
  }
  function rotateAndFlipQuadrant(n3, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n3 - 1 - point[0];
        point[1] = n3 - 1 - point[1];
      }
      const x3 = point[0];
      point[0] = point[1];
      point[1] = x3;
    }
  }
  function FromHilbertQuadKey(hilbertQuadkey) {
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    const point = [0, 0];
    let level;
    for (let i5 = maxLevel - 1; i5 >= 0; i5--) {
      level = maxLevel - i5;
      const bit = position[i5];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t3 = point[0];
      point[0] = point[1];
      point[1] = t3;
    }
    return { face, ij: point, level };
  }

  // ../geo-layers/src/s2-layer/s2-utils.ts
  var import_long2 = __toESM(require_long(), 1);
  function getIdFromToken(token) {
    const paddedToken = token.padEnd(16, "0");
    return import_long2.default.fromString(paddedToken, 16);
  }
  var MAX_RESOLUTION = 100;
  function getGeoBounds({
    face,
    ij,
    level
  }) {
    const offsets = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0]
    ];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i5 = 0; i5 < 4; i5++) {
      const offset = offsets[i5].slice(0);
      const nextOffset = offsets[i5 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j2 = 0; j2 < resolution; j2++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST(ij, level, offset);
        const uv = STToUV(st);
        const xyz = FaceUVToXYZ(face, uv);
        const lngLat = XYZToLngLat(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }
  function getS2QuadKey(token) {
    if (typeof token === "string") {
      if (token.indexOf("/") > 0) {
        return token;
      }
      token = getIdFromToken(token);
    }
    return toHilbertQuadkey(token.toString());
  }
  function getS2Polygon(token) {
    const key = getS2QuadKey(token);
    const s2cell = FromHilbertQuadKey(key);
    return getGeoBounds(s2cell);
  }

  // ../geo-layers/src/s2-layer/s2-layer.ts
  var defaultProps21 = {
    getS2Token: { type: "accessor", value: (d2) => d2.token }
  };
  var S2Layer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, getS2Token } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getS2Polygon(getS2Token(x3, objectInfo))
      };
    }
  };
  S2Layer.layerName = "S2Layer";
  S2Layer.defaultProps = defaultProps21;

  // ../geo-layers/src/quadkey-layer/quadkey-utils.ts
  var TILE_SIZE3 = 512;
  function quadkeyToWorldBounds(quadkey, coverage) {
    let x3 = 0;
    let y3 = 0;
    let mask = 1 << quadkey.length;
    const scale22 = mask / TILE_SIZE3;
    for (let i5 = 0; i5 < quadkey.length; i5++) {
      mask >>= 1;
      const q2 = parseInt(quadkey[i5]);
      if (q2 % 2)
        x3 |= mask;
      if (q2 > 1)
        y3 |= mask;
    }
    return [
      [x3 / scale22, TILE_SIZE3 - y3 / scale22],
      [(x3 + coverage) / scale22, TILE_SIZE3 - (y3 + coverage) / scale22]
    ];
  }
  function getQuadkeyPolygon(quadkey, coverage = 1) {
    const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
    const [w2, n3] = worldToLngLat(topLeft);
    const [e3, s3] = worldToLngLat(bottomRight);
    return [e3, n3, e3, s3, w2, s3, w2, n3, e3, n3];
  }

  // ../geo-layers/src/quadkey-layer/quadkey-layer.ts
  var defaultProps22 = {
    getQuadkey: { type: "accessor", value: (d2) => d2.quadkey }
  };
  var QuadkeyLayer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, extruded, getQuadkey } = this.props;
      const coverage = extruded ? 0.99 : 1;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getQuadkeyPolygon(getQuadkey(x3, objectInfo), coverage),
        updateTriggers: { getPolygon: coverage }
      };
    }
  };
  QuadkeyLayer.layerName = "QuadkeyLayer";
  QuadkeyLayer.defaultProps = defaultProps22;

  // ../geo-layers/src/tileset-2d/tile-2d-header.ts
  var Tile2DHeader = class {
    constructor(index) {
      this.index = index;
      this.isVisible = false;
      this.isSelected = false;
      this.parent = null;
      this.children = [];
      this.content = null;
      this._loader = void 0;
      this._abortController = null;
      this._loaderId = 0;
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
    }
    /** @deprecated use `boundingBox` instead */
    get bbox() {
      return this._bbox;
    }
    // TODO - remove in v9
    set bbox(value) {
      if (this._bbox)
        return;
      this._bbox = value;
      if ("west" in value) {
        this.boundingBox = [
          [value.west, value.south],
          [value.east, value.north]
        ];
      } else {
        this.boundingBox = [
          [value.left, value.top],
          [value.right, value.bottom]
        ];
      }
    }
    get data() {
      return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
    }
    get isLoaded() {
      return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
      return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
      return this._needsReload || this._isCancelled;
    }
    get byteLength() {
      const result = this.content ? this.content.byteLength : 0;
      if (!Number.isFinite(result)) {
        console.error("byteLength not defined in tile data");
      }
      return result;
    }
    /* eslint-disable max-statements */
    async _loadData({
      getData,
      requestScheduler,
      onLoad,
      onError
    }) {
      const { index, id, bbox, userData, zoom } = this;
      const loaderId = this._loaderId;
      this._abortController = new AbortController();
      const { signal } = this._abortController;
      const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
        return tile.isSelected ? 1 : -1;
      });
      if (!requestToken) {
        this._isCancelled = true;
        return;
      }
      if (this._isCancelled) {
        requestToken.done();
        return;
      }
      let tileData = null;
      let error;
      try {
        tileData = await getData({ index, id, bbox, userData, zoom, signal });
      } catch (err) {
        error = err || true;
      } finally {
        requestToken.done();
      }
      if (loaderId !== this._loaderId) {
        return;
      }
      this._loader = void 0;
      this.content = tileData;
      if (this._isCancelled && !tileData) {
        this._isLoaded = false;
        return;
      }
      this._isLoaded = true;
      this._isCancelled = false;
      if (error) {
        onError(error, this);
      } else {
        onLoad(this);
      }
    }
    loadData(opts) {
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
      this._loaderId++;
      this._loader = this._loadData(opts);
      return this._loader;
    }
    setNeedsReload() {
      if (this.isLoading) {
        this.abort();
        this._loader = void 0;
      }
      this._needsReload = true;
    }
    abort() {
      if (this.isLoaded) {
        return;
      }
      this._isCancelled = true;
      this._abortController?.abort();
    }
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/constants.js
  var INTERSECTION = {
    OUTSIDE: -1,
    // Represents that an object is not contained within the frustum.
    INTERSECTING: 0,
    // Represents that an object intersects one of the frustum's planes.
    INSIDE: 1
    // Represents that an object is fully within the frustum.
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
  var scratchVector2 = new Vector3();
  var scratchNormal = new Vector3();
  var AxisAlignedBoundingBox = class {
    /**
     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
     * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
     * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
     * @param center The center of the box; automatically computed if not supplied.
     */
    constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
      center = center || scratchVector2.copy(minimum).add(maximum).scale(0.5);
      this.center = new Vector3(center);
      this.halfDiagonal = new Vector3(maximum).subtract(this.center);
      this.minimum = new Vector3(minimum);
      this.maximum = new Vector3(maximum);
    }
    /**
     * Duplicates a AxisAlignedBoundingBox instance.
     *
     * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
     */
    clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    /**
     * Compares the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(right) {
      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */
    transform(transform2) {
      this.center.transformAsPoint(transform2);
      this.halfDiagonal.transform(transform2);
      this.minimum.transform(transform2);
      this.maximum.transform(transform2);
      return this;
    }
    /**
     * Determines which side of a plane a box is located.
     */
    intersectPlane(plane) {
      const { halfDiagonal } = this;
      const normal = scratchNormal.from(plane.normal);
      const e3 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
      const s3 = this.center.dot(normal) + plane.distance;
      if (s3 - e3 > 0) {
        return INTERSECTION.INSIDE;
      }
      if (s3 + e3 < 0) {
        return INTERSECTION.OUTSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    /** Computes the estimated distance squared from the closest point on a bounding box to a point. */
    distanceSquaredTo(point) {
      const offset = scratchVector2.from(point).subtract(this.center);
      const { halfDiagonal } = this;
      let distanceSquared = 0;
      let d2;
      d2 = Math.abs(offset.x) - halfDiagonal.x;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.y) - halfDiagonal.y;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.z) - halfDiagonal.z;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      return distanceSquared;
    }
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
  var scratchVector3 = new Vector3();
  var scratchVector22 = new Vector3();
  var BoundingSphere = class {
    /** Creates a bounding sphere */
    constructor(center = [0, 0, 0], radius = 0) {
      this.radius = -0;
      this.center = new Vector3();
      this.fromCenterRadius(center, radius);
    }
    /** Sets the bounding sphere from `center` and `radius`. */
    fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
    /**
     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
     * tightly and fully encompasses the box.
     */
    fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector3.from(oppositeCorner);
      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
    /** Compares the provided BoundingSphere component wise */
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    /** Duplicates a BoundingSphere instance. */
    clone() {
      return new BoundingSphere(this.center, this.radius);
    }
    /** Computes a bounding sphere that contains both the left and right bounding spheres. */
    union(boundingSphere) {
      const leftCenter = this.center;
      const leftRadius = this.radius;
      const rightCenter = boundingSphere.center;
      const rightRadius = boundingSphere.radius;
      const toRightCenter = scratchVector3.copy(rightCenter).subtract(leftCenter);
      const centerSeparation = toRightCenter.magnitude();
      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }
      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }
      const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector22);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
    /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
    expand(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const radius = scratchPoint2.subtract(this.center).magnitude();
      if (radius > this.radius) {
        this.radius = radius;
      }
      return this;
    }
    // BoundingVolume interface
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param sphere The bounding sphere to apply the transformation to.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns self.
     */
    transform(transform2) {
      this.center.transform(transform2);
      const scale22 = mat4_exports.getScaling(scratchVector3, transform2);
      this.radius = Math.max(scale22[0], Math.max(scale22[1], scale22[2])) * this.radius;
      return this;
    }
    /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
    distanceSquaredTo(point) {
      const d2 = this.distanceTo(point);
      return d2 * d2;
    }
    /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
    distanceTo(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const delta = scratchPoint2.subtract(this.center);
      return Math.max(0, delta.len() - this.radius);
    }
    /** Determines which side of a plane a sphere is located. */
    intersectPlane(plane) {
      const center = this.center;
      const radius = this.radius;
      const normal = plane.normal;
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane < -radius) {
        return INTERSECTION.OUTSIDE;
      }
      if (distanceToPlane < radius) {
        return INTERSECTION.INTERSECTING;
      }
      return INTERSECTION.INSIDE;
    }
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
  var scratchVector32 = new Vector3();
  var scratchOffset = new Vector3();
  var scratchVectorU = new Vector3();
  var scratchVectorV = new Vector3();
  var scratchVectorW = new Vector3();
  var scratchCorner = new Vector3();
  var scratchToCenter = new Vector3();
  var MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox = class {
    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.center = new Vector3().from(center);
      this.halfAxes = new Matrix3(halfAxes);
    }
    /** Returns an array with three halfSizes for the bounding box */
    get halfSize() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
    }
    /** Returns a quaternion describing the orientation of the bounding box */
    get quaternion() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      const normXAxis = new Vector3(xAxis).normalize();
      const normYAxis = new Vector3(yAxis).normalize();
      const normZAxis = new Vector3(zAxis).normalize();
      return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
    }
    /**
     * Create OrientedBoundingBox from quaternion based OBB,
     */
    fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
      const quaternionObject = new Quaternion(quaternion2);
      const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
      this.center = new Vector3().from(center);
      this.halfAxes = directionsMatrix;
      return this;
    }
    /** Duplicates a OrientedBoundingBox instance. */
    clone() {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    /** Compares the provided OrientedBoundingBox component wise and returns */
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
    getBoundingSphere(result = new BoundingSphere()) {
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const cornerVector = scratchVector32.copy(u3).add(v2).add(w2);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
    /** Determines which side of a plane the oriented bounding box is located. */
    intersectPlane(plane) {
      const center = this.center;
      const normal = plane.normal;
      const halfAxes = this.halfAxes;
      const normalX = normal.x;
      const normalY = normal.y;
      const normalZ = normal.z;
      const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane <= -radEffective) {
        return INTERSECTION.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return INTERSECTION.INSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    /**
     * Computes the estimated distance squared from the closest point
     * on a bounding box to a point.
     * See Geometric Tools for Computer Graphics 10.4.2
     */
    distanceSquaredTo(point) {
      const offset = scratchOffset.from(point).subtract(this.center);
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const uHalf = u3.magnitude();
      const vHalf = v2.magnitude();
      const wHalf = w2.magnitude();
      u3.normalize();
      v2.normalize();
      w2.normalize();
      let distanceSquared = 0;
      let d2;
      d2 = Math.abs(offset.dot(u3)) - uHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(v2)) - vHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(w2)) - wHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      return distanceSquared;
    }
    /**
     * The distances calculated by the vector from the center of the bounding box
     * to position projected onto direction.
     *
     * - If you imagine the infinite number of planes with normal direction,
     *   this computes the smallest distance to the closest and farthest planes
     *   from `position` that intersect the bounding box.
     *
     * @param position The position to calculate the distance from.
     * @param direction The direction from position.
     * @param result An Interval (array of length 2) to store the nearest and farthest distances.
     * @returns Interval (array of length 2) with nearest and farthest distances
     *   on the bounding box from position in direction.
     */
    // eslint-disable-next-line max-statements
    computePlaneDistances(position, direction, result = [-0, -0]) {
      let minDist = Number.POSITIVE_INFINITY;
      let maxDist = Number.NEGATIVE_INFINITY;
      const center = this.center;
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const corner = scratchCorner.copy(u3).add(v2).add(w2).add(center);
      const toCenter = scratchToCenter.copy(corner).subtract(position);
      let mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result[0] = minDist;
      result[1] = maxDist;
      return result;
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */
    transform(transformation) {
      this.center.transformAsPoint(transformation);
      const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
      xAxis.transformAsPoint(transformation);
      const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
      yAxis.transformAsPoint(transformation);
      const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
      zAxis.transformAsPoint(transformation);
      this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
      return this;
    }
    getTransform() {
      throw new Error("not implemented");
    }
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/plane.js
  var scratchPosition = new Vector3();
  var scratchNormal2 = new Vector3();
  var Plane = class {
    constructor(normal = [0, 0, 1], distance6 = 0) {
      this.normal = new Vector3();
      this.distance = -0;
      this.fromNormalDistance(normal, distance6);
    }
    /** Creates a plane from a normal and a distance from the origin. */
    fromNormalDistance(normal, distance6) {
      assert6(Number.isFinite(distance6));
      this.normal.from(normal).normalize();
      this.distance = distance6;
      return this;
    }
    /** Creates a plane from a normal and a point on the plane. */
    fromPointNormal(point, normal) {
      point = scratchPosition.from(point);
      this.normal.from(normal).normalize();
      const distance6 = -this.normal.dot(point);
      this.distance = distance6;
      return this;
    }
    /** Creates a plane from the general equation */
    fromCoefficients(a3, b2, c2, d2) {
      this.normal.set(a3, b2, c2);
      assert6(equals(this.normal.len(), 1));
      this.distance = d2;
      return this;
    }
    /** Duplicates a Plane instance. */
    clone() {
      return new Plane(this.normal, this.distance);
    }
    /** Compares the provided Planes by normal and distance */
    equals(right) {
      return equals(this.distance, right.distance) && equals(this.normal, right.normal);
    }
    /** Computes the signed shortest distance of a point to a plane.
     * The sign of the distance determines which side of the plane the point is on.
     */
    getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
    /** Transforms the plane by the given transformation matrix. */
    transform(matrix4) {
      const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
      const point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [0, 0, 0]) {
      const scratchPoint2 = scratchPosition.from(point);
      const pointDistance = this.getPointDistance(scratchPoint2);
      const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
      return scratchPoint2.subtract(scaledNormal).to(result);
    }
  };

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/culling-volume.js
  var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
  var scratchPlaneCenter = new Vector3();
  var scratchPlaneNormal = new Vector3();
  var CullingVolume = class {
    /**
     * Create a new `CullingVolume` bounded by an array of clipping planed
     * @param planes Array of clipping planes.
     * */
    constructor(planes = []) {
      this.planes = planes;
    }
    /**
     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
     * The planes are aligned to the x, y, and z axes in world coordinates.
     */
    fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces.length;
      const center = boundingSphere.center;
      const radius = boundingSphere.radius;
      let planeIndex = 0;
      for (const faceNormal of faces) {
        let plane0 = this.planes[planeIndex];
        let plane1 = this.planes[planeIndex + 1];
        if (!plane0) {
          plane0 = this.planes[planeIndex] = new Plane();
        }
        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new Plane();
        }
        const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
        plane0.fromPointNormal(plane0Center, faceNormal);
        const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
        const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
        plane1.fromPointNormal(plane1Center, negatedFaceNormal);
        planeIndex += 2;
      }
      return this;
    }
    /** Determines whether a bounding volume intersects the culling volume. */
    computeVisibility(boundingVolume) {
      let intersect4 = INTERSECTION.INSIDE;
      for (const plane of this.planes) {
        const result = boundingVolume.intersectPlane(plane);
        switch (result) {
          case INTERSECTION.OUTSIDE:
            return INTERSECTION.OUTSIDE;
          case INTERSECTION.INTERSECTING:
            intersect4 = INTERSECTION.INTERSECTING;
            break;
          default:
        }
      }
      return intersect4;
    }
    /**
     * Determines whether a bounding volume intersects the culling volume.
     *
     * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
     *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
     *   the parent (and therefore this) volume is completely inside plane[planeIndex]
     *   and that plane check can be skipped.
     */
    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      assert6(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
        return parentPlaneMask;
      }
      let mask = CullingVolume.MASK_INSIDE;
      const planes = this.planes;
      for (let k2 = 0; k2 < this.planes.length; ++k2) {
        const flag = k2 < 31 ? 1 << k2 : 0;
        if (k2 < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }
        const plane = planes[k2];
        const result = boundingVolume.intersectPlane(plane);
        if (result === INTERSECTION.OUTSIDE) {
          return CullingVolume.MASK_OUTSIDE;
        } else if (result === INTERSECTION.INTERSECTING) {
          mask |= flag;
        }
      }
      return mask;
    }
  };
  CullingVolume.MASK_OUTSIDE = 4294967295;
  CullingVolume.MASK_INSIDE = 0;
  CullingVolume.MASK_INDETERMINATE = 2147483647;

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
  var scratchPlaneUpVector = new Vector3();
  var scratchPlaneRightVector = new Vector3();
  var scratchPlaneNearCenter = new Vector3();
  var scratchPlaneFarCenter = new Vector3();
  var scratchPlaneNormal2 = new Vector3();

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin = new Vector3();
  var fromPointsYMin = new Vector3();
  var fromPointsZMin = new Vector3();
  var fromPointsXMax = new Vector3();
  var fromPointsYMax = new Vector3();
  var fromPointsZMax = new Vector3();
  var fromPointsCurrentPos = new Vector3();
  var fromPointsScratch = new Vector3();
  var fromPointsRitterCenter = new Vector3();
  var fromPointsMinBoxPt = new Vector3();
  var fromPointsMaxBoxPt = new Vector3();
  var fromPointsNaiveCenterScratch = new Vector3();

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
  var scratchMatrix = new Matrix3();
  var scratchUnitary = new Matrix3();
  var scratchDiagonal = new Matrix3();
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();
  function computeEigenDecomposition(matrix, result = {}) {
    const EIGEN_TOLERANCE = math_utils_exports.EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count3 = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
      shurDecomposition(diagonalMatrix, jMatrix);
      jMatrixTranspose.copy(jMatrix).transpose();
      diagonalMatrix.multiplyRight(jMatrix);
      diagonalMatrix.multiplyLeft(jMatrixTranspose);
      unitaryMatrix.multiplyRight(jMatrix);
      if (++count3 > 2) {
        ++sweep;
        count3 = 0;
      }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
  }
  function computeFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 9; ++i5) {
      const temp = matrix[i5];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = matrix[scratchMatrix.getElementIndex(colVal[i5], rowVal[i5])];
      norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition(matrix, result) {
    const tolerance = math_utils_exports.EPSILON15;
    let maxDiagonal = 0;
    let rotAxis = 1;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i5], rowVal[i5])]);
      if (temp > maxDiagonal) {
        rotAxis = i5;
        maxDiagonal = temp;
      }
    }
    const p3 = rowVal[rotAxis];
    const q2 = colVal[rotAxis];
    let c2 = 1;
    let s3 = 0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q2, p3)]) > tolerance) {
      const qq = matrix[scratchMatrix.getElementIndex(q2, q2)];
      const pp = matrix[scratchMatrix.getElementIndex(p3, p3)];
      const qp = matrix[scratchMatrix.getElementIndex(q2, p3)];
      const tau = (qq - pp) / 2 / qp;
      let t3;
      if (tau < 0) {
        t3 = -1 / (-tau + Math.sqrt(1 + tau * tau));
      } else {
        t3 = 1 / (tau + Math.sqrt(1 + tau * tau));
      }
      c2 = 1 / Math.sqrt(1 + t3 * t3);
      s3 = t3 * c2;
    }
    Matrix3.IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p3, p3)] = result[scratchMatrix.getElementIndex(q2, q2)] = c2;
    result[scratchMatrix.getElementIndex(q2, p3)] = s3;
    result[scratchMatrix.getElementIndex(p3, q2)] = -s3;
    return result;
  }

  // ../geo-layers/node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
  var scratchVector23 = new Vector3();
  var scratchVector33 = new Vector3();
  var scratchVector4 = new Vector3();
  var scratchVector5 = new Vector3();
  var scratchVector6 = new Vector3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    diagonal: new Matrix3(),
    unitary: new Matrix3()
  };
  function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
    if (!positions || positions.length === 0) {
      result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      result.center = new Vector3();
      return result;
    }
    const length16 = positions.length;
    const meanPoint = new Vector3(0, 0, 0);
    for (const position of positions) {
      meanPoint.add(position);
    }
    const invLength = 1 / length16;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0;
    let exy = 0;
    let exz = 0;
    let eyy = 0;
    let eyz = 0;
    let ezz = 0;
    for (const position of positions) {
      const p3 = scratchVector23.copy(position).subtract(meanPoint);
      exx += p3.x * p3.x;
      exy += p3.x * p3.y;
      exz += p3.x * p3.z;
      eyy += p3.y * p3.y;
      eyz += p3.y * p3.z;
      ezz += p3.z * p3.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u22 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l22 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions) {
      scratchVector23.copy(position);
      u1 = Math.max(scratchVector23.dot(v1), u1);
      u22 = Math.max(scratchVector23.dot(v2), u22);
      u3 = Math.max(scratchVector23.dot(v3), u3);
      l1 = Math.min(scratchVector23.dot(v1), l1);
      l22 = Math.min(scratchVector23.dot(v2), l22);
      l3 = Math.min(scratchVector23.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l22 + u22));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale22 = scratchVector33.set(u1 - l1, u22 - l22, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new Matrix3([scale22[0], 0, 0, 0, scale22[1], 0, 0, 0, scale22[2]]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
  }

  // ../geo-layers/src/tileset-2d/tile-2d-traversal.ts
  var TILE_SIZE4 = 512;
  var MAX_MAPS = 3;
  var REF_POINTS_5 = [
    [0.5, 0.5],
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1]
  ];
  var REF_POINTS_9 = REF_POINTS_5.concat([
    [0, 0.5],
    [0.5, 0],
    [1, 0.5],
    [0.5, 1]
  ]);
  var REF_POINTS_11 = REF_POINTS_9.concat([
    [0.25, 0.5],
    [0.75, 0.5]
  ]);
  var OSMNode = class {
    constructor(x3, y3, z2) {
      this.x = x3;
      this.y = y3;
      this.z = z2;
    }
    get children() {
      if (!this._children) {
        const x3 = this.x * 2;
        const y3 = this.y * 2;
        const z2 = this.z + 1;
        this._children = [
          new OSMNode(x3, y3, z2),
          new OSMNode(x3, y3 + 1, z2),
          new OSMNode(x3 + 1, y3, z2),
          new OSMNode(x3 + 1, y3 + 1, z2)
        ];
      }
      return this._children;
    }
    // eslint-disable-next-line complexity
    update(params) {
      const { viewport, cullingVolume: cullingVolume2, elevationBounds, minZ, maxZ, bounds, offset, project: project2 } = params;
      const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
      if (bounds && !this.insideBounds(bounds)) {
        return false;
      }
      const isInside = cullingVolume2.computeVisibility(boundingVolume);
      if (isInside < 0) {
        return false;
      }
      if (!this.childVisible) {
        let { z: z2 } = this;
        if (z2 < maxZ && z2 >= minZ) {
          const distance6 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
          z2 += Math.floor(Math.log2(distance6));
        }
        if (z2 >= maxZ) {
          this.selected = true;
          return true;
        }
      }
      this.selected = false;
      this.childVisible = true;
      for (const child of this.children) {
        child.update(params);
      }
      return true;
    }
    getSelected(result = []) {
      if (this.selected) {
        result.push(this);
      }
      if (this._children) {
        for (const node of this._children) {
          node.getSelected(result);
        }
      }
      return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
      const scale22 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale22;
      return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project2) {
      if (project2) {
        const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
        const refPointPositions = [];
        for (const p3 of refPoints) {
          const lngLat = osmTile2lngLat(this.x + p3[0], this.y + p3[1], this.z);
          lngLat[2] = zRange[0];
          refPointPositions.push(project2(lngLat));
          if (zRange[0] !== zRange[1]) {
            lngLat[2] = zRange[1];
            refPointPositions.push(project2(lngLat));
          }
        }
        return makeOrientedBoundingBoxFromPoints(refPointPositions);
      }
      const scale22 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale22;
      const originX = this.x * extent + worldOffset * TILE_SIZE4;
      const originY = TILE_SIZE4 - (this.y + 1) * extent;
      return new AxisAlignedBoundingBox(
        [originX, originY, zRange[0]],
        [originX + extent, originY + extent, zRange[1]]
      );
    }
  };
  function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project2 = viewport instanceof GlobeViewport && viewport.resolution ? (
      // eslint-disable-next-line @typescript-eslint/unbound-method
      viewport.projectPosition
    ) : null;
    const planes = Object.values(viewport.getFrustumPlanes()).map(
      ({ normal, distance: distance6 }) => new Plane(normal.clone().negate(), distance6)
    );
    const cullingVolume2 = new CullingVolume(planes);
    const unitsPerMeter2 = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter2 || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter2 || 0;
    const minZ = viewport instanceof WebMercatorViewport2 && viewport.pitch <= 60 ? maxZ : 0;
    if (bounds) {
      const [minLng, minLat, maxLng, maxLat] = bounds;
      const topLeft = lngLatToWorld([minLng, maxLat]);
      const bottomRight = lngLatToWorld([maxLng, minLat]);
      bounds = [topLeft[0], TILE_SIZE4 - topLeft[1], bottomRight[0], TILE_SIZE4 - bottomRight[1]];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
      viewport,
      project: project2,
      cullingVolume: cullingVolume2,
      elevationBounds: [elevationMin, elevationMax],
      minZ,
      maxZ,
      bounds,
      // num. of worlds from the center. For repeated maps
      offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof WebMercatorViewport2 && viewport.subViewports && viewport.subViewports.length > 1) {
      traversalParams.offset = -1;
      while (root.update(traversalParams)) {
        if (--traversalParams.offset < -MAX_MAPS) {
          break;
        }
      }
      traversalParams.offset = 1;
      while (root.update(traversalParams)) {
        if (++traversalParams.offset > MAX_MAPS) {
          break;
        }
      }
    }
    return root.getSelected();
  }

  // ../geo-layers/src/tileset-2d/utils.ts
  var TILE_SIZE5 = 512;
  var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
  var urlType = {
    type: "object",
    value: null,
    validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
    equal: (value1, value2) => {
      if (value1 === value2) {
        return true;
      }
      if (!Array.isArray(value1) || !Array.isArray(value2)) {
        return false;
      }
      const len8 = value1.length;
      if (len8 !== value2.length) {
        return false;
      }
      for (let i5 = 0; i5 < len8; i5++) {
        if (value1[i5] !== value2[i5]) {
          return false;
        }
      }
      return true;
    }
  };
  function transformBox(bbox, modelMatrix2) {
    const transformedCoords = [
      // top-left
      modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
      // top-right
      modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
      // bottom-left
      modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
      // bottom-right
      modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
    ];
    const transformedBox = [
      // Minimum x coord
      Math.min(...transformedCoords.map((i5) => i5[0])),
      // Minimum y coord
      Math.min(...transformedCoords.map((i5) => i5[1])),
      // Max x coord
      Math.max(...transformedCoords.map((i5) => i5[0])),
      // Max y coord
      Math.max(...transformedCoords.map((i5) => i5[1]))
    ];
    return transformedBox;
  }
  function stringHash(s3) {
    return Math.abs(s3.split("").reduce((a3, b2) => (a3 << 5) - a3 + b2.charCodeAt(0) | 0, 0));
  }
  function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
      return null;
    }
    const { index, id } = tile;
    if (Array.isArray(template)) {
      const i5 = stringHash(id) % template.length;
      template = template[i5];
    }
    let url = template;
    for (const key of Object.keys(index)) {
      const regex = new RegExp(`{${key}}`, "g");
      url = url.replace(regex, String(index[key]));
    }
    if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
      url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
    }
    return url;
  }
  function getBoundingBox2(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({ z: minZ });
      const bounds1 = viewport.getBounds({ z: maxZ });
      bounds = [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
      ];
    } else {
      bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
      return [
        // Top corner should not be more then bottom corner in either direction
        Math.max(Math.min(bounds[0], extent[2]), extent[0]),
        Math.max(Math.min(bounds[1], extent[3]), extent[1]),
        // Bottom corner should not be less then top corner in either direction
        Math.min(Math.max(bounds[2], extent[0]), extent[2]),
        Math.min(Math.max(bounds[3], extent[1]), extent[3])
      ];
    }
    return [
      Math.max(bounds[0], extent[0]),
      Math.max(bounds[1], extent[1]),
      Math.min(bounds[2], extent[2]),
      Math.min(bounds[3], extent[3])
    ];
  }
  function getCullBounds({
    viewport,
    z: z2,
    cullRect
  }) {
    const subViewports = viewport.subViewports || [viewport];
    return subViewports.map((v2) => getCullBoundsInViewport(v2, z2 || 0, cullRect));
  }
  function getCullBoundsInViewport(viewport, z2, cullRect) {
    if (!Array.isArray(z2)) {
      const x3 = cullRect.x - viewport.x;
      const y3 = cullRect.y - viewport.y;
      const { width, height } = cullRect;
      const unprojectOption = { targetZ: z2 };
      const topLeft = viewport.unproject([x3, y3], unprojectOption);
      const topRight = viewport.unproject([x3 + width, y3], unprojectOption);
      const bottomLeft = viewport.unproject([x3, y3 + height], unprojectOption);
      const bottomRight = viewport.unproject([x3 + width, y3 + height], unprojectOption);
      return [
        Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
        Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
      ];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z2[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z2[1], cullRect);
    return [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  }
  function getIndexingCoords(bbox, scale22, modelMatrixInverse) {
    if (modelMatrixInverse) {
      const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(
        (i5) => i5 * scale22 / TILE_SIZE5
      );
      return transformedTileIndex;
    }
    return bbox.map((i5) => i5 * scale22 / TILE_SIZE5);
  }
  function getScale2(z2, tileSize) {
    return Math.pow(2, z2) * TILE_SIZE5 / tileSize;
  }
  function osmTile2lngLat(x3, y3, z2) {
    const scale22 = getScale2(z2, TILE_SIZE5);
    const lng = x3 / scale22 * 360 - 180;
    const n3 = Math.PI - 2 * Math.PI * y3 / scale22;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n3) - Math.exp(-n3)));
    return [lng, lat];
  }
  function tile2XY(x3, y3, z2, tileSize) {
    const scale22 = getScale2(z2, tileSize);
    return [x3 / scale22 * TILE_SIZE5, y3 / scale22 * TILE_SIZE5];
  }
  function tileToBoundingBox(viewport, x3, y3, z2, tileSize = TILE_SIZE5) {
    if (viewport.isGeospatial) {
      const [west, north] = osmTile2lngLat(x3, y3, z2);
      const [east, south] = osmTile2lngLat(x3 + 1, y3 + 1, z2);
      return { west, north, east, south };
    }
    const [left, top] = tile2XY(x3, y3, z2, tileSize);
    const [right, bottom] = tile2XY(x3 + 1, y3 + 1, z2, tileSize);
    return { left, top, right, bottom };
  }
  function getIdentityTileIndices(viewport, z2, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox2(viewport, null, extent);
    const scale22 = getScale2(z2, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale22, modelMatrixInverse);
    const indices = [];
    for (let x3 = Math.floor(minX); x3 < maxX; x3++) {
      for (let y3 = Math.floor(minY); y3 < maxY; y3++) {
        indices.push({ x: x3, y: y3, z: z2 });
      }
    }
    return indices;
  }
  function getTileIndices({
    viewport,
    maxZoom,
    minZoom,
    zRange,
    extent,
    tileSize = TILE_SIZE5,
    modelMatrix: modelMatrix2,
    modelMatrixInverse,
    zoomOffset = 0
  }) {
    let z2 = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE5 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === "number" && Number.isFinite(minZoom) && z2 < minZoom) {
      if (!extent) {
        return [];
      }
      z2 = minZoom;
    }
    if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z2 > maxZoom) {
      z2 = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
      transformedExtent = transformBox(extent, modelMatrix2);
    }
    return viewport.isGeospatial ? getOSMTileIndices(viewport, z2, zRange, extent) : getIdentityTileIndices(
      viewport,
      z2,
      tileSize,
      transformedExtent || DEFAULT_EXTENT,
      modelMatrixInverse
    );
  }
  function isURLTemplate(s3) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s3);
  }
  function isGeoBoundingBox(v2) {
    return Number.isFinite(v2.west) && Number.isFinite(v2.north) && Number.isFinite(v2.east) && Number.isFinite(v2.south);
  }

  // ../geo-layers/src/tileset-2d/memoize.ts
  function memoize2(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual2(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }
  function isEqual2(a3, b2) {
    if (a3 === b2) {
      return true;
    }
    if (Array.isArray(a3)) {
      const len8 = a3.length;
      if (!b2 || b2.length !== len8) {
        return false;
      }
      for (let i5 = 0; i5 < len8; i5++) {
        if (a3[i5] !== b2[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../geo-layers/src/tileset-2d/tileset-2d.ts
  var TILE_STATE_VISITED = 1;
  var TILE_STATE_VISIBLE = 2;
  var STRATEGY_NEVER = "never";
  var STRATEGY_REPLACE = "no-overlap";
  var STRATEGY_DEFAULT = "best-available";
  var DEFAULT_CACHE_SCALE = 5;
  var STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: () => {
    }
  };
  var DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: "best-available",
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0,
    // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
    // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    }
  };
  var Tileset2D = class {
    /**
     * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
     * Cache size defaults to 5 * number of tiles in the current viewport
     */
    constructor(opts) {
      /* Private methods */
      this._getCullBounds = memoize2(getCullBounds);
      this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
      this.setOptions(this.opts);
      this.onTileLoad = (tile) => {
        this.opts.onTileLoad?.(tile);
        if (this.opts.maxCacheByteSize !== null) {
          this._cacheByteSize += tile.byteLength;
          this._resizeCache();
        }
      };
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
        maxRequests: this.opts.maxRequests,
        debounceTime: this.opts.debounceTime
      });
      this._cache = /* @__PURE__ */ new Map();
      this._tiles = [];
      this._dirty = false;
      this._cacheByteSize = 0;
      this._viewport = null;
      this._zRange = null;
      this._selectedTiles = null;
      this._frameNumber = 0;
      this._modelMatrix = new Matrix4();
      this._modelMatrixInverse = new Matrix4();
    }
    /* Public API */
    get tiles() {
      return this._tiles;
    }
    get selectedTiles() {
      return this._selectedTiles;
    }
    get isLoaded() {
      return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
    }
    get needsReload() {
      return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
    }
    setOptions(opts) {
      Object.assign(this.opts, opts);
      if (Number.isFinite(opts.maxZoom)) {
        this._maxZoom = Math.floor(opts.maxZoom);
      }
      if (Number.isFinite(opts.minZoom)) {
        this._minZoom = Math.ceil(opts.minZoom);
      }
    }
    // Clean up any outstanding tile requests.
    finalize() {
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          tile.abort();
        }
      }
      this._cache.clear();
      this._tiles = [];
      this._selectedTiles = null;
    }
    reloadAll() {
      for (const id of this._cache.keys()) {
        const tile = this._cache.get(id);
        if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
          this._cache.delete(id);
        } else {
          tile.setNeedsReload();
        }
      }
    }
    /**
     * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
     */
    update(viewport, { zRange, modelMatrix: modelMatrix2 } = {
      zRange: null,
      modelMatrix: null
    }) {
      const modelMatrixAsMatrix4 = modelMatrix2 ? new Matrix4(modelMatrix2) : new Matrix4();
      const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
      if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
        if (isModelMatrixNew) {
          this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
          this._modelMatrix = modelMatrixAsMatrix4;
        }
        this._viewport = viewport;
        this._zRange = zRange;
        const tileIndices = this.getTileIndices({
          viewport,
          maxZoom: this._maxZoom,
          minZoom: this._minZoom,
          zRange,
          modelMatrix: this._modelMatrix,
          modelMatrixInverse: this._modelMatrixInverse
        });
        this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
        if (this._dirty) {
          this._rebuildTree();
        }
      } else if (this.needsReload) {
        this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
      }
      const changed = this.updateTileStates();
      this._pruneRequests();
      if (this._dirty) {
        this._resizeCache();
      }
      if (changed) {
        this._frameNumber++;
      }
      return this._frameNumber;
    }
    // eslint-disable-next-line complexity
    isTileVisible(tile, cullRect) {
      if (!tile.isVisible) {
        return false;
      }
      if (cullRect && this._viewport) {
        const boundsArr = this._getCullBounds({
          viewport: this._viewport,
          z: this._zRange,
          cullRect
        });
        const { bbox } = tile;
        for (const [minX, minY, maxX, maxY] of boundsArr) {
          let overlaps;
          if ("west" in bbox) {
            overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
          } else {
            const y0 = Math.min(bbox.top, bbox.bottom);
            const y1 = Math.max(bbox.top, bbox.bottom);
            overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
          }
          if (overlaps) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    /* Public interface for subclassing */
    /** Returns array of tile indices in the current viewport */
    getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      modelMatrix: modelMatrix2,
      modelMatrixInverse
    }) {
      const { tileSize, extent, zoomOffset } = this.opts;
      return getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        tileSize,
        extent,
        modelMatrix: modelMatrix2,
        modelMatrixInverse,
        zoomOffset
      });
    }
    /** Returns unique string key for a tile index */
    getTileId(index) {
      return `${index.x}-${index.y}-${index.z}`;
    }
    /** Returns a zoom level for a tile index */
    getTileZoom(index) {
      return index.z;
    }
    /** Returns additional metadata to add to tile, bbox by default */
    getTileMetadata(index) {
      const { tileSize } = this.opts;
      return { bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize) };
    }
    /** Returns index of the parent tile */
    getParentIndex(index) {
      const x3 = Math.floor(index.x / 2);
      const y3 = Math.floor(index.y / 2);
      const z2 = index.z - 1;
      return { x: x3, y: y3, z: z2 };
    }
    // Returns true if any tile's visibility changed
    updateTileStates() {
      const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
      const visibilities = new Array(this._cache.size);
      let i5 = 0;
      for (const tile of this._cache.values()) {
        visibilities[i5++] = tile.isVisible;
        tile.isSelected = false;
        tile.isVisible = false;
      }
      for (const tile of this._selectedTiles) {
        tile.isSelected = true;
        tile.isVisible = true;
      }
      (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
      i5 = 0;
      for (const tile of this._cache.values()) {
        if (visibilities[i5++] !== tile.isVisible) {
          return true;
        }
      }
      return false;
    }
    _pruneRequests() {
      const { maxRequests = 0 } = this.opts;
      const abortCandidates = [];
      let ongoingRequestCount = 0;
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          ongoingRequestCount++;
          if (!tile.isSelected && !tile.isVisible) {
            abortCandidates.push(tile);
          }
        }
      }
      while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
        const tile = abortCandidates.shift();
        tile.abort();
        ongoingRequestCount--;
      }
    }
    // This needs to be called every time some tiles have been added/removed from cache
    _rebuildTree() {
      const { _cache } = this;
      for (const tile of _cache.values()) {
        tile.parent = null;
        if (tile.children) {
          tile.children.length = 0;
        }
      }
      for (const tile of _cache.values()) {
        const parent = this._getNearestAncestor(tile);
        tile.parent = parent;
        if (parent?.children) {
          parent.children.push(tile);
        }
      }
    }
    /**
     * Clear tiles that are not visible when the cache is full
     */
    /* eslint-disable complexity */
    _resizeCache() {
      const { _cache, opts } = this;
      const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
      (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
      const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
      const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
      if (overflown) {
        for (const [id, tile] of _cache) {
          if (!tile.isVisible && !tile.isSelected) {
            this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
            _cache.delete(id);
            this.opts.onTileUnload?.(tile);
          }
          if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
            break;
          }
        }
        this._rebuildTree();
        this._dirty = true;
      }
      if (this._dirty) {
        this._tiles = Array.from(this._cache.values()).sort((t1, t22) => t1.zoom - t22.zoom);
        this._dirty = false;
      }
    }
    _getTile(index, create30) {
      const id = this.getTileId(index);
      let tile = this._cache.get(id);
      let needsReload = false;
      if (!tile && create30) {
        tile = new Tile2DHeader(index);
        Object.assign(tile, this.getTileMetadata(tile.index));
        Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
        needsReload = true;
        this._cache.set(id, tile);
        this._dirty = true;
      } else if (tile && tile.needsReload) {
        needsReload = true;
      }
      if (tile && needsReload) {
        tile.loadData({
          getData: this.opts.getTileData,
          requestScheduler: this._requestScheduler,
          onLoad: this.onTileLoad,
          onError: this.opts.onTileError
        });
      }
      return tile;
    }
    _getNearestAncestor(tile) {
      const { _minZoom = 0 } = this;
      let index = tile.index;
      while (this.getTileZoom(index) > _minZoom) {
        index = this.getParentIndex(index);
        const parent = this._getTile(index);
        if (parent) {
          return parent;
        }
      }
      return null;
    }
  };
  function updateTileStateDefault(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
        getPlaceholderInChildren(tile);
      }
    }
    for (const tile of allTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
  }
  function updateTileStateReplace(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected) {
        getPlaceholderInAncestors(tile);
      }
    }
    const sortedTiles = Array.from(allTiles).sort((t1, t22) => t1.zoom - t22.zoom);
    for (const tile of sortedTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
      if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
        for (const child of tile.children) {
          child.state = TILE_STATE_VISITED;
        }
      } else if (tile.isSelected) {
        getPlaceholderInChildren(tile);
      }
    }
  }
  function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while (tile) {
      if (tile.isLoaded || tile.content) {
        tile.state |= TILE_STATE_VISIBLE;
        return true;
      }
      tile = tile.parent;
    }
    return false;
  }
  function getPlaceholderInChildren(tile) {
    for (const child of tile.children) {
      if (child.isLoaded || child.content) {
        child.state |= TILE_STATE_VISIBLE;
      } else {
        getPlaceholderInChildren(child);
      }
    }
  }

  // ../geo-layers/src/tile-layer/tile-layer.ts
  var defaultProps23 = {
    TilesetClass: Tileset2D,
    data: { type: "data", value: [] },
    dataComparator: urlType.equal,
    renderSubLayers: { type: "function", value: (props) => new GeoJsonLayer(props) },
    getTileData: { type: "function", optional: true, value: null },
    // TODO - change to onViewportLoad to align with Tile3DLayer
    onViewportLoad: { type: "function", optional: true, value: null },
    onTileLoad: { type: "function", value: (tile) => {
    } },
    onTileUnload: { type: "function", value: (tile) => {
    } },
    // eslint-disable-next-line
    onTileError: { type: "function", value: (err) => console.error(err) },
    extent: { type: "array", optional: true, value: null, compare: true },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: STRATEGY_DEFAULT,
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0
  };
  var TileLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        tileset: null,
        isLoaded: false
      };
    }
    finalizeState() {
      this.state?.tileset?.finalize();
    }
    get isLoaded() {
      return Boolean(
        this.state?.tileset?.selectedTiles?.every(
          (tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)
        )
      );
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState({ changeFlags }) {
      let { tileset } = this.state;
      const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
      const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
      if (!tileset) {
        tileset = new this.props.TilesetClass(this._getTilesetOptions());
        this.setState({ tileset });
      } else if (propsChanged) {
        tileset.setOptions(this._getTilesetOptions());
        if (dataChanged) {
          tileset.reloadAll();
        } else {
          tileset.tiles.forEach((tile) => {
            tile.layers = null;
          });
        }
      }
      this._updateTileset();
    }
    _getTilesetOptions() {
      const {
        tileSize,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy,
        extent,
        maxZoom,
        minZoom,
        maxRequests,
        debounceTime,
        zoomOffset
      } = this.props;
      return {
        maxCacheSize,
        maxCacheByteSize,
        maxZoom,
        minZoom,
        tileSize,
        refinementStrategy,
        extent,
        maxRequests,
        debounceTime,
        zoomOffset,
        getTileData: this.getTileData.bind(this),
        onTileLoad: this._onTileLoad.bind(this),
        onTileError: this._onTileError.bind(this),
        onTileUnload: this._onTileUnload.bind(this)
      };
    }
    _updateTileset() {
      const tileset = this.state.tileset;
      const { zRange, modelMatrix: modelMatrix2 } = this.props;
      const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix: modelMatrix2 });
      const { isLoaded } = tileset;
      const loadingStateChanged = this.state.isLoaded !== isLoaded;
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (isLoaded && (loadingStateChanged || tilesetChanged)) {
        this._onViewportLoad();
      }
      if (tilesetChanged) {
        this.setState({ frameNumber });
      }
      this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
      const { tileset } = this.state;
      const { onViewportLoad } = this.props;
      if (onViewportLoad) {
        onViewportLoad(tileset.selectedTiles);
      }
    }
    _onTileLoad(tile) {
      this.props.onTileLoad(tile);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileError(error, tile) {
      this.props.onTileError(error);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
      this.props.onTileUnload(tile);
    }
    // Methods for subclass to override
    getTileData(tile) {
      const { data, getTileData, fetch: fetch2 } = this.props;
      const { signal } = tile;
      tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
      if (getTileData) {
        return getTileData(tile);
      }
      if (fetch2 && tile.url) {
        return fetch2(tile.url, { propName: "data", layer: this, signal });
      }
      return null;
    }
    renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
      return null;
    }
    getPickingInfo(params) {
      const sourceLayer = params.sourceLayer;
      const sourceTile = sourceLayer.props.tile;
      const info = params.info;
      if (info.picked) {
        info.tile = sourceTile;
      }
      info.sourceTile = sourceTile;
      info.sourceTileSubLayer = sourceLayer;
      return info;
    }
    _updateAutoHighlight(info) {
      info.sourceTileSubLayer.updateAutoHighlight(info);
    }
    renderLayers() {
      return this.state.tileset.tiles.map((tile) => {
        const subLayerProps = this.getSubLayerPropsByTile(tile);
        if (!tile.isLoaded && !tile.content) {
        } else if (!tile.layers) {
          const layers = this.renderSubLayers({
            ...this.props,
            ...this.getSubLayerProps({
              id: tile.id,
              updateTriggers: this.props.updateTriggers
            }),
            data: tile.content,
            _offset: 0,
            tile
          });
          tile.layers = flatten(layers, Boolean).map(
            (layer) => layer.clone({
              tile,
              ...subLayerProps
            })
          );
        } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(
          (propName) => tile.layers[0].props[propName] !== subLayerProps[propName]
        )) {
          tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
        }
        return tile.layers;
      });
    }
    filterSubLayer({ layer, cullRect }) {
      const { tile } = layer.props;
      return this.state.tileset.isTileVisible(tile, cullRect);
    }
  };
  TileLayer.defaultProps = defaultProps23;
  TileLayer.layerName = "TileLayer";

  // ../geo-layers/src/trips-layer/trips-layer-uniforms.ts
  var uniformBlock16 = `uniform tripsUniforms {
  bool fadeTrail;
  float trailLength;
  float currentTime;
} trips;
`;
  var tripsUniforms = {
    name: "trips",
    vs: uniformBlock16,
    fs: uniformBlock16,
    uniformTypes: {
      fadeTrail: "f32",
      trailLength: "f32",
      currentTime: "f32"
    }
  };

  // ../geo-layers/src/trips-layer/trips-layer.ts
  var defaultProps24 = {
    fadeTrail: true,
    trailLength: { type: "number", value: 120, min: 0 },
    currentTime: { type: "number", value: 0, min: 0 },
    getTimestamps: { type: "accessor", value: (d2) => d2.timestamps }
  };
  var TripsLayer = class extends PathLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.inject = {
        "vs:#decl": `in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
        // Timestamp of the vertex
        "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
        "fs:#decl": `in float vTime;
`,
        // Drop the segments outside of the time window
        "fs:#main-start": `if(vTime > trips.currentTime || (trips.fadeTrail && (vTime < trips.currentTime - trips.trailLength))) {
  discard;
}
`,
        // Fade the color (currentTime - 100%, end of trail - 0%)
        "fs:DECKGL_FILTER_COLOR": `if(trips.fadeTrail) {
  color.a *= 1.0 - (trips.currentTime - vTime) / trips.trailLength;
}
`
      };
      shaders.modules = [...shaders.modules, tripsUniforms];
      return shaders;
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        timestamps: {
          size: 1,
          accessor: "getTimestamps",
          shaderAttributes: {
            instanceTimestamps: {
              vertexOffset: 0
            },
            instanceNextTimestamps: {
              vertexOffset: 1
            }
          }
        }
      });
    }
    draw(params) {
      const { fadeTrail, trailLength, currentTime } = this.props;
      const tripsProps = { fadeTrail, trailLength, currentTime };
      const model = this.state.model;
      model.shaderInputs.setProps({ trips: tripsProps });
      super.draw(params);
    }
  };
  TripsLayer.layerName = "TripsLayer";
  TripsLayer.defaultProps = defaultProps24;

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var import_h3_js3 = __toESM(require_h3_js(), 1);

  // ../geo-layers/src/h3-layers/h3-hexagon-layer.ts
  var import_h3_js2 = __toESM(require_h3_js(), 1);

  // ../geo-layers/src/h3-layers/h3-utils.ts
  var import_h3_js = __toESM(require_h3_js(), 1);
  function normalizeLongitudes(vertices, refLng) {
    refLng = refLng === void 0 ? vertices[0][0] : refLng;
    for (const pt of vertices) {
      const deltaLng = pt[0] - refLng;
      if (deltaLng > 180) {
        pt[0] -= 360;
      } else if (deltaLng < -180) {
        pt[0] += 360;
      }
    }
  }
  function scalePolygon(hexId, vertices, factor) {
    const [lat, lng] = (0, import_h3_js.cellToLatLng)(hexId);
    const actualCount = vertices.length;
    normalizeLongitudes(vertices, lng);
    const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
    for (let i5 = 0; i5 < vertexCount; i5++) {
      vertices[i5][0] = lerp(lng, vertices[i5][0], factor);
      vertices[i5][1] = lerp(lat, vertices[i5][1], factor);
    }
  }
  function getHexagonCentroid(getHexagon, object, objectInfo) {
    const hexagonId = getHexagon(object, objectInfo);
    const [lat, lng] = (0, import_h3_js.cellToLatLng)(hexagonId);
    return [lng, lat];
  }
  function h3ToPolygon(hexId, coverage = 1) {
    const vertices = (0, import_h3_js.cellToBoundary)(hexId, true);
    if (coverage !== 1) {
      scalePolygon(hexId, vertices, coverage);
    } else {
      normalizeLongitudes(vertices);
    }
    return vertices;
  }
  function flattenPolygon(vertices) {
    const positions = new Float64Array(vertices.length * 2);
    let i5 = 0;
    for (const pt of vertices) {
      positions[i5++] = pt[0];
      positions[i5++] = pt[1];
    }
    return positions;
  }

  // ../geo-layers/src/h3-layers/h3-hexagon-layer.ts
  var UPDATE_THRESHOLD_KM = 10;
  function mergeTriggers(getHexagon, coverage) {
    let trigger;
    if (getHexagon === void 0 || getHexagon === null) {
      trigger = coverage;
    } else if (typeof getHexagon === "object") {
      trigger = { ...getHexagon, coverage };
    } else {
      trigger = { getHexagon, coverage };
    }
    return trigger;
  }
  var defaultProps25 = {
    ...PolygonLayer.defaultProps,
    highPrecision: "auto",
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    centerHexagon: null,
    getHexagon: { type: "accessor", value: (x3) => x3.hexagon },
    extruded: true
  };
  var _H3HexagonLayer = class extends CompositeLayer {
    initializeState() {
      _H3HexagonLayer._checkH3Lib();
      this.state = {
        edgeLengthKM: 0,
        resolution: -1
      };
    }
    shouldUpdateState({ changeFlags }) {
      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
    }
    updateState({ props, changeFlags }) {
      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
        const dataProps = this._calculateH3DataProps();
        this.setState(dataProps);
      }
      this._updateVertices(this.context.viewport);
    }
    _calculateH3DataProps() {
      let resolution = -1;
      let hasPentagon = false;
      let hasMultipleRes = false;
      const { iterable, objectInfo } = createIterable(this.props.data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexId = this.props.getHexagon(object, objectInfo);
        const hexResolution = (0, import_h3_js2.getResolution)(hexId);
        if (resolution < 0) {
          resolution = hexResolution;
          if (!this.props.highPrecision)
            break;
        } else if (resolution !== hexResolution) {
          hasMultipleRes = true;
          break;
        }
        if ((0, import_h3_js2.isPentagon)(hexId)) {
          hasPentagon = true;
          break;
        }
      }
      return {
        resolution,
        edgeLengthKM: resolution >= 0 ? (0, import_h3_js2.getHexagonEdgeLengthAvg)(resolution, "km") : 0,
        hasMultipleRes,
        hasPentagon
      };
    }
    _shouldUseHighPrecision() {
      if (this.props.highPrecision === "auto") {
        const { resolution, hasPentagon, hasMultipleRes } = this.state;
        const { viewport } = this.context;
        return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
      }
      return this.props.highPrecision;
    }
    _updateVertices(viewport) {
      if (this._shouldUseHighPrecision()) {
        return;
      }
      const { resolution, edgeLengthKM, centerHex } = this.state;
      if (resolution < 0) {
        return;
      }
      const hex = this.props.centerHexagon || (0, import_h3_js2.latLngToCell)(viewport.latitude, viewport.longitude, resolution);
      if (centerHex === hex) {
        return;
      }
      if (centerHex) {
        try {
          const distance6 = (0, import_h3_js2.gridDistance)(centerHex, hex);
          if (distance6 * edgeLengthKM < UPDATE_THRESHOLD_KM) {
            return;
          }
        } catch {
        }
      }
      const { unitsPerMeter: unitsPerMeter2 } = viewport.distanceScales;
      let vertices = h3ToPolygon(hex);
      const [centerLat, centerLng] = (0, import_h3_js2.cellToLatLng)(hex);
      const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
      vertices = vertices.map((p3) => {
        const worldPosition = viewport.projectFlat(p3);
        return [
          (worldPosition[0] - centerX) / unitsPerMeter2[0],
          (worldPosition[1] - centerY) / unitsPerMeter2[1]
        ];
      });
      this.setState({ centerHex: hex, vertices });
    }
    renderLayers() {
      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
    }
    _getForwardProps() {
      const {
        elevationScale,
        material,
        coverage,
        extruded,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        getFillColor,
        getElevation,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers
      } = this.props;
      return {
        elevationScale,
        extruded,
        coverage,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        material,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers: {
          getFillColor: updateTriggers.getFillColor,
          getElevation: updateTriggers.getElevation,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      };
    }
    _renderPolygonLayer() {
      const { data, getHexagon, updateTriggers, coverage } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
      return new SubLayerClass(
        forwardProps2,
        this.getSubLayerProps({
          id: "hexagon-cell-hifi",
          updateTriggers: forwardProps2.updateTriggers
        }),
        {
          data,
          _normalize: false,
          _windingOrder: "CCW",
          positionFormat: "XY",
          getPolygon: (object, objectInfo) => {
            const hexagonId = getHexagon(object, objectInfo);
            return flattenPolygon(h3ToPolygon(hexagonId, coverage));
          }
        }
      );
    }
    _renderColumnLayer() {
      const { data, getHexagon, updateTriggers } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
      return new SubLayerClass(
        forwardProps2,
        this.getSubLayerProps({
          id: "hexagon-cell",
          flatShading: true,
          updateTriggers: forwardProps2.updateTriggers
        }),
        {
          data,
          diskResolution: 6,
          // generate an extruded hexagon as the base geometry
          radius: 1,
          vertices: this.state.vertices,
          getPosition: getHexagonCentroid.bind(null, getHexagon)
        }
      );
    }
  };
  var H3HexagonLayer = _H3HexagonLayer;
  H3HexagonLayer.defaultProps = defaultProps25;
  H3HexagonLayer.layerName = "H3HexagonLayer";
  // See `main/bundle.ts`
  H3HexagonLayer._checkH3Lib = () => {
  };

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var defaultProps26 = {
    getHexagons: { type: "accessor", value: (d2) => d2.hexagons }
  };
  var H3ClusterLayer = class extends GeoCellLayer {
    initializeState() {
      H3HexagonLayer._checkH3Lib();
    }
    updateState({ props, changeFlags }) {
      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
        const { data, getHexagons } = props;
        const polygons = [];
        const { iterable, objectInfo } = createIterable(data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexagons = getHexagons(object, objectInfo);
          const multiPolygon = (0, import_h3_js3.cellsToMultiPolygon)(hexagons, true);
          for (const polygon of multiPolygon) {
            for (const ring of polygon) {
              normalizeLongitudes(ring);
            }
            polygons.push(this.getSubLayerRow({ polygon }, object, objectInfo.index));
          }
        }
        this.setState({ polygons });
      }
    }
    indexToBounds() {
      const { getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
      return {
        data: this.state.polygons,
        getPolygon: (d2) => d2.polygon,
        getElevation: this.getSubLayerAccessor(getElevation),
        getFillColor: this.getSubLayerAccessor(getFillColor),
        getLineColor: this.getSubLayerAccessor(getLineColor),
        getLineWidth: this.getSubLayerAccessor(getLineWidth)
      };
    }
  };
  H3ClusterLayer.layerName = "H3ClusterLayer";
  H3ClusterLayer.defaultProps = defaultProps26;

  // ../mesh-layers/src/utils/matrix.ts
  var RADIAN_PER_DEGREE = Math.PI / 180;
  var modelMatrix = new Float32Array(16);
  var valueArray = new Float32Array(12);
  function calculateTransformMatrix(targetMatrix, orientation, scale22) {
    const pitch = orientation[0] * RADIAN_PER_DEGREE;
    const yaw = orientation[1] * RADIAN_PER_DEGREE;
    const roll = orientation[2] * RADIAN_PER_DEGREE;
    const sr = Math.sin(roll);
    const sp = Math.sin(pitch);
    const sw = Math.sin(yaw);
    const cr = Math.cos(roll);
    const cp = Math.cos(pitch);
    const cw = Math.cos(yaw);
    const scx = scale22[0];
    const scy = scale22[1];
    const scz = scale22[2];
    targetMatrix[0] = scx * cw * cp;
    targetMatrix[1] = scx * sw * cp;
    targetMatrix[2] = scx * -sp;
    targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
    targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
    targetMatrix[5] = scy * cp * sr;
    targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
    targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
    targetMatrix[8] = scz * cp * cr;
  }
  function getExtendedMat3FromMat4(mat4) {
    mat4[0] = mat4[0];
    mat4[1] = mat4[1];
    mat4[2] = mat4[2];
    mat4[3] = mat4[4];
    mat4[4] = mat4[5];
    mat4[5] = mat4[6];
    mat4[6] = mat4[8];
    mat4[7] = mat4[9];
    mat4[8] = mat4[10];
    mat4[9] = mat4[12];
    mat4[10] = mat4[13];
    mat4[11] = mat4[14];
    return mat4.subarray(0, 12);
  }
  var MATRIX_ATTRIBUTES = {
    size: 12,
    accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
    shaderAttributes: {
      instanceModelMatrixCol0: {
        size: 3,
        elementOffset: 0
      },
      instanceModelMatrixCol1: {
        size: 3,
        elementOffset: 3
      },
      instanceModelMatrixCol2: {
        size: 3,
        elementOffset: 6
      },
      instanceTranslation: {
        size: 3,
        elementOffset: 9
      }
    },
    update(attribute, { startRow, endRow }) {
      const { data, getOrientation, getScale: getScale3, getTranslation: getTranslation3, getTransformMatrix } = this.props;
      const arrayMatrix = Array.isArray(getTransformMatrix);
      const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
      const constantScale = Array.isArray(getScale3);
      const constantOrientation = Array.isArray(getOrientation);
      const constantTranslation = Array.isArray(getTranslation3);
      const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
      if (hasMatrix) {
        attribute.constant = constantMatrix;
      } else {
        attribute.constant = constantOrientation && constantScale && constantTranslation;
      }
      const instanceModelMatrixData = attribute.value;
      if (attribute.constant) {
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(getTransformMatrix);
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = getOrientation;
          const scale22 = getScale3;
          calculateTransformMatrix(matrix, orientation, scale22);
          matrix.set(getTranslation3, 9);
        }
        attribute.value = new Float32Array(matrix);
      } else {
        let i5 = startRow * attribute.size;
        const { iterable, objectInfo } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(
              constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)
            );
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
            const scale22 = constantScale ? getScale3 : getScale3(object, objectInfo);
            calculateTransformMatrix(matrix, orientation, scale22);
            matrix.set(constantTranslation ? getTranslation3 : getTranslation3(object, objectInfo), 9);
          }
          instanceModelMatrixData[i5++] = matrix[0];
          instanceModelMatrixData[i5++] = matrix[1];
          instanceModelMatrixData[i5++] = matrix[2];
          instanceModelMatrixData[i5++] = matrix[3];
          instanceModelMatrixData[i5++] = matrix[4];
          instanceModelMatrixData[i5++] = matrix[5];
          instanceModelMatrixData[i5++] = matrix[6];
          instanceModelMatrixData[i5++] = matrix[7];
          instanceModelMatrixData[i5++] = matrix[8];
          instanceModelMatrixData[i5++] = matrix[9];
          instanceModelMatrixData[i5++] = matrix[10];
          instanceModelMatrixData[i5++] = matrix[11];
        }
      }
    }
  };
  function shouldComposeModelMatrix(viewport, coordinateSystem) {
    return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
  }

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-uniforms.ts
  var uniformBlock17 = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`;
  var simpleMeshUniforms = {
    name: "simpleMesh",
    vs: uniformBlock17,
    fs: uniformBlock17,
    uniformTypes: {
      sizeScale: "f32",
      composeModelMatrix: "f32",
      hasTexture: "f32",
      flatShading: "f32"
    }
  };

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts
  var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project.cameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
  vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;

  if (simpleMesh.composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts
  var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform sampler2D sampler;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (simpleMesh.flatShading) {

  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
  } else {
    normal = normals_commonspace;
  }

  vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts
  function normalizeGeometryAttributes(attributes) {
    const positionAttribute = attributes.positions || attributes.POSITION;
    log_default.assert(positionAttribute, 'no "postions" or "POSITION" attribute in mesh');
    const vertexCount = positionAttribute.value.length / positionAttribute.size;
    let colorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!colorAttribute) {
      colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };
    }
    let normalAttribute = attributes.NORMAL || attributes.normals;
    if (!normalAttribute) {
      normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };
    }
    let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;
    if (!texCoordAttribute) {
      texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };
    }
    return {
      positions: positionAttribute,
      colors: colorAttribute,
      normals: normalAttribute,
      texCoords: texCoordAttribute
    };
  }
  function getGeometry(data) {
    if (data instanceof Geometry) {
      data.attributes = normalizeGeometryAttributes(data.attributes);
      return data;
    } else if (data.attributes) {
      return new Geometry({
        ...data,
        topology: "triangle-list",
        attributes: normalizeGeometryAttributes(data.attributes)
      });
    } else {
      return new Geometry({
        topology: "triangle-list",
        attributes: normalizeGeometryAttributes(data)
      });
    }
  }
  var DEFAULT_COLOR10 = [0, 0, 0, 255];
  var defaultProps27 = {
    mesh: { type: "object", value: null, async: true },
    texture: { type: "image", value: null, async: true },
    sizeScale: { type: "number", value: 1, min: 0 },
    // _instanced is a hack to use world position instead of meter offsets in mesh
    // TODO - formalize API
    _instanced: true,
    // NOTE(Tarek): Quick and dirty wireframe. Just draws
    // the same mesh with LINE_STRIPS. Won't follow edges
    // of the original mesh.
    wireframe: false,
    // Optional material for 'lighting' shader module
    material: true,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR10 },
    // yaw, pitch and roll are in degrees
    // https://en.wikipedia.org/wiki/Euler_angles
    // [pitch, yaw, roll]
    getOrientation: { type: "accessor", value: [0, 0, 0] },
    getScale: { type: "accessor", value: [1, 1, 1] },
    getTranslation: { type: "accessor", value: [0, 0, 0] },
    // 4x4 matrix
    getTransformMatrix: { type: "accessor", value: [] },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var SimpleMeshLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: simple_mesh_layer_vertex_glsl_default,
        fs: simple_mesh_layer_fragment_glsl_default,
        modules: [project32_default, phongMaterial, picking_default, simpleMeshUniforms]
      });
    }
    getBounds() {
      if (this.props._instanced) {
        return super.getBounds();
      }
      let result = this.state.positionBounds;
      if (result) {
        return result;
      }
      const { mesh } = this.props;
      if (!mesh) {
        return null;
      }
      result = mesh.header?.boundingBox;
      if (!result) {
        const { attributes } = getGeometry(mesh);
        attributes.POSITION = attributes.POSITION || attributes.positions;
        result = getMeshBoundingBox(attributes);
      }
      this.state.positionBounds = result;
      return result;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          transition: true,
          type: "float64",
          fp64: this.use64bitPositions(),
          size: 3,
          accessor: "getPosition"
        },
        instanceColors: {
          type: "unorm8",
          transition: true,
          size: this.props.colorFormat.length,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
      this.setState({
        // Avoid luma.gl's missing uniform warning
        // TODO - add feature to luma.gl to specify ignored uniforms?
        emptyTexture: this.context.device.createTexture({
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
        this.state.positionBounds = null;
        this.state.model?.destroy();
        if (props.mesh) {
          this.state.model = this.getModel(props.mesh);
          const attributes = props.mesh.attributes || props.mesh;
          this.setState({
            hasNormals: Boolean(attributes.NORMAL || attributes.normals)
          });
        }
        this.getAttributeManager().invalidateAll();
      }
      if (props.texture !== oldProps.texture && props.texture instanceof Texture) {
        this.setTexture(props.texture);
      }
      if (this.state.model) {
        this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.emptyTexture.delete();
    }
    draw({ uniforms }) {
      const { model } = this.state;
      if (!model) {
        return;
      }
      const { viewport, renderPass } = this.context;
      const { sizeScale, coordinateSystem, _instanced } = this.props;
      const simpleMeshProps = {
        sizeScale,
        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
        flatShading: !this.state.hasNormals
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
      model.draw(renderPass);
    }
    get isLoaded() {
      return Boolean(this.state?.model && super.isLoaded);
    }
    getModel(mesh) {
      const model = new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: getGeometry(mesh),
        isInstanced: true
      });
      const { texture } = this.props;
      const { emptyTexture } = this.state;
      const simpleMeshProps = {
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
      return model;
    }
    setTexture(texture) {
      const { emptyTexture, model } = this.state;
      if (model) {
        const simpleMeshProps = {
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        };
        model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
      }
    }
  };
  SimpleMeshLayer.defaultProps = defaultProps27;
  SimpleMeshLayer.layerName = "SimpleMeshLayer";

  // ../../node_modules/@luma.gl/gltf/dist/pbr/parse-pbr-material.js
  var GLEnum2;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum4[GLEnum4["ONE"] = 1] = "ONE";
    GLEnum4[GLEnum4["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum4[GLEnum4["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum4[GLEnum4["LINEAR"] = 9729] = "LINEAR";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  })(GLEnum2 || (GLEnum2 = {}));
  function parsePBRMaterial(device, material, attributes, options) {
    const parsedMaterial = {
      defines: {
        // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
        MANUAL_SRGB: 1,
        SRGB_FAST_APPROXIMATION: 1
      },
      bindings: {},
      uniforms: {
        // TODO: find better values?
        camera: [0, 0, 0],
        // Model should override
        metallicRoughnessValues: [1, 1]
        // Default is 1 and 1
      },
      parameters: {},
      glParameters: {},
      generatedTextures: []
    };
    parsedMaterial.defines.USE_TEX_LOD = 1;
    const { imageBasedLightingEnvironment } = options;
    if (imageBasedLightingEnvironment) {
      parsedMaterial.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler.texture;
      parsedMaterial.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler.texture;
      parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;
      parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];
    }
    if (options?.pbrDebug) {
      parsedMaterial.defines.PBR_DEBUG = 1;
      parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];
      parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];
    }
    if (attributes.NORMAL)
      parsedMaterial.defines.HAS_NORMALS = 1;
    if (attributes.TANGENT && options?.useTangents)
      parsedMaterial.defines.HAS_TANGENTS = 1;
    if (attributes.TEXCOORD_0)
      parsedMaterial.defines.HAS_UV = 1;
    if (options?.imageBasedLightingEnvironment)
      parsedMaterial.defines.USE_IBL = 1;
    if (options?.lights)
      parsedMaterial.defines.USE_LIGHTS = 1;
    if (material) {
      parseMaterial(device, material, parsedMaterial);
    }
    return parsedMaterial;
  }
  function parseMaterial(device, material, parsedMaterial) {
    parsedMaterial.uniforms.unlit = Boolean(material.unlit);
    if (material.pbrMetallicRoughness) {
      parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);
    }
    if (material.normalTexture) {
      addTexture(device, material.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", parsedMaterial);
      const { scale: scale22 = 1 } = material.normalTexture;
      parsedMaterial.uniforms.normalScale = scale22;
    }
    if (material.occlusionTexture) {
      addTexture(device, material.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", parsedMaterial);
      const { strength = 1 } = material.occlusionTexture;
      parsedMaterial.uniforms.occlusionStrength = strength;
    }
    if (material.emissiveTexture) {
      addTexture(device, material.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", parsedMaterial);
      parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];
    }
    switch (material.alphaMode) {
      case "MASK":
        const { alphaCutoff = 0.5 } = material;
        parsedMaterial.defines.ALPHA_CUTOFF = 1;
        parsedMaterial.uniforms.alphaCutoff = alphaCutoff;
        break;
      case "BLEND":
        log2.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")();
        parsedMaterial.parameters.blendColorOperation = "add";
        parsedMaterial.parameters.blendColorSrcFactor = "src-alpha";
        parsedMaterial.parameters.blendColorDstFactor = "one-minus-src-alpha";
        parsedMaterial.parameters.blendAlphaOperation = "add";
        parsedMaterial.parameters.blendAlphaSrcFactor = "one";
        parsedMaterial.parameters.blendAlphaDstFactor = "one-minus-src-alpha";
        parsedMaterial.glParameters.blend = true;
        parsedMaterial.glParameters.blendEquation = GLEnum2.FUNC_ADD;
        parsedMaterial.glParameters.blendFunc = [
          GLEnum2.SRC_ALPHA,
          GLEnum2.ONE_MINUS_SRC_ALPHA,
          GLEnum2.ONE,
          GLEnum2.ONE_MINUS_SRC_ALPHA
        ];
        break;
    }
  }
  function parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {
    if (pbrMetallicRoughness.baseColorTexture) {
      addTexture(device, pbrMetallicRoughness.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", parsedMaterial);
    }
    parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
    if (pbrMetallicRoughness.metallicRoughnessTexture) {
      addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", parsedMaterial);
    }
    const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;
    parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];
  }
  function addTexture(device, gltfTexture, uniformName, define2 = null, parsedMaterial) {
    const parameters2 = gltfTexture?.texture?.sampler?.parameters || {};
    const image = gltfTexture.texture.source.image;
    let textureOptions;
    let specialTextureParameters = {};
    if (image.compressed) {
      textureOptions = image;
      specialTextureParameters = {
        [GLEnum2.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum2.LINEAR_MIPMAP_NEAREST : GLEnum2.LINEAR
      };
    } else {
      textureOptions = { data: image };
    }
    const texture = device.createTexture({
      id: gltfTexture.uniformName || gltfTexture.id,
      parameters: {
        ...parameters2,
        ...specialTextureParameters
      },
      pixelStore: {
        [GLEnum2.UNPACK_FLIP_Y_WEBGL]: false
      },
      ...textureOptions
    });
    parsedMaterial.bindings[uniformName] = texture;
    if (define2)
      parsedMaterial.defines[define2] = 1;
    parsedMaterial.generatedTextures.push(texture);
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/utils/version.js
  var VERSION8 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
  var BASIS_EXTERNAL_LIBRARIES = {
    /** Basis transcoder, javascript wrapper part */
    TRANSCODER: "basis_transcoder.js",
    /** Basis transcoder, compiled web assembly part */
    TRANSCODER_WASM: "basis_transcoder.wasm",
    /** Basis encoder, javascript wrapper part */
    ENCODER: "basis_encoder.js",
    /** Basis encoder, compiled web assembly part */
    ENCODER_WASM: "basis_encoder.wasm"
  };
  var loadBasisTranscoderPromise;
  async function loadBasisTranscoderModule(options) {
    registerJSModules(options.modules);
    const basis = getJSModuleOrNull("basis");
    if (basis) {
      return basis;
    }
    loadBasisTranscoderPromise ||= loadBasisTranscoder(options);
    return await loadBasisTranscoderPromise;
  }
  async function loadBasisTranscoder(options) {
    let BASIS = null;
    let wasmBinary = null;
    [BASIS, wasmBinary] = await Promise.all([
      await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
      await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
    ]);
    BASIS = BASIS || globalThis.BASIS;
    return await initializeBasisTranscoderModule(BASIS, wasmBinary);
  }
  function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisModule(options).then((module) => {
        const { BasisFile, initializeBasis } = module;
        initializeBasis();
        resolve2({ BasisFile });
      });
    });
  }
  var loadBasisEncoderPromise;
  async function loadBasisEncoderModule(options) {
    const modules = options.modules || {};
    if (modules.basisEncoder) {
      return modules.basisEncoder;
    }
    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
    return await loadBasisEncoderPromise;
  }
  async function loadBasisEncoder(options) {
    let BASIS_ENCODER = null;
    let wasmBinary = null;
    [BASIS_ENCODER, wasmBinary] = await Promise.all([
      await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
      await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
    ]);
    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
  }
  function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisEncoderModule(options).then((module) => {
        const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module;
        initializeBasis();
        resolve2({ BasisFile, KTX2File, BasisEncoder });
      });
    });
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
  var GL_EXTENSIONS_CONSTANTS = {
    // WEBGL_compressed_texture_s3tc
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    // WEBGL_compressed_texture_es3
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    // WEBGL_compressed_texture_pvrtc
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    // WEBGL_compressed_texture_etc1
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    // WEBGL_compressed_texture_atc
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    // WEBGL_compressed_texture_astc
    COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
    COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
    COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
    COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
    COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
    COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
    COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
    COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
    COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
    COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
    COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
    COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
    COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
    COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
    // EXT_texture_compression_rgtc
    COMPRESSED_RED_RGTC1_EXT: 36283,
    COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
    COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
    // WEBGL_compressed_texture_s3tc_srgb
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
  };

  // ../../node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
  var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
  var WEBGL_EXTENSIONS = {
    /* eslint-disable camelcase */
    WEBGL_compressed_texture_s3tc: "dxt",
    WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
    WEBGL_compressed_texture_etc1: "etc1",
    WEBGL_compressed_texture_etc: "etc2",
    WEBGL_compressed_texture_pvrtc: "pvrtc",
    WEBGL_compressed_texture_atc: "atc",
    WEBGL_compressed_texture_astc: "astc",
    EXT_texture_compression_rgtc: "rgtc"
    /* eslint-enable camelcase */
  };
  var formats = null;
  function getSupportedGPUTextureFormats(gl) {
    if (!formats) {
      gl = gl || getWebGLContext() || void 0;
      formats = /* @__PURE__ */ new Set();
      for (const prefix of BROWSER_PREFIXES) {
        for (const extension in WEBGL_EXTENSIONS) {
          if (gl && gl.getExtension(`${prefix}${extension}`)) {
            const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
            formats.add(gpuTextureFormat);
          }
        }
      }
    }
    return formats;
  }
  function getWebGLContext() {
    try {
      const canvas2 = document.createElement("canvas");
      return canvas2.getContext("webgl");
    } catch (error) {
      return null;
    }
  }

  // ../../node_modules/ktx-parse/dist/ktx-parse.modern.js
  var t = new Uint8Array([0]);
  var n;
  var i;
  var s;
  var a;
  var r;
  var o;
  var l;
  var f;
  !function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.BASISLZ = 1] = "BASISLZ", t3[t3.ZSTD = 2] = "ZSTD", t3[t3.ZLIB = 3] = "ZLIB";
  }(n || (n = {})), function(t3) {
    t3[t3.BASICFORMAT = 0] = "BASICFORMAT";
  }(i || (i = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.ETC1S = 163] = "ETC1S", t3[t3.UASTC = 166] = "UASTC";
  }(s || (s = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.SRGB = 1] = "SRGB";
  }(a || (a = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.LINEAR = 1] = "LINEAR", t3[t3.SRGB = 2] = "SRGB", t3[t3.ITU = 3] = "ITU", t3[t3.NTSC = 4] = "NTSC", t3[t3.SLOG = 5] = "SLOG", t3[t3.SLOG2 = 6] = "SLOG2";
  }(r || (r = {})), function(t3) {
    t3[t3.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t3[t3.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
  }(o || (o = {})), function(t3) {
    t3[t3.RGB = 0] = "RGB", t3[t3.RRR = 3] = "RRR", t3[t3.GGG = 4] = "GGG", t3[t3.AAA = 15] = "AAA";
  }(l || (l = {})), function(t3) {
    t3[t3.RGB = 0] = "RGB", t3[t3.RGBA = 3] = "RGBA", t3[t3.RRR = 4] = "RRR", t3[t3.RRRG = 5] = "RRRG";
  }(f || (f = {}));

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
  var KTX2_ID = [
    // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
    171,
    75,
    84,
    88,
    32,
    50,
    48,
    187,
    13,
    10,
    26,
    10
  ];
  function isKTX(data) {
    const id = new Uint8Array(data);
    const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || // ''
    id[1] !== KTX2_ID[1] || // 'K'
    id[2] !== KTX2_ID[2] || // 'T'
    id[3] !== KTX2_ID[3] || // 'X'
    id[4] !== KTX2_ID[4] || // ' '
    id[5] !== KTX2_ID[5] || // '2'
    id[6] !== KTX2_ID[6] || // '0'
    id[7] !== KTX2_ID[7] || // ''
    id[8] !== KTX2_ID[8] || // '\r'
    id[9] !== KTX2_ID[9] || // '\n'
    id[10] !== KTX2_ID[10] || // '\x1A'
    id[11] !== KTX2_ID[11];
    return !notKTX;
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
  var OutputFormat = {
    etc1: {
      basisFormat: 0,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
    },
    etc2: { basisFormat: 1, compressed: true },
    bc1: {
      basisFormat: 2,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
    },
    bc3: {
      basisFormat: 3,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    bc4: { basisFormat: 4, compressed: true },
    bc5: { basisFormat: 5, compressed: true },
    "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
    "bc7-m5": { basisFormat: 7, compressed: true },
    "pvrtc1-4-rgb": {
      basisFormat: 8,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
    },
    "pvrtc1-4-rgba": {
      basisFormat: 9,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    },
    "astc-4x4": {
      basisFormat: 10,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
    },
    "atc-rgb": { basisFormat: 11, compressed: true },
    "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
    rgba32: { basisFormat: 13, compressed: false },
    rgb565: { basisFormat: 14, compressed: false },
    bgr565: { basisFormat: 15, compressed: false },
    rgba4444: { basisFormat: 16, compressed: false }
  };
  async function parseBasis(data, options) {
    if (options.basis.containerFormat === "auto") {
      if (isKTX(data)) {
        const fileConstructors = await loadBasisEncoderModule(options);
        return parseKTX2File(fileConstructors.KTX2File, data, options);
      }
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
    }
    switch (options.basis.module) {
      case "encoder":
        const fileConstructors = await loadBasisEncoderModule(options);
        switch (options.basis.containerFormat) {
          case "ktx2":
            return parseKTX2File(fileConstructors.KTX2File, data, options);
          case "basis":
          default:
            return parseBasisFile(fileConstructors.BasisFile, data, options);
        }
      case "transcoder":
      default:
        const { BasisFile } = await loadBasisTranscoderModule(options);
        return parseBasisFile(BasisFile, data, options);
    }
  }
  function parseBasisFile(BasisFile, data, options) {
    const basisFile = new BasisFile(new Uint8Array(data));
    try {
      if (!basisFile.startTranscoding()) {
        throw new Error("Failed to start basis transcoding");
      }
      const imageCount = basisFile.getNumImages();
      const images = [];
      for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
        const levelsCount = basisFile.getNumLevels(imageIndex);
        const levels = [];
        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
          levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
        }
        images.push(levels);
      }
      return images;
    } finally {
      basisFile.close();
      basisFile.delete();
    }
  }
  function transcodeImage(basisFile, imageIndex, levelIndex, options) {
    const width = basisFile.getImageWidth(imageIndex, levelIndex);
    const height = basisFile.getImageHeight(imageIndex, levelIndex);
    const hasAlpha = basisFile.getHasAlpha(
      /* imageIndex, levelIndex */
    );
    const { compressed, format, basisFormat } = getBasisOptions(options, hasAlpha);
    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
      throw new Error("failed to start Basis transcoding");
    }
    return {
      // standard loaders.gl image category payload
      width,
      height,
      data: decodedData,
      compressed,
      format,
      // Additional fields
      // Add levelSize field.
      hasAlpha
    };
  }
  function parseKTX2File(KTX2File, data, options) {
    const ktx2File = new KTX2File(new Uint8Array(data));
    try {
      if (!ktx2File.startTranscoding()) {
        throw new Error("failed to start KTX2 transcoding");
      }
      const levelsCount = ktx2File.getLevels();
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
        break;
      }
      return [levels];
    } finally {
      ktx2File.close();
      ktx2File.delete();
    }
  }
  function transcodeKTX2Image(ktx2File, levelIndex, options) {
    const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
    const { compressed, format, basisFormat } = getBasisOptions(options, alphaFlag);
    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!ktx2File.transcodeImage(
      decodedData,
      levelIndex,
      0,
      0,
      basisFormat,
      0,
      -1,
      -1
      /* channel1 */
    )) {
      throw new Error("Failed to transcode KTX2 image");
    }
    return {
      // standard loaders.gl image category payload
      width,
      height,
      data: decodedData,
      compressed,
      // Additional fields
      levelSize: decodedSize,
      hasAlpha: alphaFlag,
      format
    };
  }
  function getBasisOptions(options, hasAlpha) {
    let format = options && options.basis && options.basis.format;
    if (format === "auto") {
      format = selectSupportedBasisFormat();
    }
    if (typeof format === "object") {
      format = hasAlpha ? format.alpha : format.noAlpha;
    }
    format = format.toLowerCase();
    return OutputFormat[format];
  }
  function selectSupportedBasisFormat() {
    const supportedFormats = getSupportedGPUTextureFormats();
    if (supportedFormats.has("astc")) {
      return "astc-4x4";
    } else if (supportedFormats.has("dxt")) {
      return {
        alpha: "bc3",
        noAlpha: "bc1"
      };
    } else if (supportedFormats.has("pvrtc")) {
      return {
        alpha: "pvrtc1-4-rgba",
        noAlpha: "pvrtc1-4-rgb"
      };
    } else if (supportedFormats.has("etc1")) {
      return "etc1";
    } else if (supportedFormats.has("etc2")) {
      return "etc2";
    }
    return "rgb565";
  }

  // ../../node_modules/@loaders.gl/textures/dist/basis-loader.js
  var BasisWorkerLoader = {
    dataType: null,
    batchType: null,
    name: "Basis",
    id: "basis",
    module: "textures",
    version: VERSION8,
    worker: true,
    extensions: ["basis", "ktx2"],
    mimeTypes: ["application/octet-stream", "image/ktx2"],
    tests: ["sB"],
    binary: true,
    options: {
      basis: {
        format: "auto",
        libraryPath: "libs/",
        containerFormat: "auto",
        module: "transcoder"
      }
    }
  };
  var BasisLoader = {
    ...BasisWorkerLoader,
    parse: parseBasis
  };

  // ../../node_modules/@luma.gl/gltf/dist/gltf/gltf-animator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var GLTFAnimation = class {
    name;
    startTime = 0;
    playing = true;
    speed = 1;
    channels = [];
    constructor(props) {
      Object.assign(this, props);
    }
    animate(timeMs) {
      if (!this.playing) {
        return;
      }
      const absTime = timeMs / 1e3;
      const time = (absTime - this.startTime) * this.speed;
      this.channels.forEach(({ sampler, target: target2, path }) => {
        interpolate(time, sampler, target2, path);
        applyTranslationRotationScale(target2, target2._node);
      });
    }
  };
  var GLTFAnimator = class {
    animations;
    constructor(gltf) {
      this.animations = gltf.animations.map((animation, index) => {
        const name13 = animation.name || `Animation-${index}`;
        const samplers = animation.samplers.map(({ input, interpolation = "LINEAR", output }) => ({
          input: accessorToJsArray(gltf.accessors[input]),
          interpolation,
          output: accessorToJsArray(gltf.accessors[output])
        }));
        const channels = animation.channels.map(({ sampler, target: target2 }) => ({
          sampler: samplers[sampler],
          target: gltf.nodes[target2.node],
          path: target2.path
        }));
        return new GLTFAnimation({ name: name13, channels });
      });
    }
    /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
    animate(time) {
      this.setTime(time);
    }
    setTime(time) {
      this.animations.forEach((animation) => animation.animate(time));
    }
    getAnimations() {
      return this.animations;
    }
  };
  function accessorToJsArray(accessor) {
    if (!accessor._animation) {
      const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
      const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
      const length16 = components * accessor.count;
      const { buffer, byteOffset } = accessor.bufferView.data;
      const array = new ArrayType2(buffer, byteOffset + (accessor.byteOffset || 0), length16);
      if (components === 1) {
        accessor._animation = Array.from(array);
      } else {
        const slicedArray = [];
        for (let i5 = 0; i5 < array.length; i5 += components) {
          slicedArray.push(Array.from(array.slice(i5, i5 + components)));
        }
        accessor._animation = slicedArray;
      }
    }
    return accessor._animation;
  }
  var helperMatrix = new Matrix4();
  function applyTranslationRotationScale(gltfNode, node) {
    node.matrix.identity();
    if (gltfNode.translation) {
      node.matrix.translate(gltfNode.translation);
    }
    if (gltfNode.rotation) {
      const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
      node.matrix.multiplyRight(rotationMatrix);
    }
    if (gltfNode.scale) {
      node.matrix.scale(gltfNode.scale);
    }
  }
  var quaternion = new Quaternion();
  function linearInterpolate(target2, path, start, stop, ratio) {
    if (path === "rotation") {
      quaternion.slerp({ start, target: stop, ratio });
      for (let i5 = 0; i5 < quaternion.length; i5++) {
        target2[path][i5] = quaternion[i5];
      }
    } else {
      for (let i5 = 0; i5 < start.length; i5++) {
        target2[path][i5] = ratio * stop[i5] + (1 - ratio) * start[i5];
      }
    }
  }
  function cubicsplineInterpolate(target2, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t3 }) {
    for (let i5 = 0; i5 < target2[path].length; i5++) {
      const m0 = outTangent0[i5] * tDiff;
      const m1 = inTangent1[i5] * tDiff;
      target2[path][i5] = (2 * Math.pow(t3, 3) - 3 * Math.pow(t3, 2) + 1) * p0[i5] + (Math.pow(t3, 3) - 2 * Math.pow(t3, 2) + t3) * m0 + (-2 * Math.pow(t3, 3) + 3 * Math.pow(t3, 2)) * p1[i5] + (Math.pow(t3, 3) - Math.pow(t3, 2)) * m1;
    }
  }
  function stepInterpolate(target2, path, value) {
    for (let i5 = 0; i5 < value.length; i5++) {
      target2[path][i5] = value[i5];
    }
  }
  function interpolate(time, { input, interpolation, output }, target2, path) {
    const maxTime = input[input.length - 1];
    const animationTime = time % maxTime;
    const nextIndex = input.findIndex((t3) => t3 >= animationTime);
    const previousIndex = Math.max(0, nextIndex - 1);
    if (!Array.isArray(target2[path])) {
      switch (path) {
        case "translation":
          target2[path] = [0, 0, 0];
          break;
        case "rotation":
          target2[path] = [0, 0, 0, 1];
          break;
        case "scale":
          target2[path] = [1, 1, 1];
          break;
        default:
          log2.warn(`Bad animation path ${path}`)();
      }
    }
    const previousTime = input[previousIndex];
    const nextTime = input[nextIndex];
    switch (interpolation) {
      case "STEP":
        stepInterpolate(target2, path, output[previousIndex]);
        break;
      case "LINEAR":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          linearInterpolate(target2, path, output[previousIndex], output[nextIndex], ratio);
        }
        break;
      case "CUBICSPLINE":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          const tDiff = nextTime - previousTime;
          const p0 = output[3 * previousIndex + 1];
          const outTangent0 = output[3 * previousIndex + 2];
          const inTangent1 = output[3 * nextIndex + 0];
          const p1 = output[3 * nextIndex + 1];
          cubicsplineInterpolate(target2, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });
        }
        break;
      default:
        log2.warn(`Interpolation ${interpolation} not supported`)();
        break;
    }
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/create-gltf-model.js
  var SHADER = (
    /* WGSL */
    `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
  );
  var vs8 = (
    /* glsl */
    `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
  );
  var fs6 = (
    /* glsl */
    `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
  );
  function createGLTFModel(device, options) {
    const { id, geometry, material, vertexCount, materialOptions, modelOptions } = options;
    const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);
    log2.info(4, "createGLTFModel defines: ", parsedMaterial.defines)();
    const managedResources = [];
    const parameters2 = {
      depthWriteEnabled: true,
      depthCompare: "less",
      depthFormat: "depth24plus",
      cullMode: "back"
    };
    const modelProps = {
      id,
      source: SHADER,
      vs: vs8,
      fs: fs6,
      geometry,
      topology: geometry.topology,
      vertexCount,
      modules: [pbrMaterial],
      ...modelOptions,
      defines: { ...parsedMaterial.defines, ...modelOptions.defines },
      parameters: { ...parameters2, ...parsedMaterial.parameters, ...modelOptions.parameters }
    };
    const model = new Model(device, modelProps);
    const { camera, ...pbrMaterialProps } = {
      ...parsedMaterial.uniforms,
      ...modelOptions.uniforms,
      ...parsedMaterial.bindings,
      ...modelOptions.bindings
    };
    model.shaderInputs.setProps({ pbrMaterial: pbrMaterialProps, pbrProjection: { camera } });
    return new ModelNode({ managedResources, model });
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/gl-utils.js
  var GLEnum3;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["POINTS"] = 0] = "POINTS";
    GLEnum4[GLEnum4["LINES"] = 1] = "LINES";
    GLEnum4[GLEnum4["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum4[GLEnum4["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum4[GLEnum4["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum4[GLEnum4["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum4[GLEnum4["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(GLEnum3 || (GLEnum3 = {}));
  function convertGLDrawModeToTopology(drawMode) {
    switch (drawMode) {
      case GLEnum3.POINTS:
        return "point-list";
      case GLEnum3.LINES:
        return "line-list";
      case GLEnum3.LINE_STRIP:
        return "line-strip";
      case GLEnum3.TRIANGLES:
        return "triangle-list";
      case GLEnum3.TRIANGLE_STRIP:
        return "triangle-strip";
      default:
        throw new Error(String(drawMode));
    }
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/gltf-instantiator.js
  var DEFAULT_OPTIONS2 = {
    modelOptions: {},
    pbrDebug: false,
    imageBasedLightingEnvironment: null,
    lights: true,
    useTangents: false
  };
  var GLTFInstantiator = class {
    device;
    options;
    gltf;
    constructor(device, options = {}) {
      this.device = device;
      this.options = { ...DEFAULT_OPTIONS2, ...options };
    }
    instantiate(gltf) {
      this.gltf = deepCopy(gltf);
      const scenes = (this.gltf.scenes || []).map((scene) => this.createScene(scene));
      return scenes;
    }
    createAnimator() {
      if (Array.isArray(this.gltf.animations)) {
        return new GLTFAnimator(this.gltf);
      }
      return null;
    }
    createScene(gltfScene) {
      const gltfNodes = gltfScene.nodes || [];
      const nodes = gltfNodes.map((node) => this.createNode(node));
      const scene = new GroupNode({
        id: gltfScene.name || gltfScene.id,
        children: nodes
      });
      return scene;
    }
    createNode(gltfNode) {
      if (!gltfNode._node) {
        const gltfChildren = gltfNode.children || [];
        const children = gltfChildren.map((child) => this.createNode(child));
        if (gltfNode.mesh) {
          children.push(this.createMesh(gltfNode.mesh));
        }
        const node = new GroupNode({
          id: gltfNode.name || gltfNode.id,
          children
        });
        if (gltfNode.matrix) {
          node.setMatrix(gltfNode.matrix);
        } else {
          node.matrix.identity();
          if (gltfNode.translation) {
            node.matrix.translate(gltfNode.translation);
          }
          if (gltfNode.rotation) {
            const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
            node.matrix.multiplyRight(rotationMatrix);
          }
          if (gltfNode.scale) {
            node.matrix.scale(gltfNode.scale);
          }
        }
        gltfNode._node = node;
      }
      const topLevelNode = this.gltf.nodes.find((node) => node.id === gltfNode.id);
      topLevelNode._node = gltfNode._node;
      return gltfNode._node;
    }
    createMesh(gltfMesh) {
      if (!gltfMesh._mesh) {
        const gltfPrimitives = gltfMesh.primitives || [];
        const primitives = gltfPrimitives.map((gltfPrimitive, i5) => this.createPrimitive(gltfPrimitive, i5, gltfMesh));
        const mesh = new GroupNode({
          id: gltfMesh.name || gltfMesh.id,
          children: primitives
        });
        gltfMesh._mesh = mesh;
      }
      return gltfMesh._mesh;
    }
    createPrimitive(gltfPrimitive, i5, gltfMesh) {
      const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i5}`;
      const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);
      const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes);
      const modelNode = createGLTFModel(this.device, {
        id,
        geometry: this.createGeometry(id, gltfPrimitive, topology),
        material: gltfPrimitive.material,
        materialOptions: this.options,
        modelOptions: this.options.modelOptions,
        vertexCount
      });
      modelNode.bounds = [
        gltfPrimitive.attributes.POSITION.min,
        gltfPrimitive.attributes.POSITION.max
      ];
      return modelNode;
    }
    getVertexCount(attributes) {
      throw new Error("getVertexCount not implemented");
    }
    createGeometry(id, gltfPrimitive, topology) {
      const attributes = {};
      for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {
        const { components, size, value } = attribute;
        attributes[attributeName] = { size: size ?? components, value };
      }
      return new Geometry({
        id,
        topology,
        indices: gltfPrimitive.indices.value,
        attributes
      });
    }
    createBuffer(attribute, usage) {
      if (!attribute.bufferView) {
        attribute.bufferView = {};
      }
      const { bufferView } = attribute;
      if (!bufferView.lumaBuffers) {
        bufferView.lumaBuffers = {};
      }
      if (!bufferView.lumaBuffers[usage]) {
        bufferView.lumaBuffers[usage] = this.device.createBuffer({
          id: `from-${bufferView.id}`,
          // Draco decoded files have attribute.value
          data: bufferView.data || attribute.value
        });
      }
      return bufferView.lumaBuffers[usage];
    }
    // TODO - create sampler in WebGL2
    createSampler(gltfSampler) {
      return gltfSampler;
    }
    // Helper methods (move to GLTFLoader.resolve...?)
    needsPOT() {
      return false;
    }
  };
  function deepCopy(object) {
    if (ArrayBuffer.isView(object) || object instanceof ArrayBuffer || object instanceof ImageBitmap) {
      return object;
    }
    if (Array.isArray(object)) {
      return object.map(deepCopy);
    }
    if (object && typeof object === "object") {
      const result = {};
      for (const key in object) {
        result[key] = deepCopy(object[key]);
      }
      return result;
    }
    return object;
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/create-gltf-objects.js
  function createScenegraphsFromGLTF(device, gltf, options) {
    const instantiator = new GLTFInstantiator(device, options);
    const scenes = instantiator.instantiate(gltf);
    const animator = instantiator.createAnimator();
    return { scenes, animator };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
  var EXT_mesh_features_exports = {};
  __export(EXT_mesh_features_exports, {
    decode: () => decode,
    name: () => name2
  });

  // ../../node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
  function assert9(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "assert failed: gltf");
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
  var COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES = {
    5120: 1,
    // BYTE
    5121: 1,
    // UNSIGNED_BYTE
    5122: 2,
    // SHORT
    5123: 2,
    // UNSIGNED_SHORT
    5125: 4,
    // UNSIGNED_INT
    5126: 4
    // FLOAT
  };

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
  var MIPMAP_FACTOR = 1.33;
  var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
  var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [
    [Int8Array, 5120],
    [Uint8Array, 5121],
    [Int16Array, 5122],
    [Uint16Array, 5123],
    [Uint32Array, 5125],
    [Float32Array, 5126],
    [Float64Array, 5130]
  ];
  var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
  var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function getAccessorTypeFromSize(size) {
    const type = TYPES[size - 1];
    return type || TYPES[0];
  }
  function getComponentTypeFromArray(typedArray) {
    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
    if (!componentType) {
      throw new Error("Illegal typed array");
    }
    return componentType;
  }
  function getAccessorArrayTypeAndLength(accessor, bufferView) {
    const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
    const length16 = accessor.count * components;
    const byteLength = accessor.count * components * bytesPerComponent;
    assert9(byteLength >= 0 && byteLength <= bufferView.byteLength);
    const componentByteSize = BYTES[accessor.componentType];
    const numberOfComponentsInElement = COMPONENTS[accessor.type];
    return { ArrayType: ArrayType2, length: length16, byteLength, componentByteSize, numberOfComponentsInElement };
  }
  function getMemoryUsageGLTF(gltf) {
    let { images, bufferViews } = gltf;
    images = images || [];
    bufferViews = bufferViews || [];
    const imageBufferViews = images.map((i5) => i5.bufferView);
    bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));
    const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);
    const pixelCount = images.reduce((acc, image) => {
      const { width, height } = image.image;
      return acc + width * height;
    }, 0);
    return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
  function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
    const bufferView = json.bufferViews[bufferViewIndex];
    assert9(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = buffers[bufferIndex];
    assert9(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  function getTypedArrayForAccessor(json, buffers, accessor) {
    const gltfAccessor = typeof accessor === "number" ? json.accessors?.[accessor] : accessor;
    if (!gltfAccessor) {
      throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
    }
    const bufferView = json.bufferViews?.[gltfAccessor.bufferView || 0];
    if (!bufferView) {
      throw new Error(`No gltf buffer view for accessor ${bufferView}`);
    }
    const { arrayBuffer: arrayBuffer2, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];
    const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
    const { ArrayType: ArrayType2, length: length16, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
    const elementByteSize = componentByteSize * numberOfComponentsInElement;
    const elementAddressScale = bufferView.byteStride || elementByteSize;
    if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
      const result2 = new ArrayType2(arrayBuffer2, byteOffset, length16);
      return result2;
    }
    const result = new ArrayType2(length16);
    for (let i5 = 0; i5 < gltfAccessor.count; i5++) {
      const values = new ArrayType2(arrayBuffer2, byteOffset + i5 * elementAddressScale, numberOfComponentsInElement);
      result.set(values, i5 * numberOfComponentsInElement);
    }
    return result;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
  function makeDefaultGLTFJson() {
    return {
      asset: {
        version: "2.0",
        generator: "loaders.gl"
      },
      buffers: [],
      extensions: {},
      extensionsRequired: [],
      extensionsUsed: []
    };
  }
  var GLTFScenegraph = class {
    // internal
    gltf;
    sourceBuffers;
    byteLength;
    // TODO - why is this not GLTFWithBuffers - what happens to images?
    constructor(gltf) {
      this.gltf = {
        json: gltf?.json || makeDefaultGLTFJson(),
        buffers: gltf?.buffers || [],
        images: gltf?.images || []
      };
      this.sourceBuffers = [];
      this.byteLength = 0;
      if (this.gltf.buffers && this.gltf.buffers[0]) {
        this.byteLength = this.gltf.buffers[0].byteLength;
        this.sourceBuffers = [this.gltf.buffers[0]];
      }
    }
    // Accessors
    get json() {
      return this.gltf.json;
    }
    getApplicationData(key) {
      const data = this.json[key];
      return data;
    }
    getExtraData(key) {
      const extras = this.json.extras || {};
      return extras[key];
    }
    hasExtension(extensionName) {
      const isUsedExtension = this.getUsedExtensions().find((name13) => name13 === extensionName);
      const isRequiredExtension = this.getRequiredExtensions().find((name13) => name13 === extensionName);
      return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
    }
    getExtension(extensionName) {
      const isExtension = this.getUsedExtensions().find((name13) => name13 === extensionName);
      const extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] : null;
    }
    getRequiredExtension(extensionName) {
      const isRequired = this.getRequiredExtensions().find((name13) => name13 === extensionName);
      return isRequired ? this.getExtension(extensionName) : null;
    }
    getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
    getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
    getRemovedExtensions() {
      return this.json.extensionsRemoved || [];
    }
    getObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      return extensions[extensionName];
    }
    getScene(index) {
      return this.getObject("scenes", index);
    }
    getNode(index) {
      return this.getObject("nodes", index);
    }
    getSkin(index) {
      return this.getObject("skins", index);
    }
    getMesh(index) {
      return this.getObject("meshes", index);
    }
    getMaterial(index) {
      return this.getObject("materials", index);
    }
    getAccessor(index) {
      return this.getObject("accessors", index);
    }
    // getCamera(index: number): object | null {
    //   return null; // TODO: fix thi: object  as null;
    // }
    getTexture(index) {
      return this.getObject("textures", index);
    }
    getSampler(index) {
      return this.getObject("samplers", index);
    }
    getImage(index) {
      return this.getObject("images", index);
    }
    getBufferView(index) {
      return this.getObject("bufferViews", index);
    }
    getBuffer(index) {
      return this.getObject("buffers", index);
    }
    getObject(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        throw new Error(`glTF file error: Could not find ${array}[${index}]`);
      }
      return object;
    }
    /**
     * Accepts buffer view index or buffer view object
     * @returns a `Uint8Array`
     */
    getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      const bufferIndex = bufferView.buffer;
      const binChunk = this.gltf.buffers[bufferIndex];
      assert9(binChunk);
      const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
    /** Accepts accessor index or accessor object
     * @returns a typed array with type that matches the types
     */
    getTypedArrayForAccessor(accessor) {
      const gltfAccessor = this.getAccessor(accessor);
      return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
    }
    /** accepts accessor index or accessor object
     * returns a `Uint8Array`
     */
    getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      const bufferView = this.getBufferView(image.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
    }
    // MODIFERS
    /**
     * Add an extra application-defined key to the top-level data structure
     */
    addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
    /**
     * `extras` - Standard GLTF field for storing application specific data
     */
    addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
    addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
    setObjectExtension(object, extensionName, data) {
      const extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
    removeObjectExtension(object, extensionName) {
      const extensions = object?.extensions || {};
      if (extensions[extensionName]) {
        this.json.extensionsRemoved = this.json.extensionsRemoved || [];
        const extensionsRemoved = this.json.extensionsRemoved;
        if (!extensionsRemoved.includes(extensionName)) {
          extensionsRemoved.push(extensionName);
        }
      }
      delete extensions[extensionName];
    }
    /**
     * Add to standard GLTF top level extension object, mark as used
     */
    addExtension(extensionName, extensionData = {}) {
      assert9(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
    /**
     * Standard GLTF top level extension object, mark as used and required
     */
    addRequiredExtension(extensionName, extensionData = {}) {
      assert9(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
    /**
     * Add extensionName to list of used extensions
     */
    registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];
      if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
    /**
     * Add extensionName to list of required extensions
     */
    registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];
      if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
    /**
     * Removes an extension from the top-level list
     */
    removeExtension(extensionName) {
      if (this.json.extensions?.[extensionName]) {
        this.json.extensionsRemoved = this.json.extensionsRemoved || [];
        const extensionsRemoved = this.json.extensionsRemoved;
        if (!extensionsRemoved.includes(extensionName)) {
          extensionsRemoved.push(extensionName);
        }
      }
      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }
      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }
    }
    /**
     *  Set default scene which is to be displayed at load time
     */
    setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
    /**
     * @todo: add more properties for scene initialization:
     *   name`, `extensions`, `extras`
     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
     */
    addScene(scene) {
      const { nodeIndices } = scene;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({ nodes: nodeIndices });
      return this.json.scenes.length - 1;
    }
    /**
     * @todo: add more properties for node initialization:
     *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
     */
    addNode(node) {
      const { meshIndex, matrix } = node;
      this.json.nodes = this.json.nodes || [];
      const nodeData = { mesh: meshIndex };
      if (matrix) {
        nodeData.matrix = matrix;
      }
      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
    /** Adds a mesh to the json part */
    addMesh(mesh) {
      const { attributes, indices, material, mode = 4 } = mesh;
      const accessors = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [
          {
            attributes: accessors,
            mode
          }
        ]
      };
      if (indices) {
        const indicesAccessor = this._addIndices(indices);
        glTFMesh.primitives[0].indices = indicesAccessor;
      }
      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addPointCloud(attributes) {
      const accessorIndices = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [
          {
            attributes: accessorIndices,
            mode: 0
            // GL.POINTS
          }
        ]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    /**
     * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
     * Buffer will be copied into BIN chunk during "pack"
     * Currently encodes as glTF image
     * @param imageData
     * @param mimeType
     */
    addImage(imageData, mimeTypeOpt) {
      const metadata = getBinaryImageMetadata(imageData);
      const mimeType = mimeTypeOpt || metadata?.mimeType;
      const bufferViewIndex = this.addBufferView(imageData);
      const glTFImage = {
        bufferView: bufferViewIndex,
        mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
    /**
     * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
     * @param buffer
     */
    addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {
      const byteLength = buffer.byteLength;
      assert9(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      const glTFBufferView = {
        buffer: bufferIndex,
        // Write offset from the start of the binary body
        byteOffset,
        byteLength
      };
      this.byteLength += padToNBytes(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
    /**
     * Adds an accessor to a bufferView
     * @param bufferViewIndex
     * @param accessor
     */
    addAccessor(bufferViewIndex, accessor) {
      const glTFAccessor = {
        bufferView: bufferViewIndex,
        // @ts-ignore
        type: getAccessorTypeFromSize(accessor.size),
        // @ts-ignore
        componentType: accessor.componentType,
        // @ts-ignore
        count: accessor.count,
        // @ts-ignore
        max: accessor.max,
        // @ts-ignore
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
    /**
     * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
     * Buffer will be copied into BIN chunk during "pack"
     * Currently encodes buffers as glTF accessors, but this could be optimized
     * @param sourceBuffer
     * @param accessor
     */
    addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {
      const bufferViewIndex = this.addBufferView(sourceBuffer);
      let minMax = { min: accessor.min, max: accessor.max };
      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }
      const accessorDefaults = {
        // @ts-ignore
        size: accessor.size,
        componentType: getComponentTypeFromArray(sourceBuffer),
        // @ts-ignore
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
    /**
     * Adds a texture to the json part
     * @todo: add more properties for texture initialization
     * `sampler`, `name`, `extensions`, `extras`
     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
     */
    addTexture(texture) {
      const { imageIndex } = texture;
      const glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
    /** Adds a material to the json part */
    addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
    /** Pack the binary chunk */
    createBinaryChunk() {
      this.gltf.buffers = [];
      const totalByteLength = this.byteLength;
      const arrayBuffer2 = new ArrayBuffer(totalByteLength);
      const targetArray = new Uint8Array(arrayBuffer2);
      let dstByteOffset = 0;
      for (const sourceBuffer of this.sourceBuffers || []) {
        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
      }
      if (this.json?.buffers?.[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{ byteLength: totalByteLength }];
      }
      this.gltf.binary = arrayBuffer2;
      this.sourceBuffers = [arrayBuffer2];
    }
    // PRIVATE
    _removeStringFromArray(array, string) {
      let found = true;
      while (found) {
        const index = array.indexOf(string);
        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
    /**
     * Add attributes to buffers and create `attributes` object which is part of `mesh`
     */
    _addAttributes(attributes = {}) {
      const result = {};
      for (const attributeKey in attributes) {
        const attributeData = attributes[attributeKey];
        const attrName = this._getGltfAttributeName(attributeKey);
        const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }
      return result;
    }
    /**
     * Add indices to buffers
     */
    _addIndices(indices) {
      return this.addBinaryBuffer(indices, { size: 1 });
    }
    /**
     * Deduce gltf specific attribue name from input attribute name
     */
    _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case "position":
        case "positions":
        case "vertices":
          return "POSITION";
        case "normal":
        case "normals":
          return "NORMAL";
        case "color":
        case "colors":
          return "COLOR_0";
        case "texcoord":
        case "texcoords":
          return "TEXCOORD_0";
        default:
          return attributeName;
      }
    }
    /**
     * Calculate `min` and `max` arrays of accessor according to spec:
     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
     */
    _getAccessorMinMax(buffer, size) {
      const result = { min: null, max: null };
      if (buffer.length < size) {
        return result;
      }
      result.min = [];
      result.max = [];
      const initValues = buffer.subarray(0, size);
      for (const value of initValues) {
        result.min.push(value);
        result.max.push(value);
      }
      for (let index = size; index < buffer.length; index += size) {
        for (let componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(
            // @ts-ignore
            result.min[0 + componentIndex],
            buffer[index + componentIndex]
          );
          result.max[0 + componentIndex] = Math.max(
            // @ts-ignore
            result.max[0 + componentIndex],
            buffer[index + componentIndex]
          );
        }
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
  function emod(n3) {
    return (n3 % 1 + 1) % 1;
  }
  var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
    BOOLEAN: 1,
    STRING: 1,
    ENUM: 1
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3 = {
    INT8: Int8Array,
    UINT8: Uint8Array,
    INT16: Int16Array,
    UINT16: Uint16Array,
    INT32: Int32Array,
    UINT32: Uint32Array,
    INT64: BigInt64Array,
    UINT64: BigUint64Array,
    FLOAT32: Float32Array,
    FLOAT64: Float64Array
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
    INT8: 1,
    UINT8: 1,
    INT16: 2,
    UINT16: 2,
    INT32: 4,
    UINT32: 4,
    INT64: 8,
    UINT64: 8,
    FLOAT32: 4,
    FLOAT64: 8
  };
  function getArrayElementByteSize(attributeType, componentType) {
    return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
  }
  function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
    if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
      return null;
    }
    const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
    const arrayOffsets = convertRawBufferToMetadataArray(
      arrayOffsetsBytes,
      "SCALAR",
      // offsets consist of ONE component
      offsetType,
      numberOfElements + 1
      // The number of offsets is equal to the property table `count` plus one.
    );
    if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
      return null;
    }
    return arrayOffsets;
  }
  function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {
    const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
    const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3[componentType];
    const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
    const length16 = elementCount * numberOfComponents;
    const byteLength = length16 * size;
    let buffer = data.buffer;
    let offset = data.byteOffset;
    if (offset % size !== 0) {
      const bufferArray = new Uint8Array(buffer);
      buffer = bufferArray.slice(offset, offset + byteLength).buffer;
      offset = 0;
    }
    return new ArrayType2(buffer, offset, length16);
  }
  function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
    const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
    const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
    const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
    const json = scenegraph.gltf.json;
    const textureIndex = textureInfo.index;
    const imageIndex = json.textures?.[textureIndex]?.source;
    if (typeof imageIndex !== "undefined") {
      const mimeType = json.images?.[imageIndex]?.mimeType;
      const parsedImage = scenegraph.gltf.images?.[imageIndex];
      if (parsedImage && typeof parsedImage.width !== "undefined") {
        const textureData = [];
        for (let index = 0; index < textureCoordinates.length; index += 2) {
          const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);
          textureData.push(value);
        }
        return textureData;
      }
    }
    return [];
  }
  function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
    if (!propertyData?.length) {
      return;
    }
    const featureIndices = [];
    for (const texelData of propertyData) {
      let index = featureTable.findIndex((item) => item === texelData);
      if (index === -1) {
        index = featureTable.push(texelData) - 1;
      }
      featureIndices.push(index);
    }
    const typedArray = new Uint32Array(featureIndices);
    const bufferIndex = scenegraph.gltf.buffers.push({
      arrayBuffer: typedArray.buffer,
      byteOffset: typedArray.byteOffset,
      byteLength: typedArray.byteLength
    }) - 1;
    const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
    const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
      size: 1,
      componentType: getComponentTypeFromArray(typedArray),
      count: typedArray.length
    });
    primitive.attributes[attributeName] = accessorIndex;
  }
  function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {
    const CHANNELS_MAP = {
      r: { offset: 0, shift: 0 },
      g: { offset: 1, shift: 8 },
      b: { offset: 2, shift: 16 },
      a: { offset: 3, shift: 24 }
    };
    const u3 = textureCoordinates[index];
    const v2 = textureCoordinates[index + 1];
    let components = 1;
    if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
      components = 4;
    const offset = coordinatesToOffset(u3, v2, parsedImage, components);
    let value = 0;
    for (const c2 of channels) {
      const map6 = typeof c2 === "number" ? Object.values(CHANNELS_MAP)[c2] : CHANNELS_MAP[c2];
      const imageOffset = offset + map6.offset;
      const imageData = getImageData(parsedImage);
      if (imageData.data.length <= imageOffset) {
        throw new Error(`${imageData.data.length} <= ${imageOffset}`);
      }
      const imageValue = imageData.data[imageOffset];
      value |= imageValue << map6.shift;
    }
    return value;
  }
  function coordinatesToOffset(u3, v2, parsedImage, componentsCount = 1) {
    const w2 = parsedImage.width;
    const iX = emod(u3) * (w2 - 1);
    const indX = Math.round(iX);
    const h4 = parsedImage.height;
    const iY = emod(v2) * (h4 - 1);
    const indY = Math.round(iY);
    const components = parsedImage.components ? parsedImage.components : componentsCount;
    const offset = (indY * w2 + indX) * components;
    return offset;
  }
  function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
    const attributeValueArray = [];
    for (let index = 0; index < numberOfElements; index++) {
      const arrayOffset = arrayOffsets[index];
      const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
      if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
        break;
      }
      const typedArrayOffset = arrayOffset / valueSize;
      const elementCount = arrayByteSize / valueSize;
      attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
    }
    return attributeValueArray;
  }
  function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
    const attributeValueArray = [];
    for (let index = 0; index < numberOfElements; index++) {
      const elementOffset = index * arrayCount;
      attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
    }
    return attributeValueArray;
  }
  function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
    if (arrayOffsets) {
      throw new Error("Not implemented - arrayOffsets for strings is specified");
    }
    if (stringOffsets) {
      const stringsArray = [];
      const textDecoder = new TextDecoder("utf8");
      let stringOffset = 0;
      for (let index = 0; index < numberOfElements; index++) {
        const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];
        if (stringByteSize + stringOffset <= valuesDataBytes.length) {
          const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
          const stringAttribute = textDecoder.decode(stringData);
          stringsArray.push(stringAttribute);
          stringOffset += stringByteSize;
        }
      }
      return stringsArray;
    }
    return [];
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
  var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
  var name2 = EXT_MESH_FEATURES_NAME;
  async function decode(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtMeshFeatures(scenegraph, options);
  }
  function decodeExtMeshFeatures(scenegraph, options) {
    const json = scenegraph.gltf.json;
    if (!json.meshes) {
      return;
    }
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processMeshPrimitiveFeatures(scenegraph, primitive, options);
      }
    }
  }
  function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
    if (!options?.gltf?.loadBuffers) {
      return;
    }
    const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];
    const featureIds = extension?.featureIds;
    if (!featureIds) {
      return;
    }
    for (const featureId of featureIds) {
      let featureIdData;
      if (typeof featureId.attribute !== "undefined") {
        const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
        const accessorIndex = primitive.attributes[accessorKey];
        featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
      } else if (typeof featureId.texture !== "undefined" && options?.gltf?.loadImages) {
        featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
      } else {
        featureIdData = [];
      }
      featureId.data = featureIdData;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
  var EXT_structural_metadata_exports = {};
  __export(EXT_structural_metadata_exports, {
    decode: () => decode2,
    name: () => name3
  });
  var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
  var name3 = EXT_STRUCTURAL_METADATA_NAME;
  async function decode2(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtStructuralMetadata(scenegraph, options);
  }
  function decodeExtStructuralMetadata(scenegraph, options) {
    if (!options.gltf?.loadBuffers) {
      return;
    }
    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
    if (!extension) {
      return;
    }
    if (options.gltf?.loadImages) {
      decodePropertyTextures(scenegraph, extension);
    }
    decodePropertyTables(scenegraph, extension);
  }
  function decodePropertyTextures(scenegraph, extension) {
    const propertyTextures = extension.propertyTextures;
    const json = scenegraph.gltf.json;
    if (propertyTextures && json.meshes) {
      for (const mesh of json.meshes) {
        for (const primitive of mesh.primitives) {
          processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
        }
      }
    }
  }
  function decodePropertyTables(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const propertyTables = extension.propertyTables;
    if (schemaClasses && propertyTables) {
      for (const schemaName in schemaClasses) {
        const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
        if (propertyTable) {
          processPropertyTable(scenegraph, schema, propertyTable);
        }
      }
    }
  }
  function findPropertyTableByClass(propertyTables, schemaClassName) {
    for (const propertyTable of propertyTables) {
      if (propertyTable.class === schemaClassName) {
        return propertyTable;
      }
    }
    return null;
  }
  function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
    if (!propertyTextures) {
      return;
    }
    const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];
    const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;
    if (!primitivePropertyTextureIndices) {
      return;
    }
    for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
      const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
      processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
    }
  }
  function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
    if (!propertyTexture.properties) {
      return;
    }
    if (!extension.dataAttributeNames) {
      extension.dataAttributeNames = [];
    }
    const className = propertyTexture.class;
    for (const propertyName in propertyTexture.properties) {
      const attributeName = `${className}_${propertyName}`;
      const textureInfoTopLevel = propertyTexture.properties?.[propertyName];
      if (!textureInfoTopLevel) {
        continue;
      }
      if (!textureInfoTopLevel.data) {
        textureInfoTopLevel.data = [];
      }
      const featureTextureTable = textureInfoTopLevel.data;
      const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
      if (propertyData === null) {
        continue;
      }
      primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
      textureInfoTopLevel.data = featureTextureTable;
      extension.dataAttributeNames.push(attributeName);
    }
  }
  function processPropertyTable(scenegraph, schema, propertyTable) {
    const schemaClass = schema.classes?.[propertyTable.class];
    if (!schemaClass) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
    }
    const numberOfElements = propertyTable.count;
    for (const propertyName in schemaClass.properties) {
      const classProperty = schemaClass.properties[propertyName];
      const propertyTableProperty = propertyTable.properties?.[propertyName];
      if (propertyTableProperty) {
        const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
        propertyTableProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
    let data = [];
    const valuesBufferView = propertyTableProperty.values;
    const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
    const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
    switch (classProperty.type) {
      case "SCALAR":
      case "VEC2":
      case "VEC3":
      case "VEC4":
      case "MAT2":
      case "MAT3":
      case "MAT4": {
        data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
        break;
      }
      case "BOOLEAN": {
        throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
      }
      case "STRING": {
        data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
        break;
      }
      case "ENUM": {
        data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
        break;
      }
      default:
        throw new Error(`Unknown classProperty type ${classProperty.type}`);
    }
    return data;
  }
  function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (classProperty.array && // `count` is a number of array elements. May only be defined when `array` is true.
    // If `count` is NOT defined, it's a VARIABLE-length array
    typeof classProperty.count === "undefined" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
    typeof propertyTableProperty.arrayOffsets !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
    if (typeof propertyTableProperty.stringOffsets !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    const isArray10 = classProperty.array;
    const arrayCount = classProperty.count;
    const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    let valuesData;
    if (classProperty.componentType) {
      valuesData = convertRawBufferToMetadataArray(
        valuesDataBytes,
        classProperty.type,
        // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
        classProperty.componentType,
        elementCount
      );
    } else {
      valuesData = valuesDataBytes;
    }
    if (isArray10) {
      if (arrayOffsets) {
        return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
      }
      if (arrayCount) {
        return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
      }
      return [];
    }
    return valuesData;
  }
  function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    const enumType = classProperty.enumType;
    if (!enumType) {
      throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
    }
    const enumEntry = schema.enums?.[enumType];
    if (!enumEntry) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
    }
    const enumValueType = enumEntry.valueType || "UINT16";
    const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
    if (!valuesData) {
      valuesData = valuesDataBytes;
    }
    if (classProperty.array) {
      if (arrayOffsets) {
        return parseVariableLengthArrayENUM({
          valuesData,
          numberOfElements,
          arrayOffsets,
          valuesDataBytesLength: valuesDataBytes.length,
          elementSize,
          enumEntry
        });
      }
      const arrayCount = classProperty.count;
      if (arrayCount) {
        return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
      }
      return [];
    }
    return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
  }
  function parseVariableLengthArrayENUM(params) {
    const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;
    const attributeValueArray = [];
    for (let index = 0; index < numberOfElements; index++) {
      const arrayOffset = arrayOffsets[index];
      const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
      if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
        break;
      }
      const typedArrayOffset = arrayOffset / elementSize;
      const elementCount = arrayByteSize / elementSize;
      const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
      attributeValueArray.push(array);
    }
    return attributeValueArray;
  }
  function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
    const attributeValueArray = [];
    for (let index = 0; index < numberOfElements; index++) {
      const elementOffset = arrayCount * index;
      const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
      attributeValueArray.push(array);
    }
    return attributeValueArray;
  }
  function getEnumsArray(valuesData, offset, count3, enumEntry) {
    const array = [];
    for (let i5 = 0; i5 < count3; i5++) {
      if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
        array.push("");
      } else {
        const value = valuesData[offset + i5];
        const enumObject = getEnumByValue(enumEntry, value);
        if (enumObject) {
          array.push(enumObject.name);
        } else {
          array.push("");
        }
      }
    }
    return array;
  }
  function getEnumByValue(enumEntry, value) {
    for (const enumValue of enumEntry.values) {
      if (enumValue.value === value) {
        return enumValue;
      }
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
  var EXT_feature_metadata_exports = {};
  __export(EXT_feature_metadata_exports, {
    decode: () => decode3,
    name: () => name4
  });
  var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
  var name4 = EXT_FEATURE_METADATA_NAME;
  async function decode3(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtFeatureMetadata(scenegraph, options);
  }
  function decodeExtFeatureMetadata(scenegraph, options) {
    if (!options.gltf?.loadBuffers) {
      return;
    }
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
    if (!extension) {
      return;
    }
    if (options.gltf?.loadImages) {
      decodePropertyTextures2(scenegraph, extension);
    }
    decodePropertyTables2(scenegraph, extension);
  }
  function decodePropertyTextures2(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const { featureTextures } = extension;
    if (schemaClasses && featureTextures) {
      for (const schemaName in schemaClasses) {
        const schemaClass = schemaClasses[schemaName];
        const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
        if (featureTexture) {
          handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
        }
      }
    }
  }
  function decodePropertyTables2(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const propertyTables = extension.featureTables;
    if (schemaClasses && propertyTables) {
      for (const schemaName in schemaClasses) {
        const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
        if (propertyTable) {
          processPropertyTable2(scenegraph, schema, propertyTable);
        }
      }
    }
  }
  function findPropertyTableByClass2(propertyTables, schemaClassName) {
    for (const propertyTableName in propertyTables) {
      const propertyTable = propertyTables[propertyTableName];
      if (propertyTable.class === schemaClassName) {
        return propertyTable;
      }
    }
    return null;
  }
  function findFeatureTextureByClass(featureTextures, schemaClassName) {
    for (const featureTexturesName in featureTextures) {
      const featureTable = featureTextures[featureTexturesName];
      if (featureTable.class === schemaClassName) {
        return featureTable;
      }
    }
    return null;
  }
  function processPropertyTable2(scenegraph, schema, propertyTable) {
    if (!propertyTable.class) {
      return;
    }
    const schemaClass = schema.classes?.[propertyTable.class];
    if (!schemaClass) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
    }
    const numberOfElements = propertyTable.count;
    for (const propertyName in schemaClass.properties) {
      const classProperty = schemaClass.properties[propertyName];
      const propertyTableProperty = propertyTable.properties?.[propertyName];
      if (propertyTableProperty) {
        const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
        propertyTableProperty.data = data;
      }
    }
  }
  function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
    const attributeName = featureTexture.class;
    for (const propertyName in schemaClass.properties) {
      const featureTextureProperty = featureTexture?.properties?.[propertyName];
      if (featureTextureProperty) {
        const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
        featureTextureProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
    let data = [];
    const bufferView = featureTableProperty.bufferView;
    const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
    const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
    const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
    if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
      data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
    } else if (isNumericProperty(classProperty)) {
      data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
    }
    return data;
  }
  function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (classProperty.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
    // If `componentCount` is NOT defined, it's a VARIABLE-length array
    typeof classProperty.componentCount === "undefined" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
    typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
      return getOffsetsForProperty(
        scenegraph,
        propertyTableProperty.arrayOffsetBufferView,
        propertyTableProperty.offsetType || "UINT32",
        // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
        numberOfElements
      );
    }
    return null;
  }
  function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
      return getOffsetsForProperty(
        scenegraph,
        propertyTableProperty.stringOffsetBufferView,
        propertyTableProperty.offsetType || "UINT32",
        // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
        numberOfElements
      );
    }
    return null;
  }
  function isNumericProperty(schemaProperty) {
    const types = [
      "UINT8",
      "INT16",
      "UINT16",
      "INT32",
      "UINT32",
      "INT64",
      "UINT64",
      "FLOAT32",
      "FLOAT64"
    ];
    return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
  }
  function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    const isArray10 = classProperty.type === "ARRAY";
    const arrayCount = classProperty.componentCount;
    const attributeType = "SCALAR";
    const componentType = classProperty.componentType || classProperty.type;
    const elementSize = getArrayElementByteSize(attributeType, componentType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
    if (isArray10) {
      if (arrayOffsets) {
        return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
      }
      if (arrayCount) {
        return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
      }
      return [];
    }
    return valuesData;
  }
  function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
    const json = scenegraph.gltf.json;
    if (!json.meshes) {
      return [];
    }
    const featureTextureTable = [];
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
      }
    }
    return featureTextureTable;
  }
  function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
    const textureInfoTopLevel = {
      channels: featureTextureProperty.channels,
      ...featureTextureProperty.texture
    };
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (!propertyData) {
      return;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
  var VERSION9 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
  var LITTLE_ENDIAN2 = true;
  var MAGIC_glTF = 1735152710;
  var GLB_FILE_HEADER_SIZE = 12;
  var GLB_CHUNK_HEADER_SIZE = 8;
  var GLB_CHUNK_TYPE_JSON = 1313821514;
  var GLB_CHUNK_TYPE_BIN = 5130562;
  var GLB_V1_CONTENT_FORMAT_JSON = 0;
  var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
  var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
  function getMagicString3(dataView, byteOffset = 0) {
    return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
  }
  function isGLB(arrayBuffer2, byteOffset = 0, options = {}) {
    const dataView = new DataView(arrayBuffer2);
    const { magic = MAGIC_glTF } = options;
    const magic1 = dataView.getUint32(byteOffset, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }
  function parseGLBSync(glb, arrayBuffer2, byteOffset = 0, options = {}) {
    const dataView = new DataView(arrayBuffer2);
    const type = getMagicString3(dataView, byteOffset + 0);
    const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN2);
    Object.assign(glb, {
      // Put less important stuff in a header, to avoid clutter
      header: {
        byteOffset,
        // Byte offset into the initial arrayBuffer
        byteLength,
        hasBinChunk: false
      },
      type,
      version,
      json: {},
      binChunks: []
    });
    byteOffset += GLB_FILE_HEADER_SIZE;
    switch (glb.version) {
      case 1:
        return parseGLBV1(glb, dataView, byteOffset);
      case 2:
        return parseGLBV2(glb, dataView, byteOffset, options = {});
      default:
        throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
    }
  }
  function parseGLBV1(glb, dataView, byteOffset) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
    const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
    parseJSONChunk(glb, dataView, byteOffset, contentLength);
    byteOffset += contentLength;
    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
    return byteOffset;
  }
  function parseGLBV2(glb, dataView, byteOffset, options) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    parseGLBChunksSync(glb, dataView, byteOffset, options);
    return byteOffset + glb.header.byteLength;
  }
  function parseGLBChunksSync(glb, dataView, byteOffset, options) {
    while (byteOffset + 8 <= glb.header.byteLength) {
      const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
      const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
      byteOffset += GLB_CHUNK_HEADER_SIZE;
      switch (chunkFormat) {
        case GLB_CHUNK_TYPE_JSON:
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_BIN:
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseBINChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        default:
          break;
      }
      byteOffset += padToNBytes(chunkLength, 4);
    }
    return byteOffset;
  }
  function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
    const textDecoder = new TextDecoder("utf8");
    const jsonText = textDecoder.decode(jsonChunk);
    glb.json = JSON.parse(jsonText);
    return padToNBytes(chunkLength, 4);
  }
  function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
    glb.header.hasBinChunk = true;
    glb.binChunks.push({
      byteOffset,
      byteLength: chunkLength,
      arrayBuffer: dataView.buffer
      // TODO - copy, or create typed array view?
    });
    return padToNBytes(chunkLength, 4);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
  function resolveUrl(url, options) {
    const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
    if (absolute) {
      return url;
    }
    const baseUrl = options.baseUri || options.uri;
    if (!baseUrl) {
      throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
    }
    return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
  var EXT_meshopt_compression_exports = {};
  __export(EXT_meshopt_compression_exports, {
    decode: () => decode5,
    name: () => name5
  });

  // ../../node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
  var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  var detector = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    3,
    2,
    0,
    0,
    5,
    3,
    1,
    0,
    1,
    12,
    1,
    0,
    10,
    22,
    2,
    12,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    252,
    10,
    0,
    0,
    11,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
  ]);
  var wasmpack = new Uint8Array([
    32,
    0,
    65,
    253,
    3,
    1,
    2,
    34,
    4,
    106,
    6,
    5,
    11,
    8,
    7,
    20,
    13,
    33,
    12,
    16,
    128,
    9,
    116,
    64,
    19,
    113,
    127,
    15,
    10,
    21,
    22,
    14,
    255,
    66,
    24,
    54,
    136,
    107,
    18,
    23,
    192,
    26,
    114,
    118,
    132,
    17,
    77,
    101,
    130,
    144,
    27,
    87,
    131,
    44,
    45,
    74,
    156,
    154,
    70,
    167
  ]);
  var FILTERS = {
    // legacy index-based enums for glTF
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    // string-based enums for glTF
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var DECODERS = {
    // legacy index-based enums for glTF
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    // string-based enums for glTF
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  async function meshoptDecodeGltfBuffer(target2, count3, size, source3, mode, filter = "NONE") {
    const instance = await loadWasmInstance();
    decode4(instance, instance.exports[DECODERS[mode]], target2, count3, size, source3, instance.exports[FILTERS[filter || "NONE"]]);
  }
  var wasmPromise;
  async function loadWasmInstance() {
    if (!wasmPromise) {
      wasmPromise = loadWasmModule();
    }
    return wasmPromise;
  }
  async function loadWasmModule() {
    let wasm2 = wasm_base;
    if (WebAssembly.validate(detector)) {
      wasm2 = wasm_simd;
      console.log("Warning: meshopt_decoder is using experimental SIMD support");
    }
    const result = await WebAssembly.instantiate(unpack(wasm2), {});
    await result.instance.exports.__wasm_call_ctors();
    return result.instance;
  }
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i5 = 0; i5 < data.length; ++i5) {
      const ch = data.charCodeAt(i5);
      result[i5] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i5 = 0; i5 < data.length; ++i5) {
      result[write++] = result[i5] < 60 ? wasmpack[result[i5]] : (result[i5] - 60) * 64 + result[++i5];
    }
    return result.buffer.slice(0, write);
  }
  function decode4(instance, fun, target2, count3, size, source3, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count3 + 3 & ~3;
    const tp = sbrk(count4 * size);
    const sp = sbrk(source3.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source3, sp);
    const res = fun(tp, count3, size, sp, source3.length);
    if (res === 0 && filter) {
      filter(tp, count4, size);
    }
    target2.set(heap.subarray(tp, tp + count3 * size));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error(`Malformed buffer data: ${res}`);
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
  var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
  var name5 = EXT_MESHOPT_COMPRESSION;
  async function decode5(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {
      return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
      promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    await Promise.all(promises);
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
  }
  async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
      const { byteOffset = 0, byteLength = 0, byteStride, count: count3, mode, filter = "NONE", buffer: bufferIndex } = meshoptExtension;
      const buffer = scenegraph.gltf.buffers[bufferIndex];
      const source3 = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
      const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
      await meshoptDecodeGltfBuffer(result, count3, byteStride, source3, mode, filter);
      scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
  var EXT_texture_webp_exports = {};
  __export(EXT_texture_webp_exports, {
    name: () => name6,
    preprocess: () => preprocess2
  });
  var EXT_TEXTURE_WEBP = "EXT_texture_webp";
  var name6 = EXT_TEXTURE_WEBP;
  function preprocess2(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!isImageFormatSupported("image/webp")) {
      if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
        throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
      }
      return;
    }
    const { json } = scenegraph;
    for (const texture of json.textures || []) {
      const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
      if (extension) {
        texture.source = extension.source;
      }
      scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
    }
    scenegraph.removeExtension(EXT_TEXTURE_WEBP);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
  var KHR_texture_basisu_exports = {};
  __export(KHR_texture_basisu_exports, {
    name: () => name7,
    preprocess: () => preprocess3
  });
  var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
  var name7 = KHR_TEXTURE_BASISU;
  function preprocess3(gltfData, options) {
    const scene = new GLTFScenegraph(gltfData);
    const { json } = scene;
    for (const texture of json.textures || []) {
      const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
      if (extension) {
        texture.source = extension.source;
        scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
      }
    }
    scene.removeExtension(KHR_TEXTURE_BASISU);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_draco_mesh_compression_exports = {};
  __export(KHR_draco_mesh_compression_exports, {
    decode: () => decode6,
    encode: () => encode,
    name: () => name8,
    preprocess: () => preprocess4
  });

  // ../../node_modules/@loaders.gl/draco/dist/lib/utils/version.js
  var VERSION10 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/draco/dist/draco-loader.js
  var DracoLoader = {
    dataType: null,
    batchType: null,
    name: "Draco",
    id: "draco",
    module: "draco",
    // shapes: ['mesh'],
    version: VERSION10,
    worker: true,
    extensions: ["drc"],
    mimeTypes: ["application/octet-stream"],
    binary: true,
    tests: ["DRACO"],
    options: {
      draco: {
        decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
        // 'js' for IE11
        libraryPath: "libs/",
        extraAttributes: {},
        attributeNameEntry: void 0
      }
    }
  };

  // ../../node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
  function getDracoSchema(attributes, loaderData, indices) {
    const metadata = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
      fields.push(field);
    }
    if (indices) {
      const indicesField = getArrowFieldFromAttribute("indices", indices);
      fields.push(indicesField);
    }
    return { fields, metadata };
  }
  function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
      const dracoAttribute = loaderData[key];
      result[dracoAttribute.name || "undefined"] = dracoAttribute;
    }
    return result;
  }
  function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
    const field = deduceMeshField(attributeName, attribute, metadataMap);
    return field;
  }
  function makeMetadata(metadata) {
    Object.entries(metadata);
    const serializedMetadata = {};
    for (const key in metadata) {
      serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
    }
    return serializedMetadata;
  }

  // ../../node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
  var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR_0",
    TEX_COORD: "TEXCOORD_0"
  };
  var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
    1: Int8Array,
    2: Uint8Array,
    3: Int16Array,
    4: Uint16Array,
    5: Int32Array,
    6: Uint32Array,
    // 7: BigInt64Array,
    // 8: BigUint64Array,
    9: Float32Array
    // 10: Float64Array
    // 11: BOOL - What array type do we use for this?
  };
  var INDEX_ITEM_SIZE = 4;
  var DracoParser = class {
    draco;
    decoder;
    metadataQuerier;
    // draco - the draco decoder, either import `draco3d` or load dynamically
    constructor(draco) {
      this.draco = draco;
      this.decoder = new this.draco.Decoder();
      this.metadataQuerier = new this.draco.MetadataQuerier();
    }
    /**
     * Destroy draco resources
     */
    destroy() {
      this.draco.destroy(this.decoder);
      this.draco.destroy(this.metadataQuerier);
    }
    /**
     * NOTE: caller must call `destroyGeometry` on the return value after using it
     * @param arrayBuffer
     * @param options
     */
    parseSync(arrayBuffer2, options = {}) {
      const buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer2), arrayBuffer2.byteLength);
      this._disableAttributeTransforms(options);
      const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
      const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
      try {
        let dracoStatus;
        switch (geometry_type) {
          case this.draco.TRIANGULAR_MESH:
            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            break;
          case this.draco.POINT_CLOUD:
            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            break;
          default:
            throw new Error("DRACO: Unknown geometry type.");
        }
        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          const message2 = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
          throw new Error(message2);
        }
        const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
        const geometry = this._getMeshData(dracoGeometry, loaderData, options);
        const boundingBox = getMeshBoundingBox(geometry.attributes);
        const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
        const data = {
          loader: "draco",
          loaderData,
          header: {
            vertexCount: dracoGeometry.num_points(),
            boundingBox
          },
          ...geometry,
          schema
        };
        return data;
      } finally {
        this.draco.destroy(buffer);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
      }
    }
    // Draco specific "loader data"
    /**
     * Extract
     * @param dracoGeometry
     * @param geometry_type
     * @param options
     * @returns
     */
    _getDracoLoaderData(dracoGeometry, geometry_type, options) {
      const metadata = this._getTopLevelMetadata(dracoGeometry);
      const attributes = this._getDracoAttributes(dracoGeometry, options);
      return {
        geometry_type,
        num_attributes: dracoGeometry.num_attributes(),
        num_points: dracoGeometry.num_points(),
        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
        metadata,
        attributes
      };
    }
    /**
     * Extract all draco provided information and metadata for each attribute
     * @param dracoGeometry
     * @param options
     * @returns
     */
    _getDracoAttributes(dracoGeometry, options) {
      const dracoAttributes = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
        dracoAttributes[dracoAttribute.unique_id()] = {
          unique_id: dracoAttribute.unique_id(),
          attribute_type: dracoAttribute.attribute_type(),
          data_type: dracoAttribute.data_type(),
          num_components: dracoAttribute.num_components(),
          byte_offset: dracoAttribute.byte_offset(),
          byte_stride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          attribute_index: attributeId,
          metadata
        };
        const quantization = this._getQuantizationTransform(dracoAttribute, options);
        if (quantization) {
          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
        }
        const octahedron = this._getOctahedronTransform(dracoAttribute, options);
        if (octahedron) {
          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
        }
      }
      return dracoAttributes;
    }
    /**
     * Get standard loaders.gl mesh category data
     * Extracts the geometry from draco
     * @param dracoGeometry
     * @param options
     */
    _getMeshData(dracoGeometry, loaderData, options) {
      const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
      const positionAttribute = attributes.POSITION;
      if (!positionAttribute) {
        throw new Error("DRACO: No position attribute found.");
      }
      if (dracoGeometry instanceof this.draco.Mesh) {
        switch (options.topology) {
          case "triangle-strip":
            return {
              topology: "triangle-strip",
              mode: 4,
              // GL.TRIANGLES
              attributes,
              indices: {
                value: this._getTriangleStripIndices(dracoGeometry),
                size: 1
              }
            };
          case "triangle-list":
          default:
            return {
              topology: "triangle-list",
              mode: 5,
              // GL.TRIANGLE_STRIP
              attributes,
              indices: {
                value: this._getTriangleListIndices(dracoGeometry),
                size: 1
              }
            };
        }
      }
      return {
        topology: "point-list",
        mode: 0,
        // GL.POINTS
        attributes
      };
    }
    _getMeshAttributes(loaderData, dracoGeometry, options) {
      const attributes = {};
      for (const loaderAttribute of Object.values(loaderData.attributes)) {
        const attributeName = this._deduceAttributeName(loaderAttribute, options);
        loaderAttribute.name = attributeName;
        const values = this._getAttributeValues(dracoGeometry, loaderAttribute);
        if (values) {
          const { value, size } = values;
          attributes[attributeName] = {
            value,
            size,
            byteOffset: loaderAttribute.byte_offset,
            byteStride: loaderAttribute.byte_stride,
            normalized: loaderAttribute.normalized
          };
        }
      }
      return attributes;
    }
    // MESH INDICES EXTRACTION
    /**
     * For meshes, we need indices to define the faces.
     * @param dracoGeometry
     */
    _getTriangleListIndices(dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * INDEX_ITEM_SIZE;
      const ptr = this.draco._malloc(byteLength);
      try {
        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
      } finally {
        this.draco._free(ptr);
      }
    }
    /**
     * For meshes, we need indices to define the faces.
     * @param dracoGeometry
     */
    _getTriangleStripIndices(dracoGeometry) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
        return getUint32Array(dracoArray);
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    /**
     *
     * @param dracoGeometry
     * @param dracoAttribute
     * @param attributeName
     */
    _getAttributeValues(dracoGeometry, attribute) {
      const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
      if (!TypedArrayCtor) {
        console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);
        return null;
      }
      const numComponents = attribute.num_components;
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(this.draco, TypedArrayCtor);
      let value;
      const ptr = this.draco._malloc(byteLength);
      try {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
      } finally {
        this.draco._free(ptr);
      }
      return { value, size: numComponents };
    }
    // Attribute names
    /**
     * DRACO does not store attribute names - We need to deduce an attribute name
     * for each attribute
    _getAttributeNames(
      dracoGeometry: Mesh | PointCloud,
      options: DracoParseOptions
    ): {[unique_id: number]: string} {
      const attributeNames: {[unique_id: number]: string} = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const attributeName = this._deduceAttributeName(dracoAttribute, options);
        attributeNames[attributeName] = attributeName;
      }
      return attributeNames;
    }
     */
    /**
     * Deduce an attribute name.
     * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
     * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
     * types
     * @param attributeData
     */
    _deduceAttributeName(attribute, options) {
      const uniqueId2 = attribute.unique_id;
      for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
        if (attributeUniqueId === uniqueId2) {
          return attributeName;
        }
      }
      const thisAttributeType = attribute.attribute_type;
      for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        const attributeType = this.draco[dracoAttributeConstant];
        if (attributeType === thisAttributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }
      const entryName = options.attributeNameEntry || "name";
      if (attribute.metadata[entryName]) {
        return attribute.metadata[entryName].string;
      }
      return `CUSTOM_ATTRIBUTE_${uniqueId2}`;
    }
    // METADATA EXTRACTION
    /** Get top level metadata */
    _getTopLevelMetadata(dracoGeometry) {
      const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
      return this._getDracoMetadata(dracoMetadata);
    }
    /** Get per attribute metadata */
    _getAttributeMetadata(dracoGeometry, attributeId) {
      const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._getDracoMetadata(dracoMetadata);
    }
    /**
     * Extract metadata field values
     * @param dracoMetadata
     * @returns
     */
    _getDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }
      const result = {};
      const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
      for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
      }
      return result;
    }
    /**
     * Extracts possible values for one metadata entry by name
     * @param dracoMetadata
     * @param entryName
     */
    _getDracoMetadataField(dracoMetadata, entryName) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
        const intArray = getInt32Array(dracoArray);
        return {
          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray
        };
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
    /** Skip transforms for specific attribute types */
    _disableAttributeTransforms(options) {
      const { quantizedAttributes = [], octahedronAttributes = [] } = options;
      const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
      for (const dracoAttributeName of skipAttributes) {
        this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
      }
    }
    /**
     * Extract (and apply?) Position Transform
     * @todo not used
     */
    _getQuantizationTransform(dracoAttribute, options) {
      const { quantizedAttributes = [] } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (skip) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits(),
              range: transform2.range(),
              min_values: new Float32Array([1, 2, 3]).map((i5) => transform2.min_value(i5))
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
    _getOctahedronTransform(dracoAttribute, options) {
      const { octahedronAttributes = [] } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (octahedron) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits()
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
  };
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
      default:
        return draco.DT_INVALID;
    }
  }
  function getInt32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i5 = 0; i5 < numValues; i5++) {
      intArray[i5] = dracoArray.GetValue(i5);
    }
    return intArray;
  }
  function getUint32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i5 = 0; i5 < numValues; i5++) {
      intArray[i5] = dracoArray.GetValue(i5);
    }
    return intArray;
  }

  // ../../node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
  var DRACO_DECODER_VERSION = "1.5.6";
  var DRACO_ENCODER_VERSION = "1.4.1";
  var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
  var DRACO_EXTERNAL_LIBRARIES = {
    /** The primary Draco3D encoder, javascript wrapper part */
    DECODER: "draco_wasm_wrapper.js",
    /** The primary draco decoder, compiled web assembly part */
    DECODER_WASM: "draco_decoder.wasm",
    /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
    FALLBACK_DECODER: "draco_decoder.js",
    /** Draco encoder */
    ENCODER: "draco_encoder.js"
  };
  var DRACO_EXTERNAL_LIBRARY_URLS = {
    [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
    [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
    [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
    [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
  };
  var loadDecoderPromise;
  async function loadDracoDecoderModule(options) {
    const modules = options.modules || {};
    if (modules.draco3d) {
      loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {
        return { draco };
      });
    } else {
      loadDecoderPromise ||= loadDracoDecoder(options);
    }
    return await loadDecoderPromise;
  }
  async function loadDracoDecoder(options) {
    let DracoDecoderModule;
    let wasmBinary;
    switch (options.draco && options.draco.decoderType) {
      case "js":
        DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
        break;
      case "wasm":
      default:
        [DracoDecoderModule, wasmBinary] = await Promise.all([
          await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER),
          await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)
        ]);
    }
    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
  }
  function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      DracoDecoderModule({
        ...options,
        onModuleLoaded: (draco) => resolve2({ draco })
        // Module is Promise-like. Wrap in object to avoid loop.
      });
    });
  }

  // ../../node_modules/@loaders.gl/draco/dist/index.js
  var DracoLoader2 = {
    ...DracoLoader,
    parse: parse2
  };
  async function parse2(arrayBuffer2, options) {
    const { draco } = await loadDracoDecoderModule(options);
    const dracoParser = new DracoParser(draco);
    try {
      return dracoParser.parseSync(arrayBuffer2, options?.draco);
    } finally {
      dracoParser.destroy();
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
  function getGLTFAccessors(attributes) {
    const accessors = {};
    for (const name13 in attributes) {
      const attribute = attributes[name13];
      if (name13 !== "indices") {
        const glTFAccessor = getGLTFAccessor(attribute);
        accessors[name13] = glTFAccessor;
      }
    }
    return accessors;
  }
  function getGLTFAccessor(attribute) {
    const { buffer, size, count: count3 } = getAccessorData(attribute);
    const glTFAccessor = {
      // glTF Accessor values
      // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
      // bufferView: null,
      // TODO: Deprecate `value` in favor of bufferView?
      // @ts-ignore
      value: buffer,
      size,
      // Decoded `type` (e.g. SCALAR)
      byteOffset: 0,
      count: count3,
      type: getAccessorTypeFromSize(size),
      componentType: getComponentTypeFromArray(buffer)
    };
    return glTFAccessor;
  }
  function getAccessorData(attribute) {
    let buffer = attribute;
    let size = 1;
    let count3 = 0;
    if (attribute && attribute.value) {
      buffer = attribute.value;
      size = attribute.size || 1;
    }
    if (buffer) {
      if (!ArrayBuffer.isView(buffer)) {
        buffer = toTypedArray(buffer, Float32Array);
      }
      count3 = buffer.length / size;
    }
    return { buffer, size, count: count3 };
  }
  function toTypedArray(array, ArrayType2, convertTypedArrays = false) {
    if (!array) {
      return null;
    }
    if (Array.isArray(array)) {
      return new ArrayType2(array);
    }
    if (convertTypedArrays && !(array instanceof ArrayType2)) {
      return new ArrayType2(array);
    }
    return array;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
  var name8 = KHR_DRACO_MESH_COMPRESSION;
  function preprocess4(gltfData, options, context) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      }
    }
  }
  async function decode6(gltfData, options, context) {
    if (!options?.gltf?.decompressMeshes) {
      return;
    }
    const scenegraph = new GLTFScenegraph(gltfData);
    const promises = [];
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
        promises.push(decompressPrimitive(scenegraph, primitive, options, context));
      }
    }
    await Promise.all(promises);
    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }
  function encode(gltfData, options = {}) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const mesh of scenegraph.json.meshes || []) {
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }
  async function decompressPrimitive(scenegraph, primitive, options, context) {
    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    if (!dracoExtension) {
      return;
    }
    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
    const dracoOptions = { ...options };
    delete dracoOptions["3d-tiles"];
    const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
    const decodedAttributes = getGLTFAccessors(decodedData.attributes);
    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
      if (attributeName in primitive.attributes) {
        const accessorIndex = primitive.attributes[attributeName];
        const accessor = scenegraph.getAccessor(accessorIndex);
        if (accessor?.min && accessor?.max) {
          decodedAttribute.min = accessor.min;
          decodedAttribute.max = accessor.max;
        }
      }
    }
    primitive.attributes = decodedAttributes;
    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
    scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    checkPrimitive(primitive);
  }
  function compressMesh(attributes, indices, mode = 4, options, context) {
    if (!options.DracoWriter) {
      throw new Error("options.gltf.DracoWriter not provided");
    }
    const compressedData = options.DracoWriter.encodeSync({ attributes });
    const decodedData = context?.parseSync?.({ attributes });
    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [
        {
          attributes: fauxAccessors,
          // TODO - verify with spec
          mode,
          // GL.POINTS
          extensions: {
            [KHR_DRACO_MESH_COMPRESSION]: {
              bufferView: bufferViewIndex,
              attributes: fauxAccessors
              // TODO - verify with spec
            }
          }
        }
      ]
    };
    return glTFMesh;
  }
  function checkPrimitive(primitive) {
    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
      throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
    }
  }
  function* makeMeshPrimitiveIterator(scenegraph) {
    for (const mesh of scenegraph.json.meshes || []) {
      for (const primitive of mesh.primitives) {
        yield primitive;
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
  var KHR_texture_transform_exports = {};
  __export(KHR_texture_transform_exports, {
    decode: () => decode7,
    name: () => name9
  });

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES4 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS8 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG2 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG2 } };
  var config2 = globalThis.mathgl.config;
  function formatValue2(value, { precision = config2.precision } = {}) {
    value = round6(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray4(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals6(a3, b2, epsilon) {
    const oldEpsilon = config2.EPSILON;
    if (epsilon) {
      config2.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray4(a3) && isArray4(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals6(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config2.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config2.EPSILON = oldEpsilon;
    }
  }
  function round6(value) {
    return Math.round(value / config2.EPSILON) * config2.EPSILON;
  }

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray2 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray4(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config2);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue2(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals6(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config2.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector2(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber2(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector2(v2, length16, callerName = "") {
    if (config2.debug && !validateVector2(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/lib/assert.js
  function assert10(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector5 = class extends MathArray2 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber2(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber2(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber2(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber2(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert10(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber2(this[i5]);
    }
    setComponent(i5, value) {
      assert10(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree2 = Math.PI / 180;

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create7() {
    const out = new ARRAY_TYPE2(2);
    if (ARRAY_TYPE2 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat33(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  var forEach5 = function() {
    const vec = create7();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec3_transformMat4AsVector2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat22(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat32(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m[0] * x3 + m[3] * y3 + m[6] * z2;
    out[1] = m[1] * x3 + m[4] * y3 + m[7] * z2;
    out[2] = m[2] * x3 + m[5] * y3 + m[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create8() {
    const out = new ARRAY_TYPE2(3);
    if (ARRAY_TYPE2 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function dot5(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross4(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat44(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat34(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat3(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX4(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY4(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ4(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle3(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot5(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var forEach6 = function() {
    const vec = create8();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN2 = [0, 0, 0];
  var ZERO4;
  var Vector32 = class extends Vector5 {
    static get ZERO() {
      if (!ZERO4) {
        ZERO4 = new Vector32(0, 0, 0);
        Object.freeze(ZERO4);
      }
      return ZERO4;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray4(x3)) {
        this.copy(x3);
      } else {
        if (config2.debug) {
          checkNumber2(x3);
          checkNumber2(y3);
          checkNumber2(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config2.debug) {
        checkNumber2(object.x);
        checkNumber2(object.y);
        checkNumber2(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber2(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle3(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross4(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN2 }) {
      rotateX4(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN2 }) {
      rotateY4(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN2 }) {
      rotateZ4(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat44(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector2(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat34(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat22(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat3(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix2 = class extends MathArray2 {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config2.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber2(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function transpose3(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert4(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant3(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply7(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate3(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate4(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale7(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat4(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@loaders.gl/gltf/node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES3;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES10[INDICES10["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES3 || (INDICES3 = {}));
  var IDENTITY_MATRIX5 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix32 = class extends Matrix2 {
    static get IDENTITY() {
      return getIdentityMatrix3();
    }
    static get ZERO() {
      return getZeroMatrix3();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES3;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    // Constructors
    identity() {
      return this.copy(IDENTITY_MATRIX5);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /** Calculates a 3x3 matrix from the given quaternion
     * q quat  Quaternion to create matrix from
     */
    fromQuaternion(q2) {
      fromQuat4(this, q2);
      return this.check();
    }
    /**
     * accepts column major order, stores in column major order
     */
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    /**
     * accepts row major order, stores as column major
     */
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant3(this);
    }
    // Modifiers
    transpose() {
      transpose3(this, this);
      return this.check();
    }
    /** Invert a matrix. Note that this can fail if the matrix is not invertible */
    invert() {
      invert4(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply7(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply7(this, this, a3);
      return this.check();
    }
    rotate(radians6) {
      rotate4(this, this, radians6);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale7(this, this, factor);
      } else {
        scale7(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate3(this, this, vec);
      return this.check();
    }
    // Transforms
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat33(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat34(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat32(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector2(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX32;
  var IDENTITY_MATRIX32 = null;
  function getZeroMatrix3() {
    if (!ZERO_MATRIX32) {
      ZERO_MATRIX32 = new Matrix32([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX32);
    }
    return ZERO_MATRIX32;
  }
  function getIdentityMatrix3() {
    if (!IDENTITY_MATRIX32) {
      IDENTITY_MATRIX32 = new Matrix32();
      Object.freeze(IDENTITY_MATRIX32);
    }
    return IDENTITY_MATRIX32;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
  var KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
  var name9 = KHR_TEXTURE_TRANSFORM;
  var scratchVector7 = new Vector32();
  var scratchRotationMatrix = new Matrix32();
  var scratchScaleMatrix = new Matrix32();
  async function decode7(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);
    if (!hasExtension || !options.gltf?.loadBuffers) {
      return;
    }
    const materials = gltfData.json.materials || [];
    for (let i5 = 0; i5 < materials.length; i5++) {
      transformTexCoords(i5, gltfData);
    }
  }
  function transformTexCoords(materialIndex, gltfData) {
    const material = gltfData.json.materials?.[materialIndex];
    const materialTextures = [
      material?.pbrMetallicRoughness?.baseColorTexture,
      material?.emissiveTexture,
      material?.normalTexture,
      material?.occlusionTexture,
      material?.pbrMetallicRoughness?.metallicRoughnessTexture
    ];
    const processedTexCoords = [];
    for (const textureInfo of materialTextures) {
      if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {
        transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);
      }
    }
  }
  function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
    const transformParameters = getTransformParameters(texture, processedTexCoords);
    if (!transformParameters) {
      return;
    }
    const meshes = gltfData.json.meshes || [];
    for (const mesh of meshes) {
      for (const primitive of mesh.primitives) {
        const material = primitive.material;
        if (Number.isFinite(material) && materialIndex === material) {
          transformPrimitive(gltfData, primitive, transformParameters);
        }
      }
    }
  }
  function getTransformParameters(texture, processedTexCoords) {
    const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];
    const { texCoord: originalTexCoord = 0 } = texture;
    const { texCoord = originalTexCoord } = textureInfo;
    const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;
    if (!isProcessed) {
      const matrix = makeTransformationMatrix(textureInfo);
      if (originalTexCoord !== texCoord) {
        texture.texCoord = texCoord;
      }
      processedTexCoords.push([originalTexCoord, texCoord]);
      return { originalTexCoord, texCoord, matrix };
    }
    return null;
  }
  function transformPrimitive(gltfData, primitive, transformParameters) {
    const { originalTexCoord, texCoord, matrix } = transformParameters;
    const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
    if (Number.isFinite(texCoordAccessor)) {
      const accessor = gltfData.json.accessors?.[texCoordAccessor];
      if (accessor && accessor.bufferView) {
        const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];
        if (bufferView) {
          const { arrayBuffer: arrayBuffer2, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];
          const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
          const { ArrayType: ArrayType2, length: length16 } = getAccessorArrayTypeAndLength(accessor, bufferView);
          const bytes = BYTES[accessor.componentType];
          const components = COMPONENTS[accessor.type];
          const elementAddressScale = bufferView.byteStride || bytes * components;
          const result = new Float32Array(length16);
          for (let i5 = 0; i5 < accessor.count; i5++) {
            const uv = new ArrayType2(arrayBuffer2, byteOffset + i5 * elementAddressScale, 2);
            scratchVector7.set(uv[0], uv[1], 1);
            scratchVector7.transformByMatrix3(matrix);
            result.set([scratchVector7[0], scratchVector7[1]], i5 * components);
          }
          if (originalTexCoord === texCoord) {
            updateGltf(accessor, bufferView, gltfData.buffers, result);
          } else {
            createAttribute(texCoord, accessor, primitive, gltfData, result);
          }
        }
      }
    }
  }
  function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
    accessor.componentType = 5126;
    buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    bufferView.buffer = buffers.length - 1;
    bufferView.byteLength = newTexCoordArray.buffer.byteLength;
    bufferView.byteOffset = 0;
    delete bufferView.byteStride;
  }
  function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
    gltfData.buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    const bufferViews = gltfData.json.bufferViews;
    if (!bufferViews) {
      return;
    }
    bufferViews.push({
      buffer: gltfData.buffers.length - 1,
      byteLength: newTexCoordArray.buffer.byteLength,
      byteOffset: 0
    });
    const accessors = gltfData.json.accessors;
    if (!accessors) {
      return;
    }
    accessors.push({
      bufferView: bufferViews?.length - 1,
      byteOffset: 0,
      componentType: 5126,
      count: originalAccessor.count,
      type: "VEC2"
    });
    primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
  }
  function makeTransformationMatrix(extensionData) {
    const { offset = [0, 0], rotation = 0, scale: scale22 = [1, 1] } = extensionData;
    const translationMatrix = new Matrix32().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
    const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
    const scaleMatrix = scratchScaleMatrix.set(scale22[0], 0, 0, 0, scale22[1], 0, 0, 0, 1);
    return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
  var KHR_lights_punctual_exports = {};
  __export(KHR_lights_punctual_exports, {
    decode: () => decode8,
    encode: () => encode2,
    name: () => name10
  });
  var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
  var name10 = KHR_LIGHTS_PUNCTUAL;
  async function decode8(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
    }
    for (const node of json.nodes || []) {
      const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
      if (nodeExtension) {
        node.light = nodeExtension.light;
      }
      gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    }
  }
  async function encode2(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    if (json.lights) {
      const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
      assert9(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node = light.node;
        gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
      }
      delete gltfScenegraph.json.lights;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
  var KHR_materials_unlit_exports = {};
  __export(KHR_materials_unlit_exports, {
    decode: () => decode9,
    encode: () => encode3,
    name: () => name11
  });
  var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
  var name11 = KHR_MATERIALS_UNLIT;
  async function decode9(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    for (const material of json.materials || []) {
      const extension = material.extensions && material.extensions.KHR_materials_unlit;
      if (extension) {
        material.unlit = true;
      }
      gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
    }
    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
  }
  function encode3(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    if (gltfScenegraph.materials) {
      for (const material of json.materials || []) {
        if (material.unlit) {
          delete material.unlit;
          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
  var KHR_techniques_webgl_exports = {};
  __export(KHR_techniques_webgl_exports, {
    decode: () => decode10,
    encode: () => encode4,
    name: () => name12
  });
  var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
  var name12 = KHR_TECHNIQUES_WEBGL;
  async function decode10(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
    if (extension) {
      const techniques = resolveTechniques(extension, gltfScenegraph);
      for (const material of json.materials || []) {
        const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
        if (materialExtension) {
          material.technique = Object.assign(
            {},
            materialExtension,
            // @ts-ignore
            techniques[materialExtension.technique]
          );
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }
        gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      }
      gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
    }
  }
  async function encode4(gltfData, options) {
  }
  function resolveTechniques(techniquesExtension, gltfScenegraph) {
    const { programs = [], shaders = [], techniques = [] } = techniquesExtension;
    const textDecoder = new TextDecoder();
    shaders.forEach((shader) => {
      if (Number.isFinite(shader.bufferView)) {
        shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
      } else {
        throw new Error("KHR_techniques_webgl: no shader code");
      }
    });
    programs.forEach((program) => {
      program.fragmentShader = shaders[program.fragmentShader];
      program.vertexShader = shaders[program.vertexShader];
    });
    techniques.forEach((technique) => {
      technique.program = programs[technique.program];
    });
    return techniques;
  }
  function resolveValues(technique, gltfScenegraph) {
    const values = Object.assign({}, technique.values);
    Object.keys(technique.uniforms || {}).forEach((uniform) => {
      if (technique.uniforms[uniform].value && !(uniform in values)) {
        values[uniform] = technique.uniforms[uniform].value;
      }
    });
    Object.keys(values).forEach((uniform) => {
      if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
        values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
      }
    });
    return values;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
  var EXTENSIONS2 = [
    // 1.0
    // KHR_binary_gltf is handled separately - must be processed before other parsing starts
    // KHR_binary_gltf,
    // 2.0
    EXT_structural_metadata_exports,
    EXT_mesh_features_exports,
    EXT_meshopt_compression_exports,
    EXT_texture_webp_exports,
    // Basisu should come after webp, we want basisu to be preferred if both are provided
    KHR_texture_basisu_exports,
    KHR_draco_mesh_compression_exports,
    KHR_lights_punctual_exports,
    KHR_materials_unlit_exports,
    KHR_techniques_webgl_exports,
    KHR_texture_transform_exports,
    EXT_feature_metadata_exports
  ];
  function preprocessExtensions(gltf, options = {}, context) {
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      extension.preprocess?.(gltf, options, context);
    }
  }
  async function decodeExtensions(gltf, options = {}, context) {
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      await extension.decode?.(gltf, options, context);
    }
  }
  function useExtension(extensionName, options) {
    const excludes = options?.gltf?.excludeExtensions || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    return !exclude;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
  var KHR_BINARY_GLTF = "KHR_binary_glTF";
  function preprocess5(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const { json } = gltfScenegraph;
    for (const image of json.images || []) {
      const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
      if (extension) {
        Object.assign(image, extension);
      }
      gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
    }
    if (json.buffers && json.buffers[0]) {
      delete json.buffers[0].uri;
    }
    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
  var GLTF_ARRAYS = {
    accessors: "accessor",
    animations: "animation",
    buffers: "buffer",
    bufferViews: "bufferView",
    images: "image",
    materials: "material",
    meshes: "mesh",
    nodes: "node",
    samplers: "sampler",
    scenes: "scene",
    skins: "skin",
    textures: "texture"
  };
  var GLTF_KEYS = {
    accessor: "accessors",
    animations: "animation",
    buffer: "buffers",
    bufferView: "bufferViews",
    image: "images",
    material: "materials",
    mesh: "meshes",
    node: "nodes",
    sampler: "samplers",
    scene: "scenes",
    skin: "skins",
    texture: "textures"
  };
  var GLTFV1Normalizer = class {
    idToIndexMap = {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    };
    json;
    // constructor() {}
    /**
     * Convert (normalize) glTF < 2.0 to glTF 2.0
     * @param gltf - object with json and binChunks
     * @param options
     * @param options normalize Whether to actually normalize
     */
    normalize(gltf, options) {
      this.json = gltf.json;
      const json = gltf.json;
      switch (json.asset && json.asset.version) {
        case "2.0":
          return;
        case void 0:
        case "1.0":
          break;
        default:
          console.warn(`glTF: Unknown version ${json.asset.version}`);
          return;
      }
      if (!options.normalize) {
        throw new Error("glTF v1 is not supported.");
      }
      console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
      this._addAsset(json);
      this._convertTopLevelObjectsToArrays(json);
      preprocess5(gltf);
      this._convertObjectIdsToArrayIndices(json);
      this._updateObjects(json);
      this._updateMaterial(json);
    }
    // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
    _addAsset(json) {
      json.asset = json.asset || {};
      json.asset.version = "2.0";
      json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
    }
    _convertTopLevelObjectsToArrays(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertTopLevelObjectToArray(json, arrayName);
      }
    }
    /** Convert one top level object to array */
    _convertTopLevelObjectToArray(json, mapName) {
      const objectMap = json[mapName];
      if (!objectMap || Array.isArray(objectMap)) {
        return;
      }
      json[mapName] = [];
      for (const id in objectMap) {
        const object = objectMap[id];
        object.id = object.id || id;
        const index = json[mapName].length;
        json[mapName].push(object);
        this.idToIndexMap[mapName][id] = index;
      }
    }
    /** Go through all objects in all top-level arrays and replace ids with indices */
    _convertObjectIdsToArrayIndices(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertIdsToIndices(json, arrayName);
      }
      if ("scene" in json) {
        json.scene = this._convertIdToIndex(json.scene, "scene");
      }
      for (const texture of json.textures) {
        this._convertTextureIds(texture);
      }
      for (const mesh of json.meshes) {
        this._convertMeshIds(mesh);
      }
      for (const node of json.nodes) {
        this._convertNodeIds(node);
      }
      for (const node of json.scenes) {
        this._convertSceneIds(node);
      }
    }
    _convertTextureIds(texture) {
      if (texture.source) {
        texture.source = this._convertIdToIndex(texture.source, "image");
      }
    }
    _convertMeshIds(mesh) {
      for (const primitive of mesh.primitives) {
        const { attributes, indices, material } = primitive;
        for (const attributeName in attributes) {
          attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
        }
        if (indices) {
          primitive.indices = this._convertIdToIndex(indices, "accessor");
        }
        if (material) {
          primitive.material = this._convertIdToIndex(material, "material");
        }
      }
    }
    _convertNodeIds(node) {
      if (node.children) {
        node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
      }
      if (node.meshes) {
        node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
      }
    }
    _convertSceneIds(scene) {
      if (scene.nodes) {
        scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
      }
    }
    /** Go through all objects in a top-level array and replace ids with indices */
    _convertIdsToIndices(json, topLevelArrayName) {
      if (!json[topLevelArrayName]) {
        console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
        json[topLevelArrayName] = [];
      }
      for (const object of json[topLevelArrayName]) {
        for (const key in object) {
          const id = object[key];
          const index = this._convertIdToIndex(id, key);
          object[key] = index;
        }
      }
    }
    _convertIdToIndex(id, key) {
      const arrayName = GLTF_KEYS[key];
      if (arrayName in this.idToIndexMap) {
        const index = this.idToIndexMap[arrayName][id];
        if (!Number.isFinite(index)) {
          throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
        }
        return index;
      }
      return id;
    }
    /**
     *
     * @param {*} json
     */
    _updateObjects(json) {
      for (const buffer of this.json.buffers) {
        delete buffer.type;
      }
    }
    /**
     * Update material (set pbrMetallicRoughness)
     * @param {*} json
     */
    _updateMaterial(json) {
      for (const material of json.materials) {
        material.pbrMetallicRoughness = {
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1
        };
        const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;
        const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
        if (textureIndex !== -1) {
          material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
        }
      }
    }
  };
  function normalizeGLTFV1(gltf, options = {}) {
    return new GLTFV1Normalizer().normalize(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
  async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    normalizeGLTFV1(gltf, { normalize: options?.gltf?.normalize });
    preprocessExtensions(gltf, options, context);
    if (options?.gltf?.loadBuffers && gltf.json.buffers) {
      await loadBuffers(gltf, options, context);
    }
    if (options?.gltf?.loadImages) {
      await loadImages(gltf, options, context);
    }
    await decodeExtensions(gltf, options, context);
    return gltf;
  }
  function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    if (options.uri) {
      gltf.baseUri = options.uri;
    }
    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(data);
    }
    if (typeof data === "string") {
      gltf.json = parseJSON(data);
    } else if (data instanceof ArrayBuffer) {
      const glb = {};
      byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
      assert9(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
      gltf._glb = glb;
      gltf.json = glb.json;
    } else {
      assert9(false, "GLTF: must be ArrayBuffer or string");
    }
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
      const { binChunks } = gltf._glb;
      gltf.buffers[0] = {
        arrayBuffer: binChunks[0].arrayBuffer,
        byteOffset: binChunks[0].byteOffset,
        byteLength: binChunks[0].byteLength
      };
    }
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
  }
  async function loadBuffers(gltf, options, context) {
    const buffers = gltf.json.buffers || [];
    for (let i5 = 0; i5 < buffers.length; ++i5) {
      const buffer = buffers[i5];
      if (buffer.uri) {
        const { fetch: fetch2 } = context;
        assert9(fetch2);
        const uri = resolveUrl(buffer.uri, options);
        const response = await context?.fetch?.(uri);
        const arrayBuffer2 = await response?.arrayBuffer?.();
        gltf.buffers[i5] = {
          arrayBuffer: arrayBuffer2,
          byteOffset: 0,
          byteLength: arrayBuffer2.byteLength
        };
        delete buffer.uri;
      } else if (gltf.buffers[i5] === null) {
        gltf.buffers[i5] = {
          arrayBuffer: new ArrayBuffer(buffer.byteLength),
          byteOffset: 0,
          byteLength: buffer.byteLength
        };
      }
    }
  }
  async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
      promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
  }
  function getReferencesImageIndices(gltf) {
    const imageIndices = /* @__PURE__ */ new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
      if (texture.source !== void 0) {
        imageIndices.add(texture.source);
      }
    }
    return Array.from(imageIndices).sort();
  }
  async function loadImage(gltf, image, index, options, context) {
    let arrayBuffer2;
    if (image.uri && !image.hasOwnProperty("bufferView")) {
      const uri = resolveUrl(image.uri, options);
      const { fetch: fetch2 } = context;
      const response = await fetch2(uri);
      arrayBuffer2 = await response.arrayBuffer();
      image.bufferView = {
        data: arrayBuffer2
      };
    }
    if (Number.isFinite(image.bufferView)) {
      const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
      arrayBuffer2 = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
    }
    assert9(arrayBuffer2, "glTF image has no data");
    let parsedImage = await parseFromContext(arrayBuffer2, [ImageLoader, BasisLoader], {
      ...options,
      mimeType: image.mimeType,
      basis: options.basis || { format: selectSupportedBasisFormat() }
    }, context);
    if (parsedImage && parsedImage[0]) {
      parsedImage = {
        compressed: true,
        // @ts-expect-error
        mipmaps: false,
        width: parsedImage[0].width,
        height: parsedImage[0].height,
        data: parsedImage[0]
      };
    }
    gltf.images = gltf.images || [];
    gltf.images[index] = parsedImage;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/gltf-loader.js
  var GLTFLoader = {
    dataType: null,
    batchType: null,
    name: "glTF",
    id: "gltf",
    module: "gltf",
    version: VERSION9,
    extensions: ["gltf", "glb"],
    mimeTypes: ["model/gltf+json", "model/gltf-binary"],
    text: true,
    binary: true,
    tests: ["glTF"],
    parse: parse3,
    options: {
      gltf: {
        normalize: true,
        // Normalize glTF v1 to glTF v2 format (not yet stable)
        loadBuffers: true,
        // Fetch any linked .BIN buffers, decode base64
        loadImages: true,
        // Create image objects
        decompressMeshes: true
        // Decompress Draco encoded meshes
      },
      // common?
      log: console
      // eslint-disable-line
    }
  };
  async function parse3(arrayBuffer2, options = {}, context) {
    options = { ...GLTFLoader.options, ...options };
    options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };
    const { byteOffset = 0 } = options;
    const gltf = {};
    return await parseGLTF(gltf, arrayBuffer2, byteOffset, options, context);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
  var COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES2 = {
    5120: 1,
    // BYTE
    5121: 1,
    // UNSIGNED_BYTE
    5122: 2,
    // SHORT
    5123: 2,
    // UNSIGNED_SHORT
    5125: 4,
    // UNSIGNED_INT
    5126: 4
    // FLOAT
  };
  var GL_SAMPLER = {
    // Sampler parameters
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    // Sampler default values
    REPEAT: 10497,
    LINEAR: 9729,
    NEAREST_MIPMAP_LINEAR: 9986
  };
  var SAMPLER_PARAMETER_GLTF_TO_GL = {
    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
    wrapT: GL_SAMPLER.TEXTURE_WRAP_T
  };
  var DEFAULT_SAMPLER_PARAMETERS2 = {
    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
  };
  function makeDefaultSampler() {
    return {
      id: "default-sampler",
      parameters: DEFAULT_SAMPLER_PARAMETERS2
    };
  }
  function getBytesFromComponentType(componentType) {
    return BYTES2[componentType];
  }
  function getSizeFromAccessorType(type) {
    return COMPONENTS2[type];
  }
  var GLTFPostProcessor = class {
    baseUri = "";
    // @ts-expect-error
    jsonUnprocessed;
    // @ts-expect-error
    json;
    buffers = [];
    images = [];
    postProcess(gltf, options = {}) {
      const { json, buffers = [], images = [] } = gltf;
      const { baseUri = "" } = gltf;
      assert9(json);
      this.baseUri = baseUri;
      this.buffers = buffers;
      this.images = images;
      this.jsonUnprocessed = json;
      this.json = this._resolveTree(gltf.json, options);
      return this.json;
    }
    // Convert indexed glTF structure into tree structure
    // cross-link index resolution, enum lookup, convenience calculations
    // eslint-disable-next-line complexity, max-statements
    _resolveTree(gltf, options = {}) {
      const json = { ...gltf };
      this.json = json;
      if (gltf.bufferViews) {
        json.bufferViews = gltf.bufferViews.map((bufView, i5) => this._resolveBufferView(bufView, i5));
      }
      if (gltf.images) {
        json.images = gltf.images.map((image, i5) => this._resolveImage(image, i5));
      }
      if (gltf.samplers) {
        json.samplers = gltf.samplers.map((sampler, i5) => this._resolveSampler(sampler, i5));
      }
      if (gltf.textures) {
        json.textures = gltf.textures.map((texture, i5) => this._resolveTexture(texture, i5));
      }
      if (gltf.accessors) {
        json.accessors = gltf.accessors.map((accessor, i5) => this._resolveAccessor(accessor, i5));
      }
      if (gltf.materials) {
        json.materials = gltf.materials.map((material, i5) => this._resolveMaterial(material, i5));
      }
      if (gltf.meshes) {
        json.meshes = gltf.meshes.map((mesh, i5) => this._resolveMesh(mesh, i5));
      }
      if (gltf.nodes) {
        json.nodes = gltf.nodes.map((node, i5) => this._resolveNode(node, i5));
        json.nodes = json.nodes.map((node, i5) => this._resolveNodeChildren(node));
      }
      if (gltf.skins) {
        json.skins = gltf.skins.map((skin, i5) => this._resolveSkin(skin, i5));
      }
      if (gltf.scenes) {
        json.scenes = gltf.scenes.map((scene, i5) => this._resolveScene(scene, i5));
      }
      if (typeof this.json.scene === "number" && json.scenes) {
        json.scene = json.scenes[this.json.scene];
      }
      return json;
    }
    getScene(index) {
      return this._get(this.json.scenes, index);
    }
    getNode(index) {
      return this._get(this.json.nodes, index);
    }
    getSkin(index) {
      return this._get(this.json.skins, index);
    }
    getMesh(index) {
      return this._get(this.json.meshes, index);
    }
    getMaterial(index) {
      return this._get(this.json.materials, index);
    }
    getAccessor(index) {
      return this._get(this.json.accessors, index);
    }
    getCamera(index) {
      return this._get(this.json.cameras, index);
    }
    getTexture(index) {
      return this._get(this.json.textures, index);
    }
    getSampler(index) {
      return this._get(this.json.samplers, index);
    }
    getImage(index) {
      return this._get(this.json.images, index);
    }
    getBufferView(index) {
      return this._get(this.json.bufferViews, index);
    }
    getBuffer(index) {
      return this._get(this.json.buffers, index);
    }
    _get(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = array && array[index];
      if (!object) {
        console.warn(`glTF file error: Could not find ${array}[${index}]`);
      }
      return object;
    }
    // PARSING HELPERS
    _resolveScene(scene, index) {
      return {
        ...scene,
        // @ts-ignore
        id: scene.id || `scene-${index}`,
        nodes: (scene.nodes || []).map((node) => this.getNode(node))
      };
    }
    _resolveNode(gltfNode, index) {
      const node = {
        ...gltfNode,
        // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: gltfNode?.id || `node-${index}`
      };
      if (gltfNode.mesh !== void 0) {
        node.mesh = this.getMesh(gltfNode.mesh);
      }
      if (gltfNode.camera !== void 0) {
        node.camera = this.getCamera(gltfNode.camera);
      }
      if (gltfNode.skin !== void 0) {
        node.skin = this.getSkin(gltfNode.skin);
      }
      if (gltfNode.meshes !== void 0 && gltfNode.meshes.length) {
        node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
          const mesh = this.getMesh(meshIndex);
          accum.id = mesh.id;
          accum.primitives = accum.primitives.concat(mesh.primitives);
          return accum;
        }, { primitives: [] });
      }
      return node;
    }
    _resolveNodeChildren(node) {
      if (node.children) {
        node.children = node.children.map((child) => this.getNode(child));
      }
      return node;
    }
    _resolveSkin(gltfSkin, index) {
      const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : void 0;
      return {
        ...gltfSkin,
        id: gltfSkin.id || `skin-${index}`,
        inverseBindMatrices
      };
    }
    _resolveMesh(gltfMesh, index) {
      const mesh = {
        ...gltfMesh,
        id: gltfMesh.id || `mesh-${index}`,
        primitives: []
      };
      if (gltfMesh.primitives) {
        mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
          const primitive = {
            ...gltfPrimitive,
            attributes: {},
            indices: void 0,
            material: void 0
          };
          const attributes = gltfPrimitive.attributes;
          for (const attribute in attributes) {
            primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
          }
          if (gltfPrimitive.indices !== void 0) {
            primitive.indices = this.getAccessor(gltfPrimitive.indices);
          }
          if (gltfPrimitive.material !== void 0) {
            primitive.material = this.getMaterial(gltfPrimitive.material);
          }
          return primitive;
        });
      }
      return mesh;
    }
    _resolveMaterial(gltfMaterial, index) {
      const material = {
        ...gltfMaterial,
        // @ts-expect-error
        id: gltfMaterial.id || `material-${index}`
      };
      if (material.normalTexture) {
        material.normalTexture = { ...material.normalTexture };
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }
      if (material.occlusionTexture) {
        material.occlusionTexture = { ...material.occlusionTexture };
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }
      if (material.emissiveTexture) {
        material.emissiveTexture = { ...material.emissiveTexture };
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }
      if (!material.emissiveFactor) {
        material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
      }
      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };
        const mr = material.pbrMetallicRoughness;
        if (mr.baseColorTexture) {
          mr.baseColorTexture = { ...mr.baseColorTexture };
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }
        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
      return material;
    }
    _resolveAccessor(gltfAccessor, index) {
      const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
      const components = getSizeFromAccessorType(gltfAccessor.type);
      const bytesPerElement = bytesPerComponent * components;
      const accessor = {
        ...gltfAccessor,
        // @ts-expect-error
        id: gltfAccessor.id || `accessor-${index}`,
        bytesPerComponent,
        components,
        bytesPerElement,
        value: void 0,
        bufferView: void 0,
        sparse: void 0
      };
      if (gltfAccessor.bufferView !== void 0) {
        accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
      }
      if (accessor.bufferView) {
        const buffer = accessor.bufferView.buffer;
        const { ArrayType: ArrayType2, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
        const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
        let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        if (accessor.bufferView.byteStride) {
          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
        }
        accessor.value = new ArrayType2(cutBuffer);
      }
      return accessor;
    }
    /**
     * Take values of particular accessor from interleaved buffer
     * various parts of the buffer
     * @param buffer
     * @param byteOffset
     * @param byteStride
     * @param bytesPerElement
     * @param count
     * @returns
     */
    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count3) {
      const result = new Uint8Array(count3 * bytesPerElement);
      for (let i5 = 0; i5 < count3; i5++) {
        const elementOffset = byteOffset + i5 * byteStride;
        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i5 * bytesPerElement);
      }
      return result.buffer;
    }
    _resolveTexture(gltfTexture, index) {
      return {
        ...gltfTexture,
        // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: gltfTexture.id || `texture-${index}`,
        sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
        source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : void 0
      };
    }
    _resolveSampler(gltfSampler, index) {
      const sampler = {
        // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: gltfSampler.id || `sampler-${index}`,
        ...gltfSampler,
        parameters: {}
      };
      for (const key in sampler) {
        const glEnum = this._enumSamplerParameter(key);
        if (glEnum !== void 0) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
      return sampler;
    }
    _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
    _resolveImage(gltfImage, index) {
      const image = {
        ...gltfImage,
        // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: gltfImage.id || `image-${index}`,
        image: null,
        bufferView: gltfImage.bufferView !== void 0 ? this.getBufferView(gltfImage.bufferView) : void 0
      };
      const preloadedImage = this.images[index];
      if (preloadedImage) {
        image.image = preloadedImage;
      }
      return image;
    }
    _resolveBufferView(gltfBufferView, index) {
      const bufferIndex = gltfBufferView.buffer;
      const arrayBuffer2 = this.buffers[bufferIndex].arrayBuffer;
      let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
      if (gltfBufferView.byteOffset) {
        byteOffset += gltfBufferView.byteOffset;
      }
      const bufferView = {
        // // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: `bufferView-${index}`,
        ...gltfBufferView,
        // ...this.buffers[bufferIndex],
        buffer: this.buffers[bufferIndex],
        data: new Uint8Array(arrayBuffer2, byteOffset, gltfBufferView.byteLength)
      };
      return bufferView;
    }
    _resolveCamera(gltfCamera, index) {
      const camera = {
        ...gltfCamera,
        // @ts-expect-error id could already be present, glTF standard does not prevent it
        id: gltfCamera.id || `camera-${index}`
      };
      if (camera.perspective) {
      }
      if (camera.orthographic) {
      }
      return camera;
    }
  };
  function postProcessGLTF(gltf, options) {
    return new GLTFPostProcessor().postProcess(gltf, options);
  }

  // ../mesh-layers/src/scenegraph-layer/gltf-utils.ts
  async function waitForGLTFAssets(gltfObjects) {
    const remaining = [];
    gltfObjects.scenes.forEach((scene) => {
      scene.traverse((modelNode) => {
        Object.values(modelNode.model.uniforms).forEach((uniform) => {
          if (uniform.loaded === false) {
            remaining.push(uniform);
          }
        });
      });
    });
    return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
  }
  async function waitWhileCondition(condition) {
    while (condition()) {
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
    }
  }

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-uniforms.ts
  var uniformBlock18 = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`;
  var scenegraphUniforms = {
    name: "scenegraph",
    vs: uniformBlock18,
    fs: uniformBlock18,
    uniformTypes: {
      sizeScale: "f32",
      sizeMinPixels: "f32",
      sizeMaxPixels: "f32",
      sceneModelMatrix: "mat4x4<f32>",
      composeModelMatrix: "f32"
    }
  };

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts
  var scenegraph_layer_vertex_glsl_default = `#version 300 es

#define SHADER_NAME scenegraph-layer-vertex-shader

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;

// Primitive attributes
in vec3 positions;
#ifdef HAS_UV
  in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
  #ifdef HAS_NORMALS
    in vec3 normals;
  #endif
#endif

// Varying
out vec4 vColor;

// pbrMaterial contains all the varying definitions needed
#ifndef LIGHTING_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif

// Main
void main(void) {
  #if defined(HAS_UV) && !defined(LIGHTING_PBR)
    vTEXCOORD_0 = texCoords;
    geometry.uv = texCoords;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef LIGHTING_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(scenegraph.sizeScale);
  float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(scenegraph.composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef LIGHTING_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = texCoords;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts
  var scenegraph_layer_fragment_glsl_default = `#version 300 es

#define SHADER_NAME scenegraph-layer-fragment-shader

// Varying
in vec4 vColor;

out vec4 fragColor;

// pbrMaterial contains all the varying definitions needed
#ifndef LIGHTING_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D pbr_baseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef LIGHTING_PBR
    fragColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragColor = vColor;
    #endif
  #endif

  fragColor.a *= layer.opacity;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer.ts
  var DEFAULT_COLOR11 = [255, 255, 255, 255];
  var defaultProps28 = {
    scenegraph: { type: "object", value: null, async: true },
    getScene: (gltf) => {
      if (gltf && gltf.scenes) {
        return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
      }
      return gltf;
    },
    getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
    _animations: null,
    sizeScale: { type: "number", value: 1, min: 0 },
    sizeMinPixels: { type: "number", min: 0, value: 0 },
    sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR11 },
    // flat or pbr
    _lighting: "flat",
    // _lighting must be pbr for this to work
    _imageBasedLightingEnvironment: void 0,
    // yaw, pitch and roll are in degrees
    // https://en.wikipedia.org/wiki/Euler_angles
    // [pitch, yaw, roll]
    getOrientation: { type: "accessor", value: [0, 0, 0] },
    getScale: { type: "accessor", value: [1, 1, 1] },
    getTranslation: { type: "accessor", value: [0, 0, 0] },
    // 4x4 matrix
    getTransformMatrix: { type: "accessor", value: [] },
    loaders: [GLTFLoader]
  };
  var ScenegraphLayer = class extends Layer {
    getShaders() {
      const defines2 = {};
      let pbr;
      if (this.props._lighting === "pbr") {
        pbr = pbrMaterial;
        defines2.LIGHTING_PBR = 1;
      } else {
        pbr = { name: "pbrMaterial" };
      }
      const modules = [project32_default, picking_default, scenegraphUniforms, pbr];
      return super.getShaders({ defines: defines2, vs: scenegraph_layer_vertex_glsl_default, fs: scenegraph_layer_fragment_glsl_default, modules });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          accessor: "getPosition",
          transition: true
        },
        instanceColors: {
          type: "unorm8",
          size: this.props.colorFormat.length,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR11,
          transition: true
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      if (props.scenegraph !== oldProps.scenegraph) {
        this._updateScenegraph();
      } else if (props._animations !== oldProps._animations) {
        this._applyAnimationsProp(this.state.animator, props._animations);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.scenegraph?.destroy();
    }
    get isLoaded() {
      return Boolean(this.state?.scenegraph && super.isLoaded);
    }
    _updateScenegraph() {
      const props = this.props;
      const { device } = this.context;
      let scenegraphData = null;
      if (props.scenegraph instanceof ScenegraphNode) {
        scenegraphData = { scenes: [props.scenegraph] };
      } else if (props.scenegraph && typeof props.scenegraph === "object") {
        const gltf = props.scenegraph;
        const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;
        const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());
        scenegraphData = { gltf: processedGLTF, ...gltfObjects };
        waitForGLTFAssets(gltfObjects).then(() => {
          this.setNeedsRedraw();
        }).catch((ex) => {
          this.raiseError(ex, "loading glTF");
        });
      }
      const options = { layer: this, device: this.context.device };
      const scenegraph = props.getScene(scenegraphData, options);
      const animator = props.getAnimator(scenegraphData, options);
      if (scenegraph instanceof GroupNode) {
        this.state.scenegraph?.destroy();
        this._applyAnimationsProp(animator, props._animations);
        const models = [];
        scenegraph.traverse((node) => {
          if (node instanceof ModelNode) {
            models.push(node.model);
          }
        });
        this.setState({ scenegraph, animator, models });
        this.getAttributeManager().invalidateAll();
      } else if (scenegraph !== null) {
        log_default.warn("invalid scenegraph:", scenegraph)();
      }
    }
    _applyAnimationsProp(animator, animationsProp) {
      if (!animator || !animationsProp) {
        return;
      }
      const animations = animator.getAnimations();
      Object.keys(animationsProp).sort().forEach((key) => {
        const value = animationsProp[key];
        if (key === "*") {
          animations.forEach((animation) => {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          const number = Number(key);
          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        } else {
          const findResult = animations.find(({ name: name13 }) => name13 === key);
          if (findResult) {
            Object.assign(findResult, value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        }
      });
    }
    _getModelOptions() {
      const { _imageBasedLightingEnvironment } = this.props;
      let env;
      if (_imageBasedLightingEnvironment) {
        if (typeof _imageBasedLightingEnvironment === "function") {
          env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });
        } else {
          env = _imageBasedLightingEnvironment;
        }
      }
      return {
        imageBasedLightingEnvironment: env,
        modelOptions: {
          id: this.props.id,
          isInstanced: true,
          bufferLayout: this.getAttributeManager().getBufferLayouts(),
          ...this.getShaders()
        },
        // tangents are not supported
        useTangents: false
      };
    }
    draw({ context }) {
      if (!this.state.scenegraph)
        return;
      if (this.props._animations && this.state.animator) {
        this.state.animator.animate(context.timeline.getTime());
        this.setNeedsRedraw();
      }
      const { viewport, renderPass } = this.context;
      const { sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem } = this.props;
      const numInstances = this.getNumInstances();
      this.state.scenegraph.traverse((node, { worldMatrix }) => {
        if (node instanceof ModelNode) {
          const { model } = node;
          model.setInstanceCount(numInstances);
          const pbrProjectionProps = {
            // Needed for PBR (TODO: find better way to get it)
            camera: model.uniforms.cameraPosition
          };
          const scenegraphProps = {
            sizeScale,
            sizeMinPixels,
            sizeMaxPixels,
            composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
            sceneModelMatrix: worldMatrix
          };
          model.shaderInputs.setProps({
            pbrProjection: pbrProjectionProps,
            scenegraph: scenegraphProps
          });
          model.draw(renderPass);
        }
      });
    }
  };
  ScenegraphLayer.defaultProps = defaultProps28;
  ScenegraphLayer.layerName = "ScenegraphLayer";

  // ../geo-layers/src/mesh-layer/mesh-layer-uniforms.ts
  var uniformBlock19 = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`;
  var meshUniforms = {
    name: "mesh",
    vs: uniformBlock19,
    fs: uniformBlock19,
    uniformTypes: {
      pickFeatureIds: "f32"
    }
  };

  // ../geo-layers/src/mesh-layer/mesh-layer-vertex.glsl.ts
  var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;

// Instance attributes
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/geometryUVRegion.cmn.md
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (mesh.pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);

  vTexCoord = uv;
  cameraPosition = project.cameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBRMATERIAL
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer-fragment.glsl.ts
  var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform sampler2D sampler;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBRMATERIAL

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= layer.opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (simpleMesh.flatShading) {

  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
  } else {
    normal = normals_commonspace;
  }

  vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * layer.opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer.ts
  function validateGeometryAttributes(attributes) {
    const positionAttribute = attributes.positions || attributes.POSITION;
    const vertexCount = positionAttribute.value.length / positionAttribute.size;
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!hasColorAttribute) {
      attributes.colors = {
        size: 4,
        value: new Uint8Array(vertexCount * 4).fill(255),
        normalized: true
      };
    }
  }
  var defaultProps29 = {
    pbrMaterial: { type: "object", value: null },
    featureIds: { type: "array", value: null, optional: true }
  };
  var MeshLayer = class extends SimpleMeshLayer {
    getShaders() {
      const shaders = super.getShaders();
      const modules = shaders.modules;
      modules.push(pbrMaterial, meshUniforms);
      return { ...shaders, vs: mesh_layer_vertex_glsl_default, fs: mesh_layer_fragment_glsl_default };
    }
    initializeState() {
      const { featureIds } = this.props;
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      if (featureIds) {
        attributeManager.add({
          featureIdsPickingColors: {
            type: "uint8",
            size: 3,
            noAlloc: true,
            // eslint-disable-next-line @typescript-eslint/unbound-method
            update: this.calculateFeatureIdsPickingColors
          }
        });
      }
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      if (props.pbrMaterial !== oldProps.pbrMaterial) {
        this.updatePbrMaterialUniforms(props.pbrMaterial);
      }
    }
    draw(opts) {
      const { featureIds } = this.props;
      const { model } = this.state;
      if (!model) {
        return;
      }
      const meshProps = {
        pickFeatureIds: Boolean(featureIds)
      };
      const pbrProjectionProps = {
        // Needed for PBR (TODO: find better way to get it)
        camera: model.uniforms.cameraPosition
      };
      model.shaderInputs.setProps({
        pbrProjection: pbrProjectionProps,
        mesh: meshProps
      });
      super.draw(opts);
    }
    getModel(mesh) {
      const { id } = this.props;
      const parsedPBRMaterial = this.parseMaterial(this.props.pbrMaterial, mesh);
      this.setState({ parsedPBRMaterial });
      const shaders = this.getShaders();
      validateGeometryAttributes(mesh.attributes);
      const model = new Model(this.context.device, {
        ...this.getShaders(),
        id,
        geometry: mesh,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        defines: {
          ...shaders.defines,
          ...parsedPBRMaterial?.defines,
          HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0
        },
        parameters: parsedPBRMaterial?.parameters,
        isInstanced: true
      });
      return model;
    }
    updatePbrMaterialUniforms(material) {
      const { model } = this.state;
      if (model) {
        const { mesh } = this.props;
        const parsedPBRMaterial = this.parseMaterial(material, mesh);
        this.setState({ parsedPBRMaterial });
        const { pbr_baseColorSampler } = parsedPBRMaterial.bindings;
        const { emptyTexture } = this.state;
        const simpleMeshProps = {
          sampler: pbr_baseColorSampler || emptyTexture,
          hasTexture: Boolean(pbr_baseColorSampler)
        };
        const { camera, ...pbrMaterialProps } = {
          ...parsedPBRMaterial.bindings,
          ...parsedPBRMaterial.uniforms
        };
        model.shaderInputs.setProps({ simpleMesh: simpleMeshProps, pbrMaterial: pbrMaterialProps });
      }
    }
    parseMaterial(material, mesh) {
      const unlit = Boolean(
        material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture
      );
      return parsePBRMaterial(
        this.context.device,
        { unlit, ...material },
        { NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords },
        {
          pbrDebug: false,
          lights: true,
          useTangents: false
        }
      );
    }
    calculateFeatureIdsPickingColors(attribute) {
      const featureIds = this.props.featureIds;
      const value = new Uint8ClampedArray(featureIds.length * attribute.size);
      const pickingColor = [];
      for (let index = 0; index < featureIds.length; index++) {
        this.encodePickingColor(featureIds[index], pickingColor);
        value[index * 3] = pickingColor[0];
        value[index * 3 + 1] = pickingColor[1];
        value[index * 3 + 2] = pickingColor[2];
      }
      attribute.value = value;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.parsedPBRMaterial?.generatedTextures.forEach((texture) => texture.destroy());
      this.setState({ parsedPBRMaterial: null });
    }
  };
  MeshLayer.layerName = "MeshLayer";
  MeshLayer.defaultProps = defaultProps29;

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES5 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS9 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG3 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG3 } };
  var config3 = globalThis.mathgl.config;
  function formatValue3(value, { precision = config3.precision } = {}) {
    value = round8(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray5(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function degrees2(radians6, result) {
    return map3(radians6, (radians7) => radians7 * RADIANS_TO_DEGREES5, result);
  }
  function equals7(a3, b2, epsilon) {
    const oldEpsilon = config3.EPSILON;
    if (epsilon) {
      config3.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray5(a3) && isArray5(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals7(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config3.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config3.EPSILON = oldEpsilon;
    }
  }
  function round8(value) {
    return Math.round(value / config3.EPSILON) * config3.EPSILON;
  }
  function duplicateArray2(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map3(value, func, result) {
    if (isArray5(value)) {
      const array = value;
      result = result || duplicateArray2(array);
      for (let i5 = 0; i5 < result.length && i5 < array.length; ++i5) {
        const val2 = typeof value === "number" ? value : value[i5];
        result[i5] = func(val2, i5, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray3 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray5(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config3);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue3(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals7(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config3.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector3(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber3(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector3(v2, length16, callerName = "") {
    if (config3.debug && !validateVector3(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/lib/assert.js
  function assert11(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector6 = class extends MathArray3 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber3(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber3(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber3(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber3(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert11(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber3(this[i5]);
    }
    setComponent(i5, value) {
      assert11(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON25 = 1e-6;
  var ARRAY_TYPE3 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree3 = Math.PI / 180;

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create9() {
    const out = new ARRAY_TYPE3(2);
    if (ARRAY_TYPE3 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat35(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  function transformMat45(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[4] * y3 + m[12];
    out[1] = m[1] * x3 + m[5] * y3 + m[13];
    return out;
  }
  var forEach7 = function() {
    const vec = create9();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m[3] * x3 + m[7] * y3 || 1;
    out[0] = (m[0] * x3 + m[4] * y3) / w2;
    out[1] = (m[1] * x3 + m[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector3(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat23(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat22(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function vec4_transformMat33(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m[0] * x3 + m[3] * y3 + m[6] * z2;
    out[1] = m[1] * x3 + m[4] * y3 + m[7] * z2;
    out[2] = m[2] * x3 + m[5] * y3 + m[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create10() {
    const out = new ARRAY_TYPE3(3);
    if (ARRAY_TYPE3 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length5(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues5(x3, y3, z2) {
    const out = new ARRAY_TYPE3(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function normalize6(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    out[2] = a3[2] * len8;
    return out;
  }
  function dot6(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross5(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat46(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat36(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat4(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX5(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY5(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ5(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle4(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot6(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var len4 = length5;
  var forEach8 = function() {
    const vec = create10();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN3 = [0, 0, 0];
  var ZERO5;
  var Vector33 = class extends Vector6 {
    static get ZERO() {
      if (!ZERO5) {
        ZERO5 = new Vector33(0, 0, 0);
        Object.freeze(ZERO5);
      }
      return ZERO5;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray5(x3)) {
        this.copy(x3);
      } else {
        if (config3.debug) {
          checkNumber3(x3);
          checkNumber3(y3);
          checkNumber3(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config3.debug) {
        checkNumber3(object.x);
        checkNumber3(object.y);
        checkNumber3(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber3(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle4(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross5(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN3 }) {
      rotateX5(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN3 }) {
      rotateY5(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN3 }) {
      rotateZ5(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat46(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector3(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat36(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat23(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat4(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/vector4.js
  var ZERO6;
  var Vector42 = class extends Vector6 {
    static get ZERO() {
      if (!ZERO6) {
        ZERO6 = new Vector42(0, 0, 0, 0);
        Object.freeze(ZERO6);
      }
      return ZERO6;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 0) {
      super(-0, -0, -0, -0);
      if (isArray5(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config3.debug) {
          checkNumber3(x3);
          checkNumber3(y3);
          checkNumber3(z2);
          checkNumber3(w2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
        this[3] = w2;
      }
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config3.debug) {
        checkNumber3(object.x);
        checkNumber3(object.y);
        checkNumber3(object.z);
        checkNumber3(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber3(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber3(value);
    }
    transform(matrix4) {
      transformMat46(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat33(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat22(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat4(this, this, quaternion2);
      return this.check();
    }
    // three.js compatibility
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix5 = class extends MathArray3 {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config3.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber3(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function create11() {
    const out = new ARRAY_TYPE3(9);
    if (ARRAY_TYPE3 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose4(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert5(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant4(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply8(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate4(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate5(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale8(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat5(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES4;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES10[INDICES10["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES4 || (INDICES4 = {}));
  var IDENTITY_MATRIX6 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix33 = class extends Matrix5 {
    static get IDENTITY() {
      return getIdentityMatrix4();
    }
    static get ZERO() {
      return getZeroMatrix4();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES4;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    // Constructors
    identity() {
      return this.copy(IDENTITY_MATRIX6);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /** Calculates a 3x3 matrix from the given quaternion
     * q quat  Quaternion to create matrix from
     */
    fromQuaternion(q2) {
      fromQuat5(this, q2);
      return this.check();
    }
    /**
     * accepts column major order, stores in column major order
     */
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    /**
     * accepts row major order, stores as column major
     */
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant4(this);
    }
    // Modifiers
    transpose() {
      transpose4(this, this);
      return this.check();
    }
    /** Invert a matrix. Note that this can fail if the matrix is not invertible */
    invert() {
      invert5(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply8(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply8(this, this, a3);
      return this.check();
    }
    rotate(radians6) {
      rotate5(this, this, radians6);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale8(this, this, factor);
      } else {
        scale8(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate4(this, this, vec);
      return this.check();
    }
    // Transforms
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat35(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat36(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat33(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector3(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX33;
  var IDENTITY_MATRIX33 = null;
  function getZeroMatrix4() {
    if (!ZERO_MATRIX33) {
      ZERO_MATRIX33 = new Matrix33([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX33);
    }
    return ZERO_MATRIX33;
  }
  function getIdentityMatrix4() {
    if (!IDENTITY_MATRIX33) {
      IDENTITY_MATRIX33 = new Matrix33();
      Object.freeze(IDENTITY_MATRIX33);
    }
    return IDENTITY_MATRIX33;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose5(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert6(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant5(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply9(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate5(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale9(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate6(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len8 < EPSILON25) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX6(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY6(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ6(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromQuat6(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum2(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO2(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective2 = perspectiveNO2;
  function orthoNO2(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho2 = orthoNO2;
  function lookAt2(out, eye, center, up) {
    let len8;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON25 && Math.abs(eyey - centery) < EPSILON25 && Math.abs(eyez - centerz) < EPSILON25) {
      return identity3(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len8 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len8;
    z1 *= len8;
    z2 *= len8;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len8 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len8) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len8 = 1 / len8;
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len8 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len8) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len8 = 1 / len8;
      y0 *= len8;
      y1 *= len8;
      y22 *= len8;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create12() {
    const out = new ARRAY_TYPE3(4);
    if (ARRAY_TYPE3 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add7(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    return out;
  }
  function scale10(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    return out;
  }
  function length6(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredLength5(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function normalize7(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = x3 * len8;
    out[1] = y3 * len8;
    out[2] = z2 * len8;
    out[3] = w2 * len8;
    return out;
  }
  function dot7(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
  }
  function lerp7(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    out[3] = aw + t3 * (b2[3] - aw);
    return out;
  }
  function transformMat47(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    out[0] = m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12] * w2;
    out[1] = m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13] * w2;
    out[2] = m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14] * w2;
    out[3] = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15] * w2;
    return out;
  }
  function transformQuat5(out, a3, q2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  var forEach9 = function() {
    const vec = create12();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES5;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES10[INDICES10["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES10[INDICES10["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES10[INDICES10["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES10[INDICES10["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES10[INDICES10["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES10[INDICES10["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES10[INDICES10["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES10[INDICES10["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES5 || (INDICES5 = {}));
  var DEFAULT_FOVY2 = 45 * Math.PI / 180;
  var DEFAULT_ASPECT2 = 1;
  var DEFAULT_NEAR2 = 0.1;
  var DEFAULT_FAR2 = 500;
  var IDENTITY_MATRIX7 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix42 = class extends Matrix5 {
    static get IDENTITY() {
      return getIdentityMatrix5();
    }
    static get ZERO() {
      return getZeroMatrix5();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES5;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX7);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion2) {
      fromQuat6(this, quaternion2);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR2, far = DEFAULT_FAR2 } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter2(this, left, right, bottom, top, near);
      } else {
        frustum2(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt2(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR2, far = DEFAULT_FAR2 } = view;
      ortho2(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY2, aspect = DEFAULT_ASPECT2, focalDistance = 1, near = DEFAULT_NEAR2, far = DEFAULT_FAR2 } = view;
      checkRadians2(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians2(fovy);
      perspective2(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant5(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose5(this, this);
      return this.check();
    }
    invert() {
      invert6(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply9(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply9(this, this, a3);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians6) {
      rotateX6(this, this, radians6);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians6) {
      rotateY6(this, this, radians6);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians6) {
      rotateZ6(this, this, radians6);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians6, axis) {
      rotate6(this, this, radians6, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale9(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate5(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat47(result || [-0, -0, -0, -0], vector, this);
        checkVector3(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length: length16 } = vector;
      let out;
      switch (length16) {
        case 2:
          out = transformMat45(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat46(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector3(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector2(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector3(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector3(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians6) {
      return this.identity().rotateX(radians6);
    }
    makeTranslation(x3, y3, z2) {
      return this.identity().translate([x3, y3, z2]);
    }
  };
  var ZERO7;
  var IDENTITY3;
  function getZeroMatrix5() {
    if (!ZERO7) {
      ZERO7 = new Matrix42([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO7);
    }
    return ZERO7;
  }
  function getIdentityMatrix5() {
    if (!IDENTITY3) {
      IDENTITY3 = new Matrix42();
      Object.freeze(IDENTITY3);
    }
    return IDENTITY3;
  }
  function checkRadians2(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter2(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/gl-matrix/quat.js
  function create13() {
    const out = new ARRAY_TYPE3(4);
    if (ARRAY_TYPE3 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle2(out, axis, rad) {
    rad = rad * 0.5;
    const s3 = Math.sin(rad);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply10(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const bw = b2[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX7(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY7(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ7(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW2(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z2 * z2));
    return out;
  }
  function slerp3(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    let bx = b2[0];
    let by = b2[1];
    let bz = b2[2];
    let bw = b2[3];
    let cosom;
    let omega;
    let scale0;
    let scale1;
    let sinom;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON25) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t3) * omega) / sinom;
      scale1 = Math.sin(t3 * omega) / sinom;
    } else {
      scale0 = 1 - t3;
      scale1 = t3;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert7(out, a3) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const dot17 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    const invDot = dot17 ? 1 / dot17 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate2(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat32(out, m) {
    const fTrace = m[0] + m[4] + m[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m[4] > m[0])
        i5 = 1;
      if (m[8] > m[i5 * 3 + i5])
        i5 = 2;
      const j2 = (i5 + 1) % 3;
      const k2 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m[i5 * 3 + i5] - m[j2 * 3 + j2] - m[k2 * 3 + k2] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j2 * 3 + k2] - m[k2 * 3 + j2]) * fRoot;
      out[j2] = (m[j2 * 3 + i5] + m[i5 * 3 + j2]) * fRoot;
      out[k2] = (m[k2 * 3 + i5] + m[i5 * 3 + k2]) * fRoot;
    }
    return out;
  }
  var add8 = add7;
  var scale11 = scale10;
  var dot8 = dot7;
  var lerp8 = lerp7;
  var length7 = length6;
  var squaredLength6 = squaredLength5;
  var normalize8 = normalize7;
  var rotationTo2 = function() {
    const tmpvec3 = create10();
    const xUnitVec3 = fromValues5(1, 0, 0);
    const yUnitVec3 = fromValues5(0, 1, 0);
    return function(out, a3, b2) {
      const dot17 = dot6(a3, b2);
      if (dot17 < -0.999999) {
        cross5(tmpvec3, xUnitVec3, a3);
        if (len4(tmpvec3) < 1e-6)
          cross5(tmpvec3, yUnitVec3, a3);
        normalize6(tmpvec3, tmpvec3);
        setAxisAngle2(out, tmpvec3, Math.PI);
        return out;
      } else if (dot17 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      cross5(tmpvec3, a3, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot17;
      return normalize8(out, out);
    };
  }();
  var sqlerp2 = function() {
    const temp1 = create13();
    const temp2 = create13();
    return function(out, a3, b2, c2, d2, t3) {
      slerp3(temp1, a3, d2, t3);
      slerp3(temp2, b2, c2, t3);
      slerp3(out, temp1, temp2, 2 * t3 * (1 - t3));
      return out;
    };
  }();
  var setAxes2 = function() {
    const matr = create11();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize8(out, fromMat32(out, matr));
    };
  }();

  // ../../node_modules/@loaders.gl/tiles/node_modules/@math.gl/core/dist/classes/quaternion.js
  var IDENTITY_QUATERNION2 = [0, 0, 0, 1];
  var Quaternion2 = class extends MathArray3 {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        this.set(x3, y3, z2, w2);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * NOTE: The resultant quaternion is not normalized, so you should
     * be sure to renormalize the quaternion yourself where necessary.
     * @param m
     * @returns
     */
    fromMatrix3(m) {
      fromMat32(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle2(this, axis, rad);
      return this.check();
    }
    /** Set a quat to the identity quaternion */
    identity() {
      identity4(this);
      return this.check();
    }
    // Set the components of a quat to the given values
    // set(i, j, k, l) {
    //   quat_set(this, i, j, k, l);
    //   return this.check();
    // }
    // Sets a quat from the given angle and rotation axis, then returns it.
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    // Getters/setters
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber3(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber3(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber3(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber3(value);
    }
    // Calculates the length of a quat
    len() {
      return length7(this);
    }
    // Calculates the squared length of a quat
    lengthSquared() {
      return squaredLength6(this);
    }
    // Calculates the dot product of two quat's
    // @return {Number}
    dot(a3) {
      return dot8(this, a3);
    }
    // Gets the rotation axis and angle for a given quaternion.
    // If a quaternion is created with setAxisAngle, this method will
    // return the same values as providied in the original parameter
    // list OR functionally equivalent values.
    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
    // is the same as the quaternion formed by [0, 0, 1] and 270.
    // This method favors the latter.
    // @return {{[x,y,z], Number}}
    // getAxisAngle() {
    //   const axis = [];
    // //   const angle = quat_getAxisAngle(axis, this);
    //   return {axis, angle};
    // }
    // MODIFIERS
    // Sets a quaternion to represent the shortest rotation from one vector
    // to another. Both vectors are assumed to be unit length.
    rotationTo(vectorA, vectorB) {
      rotationTo2(this, vectorA, vectorB);
      return this.check();
    }
    // Sets the specified quaternion with values corresponding to the given axes.
    // Each axis is a vec3 and is expected to be unit length and perpendicular
    // to all other specified axes.
    // setAxes() {
    //   Number
    // }
    // Performs a spherical linear interpolation with two control points
    // sqlerp() {
    //   Number;
    // }
    // Adds two quat's
    add(a3) {
      add8(this, this, a3);
      return this.check();
    }
    // Calculates the W component of a quat from the X, Y, and Z components.
    // Any existing W component will be ignored.
    calculateW() {
      calculateW2(this, this);
      return this.check();
    }
    // Calculates the conjugate of a quat If the quaternion is normalized,
    // this function is faster than quat_invert and produces the same result.
    conjugate() {
      conjugate2(this, this);
      return this.check();
    }
    // Calculates the inverse of a quat
    invert() {
      invert7(this, this);
      return this.check();
    }
    // Performs a linear interpolation between two quat's
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      lerp8(this, a3, b2, t3);
      return this.check();
    }
    // Multiplies two quat's
    multiplyRight(a3) {
      multiply10(this, this, a3);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply10(this, a3, this);
      return this.check();
    }
    // Normalize a quat
    normalize() {
      const length16 = this.len();
      const l3 = length16 > 0 ? 1 / length16 : 0;
      this[0] = this[0] * l3;
      this[1] = this[1] * l3;
      this[2] = this[2] * l3;
      this[3] = this[3] * l3;
      if (length16 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    // Rotates a quaternion by the given angle about the X axis
    rotateX(rad) {
      rotateX7(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Y axis
    rotateY(rad) {
      rotateY7(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Z axis
    rotateZ(rad) {
      rotateZ7(this, this, rad);
      return this.check();
    }
    // Scales a quat by a scalar number
    scale(b2) {
      scale11(this, this, b2);
      return this.check();
    }
    // Performs a spherical linear interpolation between two quat
    slerp(arg0, arg1, arg2) {
      let start;
      let target2;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION2,
            target: target2,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target2 = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target2 = arg1;
          ratio = arg2;
      }
      slerp3(this, start, target2, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector42()) {
      transformQuat5(result, vector, this);
      return checkVector3(result, 4);
    }
    // THREE.js Math API compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a3) {
      return this.multiplyLeft(a3);
    }
    multiply(a3) {
      return this.multiplyRight(a3);
    }
  };

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES6 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS10 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG4 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG4 } };
  var config4 = globalThis.mathgl.config;
  function formatValue4(value, { precision = config4.precision } = {}) {
    value = round10(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray6(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function toRadians3(degrees6) {
    return radians3(degrees6);
  }
  function toDegrees3(radians6) {
    return degrees3(radians6);
  }
  function radians3(degrees6, result) {
    return map4(degrees6, (degrees7) => degrees7 * DEGREES_TO_RADIANS10, result);
  }
  function degrees3(radians6, result) {
    return map4(radians6, (radians7) => radians7 * RADIANS_TO_DEGREES6, result);
  }
  function equals8(a3, b2, epsilon) {
    const oldEpsilon = config4.EPSILON;
    if (epsilon) {
      config4.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray6(a3) && isArray6(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals8(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config4.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config4.EPSILON = oldEpsilon;
    }
  }
  function round10(value) {
    return Math.round(value / config4.EPSILON) * config4.EPSILON;
  }
  function duplicateArray3(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map4(value, func, result) {
    if (isArray6(value)) {
      const array = value;
      result = result || duplicateArray3(array);
      for (let i5 = 0; i5 < result.length && i5 < array.length; ++i5) {
        const val2 = typeof value === "number" ? value : value[i5];
        result[i5] = func(val2, i5, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray4 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray6(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config4);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue4(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals8(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config4.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector4(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber4(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector4(v2, length16, callerName = "") {
    if (config4.debug && !validateVector4(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/lib/assert.js
  function assert12(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector7 = class extends MathArray4 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber4(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber4(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber4(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber4(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert12(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber4(this[i5]);
    }
    setComponent(i5, value) {
      assert12(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON26 = 1e-6;
  var ARRAY_TYPE4 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM4 = Math.random;
  function round11(a3) {
    if (a3 >= 0)
      return Math.round(a3);
    return a3 % 0.5 === 0 ? Math.floor(a3) : Math.round(a3);
  }
  var degree4 = Math.PI / 180;

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create14() {
    const out = new ARRAY_TYPE4(2);
    if (ARRAY_TYPE4 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat48(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[4] * y3 + m[12];
    out[1] = m[1] * x3 + m[5] * y3 + m[13];
    return out;
  }
  var forEach10 = function() {
    const vec = create14();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector3(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m[3] * x3 + m[7] * y3 || 1;
    out[0] = (m[0] * x3 + m[4] * y3) / w2;
    out[1] = (m[1] * x3 + m[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector4(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat24(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  var vec3_exports3 = {};
  __export(vec3_exports3, {
    add: () => add9,
    angle: () => angle5,
    bezier: () => bezier2,
    ceil: () => ceil4,
    clone: () => clone8,
    copy: () => copy7,
    create: () => create15,
    cross: () => cross6,
    dist: () => dist4,
    distance: () => distance5,
    div: () => div4,
    divide: () => divide4,
    dot: () => dot9,
    equals: () => equals9,
    exactEquals: () => exactEquals8,
    floor: () => floor4,
    forEach: () => forEach11,
    fromValues: () => fromValues7,
    hermite: () => hermite2,
    inverse: () => inverse4,
    len: () => len5,
    length: () => length8,
    lerp: () => lerp10,
    max: () => max4,
    min: () => min4,
    mul: () => mul5,
    multiply: () => multiply11,
    negate: () => negate4,
    normalize: () => normalize9,
    random: () => random4,
    rotateX: () => rotateX8,
    rotateY: () => rotateY8,
    rotateZ: () => rotateZ8,
    round: () => round12,
    scale: () => scale12,
    scaleAndAdd: () => scaleAndAdd4,
    set: () => set6,
    slerp: () => slerp4,
    sqrDist: () => sqrDist4,
    sqrLen: () => sqrLen4,
    squaredDistance: () => squaredDistance4,
    squaredLength: () => squaredLength7,
    str: () => str5,
    sub: () => sub5,
    subtract: () => subtract5,
    transformMat3: () => transformMat37,
    transformMat4: () => transformMat49,
    transformQuat: () => transformQuat6,
    zero: () => zero4
  });
  function create15() {
    const out = new ARRAY_TYPE4(3);
    if (ARRAY_TYPE4 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone8(a3) {
    const out = new ARRAY_TYPE4(3);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function length8(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues7(x3, y3, z2) {
    const out = new ARRAY_TYPE4(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function copy7(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function set6(out, x3, y3, z2) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function add9(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    return out;
  }
  function subtract5(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    return out;
  }
  function multiply11(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    out[2] = a3[2] * b2[2];
    return out;
  }
  function divide4(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    out[2] = a3[2] / b2[2];
    return out;
  }
  function ceil4(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    return out;
  }
  function floor4(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    return out;
  }
  function min4(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    out[2] = Math.min(a3[2], b2[2]);
    return out;
  }
  function max4(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    out[2] = Math.max(a3[2], b2[2]);
    return out;
  }
  function round12(out, a3) {
    out[0] = round11(a3[0]);
    out[1] = round11(a3[1]);
    out[2] = round11(a3[2]);
    return out;
  }
  function scale12(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    return out;
  }
  function scaleAndAdd4(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    out[2] = a3[2] + b2[2] * scale22;
    return out;
  }
  function distance5(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function squaredDistance4(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function squaredLength7(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function negate4(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    return out;
  }
  function inverse4(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    return out;
  }
  function normalize9(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    out[2] = a3[2] * len8;
    return out;
  }
  function dot9(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross6(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp10(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    return out;
  }
  function slerp4(out, a3, b2, t3) {
    const angle9 = Math.acos(Math.min(Math.max(dot9(a3, b2), -1), 1));
    const sinTotal = Math.sin(angle9);
    const ratioA = Math.sin((1 - t3) * angle9) / sinTotal;
    const ratioB = Math.sin(t3 * angle9) / sinTotal;
    out[0] = ratioA * a3[0] + ratioB * b2[0];
    out[1] = ratioA * a3[1] + ratioB * b2[1];
    out[2] = ratioA * a3[2] + ratioB * b2[2];
    return out;
  }
  function hermite2(out, a3, b2, c2, d2, t3) {
    const factorTimes2 = t3 * t3;
    const factor1 = factorTimes2 * (2 * t3 - 3) + 1;
    const factor2 = factorTimes2 * (t3 - 2) + t3;
    const factor3 = factorTimes2 * (t3 - 1);
    const factor4 = factorTimes2 * (3 - 2 * t3);
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function bezier2(out, a3, b2, c2, d2, t3) {
    const inverseFactor = 1 - t3;
    const inverseFactorTimesTwo = inverseFactor * inverseFactor;
    const factorTimes2 = t3 * t3;
    const factor1 = inverseFactorTimesTwo * inverseFactor;
    const factor2 = 3 * t3 * inverseFactorTimesTwo;
    const factor3 = 3 * factorTimes2 * inverseFactor;
    const factor4 = factorTimes2 * t3;
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function random4(out, scale22) {
    scale22 = scale22 === void 0 ? 1 : scale22;
    const r3 = RANDOM4() * 2 * Math.PI;
    const z2 = RANDOM4() * 2 - 1;
    const zScale = Math.sqrt(1 - z2 * z2) * scale22;
    out[0] = Math.cos(r3) * zScale;
    out[1] = Math.sin(r3) * zScale;
    out[2] = z2 * scale22;
    return out;
  }
  function transformMat49(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat37(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat6(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX8(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY8(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ8(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle5(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot9(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero4(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str5(a3) {
    return `vec3(${a3[0]}, ${a3[1]}, ${a3[2]})`;
  }
  function exactEquals8(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2];
  }
  function equals9(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    return Math.abs(a0 - b0) <= EPSILON26 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON26 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON26 * Math.max(1, Math.abs(a22), Math.abs(b22));
  }
  var sub5 = subtract5;
  var mul5 = multiply11;
  var div4 = divide4;
  var dist4 = distance5;
  var sqrDist4 = squaredDistance4;
  var len5 = length8;
  var sqrLen4 = squaredLength7;
  var forEach11 = function() {
    const vec = create15();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN4 = [0, 0, 0];
  var ZERO8;
  var Vector34 = class extends Vector7 {
    static get ZERO() {
      if (!ZERO8) {
        ZERO8 = new Vector34(0, 0, 0);
        Object.freeze(ZERO8);
      }
      return ZERO8;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray6(x3)) {
        this.copy(x3);
      } else {
        if (config4.debug) {
          checkNumber4(x3);
          checkNumber4(y3);
          checkNumber4(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config4.debug) {
        checkNumber4(object.x);
        checkNumber4(object.y);
        checkNumber4(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber4(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle5(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross6(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN4 }) {
      rotateX8(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN4 }) {
      rotateY8(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN4 }) {
      rotateZ8(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat49(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector4(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat37(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat24(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat6(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix6 = class extends MathArray4 {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config4.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber4(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity5(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose6(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert8(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant6(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply12(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate6(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale13(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate7(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len8 < EPSILON26) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX9(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY9(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ9(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromQuat7(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum3(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO3(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective3 = perspectiveNO3;
  function orthoNO3(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho3 = orthoNO3;
  function lookAt3(out, eye, center, up) {
    let len8;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON26 && Math.abs(eyey - centery) < EPSILON26 && Math.abs(eyez - centerz) < EPSILON26) {
      return identity5(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len8 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len8;
    z1 *= len8;
    z2 *= len8;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len8 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len8) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len8 = 1 / len8;
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len8 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len8) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len8 = 1 / len8;
      y0 *= len8;
      y1 *= len8;
      y22 *= len8;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create16() {
    const out = new ARRAY_TYPE4(4);
    if (ARRAY_TYPE4 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function transformMat410(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    out[0] = m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12] * w2;
    out[1] = m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13] * w2;
    out[2] = m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14] * w2;
    out[3] = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15] * w2;
    return out;
  }
  var forEach12 = function() {
    const vec = create16();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES6;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES10[INDICES10["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES10[INDICES10["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES10[INDICES10["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES10[INDICES10["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES10[INDICES10["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES10[INDICES10["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES10[INDICES10["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES10[INDICES10["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES6 || (INDICES6 = {}));
  var DEFAULT_FOVY3 = 45 * Math.PI / 180;
  var DEFAULT_ASPECT3 = 1;
  var DEFAULT_NEAR3 = 0.1;
  var DEFAULT_FAR3 = 500;
  var IDENTITY_MATRIX8 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix43 = class extends Matrix6 {
    static get IDENTITY() {
      return getIdentityMatrix6();
    }
    static get ZERO() {
      return getZeroMatrix6();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES6;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX8);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion2) {
      fromQuat7(this, quaternion2);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR3, far = DEFAULT_FAR3 } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter3(this, left, right, bottom, top, near);
      } else {
        frustum3(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt3(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR3, far = DEFAULT_FAR3 } = view;
      ortho3(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY3, aspect = DEFAULT_ASPECT3, focalDistance = 1, near = DEFAULT_NEAR3, far = DEFAULT_FAR3 } = view;
      checkRadians3(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians3(fovy);
      perspective3(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant6(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose6(this, this);
      return this.check();
    }
    invert() {
      invert8(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply12(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply12(this, this, a3);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians6) {
      rotateX9(this, this, radians6);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians6) {
      rotateY9(this, this, radians6);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians6) {
      rotateZ9(this, this, radians6);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians6, axis) {
      rotate7(this, this, radians6, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale13(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate6(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat410(result || [-0, -0, -0, -0], vector, this);
        checkVector4(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length: length16 } = vector;
      let out;
      switch (length16) {
        case 2:
          out = transformMat48(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat49(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector4(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector4(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector4(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians6) {
      return this.identity().rotateX(radians6);
    }
    makeTranslation(x3, y3, z2) {
      return this.identity().translate([x3, y3, z2]);
    }
  };
  var ZERO9;
  var IDENTITY4;
  function getZeroMatrix6() {
    if (!ZERO9) {
      ZERO9 = new Matrix43([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO9);
    }
    return ZERO9;
  }
  function getIdentityMatrix6() {
    if (!IDENTITY4) {
      IDENTITY4 = new Matrix43();
      Object.freeze(IDENTITY4);
    }
    return IDENTITY4;
  }
  function checkRadians3(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter3(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/@math.gl/geospatial/node_modules/@math.gl/core/dist/lib/math-utils.js
  var math_utils_exports2 = {};
  __export(math_utils_exports2, {
    EPSILON1: () => EPSILON110,
    EPSILON10: () => EPSILON102,
    EPSILON11: () => EPSILON112,
    EPSILON12: () => EPSILON122,
    EPSILON13: () => EPSILON132,
    EPSILON14: () => EPSILON142,
    EPSILON15: () => EPSILON152,
    EPSILON16: () => EPSILON162,
    EPSILON17: () => EPSILON172,
    EPSILON18: () => EPSILON182,
    EPSILON19: () => EPSILON192,
    EPSILON2: () => EPSILON27,
    EPSILON20: () => EPSILON202,
    EPSILON3: () => EPSILON32,
    EPSILON4: () => EPSILON42,
    EPSILON5: () => EPSILON52,
    EPSILON6: () => EPSILON62,
    EPSILON7: () => EPSILON72,
    EPSILON8: () => EPSILON82,
    EPSILON9: () => EPSILON92,
    PI_OVER_FOUR: () => PI_OVER_FOUR2,
    PI_OVER_SIX: () => PI_OVER_SIX2,
    PI_OVER_TWO: () => PI_OVER_TWO2,
    TWO_PI: () => TWO_PI2
  });
  var EPSILON110 = 0.1;
  var EPSILON27 = 0.01;
  var EPSILON32 = 1e-3;
  var EPSILON42 = 1e-4;
  var EPSILON52 = 1e-5;
  var EPSILON62 = 1e-6;
  var EPSILON72 = 1e-7;
  var EPSILON82 = 1e-8;
  var EPSILON92 = 1e-9;
  var EPSILON102 = 1e-10;
  var EPSILON112 = 1e-11;
  var EPSILON122 = 1e-12;
  var EPSILON132 = 1e-13;
  var EPSILON142 = 1e-14;
  var EPSILON152 = 1e-15;
  var EPSILON162 = 1e-16;
  var EPSILON172 = 1e-17;
  var EPSILON182 = 1e-18;
  var EPSILON192 = 1e-19;
  var EPSILON202 = 1e-20;
  var PI_OVER_TWO2 = Math.PI / 2;
  var PI_OVER_FOUR2 = Math.PI / 4;
  var PI_OVER_SIX2 = Math.PI / 6;
  var TWO_PI2 = Math.PI * 2;

  // ../../node_modules/@math.gl/geospatial/dist/constants.js
  var WGS84_RADIUS_X = 6378137;
  var WGS84_RADIUS_Y = 6378137;
  var WGS84_RADIUS_Z = 6356752314245179e-9;
  var WGS84_CONSTANTS = {
    radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
    radiiSquared: [
      WGS84_RADIUS_X * WGS84_RADIUS_X,
      WGS84_RADIUS_Y * WGS84_RADIUS_Y,
      WGS84_RADIUS_Z * WGS84_RADIUS_Z
    ],
    oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
    oneOverRadiiSquared: [
      1 / (WGS84_RADIUS_X * WGS84_RADIUS_X),
      1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),
      1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)
    ],
    maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
    centerToleranceSquared: 0.1
    // EPSILON1;
  };

  // ../../node_modules/@math.gl/geospatial/dist/type-utils.js
  function identity6(x3) {
    return x3;
  }
  var scratchVector8 = new Vector34();
  function fromCartographic(cartographic, result = [], map6 = identity6) {
    if ("longitude" in cartographic) {
      result[0] = map6(cartographic.longitude);
      result[1] = map6(cartographic.latitude);
      result[2] = cartographic.height;
    } else if ("x" in cartographic) {
      result[0] = map6(cartographic.x);
      result[1] = map6(cartographic.y);
      result[2] = cartographic.z;
    } else {
      result[0] = map6(cartographic[0]);
      result[1] = map6(cartographic[1]);
      result[2] = cartographic[2];
    }
    return result;
  }
  function fromCartographicToRadians(cartographic, vector = []) {
    return fromCartographic(cartographic, vector, config4._cartographicRadians ? identity6 : toRadians3);
  }
  function toCartographic(vector, cartographic, map6 = identity6) {
    if ("longitude" in cartographic) {
      cartographic.longitude = map6(vector[0]);
      cartographic.latitude = map6(vector[1]);
      cartographic.height = vector[2];
    } else if ("x" in cartographic) {
      cartographic.x = map6(vector[0]);
      cartographic.y = map6(vector[1]);
      cartographic.z = vector[2];
    } else {
      cartographic[0] = map6(vector[0]);
      cartographic[1] = map6(vector[1]);
      cartographic[2] = vector[2];
    }
    return cartographic;
  }
  function toCartographicFromRadians(vector, cartographic) {
    return toCartographic(vector, cartographic, config4._cartographicRadians ? identity6 : toDegrees3);
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/ellipsoid-transform.js
  var EPSILON143 = 1e-14;
  var scratchOrigin = new Vector34();
  var VECTOR_PRODUCT_LOCAL_FRAME = {
    up: {
      south: "east",
      north: "west",
      west: "south",
      east: "north"
    },
    down: {
      south: "west",
      north: "east",
      west: "north",
      east: "south"
    },
    south: {
      up: "west",
      down: "east",
      west: "down",
      east: "up"
    },
    north: {
      up: "east",
      down: "west",
      west: "up",
      east: "down"
    },
    west: {
      up: "north",
      down: "south",
      north: "down",
      south: "up"
    },
    east: {
      up: "south",
      down: "north",
      north: "up",
      south: "down"
    }
  };
  var degeneratePositionLocalFrame = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1]
  };
  var scratchAxisVectors = {
    east: new Vector34(),
    north: new Vector34(),
    up: new Vector34(),
    west: new Vector34(),
    south: new Vector34(),
    down: new Vector34()
  };
  var scratchVector1 = new Vector34();
  var scratchVector24 = new Vector34();
  var scratchVector34 = new Vector34();
  function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
    const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
    assert12(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
    let firstAxisVector;
    let secondAxisVector;
    let thirdAxisVector;
    const origin = scratchOrigin.copy(cartesianOrigin);
    const atPole = equals8(origin.x, 0, EPSILON143) && equals8(origin.y, 0, EPSILON143);
    if (atPole) {
      const sign2 = Math.sign(origin.z);
      firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
      if (firstAxis !== "east" && firstAxis !== "west") {
        firstAxisVector.scale(sign2);
      }
      secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
      if (secondAxis !== "east" && secondAxis !== "west") {
        secondAxisVector.scale(sign2);
      }
      thirdAxisVector = scratchVector34.fromArray(degeneratePositionLocalFrame[thirdAxis]);
      if (thirdAxis !== "east" && thirdAxis !== "west") {
        thirdAxisVector.scale(sign2);
      }
    } else {
      const { up, east, north } = scratchAxisVectors;
      east.set(-origin.y, origin.x, 0).normalize();
      ellipsoid.geodeticSurfaceNormal(origin, up);
      north.copy(up).cross(east);
      const { down, west, south } = scratchAxisVectors;
      down.copy(up).scale(-1);
      west.copy(east).scale(-1);
      south.copy(north).scale(-1);
      firstAxisVector = scratchAxisVectors[firstAxis];
      secondAxisVector = scratchAxisVectors[secondAxis];
      thirdAxisVector = scratchAxisVectors[thirdAxis];
    }
    result[0] = firstAxisVector.x;
    result[1] = firstAxisVector.y;
    result[2] = firstAxisVector.z;
    result[3] = 0;
    result[4] = secondAxisVector.x;
    result[5] = secondAxisVector.y;
    result[6] = secondAxisVector.z;
    result[7] = 0;
    result[8] = thirdAxisVector.x;
    result[9] = thirdAxisVector.y;
    result[10] = thirdAxisVector.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/scale-to-geodetic-surface.js
  var scratchVector9 = new Vector34();
  var scaleToGeodeticSurfaceIntersection = new Vector34();
  var scaleToGeodeticSurfaceGradient = new Vector34();
  function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
    const { oneOverRadii, oneOverRadiiSquared, centerToleranceSquared } = ellipsoid;
    scratchVector9.from(cartesian);
    const positionX = scratchVector9.x;
    const positionY = scratchVector9.y;
    const positionZ = scratchVector9.z;
    const oneOverRadiiX = oneOverRadii.x;
    const oneOverRadiiY = oneOverRadii.y;
    const oneOverRadiiZ = oneOverRadii.z;
    const x22 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    const y22 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    const squaredNorm = x22 + y22 + z2;
    const ratio = Math.sqrt(1 / squaredNorm);
    if (!Number.isFinite(ratio)) {
      return void 0;
    }
    const intersection = scaleToGeodeticSurfaceIntersection;
    intersection.copy(cartesian).scale(ratio);
    if (squaredNorm < centerToleranceSquared) {
      return intersection.to(result);
    }
    const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    const gradient = scaleToGeodeticSurfaceGradient;
    gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
    let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
    let correction = 0;
    let xMultiplier;
    let yMultiplier;
    let zMultiplier;
    let func;
    do {
      lambda -= correction;
      xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
      const xMultiplier2 = xMultiplier * xMultiplier;
      const yMultiplier2 = yMultiplier * yMultiplier;
      const zMultiplier2 = zMultiplier * zMultiplier;
      const xMultiplier3 = xMultiplier2 * xMultiplier;
      const yMultiplier3 = yMultiplier2 * yMultiplier;
      const zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x22 * xMultiplier2 + y22 * yMultiplier2 + z2 * zMultiplier2 - 1;
      const denominator = x22 * xMultiplier3 * oneOverRadiiSquaredX + y22 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      const derivative = -2 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > math_utils_exports2.EPSILON12);
    return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/ellipsoid.js
  var scratchVector10 = new Vector34();
  var scratchNormal3 = new Vector34();
  var scratchK = new Vector34();
  var scratchPosition2 = new Vector34();
  var scratchHeight = new Vector34();
  var scratchCartesian = new Vector34();
  var Ellipsoid = class {
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      this.centerToleranceSquared = math_utils_exports2.EPSILON1;
      assert12(x3 >= 0);
      assert12(y3 >= 0);
      assert12(z2 >= 0);
      this.radii = new Vector34(x3, y3, z2);
      this.radiiSquared = new Vector34(x3 * x3, y3 * y3, z2 * z2);
      this.radiiToTheFourth = new Vector34(x3 * x3 * x3 * x3, y3 * y3 * y3 * y3, z2 * z2 * z2 * z2);
      this.oneOverRadii = new Vector34(x3 === 0 ? 0 : 1 / x3, y3 === 0 ? 0 : 1 / y3, z2 === 0 ? 0 : 1 / z2);
      this.oneOverRadiiSquared = new Vector34(x3 === 0 ? 0 : 1 / (x3 * x3), y3 === 0 ? 0 : 1 / (y3 * y3), z2 === 0 ? 0 : 1 / (z2 * z2));
      this.minimumRadius = Math.min(x3, y3, z2);
      this.maximumRadius = Math.max(x3, y3, z2);
      if (this.radiiSquared.z !== 0) {
        this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
      }
      Object.freeze(this);
    }
    /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
    equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
    /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
    toString() {
      return this.radii.toString();
    }
    cartographicToCartesian(cartographic, result = [0, 0, 0]) {
      const normal = scratchNormal3;
      const k2 = scratchK;
      const [, , height] = cartographic;
      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k2.copy(this.radiiSquared).scale(normal);
      const gamma = Math.sqrt(normal.dot(k2));
      k2.scale(1 / gamma);
      normal.scale(height);
      k2.add(normal);
      return k2.to(result);
    }
    cartesianToCartographic(cartesian, result = [0, 0, 0]) {
      scratchCartesian.from(cartesian);
      const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
      if (!point) {
        return void 0;
      }
      const normal = this.geodeticSurfaceNormal(point, scratchNormal3);
      const h4 = scratchHeight;
      h4.copy(scratchCartesian).subtract(point);
      const longitude = Math.atan2(normal.y, normal.x);
      const latitude = Math.asin(normal.z);
      const height = Math.sign(vec3_exports3.dot(h4, scratchCartesian)) * vec3_exports3.length(h4);
      return toCartographicFromRadians([longitude, latitude, height], result);
    }
    eastNorthUpToFixedFrame(origin, result = new Matrix43()) {
      return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
    }
    // Computes a 4x4 transformation matrix from a reference frame centered at
    // the provided origin to the ellipsoid's fixed reference frame.
    localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix43()) {
      return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
    geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).normalize().to(result);
    }
    geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
      const cartographicVectorRadians = fromCartographicToRadians(cartographic);
      const longitude = cartographicVectorRadians[0];
      const latitude = cartographicVectorRadians[1];
      const cosLatitude = Math.cos(latitude);
      scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector10.to(result);
    }
    geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
    /** Scales the provided Cartesian position along the geodetic surface normal
     * so that it is on the surface of this ellipsoid.  If the position is
     * at the center of the ellipsoid, this function returns undefined. */
    scaleToGeodeticSurface(cartesian, result) {
      return scaleToGeodeticSurface(cartesian, this, result);
    }
    /** Scales the provided Cartesian position along the geocentric surface normal
     * so that it is on the surface of this ellipsoid. */
    scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
      scratchPosition2.from(cartesian);
      const positionX = scratchPosition2.x;
      const positionY = scratchPosition2.y;
      const positionZ = scratchPosition2.z;
      const oneOverRadiiSquared = this.oneOverRadiiSquared;
      const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition2.multiplyScalar(beta).to(result);
    }
    /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
     * its components by the result of `Ellipsoid#oneOverRadii` */
    transformPositionToScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
    }
    /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
     * its components by the result of `Ellipsoid#radii`. */
    transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.radii).to(result);
    }
    /** Computes a point which is the intersection of the surface normal with the z-axis. */
    getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
      assert12(equals8(this.radii.x, this.radii.y, math_utils_exports2.EPSILON15));
      assert12(this.radii.z > 0);
      scratchPosition2.from(position);
      const z2 = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
      if (Math.abs(z2) >= this.radii.z - buffer) {
        return void 0;
      }
      return scratchPosition2.set(0, 0, z2).to(result);
    }
  };
  Ellipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);

  // ../../node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list-node.js
  var DoublyLinkedListNode = class {
    item;
    previous;
    next;
    constructor(item, previous, next) {
      this.item = item;
      this.previous = previous;
      this.next = next;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list.js
  var DoublyLinkedList = class {
    head = null;
    tail = null;
    _length = 0;
    get length() {
      return this._length;
    }
    /**
     * Adds the item to the end of the list
     * @param {*} [item]
     * @return {DoublyLinkedListNode}
     */
    add(item) {
      const node = new DoublyLinkedListNode(item, this.tail, null);
      if (this.tail) {
        this.tail.next = node;
        this.tail = node;
      } else {
        this.head = node;
        this.tail = node;
      }
      ++this._length;
      return node;
    }
    /**
     * Removes the given node from the list
     * @param {DoublyLinkedListNode} node
     */
    remove(node) {
      if (!node) {
        return;
      }
      if (node.previous && node.next) {
        node.previous.next = node.next;
        node.next.previous = node.previous;
      } else if (node.previous) {
        node.previous.next = null;
        this.tail = node.previous;
      } else if (node.next) {
        node.next.previous = null;
        this.head = node.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      node.next = null;
      node.previous = null;
      --this._length;
    }
    /**
     * Moves nextNode after node
     * @param {DoublyLinkedListNode} node
     * @param {DoublyLinkedListNode} nextNode
     */
    splice(node, nextNode) {
      if (node === nextNode) {
        return;
      }
      this.remove(nextNode);
      this._insert(node, nextNode);
    }
    _insert(node, nextNode) {
      const oldNodeNext = node.next;
      node.next = nextNode;
      if (this.tail === node) {
        this.tail = nextNode;
      } else {
        oldNodeNext.previous = nextNode;
      }
      nextNode.next = oldNodeNext;
      nextNode.previous = node;
      ++this._length;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-cache.js
  var TilesetCache = class {
    _list;
    _sentinel;
    _trimTiles;
    constructor() {
      this._list = new DoublyLinkedList();
      this._sentinel = this._list.add("sentinel");
      this._trimTiles = false;
    }
    reset() {
      this._list.splice(this._list.tail, this._sentinel);
    }
    touch(tile) {
      const node = tile._cacheNode;
      if (node) {
        this._list.splice(this._sentinel, node);
      }
    }
    add(tileset, tile, addCallback) {
      if (!tile._cacheNode) {
        tile._cacheNode = this._list.add(tile);
        if (addCallback) {
          addCallback(tileset, tile);
        }
      }
    }
    unloadTile(tileset, tile, unloadCallback) {
      const node = tile._cacheNode;
      if (!node) {
        return;
      }
      this._list.remove(node);
      tile._cacheNode = null;
      if (unloadCallback) {
        unloadCallback(tileset, tile);
      }
    }
    unloadTiles(tileset, unloadCallback) {
      const trimTiles = this._trimTiles;
      this._trimTiles = false;
      const list = this._list;
      const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
      const sentinel = this._sentinel;
      let node = list.head;
      while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
        const tile = node.item;
        node = node.next;
        this.unloadTile(tileset, tile, unloadCallback);
      }
    }
    trim() {
      this._trimTiles = true;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/transform-utils.js
  function calculateTransformProps(tileHeader, tile) {
    assert2(tileHeader);
    assert2(tile);
    const { rtcCenter, gltfUpAxis } = tile;
    const { computedTransform, boundingVolume: { center } } = tileHeader;
    let modelMatrix2 = new Matrix42(computedTransform);
    if (rtcCenter) {
      modelMatrix2.translate(rtcCenter);
    }
    switch (gltfUpAxis) {
      case "Z":
        break;
      case "Y":
        const rotationY = new Matrix42().rotateX(Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
        break;
      case "X":
        const rotationX = new Matrix42().rotateY(-Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
        break;
      default:
        break;
    }
    if (tile.isQuantized) {
      modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
    }
    const cartesianOrigin = new Vector33(center);
    tile.cartesianModelMatrix = modelMatrix2;
    tile.cartesianOrigin = cartesianOrigin;
    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector33());
    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
    tile.cartographicOrigin = cartographicOrigin;
    if (!tile.coordinateSystem) {
      tile.modelMatrix = tile.cartographicModelMatrix;
    }
  }

  // ../../node_modules/@math.gl/culling/dist/constants.js
  var INTERSECTION2 = {
    OUTSIDE: -1,
    // Represents that an object is not contained within the frustum.
    INTERSECTING: 0,
    // Represents that an object intersects one of the frustum's planes.
    INSIDE: 1
    // Represents that an object is fully within the frustum.
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES7 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS11 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG5 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG5 } };
  var config5 = globalThis.mathgl.config;
  function formatValue5(value, { precision = config5.precision } = {}) {
    value = round13(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray7(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals10(a3, b2, epsilon) {
    const oldEpsilon = config5.EPSILON;
    if (epsilon) {
      config5.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray7(a3) && isArray7(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals10(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config5.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config5.EPSILON = oldEpsilon;
    }
  }
  function round13(value) {
    return Math.round(value / config5.EPSILON) * config5.EPSILON;
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray5 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray7(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config5);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue5(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals10(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config5.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector5(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber5(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector5(v2, length16, callerName = "") {
    if (config5.debug && !validateVector5(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/lib/assert.js
  function assert13(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector8 = class extends MathArray5 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber5(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber5(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber5(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber5(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert13(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber5(this[i5]);
    }
    setComponent(i5, value) {
      assert13(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON28 = 1e-6;
  var ARRAY_TYPE5 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree5 = Math.PI / 180;

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create17() {
    const out = new ARRAY_TYPE5(2);
    if (ARRAY_TYPE5 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat38(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  var forEach13 = function() {
    const vec = create17();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec3_transformMat4AsVector5(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat25(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat23(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function vec4_transformMat34(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m[0] * x3 + m[3] * y3 + m[6] * z2;
    out[1] = m[1] * x3 + m[4] * y3 + m[7] * z2;
    out[2] = m[2] * x3 + m[5] * y3 + m[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create18() {
    const out = new ARRAY_TYPE5(3);
    if (ARRAY_TYPE5 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length9(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues8(x3, y3, z2) {
    const out = new ARRAY_TYPE5(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function normalize10(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    out[2] = a3[2] * len8;
    return out;
  }
  function dot10(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross7(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat411(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat39(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat7(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX10(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY10(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ10(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle6(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot10(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var len6 = length9;
  var forEach14 = function() {
    const vec = create18();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN5 = [0, 0, 0];
  var ZERO10;
  var Vector35 = class extends Vector8 {
    static get ZERO() {
      if (!ZERO10) {
        ZERO10 = new Vector35(0, 0, 0);
        Object.freeze(ZERO10);
      }
      return ZERO10;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray7(x3)) {
        this.copy(x3);
      } else {
        if (config5.debug) {
          checkNumber5(x3);
          checkNumber5(y3);
          checkNumber5(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config5.debug) {
        checkNumber5(object.x);
        checkNumber5(object.y);
        checkNumber5(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber5(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle6(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross7(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN5 }) {
      rotateX10(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN5 }) {
      rotateY10(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN5 }) {
      rotateZ10(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat411(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector5(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat39(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat25(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat7(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/vector4.js
  var ZERO11;
  var Vector43 = class extends Vector8 {
    static get ZERO() {
      if (!ZERO11) {
        ZERO11 = new Vector43(0, 0, 0, 0);
        Object.freeze(ZERO11);
      }
      return ZERO11;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 0) {
      super(-0, -0, -0, -0);
      if (isArray7(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config5.debug) {
          checkNumber5(x3);
          checkNumber5(y3);
          checkNumber5(z2);
          checkNumber5(w2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
        this[3] = w2;
      }
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config5.debug) {
        checkNumber5(object.x);
        checkNumber5(object.y);
        checkNumber5(object.z);
        checkNumber5(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber5(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber5(value);
    }
    transform(matrix4) {
      transformMat411(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat34(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat23(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat7(this, this, quaternion2);
      return this.check();
    }
    // three.js compatibility
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix7 = class extends MathArray5 {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config5.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber5(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function create19() {
    const out = new ARRAY_TYPE5(9);
    if (ARRAY_TYPE5 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose7(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert9(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant7(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply13(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate7(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate8(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale14(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat8(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES7;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES10[INDICES10["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES7 || (INDICES7 = {}));
  var IDENTITY_MATRIX9 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix34 = class extends Matrix7 {
    static get IDENTITY() {
      return getIdentityMatrix7();
    }
    static get ZERO() {
      return getZeroMatrix7();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES7;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    // Constructors
    identity() {
      return this.copy(IDENTITY_MATRIX9);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /** Calculates a 3x3 matrix from the given quaternion
     * q quat  Quaternion to create matrix from
     */
    fromQuaternion(q2) {
      fromQuat8(this, q2);
      return this.check();
    }
    /**
     * accepts column major order, stores in column major order
     */
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    /**
     * accepts row major order, stores as column major
     */
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant7(this);
    }
    // Modifiers
    transpose() {
      transpose7(this, this);
      return this.check();
    }
    /** Invert a matrix. Note that this can fail if the matrix is not invertible */
    invert() {
      invert9(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply13(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply13(this, this, a3);
      return this.check();
    }
    rotate(radians6) {
      rotate8(this, this, radians6);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale14(this, this, factor);
      } else {
        scale14(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate7(this, this, vec);
      return this.check();
    }
    // Transforms
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat38(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat39(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat34(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector5(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX34;
  var IDENTITY_MATRIX34 = null;
  function getZeroMatrix7() {
    if (!ZERO_MATRIX34) {
      ZERO_MATRIX34 = new Matrix34([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX34);
    }
    return ZERO_MATRIX34;
  }
  function getIdentityMatrix7() {
    if (!IDENTITY_MATRIX34) {
      IDENTITY_MATRIX34 = new Matrix34();
      Object.freeze(IDENTITY_MATRIX34);
    }
    return IDENTITY_MATRIX34;
  }

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  var mat4_exports2 = {};
  __export(mat4_exports2, {
    add: () => add10,
    adjoint: () => adjoint2,
    clone: () => clone10,
    copy: () => copy8,
    create: () => create20,
    decompose: () => decompose2,
    determinant: () => determinant8,
    equals: () => equals11,
    exactEquals: () => exactEquals10,
    frob: () => frob2,
    fromQuat: () => fromQuat9,
    fromQuat2: () => fromQuat22,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation2,
    fromRotationTranslationScale: () => fromRotationTranslationScale2,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin2,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues9,
    fromXRotation: () => fromXRotation2,
    fromYRotation: () => fromYRotation2,
    fromZRotation: () => fromZRotation2,
    frustum: () => frustum4,
    getRotation: () => getRotation3,
    getScaling: () => getScaling2,
    getTranslation: () => getTranslation2,
    identity: () => identity7,
    invert: () => invert10,
    lookAt: () => lookAt4,
    mul: () => mul6,
    multiply: () => multiply14,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho4,
    orthoNO: () => orthoNO4,
    orthoZO: () => orthoZO2,
    perspective: () => perspective4,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView2,
    perspectiveNO: () => perspectiveNO4,
    perspectiveZO: () => perspectiveZO2,
    rotate: () => rotate9,
    rotateX: () => rotateX11,
    rotateY: () => rotateY11,
    rotateZ: () => rotateZ11,
    scale: () => scale15,
    set: () => set7,
    str: () => str6,
    sub: () => sub6,
    subtract: () => subtract6,
    targetTo: () => targetTo2,
    translate: () => translate8,
    transpose: () => transpose8
  });
  function create20() {
    const out = new ARRAY_TYPE5(16);
    if (ARRAY_TYPE5 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone10(a3) {
    const out = new ARRAY_TYPE5(16);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function copy8(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function fromValues9(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    const out = new ARRAY_TYPE5(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set7(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity7(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose8(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert10(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    out[0] = a11 * b11 - a12 * b10 + a13 * b09;
    out[1] = a02 * b10 - a01 * b11 - a03 * b09;
    out[2] = a31 * b05 - a32 * b04 + a33 * b03;
    out[3] = a22 * b04 - a21 * b05 - a23 * b03;
    out[4] = a12 * b08 - a10 * b11 - a13 * b07;
    out[5] = a00 * b11 - a02 * b08 + a03 * b07;
    out[6] = a32 * b02 - a30 * b05 - a33 * b01;
    out[7] = a20 * b05 - a22 * b02 + a23 * b01;
    out[8] = a10 * b10 - a11 * b08 + a13 * b06;
    out[9] = a01 * b08 - a00 * b10 - a03 * b06;
    out[10] = a30 * b04 - a31 * b02 + a33 * b00;
    out[11] = a21 * b02 - a20 * b04 - a23 * b00;
    out[12] = a11 * b07 - a10 * b09 - a12 * b06;
    out[13] = a00 * b09 - a01 * b07 + a02 * b06;
    out[14] = a31 * b01 - a30 * b03 - a32 * b00;
    out[15] = a20 * b03 - a21 * b01 + a22 * b00;
    return out;
  }
  function determinant8(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply14(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate8(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale15(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate9(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len8 < EPSILON28) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX11(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY11(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ11(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromTranslation2(out, v2) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v2) {
    out[0] = v2[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v2[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v2[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    if (len8 < EPSILON28) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    out[0] = x3 * x3 * t3 + c2;
    out[1] = y3 * x3 * t3 + z2 * s3;
    out[2] = z2 * x3 * t3 - y3 * s3;
    out[3] = 0;
    out[4] = x3 * y3 * t3 - z2 * s3;
    out[5] = y3 * y3 * t3 + c2;
    out[6] = z2 * y3 * t3 + x3 * s3;
    out[7] = 0;
    out[8] = x3 * z2 * t3 + y3 * s3;
    out[9] = y3 * z2 * t3 - x3 * s3;
    out[10] = z2 * z2 * t3 + c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation2(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c2;
    out[6] = s3;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s3;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation2(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = 0;
    out[2] = -s3;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s3;
    out[9] = 0;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation2(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = s3;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s3;
    out[5] = c2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation2(out, q2, v2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromQuat22(out, a3) {
    const translation = new ARRAY_TYPE5(3);
    const bx = -a3[0];
    const by = -a3[1];
    const bz = -a3[2];
    const bw = a3[3];
    const ax = a3[4];
    const ay = a3[5];
    const az = a3[6];
    const aw = a3[7];
    const magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation2(out, a3, translation);
    return out;
  }
  function getTranslation2(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling2(out, mat) {
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  function getRotation3(out, mat) {
    const scaling = new ARRAY_TYPE5(3);
    getScaling2(scaling, mat);
    const is1 = 1 / scaling[0];
    const is2 = 1 / scaling[1];
    const is3 = 1 / scaling[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S2;
      out[0] = (sm23 - sm32) / S2;
      out[1] = (sm31 - sm13) / S2;
      out[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S2;
      out[0] = 0.25 * S2;
      out[1] = (sm12 + sm21) / S2;
      out[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S2;
      out[0] = (sm12 + sm21) / S2;
      out[1] = 0.25 * S2;
      out[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S2;
      out[0] = (sm31 + sm13) / S2;
      out[1] = (sm23 + sm32) / S2;
      out[2] = 0.25 * S2;
    }
    return out;
  }
  function decompose2(out_r, out_t, out_s, mat) {
    out_t[0] = mat[12];
    out_t[1] = mat[13];
    out_t[2] = mat[14];
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    const is1 = 1 / out_s[0];
    const is2 = 1 / out_s[1];
    const is3 = 1 / out_s[2];
    const sm11 = m11 * is1;
    const sm12 = m12 * is2;
    const sm13 = m13 * is3;
    const sm21 = m21 * is1;
    const sm22 = m22 * is2;
    const sm23 = m23 * is3;
    const sm31 = m31 * is1;
    const sm32 = m32 * is2;
    const sm33 = m33 * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out_r[3] = 0.25 * S2;
      out_r[0] = (sm23 - sm32) / S2;
      out_r[1] = (sm31 - sm13) / S2;
      out_r[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out_r[3] = (sm23 - sm32) / S2;
      out_r[0] = 0.25 * S2;
      out_r[1] = (sm12 + sm21) / S2;
      out_r[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out_r[3] = (sm31 - sm13) / S2;
      out_r[0] = (sm12 + sm21) / S2;
      out_r[1] = 0.25 * S2;
      out_r[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out_r[3] = (sm12 - sm21) / S2;
      out_r[0] = (sm31 + sm13) / S2;
      out_r[1] = (sm23 + sm32) / S2;
      out_r[2] = 0.25 * S2;
    }
    return out_r;
  }
  function fromRotationTranslationScale2(out, q2, v2, s3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin2(out, q2, v2, s3, o3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    const ox = o3[0];
    const oy = o3[1];
    const oz = o3[2];
    const out0 = (1 - (yy + zz)) * sx;
    const out1 = (xy + wz) * sx;
    const out2 = (xz - wy) * sx;
    const out4 = (xy - wz) * sy;
    const out5 = (1 - (xx + zz)) * sy;
    const out6 = (yz + wx) * sy;
    const out8 = (xz + wy) * sz;
    const out9 = (yz - wx) * sz;
    const out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat9(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum4(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO4(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective4 = perspectiveNO4;
  function perspectiveZO2(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView2(out, fov, near, far) {
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO4(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho4 = orthoNO4;
  function orthoZO2(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt4(out, eye, center, up) {
    let len8;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON28 && Math.abs(eyey - centery) < EPSILON28 && Math.abs(eyez - centerz) < EPSILON28) {
      return identity7(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len8 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len8;
    z1 *= len8;
    z2 *= len8;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len8 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len8) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len8 = 1 / len8;
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len8 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len8) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len8 = 1 / len8;
      y0 *= len8;
      y1 *= len8;
      y22 *= len8;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo2(out, eye, target2, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    let z0 = eyex - target2[0];
    let z1 = eyey - target2[1];
    let z2 = eyez - target2[2];
    let len8 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
      z0 *= len8;
      z1 *= len8;
      z2 *= len8;
    }
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x22 = upx * z1 - upy * z0;
    len8 = x0 * x0 + x1 * x1 + x22 * x22;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z2 * x1;
    out[5] = z2 * x0 - z0 * x22;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str6(a3) {
    return `mat4(${a3[0]}, ${a3[1]}, ${a3[2]}, ${a3[3]}, ${a3[4]}, ${a3[5]}, ${a3[6]}, ${a3[7]}, ${a3[8]}, ${a3[9]}, ${a3[10]}, ${a3[11]}, ${a3[12]}, ${a3[13]}, ${a3[14]}, ${a3[15]})`;
  }
  function frob2(a3) {
    return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8] + a3[9] * a3[9] + a3[10] * a3[10] + a3[11] * a3[11] + a3[12] * a3[12] + a3[13] * a3[13] + a3[14] * a3[14] + a3[15] * a3[15]);
  }
  function add10(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    out[4] = a3[4] + b2[4];
    out[5] = a3[5] + b2[5];
    out[6] = a3[6] + b2[6];
    out[7] = a3[7] + b2[7];
    out[8] = a3[8] + b2[8];
    out[9] = a3[9] + b2[9];
    out[10] = a3[10] + b2[10];
    out[11] = a3[11] + b2[11];
    out[12] = a3[12] + b2[12];
    out[13] = a3[13] + b2[13];
    out[14] = a3[14] + b2[14];
    out[15] = a3[15] + b2[15];
    return out;
  }
  function subtract6(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    out[3] = a3[3] - b2[3];
    out[4] = a3[4] - b2[4];
    out[5] = a3[5] - b2[5];
    out[6] = a3[6] - b2[6];
    out[7] = a3[7] - b2[7];
    out[8] = a3[8] - b2[8];
    out[9] = a3[9] - b2[9];
    out[10] = a3[10] - b2[10];
    out[11] = a3[11] - b2[11];
    out[12] = a3[12] - b2[12];
    out[13] = a3[13] - b2[13];
    out[14] = a3[14] - b2[14];
    out[15] = a3[15] - b2[15];
    return out;
  }
  function multiplyScalar2(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    out[4] = a3[4] * b2;
    out[5] = a3[5] * b2;
    out[6] = a3[6] * b2;
    out[7] = a3[7] * b2;
    out[8] = a3[8] * b2;
    out[9] = a3[9] * b2;
    out[10] = a3[10] * b2;
    out[11] = a3[11] * b2;
    out[12] = a3[12] * b2;
    out[13] = a3[13] * b2;
    out[14] = a3[14] * b2;
    out[15] = a3[15] * b2;
    return out;
  }
  function multiplyScalarAndAdd2(out, a3, b2, scale22) {
    out[0] = a3[0] + b2[0] * scale22;
    out[1] = a3[1] + b2[1] * scale22;
    out[2] = a3[2] + b2[2] * scale22;
    out[3] = a3[3] + b2[3] * scale22;
    out[4] = a3[4] + b2[4] * scale22;
    out[5] = a3[5] + b2[5] * scale22;
    out[6] = a3[6] + b2[6] * scale22;
    out[7] = a3[7] + b2[7] * scale22;
    out[8] = a3[8] + b2[8] * scale22;
    out[9] = a3[9] + b2[9] * scale22;
    out[10] = a3[10] + b2[10] * scale22;
    out[11] = a3[11] + b2[11] * scale22;
    out[12] = a3[12] + b2[12] * scale22;
    out[13] = a3[13] + b2[13] * scale22;
    out[14] = a3[14] + b2[14] * scale22;
    out[15] = a3[15] + b2[15] * scale22;
    return out;
  }
  function exactEquals10(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2] && a3[3] === b2[3] && a3[4] === b2[4] && a3[5] === b2[5] && a3[6] === b2[6] && a3[7] === b2[7] && a3[8] === b2[8] && a3[9] === b2[9] && a3[10] === b2[10] && a3[11] === b2[11] && a3[12] === b2[12] && a3[13] === b2[13] && a3[14] === b2[14] && a3[15] === b2[15];
  }
  function equals11(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const a4 = a3[4];
    const a5 = a3[5];
    const a6 = a3[6];
    const a7 = a3[7];
    const a8 = a3[8];
    const a9 = a3[9];
    const a10 = a3[10];
    const a11 = a3[11];
    const a12 = a3[12];
    const a13 = a3[13];
    const a14 = a3[14];
    const a15 = a3[15];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    const b3 = b2[3];
    const b4 = b2[4];
    const b5 = b2[5];
    const b6 = b2[6];
    const b7 = b2[7];
    const b8 = b2[8];
    const b9 = b2[9];
    const b10 = b2[10];
    const b11 = b2[11];
    const b12 = b2[12];
    const b13 = b2[13];
    const b14 = b2[14];
    const b15 = b2[15];
    return Math.abs(a0 - b0) <= EPSILON28 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON28 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON28 * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b3) <= EPSILON28 * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON28 * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON28 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON28 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON28 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON28 * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON28 * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON28 * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON28 * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON28 * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON28 * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON28 * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON28 * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul6 = multiply14;
  var sub6 = subtract6;

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create21() {
    const out = new ARRAY_TYPE5(4);
    if (ARRAY_TYPE5 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add11(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    return out;
  }
  function scale16(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    return out;
  }
  function length10(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredLength8(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function normalize11(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = x3 * len8;
    out[1] = y3 * len8;
    out[2] = z2 * len8;
    out[3] = w2 * len8;
    return out;
  }
  function dot11(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
  }
  function lerp12(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    out[3] = aw + t3 * (b2[3] - aw);
    return out;
  }
  function transformQuat8(out, a3, q2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  var forEach15 = function() {
    const vec = create21();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/gl-matrix/quat.js
  function create22() {
    const out = new ARRAY_TYPE5(4);
    if (ARRAY_TYPE5 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity8(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle3(out, axis, rad) {
    rad = rad * 0.5;
    const s3 = Math.sin(rad);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply15(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const bw = b2[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX12(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY12(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ12(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW3(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z2 * z2));
    return out;
  }
  function slerp5(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    let bx = b2[0];
    let by = b2[1];
    let bz = b2[2];
    let bw = b2[3];
    let cosom;
    let omega;
    let scale0;
    let scale1;
    let sinom;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON28) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t3) * omega) / sinom;
      scale1 = Math.sin(t3 * omega) / sinom;
    } else {
      scale0 = 1 - t3;
      scale1 = t3;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert11(out, a3) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const dot17 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    const invDot = dot17 ? 1 / dot17 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate3(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat33(out, m) {
    const fTrace = m[0] + m[4] + m[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m[4] > m[0])
        i5 = 1;
      if (m[8] > m[i5 * 3 + i5])
        i5 = 2;
      const j2 = (i5 + 1) % 3;
      const k2 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m[i5 * 3 + i5] - m[j2 * 3 + j2] - m[k2 * 3 + k2] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j2 * 3 + k2] - m[k2 * 3 + j2]) * fRoot;
      out[j2] = (m[j2 * 3 + i5] + m[i5 * 3 + j2]) * fRoot;
      out[k2] = (m[k2 * 3 + i5] + m[i5 * 3 + k2]) * fRoot;
    }
    return out;
  }
  var add12 = add11;
  var scale17 = scale16;
  var dot12 = dot11;
  var lerp13 = lerp12;
  var length11 = length10;
  var squaredLength9 = squaredLength8;
  var normalize12 = normalize11;
  var rotationTo3 = function() {
    const tmpvec3 = create18();
    const xUnitVec3 = fromValues8(1, 0, 0);
    const yUnitVec3 = fromValues8(0, 1, 0);
    return function(out, a3, b2) {
      const dot17 = dot10(a3, b2);
      if (dot17 < -0.999999) {
        cross7(tmpvec3, xUnitVec3, a3);
        if (len6(tmpvec3) < 1e-6)
          cross7(tmpvec3, yUnitVec3, a3);
        normalize10(tmpvec3, tmpvec3);
        setAxisAngle3(out, tmpvec3, Math.PI);
        return out;
      } else if (dot17 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      cross7(tmpvec3, a3, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot17;
      return normalize12(out, out);
    };
  }();
  var sqlerp3 = function() {
    const temp1 = create22();
    const temp2 = create22();
    return function(out, a3, b2, c2, d2, t3) {
      slerp5(temp1, a3, d2, t3);
      slerp5(temp2, b2, c2, t3);
      slerp5(out, temp1, temp2, 2 * t3 * (1 - t3));
      return out;
    };
  }();
  var setAxes3 = function() {
    const matr = create19();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize12(out, fromMat33(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/classes/quaternion.js
  var IDENTITY_QUATERNION3 = [0, 0, 0, 1];
  var Quaternion3 = class extends MathArray5 {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        this.set(x3, y3, z2, w2);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * NOTE: The resultant quaternion is not normalized, so you should
     * be sure to renormalize the quaternion yourself where necessary.
     * @param m
     * @returns
     */
    fromMatrix3(m) {
      fromMat33(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle3(this, axis, rad);
      return this.check();
    }
    /** Set a quat to the identity quaternion */
    identity() {
      identity8(this);
      return this.check();
    }
    // Set the components of a quat to the given values
    // set(i, j, k, l) {
    //   quat_set(this, i, j, k, l);
    //   return this.check();
    // }
    // Sets a quat from the given angle and rotation axis, then returns it.
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    // Getters/setters
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber5(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber5(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber5(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber5(value);
    }
    // Calculates the length of a quat
    len() {
      return length11(this);
    }
    // Calculates the squared length of a quat
    lengthSquared() {
      return squaredLength9(this);
    }
    // Calculates the dot product of two quat's
    // @return {Number}
    dot(a3) {
      return dot12(this, a3);
    }
    // Gets the rotation axis and angle for a given quaternion.
    // If a quaternion is created with setAxisAngle, this method will
    // return the same values as providied in the original parameter
    // list OR functionally equivalent values.
    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
    // is the same as the quaternion formed by [0, 0, 1] and 270.
    // This method favors the latter.
    // @return {{[x,y,z], Number}}
    // getAxisAngle() {
    //   const axis = [];
    // //   const angle = quat_getAxisAngle(axis, this);
    //   return {axis, angle};
    // }
    // MODIFIERS
    // Sets a quaternion to represent the shortest rotation from one vector
    // to another. Both vectors are assumed to be unit length.
    rotationTo(vectorA, vectorB) {
      rotationTo3(this, vectorA, vectorB);
      return this.check();
    }
    // Sets the specified quaternion with values corresponding to the given axes.
    // Each axis is a vec3 and is expected to be unit length and perpendicular
    // to all other specified axes.
    // setAxes() {
    //   Number
    // }
    // Performs a spherical linear interpolation with two control points
    // sqlerp() {
    //   Number;
    // }
    // Adds two quat's
    add(a3) {
      add12(this, this, a3);
      return this.check();
    }
    // Calculates the W component of a quat from the X, Y, and Z components.
    // Any existing W component will be ignored.
    calculateW() {
      calculateW3(this, this);
      return this.check();
    }
    // Calculates the conjugate of a quat If the quaternion is normalized,
    // this function is faster than quat_invert and produces the same result.
    conjugate() {
      conjugate3(this, this);
      return this.check();
    }
    // Calculates the inverse of a quat
    invert() {
      invert11(this, this);
      return this.check();
    }
    // Performs a linear interpolation between two quat's
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      lerp13(this, a3, b2, t3);
      return this.check();
    }
    // Multiplies two quat's
    multiplyRight(a3) {
      multiply15(this, this, a3);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply15(this, a3, this);
      return this.check();
    }
    // Normalize a quat
    normalize() {
      const length16 = this.len();
      const l3 = length16 > 0 ? 1 / length16 : 0;
      this[0] = this[0] * l3;
      this[1] = this[1] * l3;
      this[2] = this[2] * l3;
      this[3] = this[3] * l3;
      if (length16 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    // Rotates a quaternion by the given angle about the X axis
    rotateX(rad) {
      rotateX12(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Y axis
    rotateY(rad) {
      rotateY12(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Z axis
    rotateZ(rad) {
      rotateZ12(this, this, rad);
      return this.check();
    }
    // Scales a quat by a scalar number
    scale(b2) {
      scale17(this, this, b2);
      return this.check();
    }
    // Performs a spherical linear interpolation between two quat
    slerp(arg0, arg1, arg2) {
      let start;
      let target2;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION3,
            target: target2,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target2 = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target2 = arg1;
          ratio = arg2;
      }
      slerp5(this, start, target2, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector43()) {
      transformQuat8(result, vector, this);
      return checkVector5(result, 4);
    }
    // THREE.js Math API compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a3) {
      return this.multiplyLeft(a3);
    }
    multiply(a3) {
      return this.multiplyRight(a3);
    }
  };

  // ../../node_modules/@math.gl/culling/node_modules/@math.gl/core/dist/lib/math-utils.js
  var math_utils_exports3 = {};
  __export(math_utils_exports3, {
    EPSILON1: () => EPSILON111,
    EPSILON10: () => EPSILON103,
    EPSILON11: () => EPSILON113,
    EPSILON12: () => EPSILON123,
    EPSILON13: () => EPSILON133,
    EPSILON14: () => EPSILON144,
    EPSILON15: () => EPSILON153,
    EPSILON16: () => EPSILON163,
    EPSILON17: () => EPSILON173,
    EPSILON18: () => EPSILON183,
    EPSILON19: () => EPSILON193,
    EPSILON2: () => EPSILON29,
    EPSILON20: () => EPSILON203,
    EPSILON3: () => EPSILON33,
    EPSILON4: () => EPSILON43,
    EPSILON5: () => EPSILON53,
    EPSILON6: () => EPSILON63,
    EPSILON7: () => EPSILON73,
    EPSILON8: () => EPSILON83,
    EPSILON9: () => EPSILON93,
    PI_OVER_FOUR: () => PI_OVER_FOUR3,
    PI_OVER_SIX: () => PI_OVER_SIX3,
    PI_OVER_TWO: () => PI_OVER_TWO3,
    TWO_PI: () => TWO_PI3
  });
  var EPSILON111 = 0.1;
  var EPSILON29 = 0.01;
  var EPSILON33 = 1e-3;
  var EPSILON43 = 1e-4;
  var EPSILON53 = 1e-5;
  var EPSILON63 = 1e-6;
  var EPSILON73 = 1e-7;
  var EPSILON83 = 1e-8;
  var EPSILON93 = 1e-9;
  var EPSILON103 = 1e-10;
  var EPSILON113 = 1e-11;
  var EPSILON123 = 1e-12;
  var EPSILON133 = 1e-13;
  var EPSILON144 = 1e-14;
  var EPSILON153 = 1e-15;
  var EPSILON163 = 1e-16;
  var EPSILON173 = 1e-17;
  var EPSILON183 = 1e-18;
  var EPSILON193 = 1e-19;
  var EPSILON203 = 1e-20;
  var PI_OVER_TWO3 = Math.PI / 2;
  var PI_OVER_FOUR3 = Math.PI / 4;
  var PI_OVER_SIX3 = Math.PI / 6;
  var TWO_PI3 = Math.PI * 2;

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
  var scratchVector11 = new Vector35();
  var scratchNormal4 = new Vector35();

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
  var scratchVector12 = new Vector35();
  var scratchVector25 = new Vector35();
  var BoundingSphere2 = class {
    /** Creates a bounding sphere */
    constructor(center = [0, 0, 0], radius = 0) {
      this.radius = -0;
      this.center = new Vector35();
      this.fromCenterRadius(center, radius);
    }
    /** Sets the bounding sphere from `center` and `radius`. */
    fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
    /**
     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
     * tightly and fully encompasses the box.
     */
    fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector12.from(oppositeCorner);
      this.center = new Vector35().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
    /** Compares the provided BoundingSphere component wise */
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    /** Duplicates a BoundingSphere instance. */
    clone() {
      return new BoundingSphere2(this.center, this.radius);
    }
    /** Computes a bounding sphere that contains both the left and right bounding spheres. */
    union(boundingSphere) {
      const leftCenter = this.center;
      const leftRadius = this.radius;
      const rightCenter = boundingSphere.center;
      const rightRadius = boundingSphere.radius;
      const toRightCenter = scratchVector12.copy(rightCenter).subtract(leftCenter);
      const centerSeparation = toRightCenter.magnitude();
      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }
      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }
      const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector25.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector25);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
    /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
    expand(point) {
      const scratchPoint2 = scratchVector12.from(point);
      const radius = scratchPoint2.subtract(this.center).magnitude();
      if (radius > this.radius) {
        this.radius = radius;
      }
      return this;
    }
    // BoundingVolume interface
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param sphere The bounding sphere to apply the transformation to.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns self.
     */
    transform(transform2) {
      this.center.transform(transform2);
      const scale22 = mat4_exports2.getScaling(scratchVector12, transform2);
      this.radius = Math.max(scale22[0], Math.max(scale22[1], scale22[2])) * this.radius;
      return this;
    }
    /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
    distanceSquaredTo(point) {
      const d2 = this.distanceTo(point);
      return d2 * d2;
    }
    /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
    distanceTo(point) {
      const scratchPoint2 = scratchVector12.from(point);
      const delta = scratchPoint2.subtract(this.center);
      return Math.max(0, delta.len() - this.radius);
    }
    /** Determines which side of a plane a sphere is located. */
    intersectPlane(plane) {
      const center = this.center;
      const radius = this.radius;
      const normal = plane.normal;
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane < -radius) {
        return INTERSECTION2.OUTSIDE;
      }
      if (distanceToPlane < radius) {
        return INTERSECTION2.INTERSECTING;
      }
      return INTERSECTION2.INSIDE;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
  var scratchVector35 = new Vector35();
  var scratchOffset2 = new Vector35();
  var scratchVectorU2 = new Vector35();
  var scratchVectorV2 = new Vector35();
  var scratchVectorW2 = new Vector35();
  var scratchCorner2 = new Vector35();
  var scratchToCenter2 = new Vector35();
  var MATRIX32 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox2 = class {
    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.center = new Vector35().from(center);
      this.halfAxes = new Matrix34(halfAxes);
    }
    /** Returns an array with three halfSizes for the bounding box */
    get halfSize() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      return [new Vector35(xAxis).len(), new Vector35(yAxis).len(), new Vector35(zAxis).len()];
    }
    /** Returns a quaternion describing the orientation of the bounding box */
    get quaternion() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      const normXAxis = new Vector35(xAxis).normalize();
      const normYAxis = new Vector35(yAxis).normalize();
      const normZAxis = new Vector35(zAxis).normalize();
      return new Quaternion3().fromMatrix3(new Matrix34([...normXAxis, ...normYAxis, ...normZAxis]));
    }
    /**
     * Create OrientedBoundingBox from quaternion based OBB,
     */
    fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
      const quaternionObject = new Quaternion3(quaternion2);
      const directionsMatrix = new Matrix34().fromQuaternion(quaternionObject);
      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
      this.center = new Vector35().from(center);
      this.halfAxes = directionsMatrix;
      return this;
    }
    /** Duplicates a OrientedBoundingBox instance. */
    clone() {
      return new OrientedBoundingBox2(this.center, this.halfAxes);
    }
    /** Compares the provided OrientedBoundingBox component wise and returns */
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
    getBoundingSphere(result = new BoundingSphere2()) {
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU2);
      const v2 = halfAxes.getColumn(1, scratchVectorV2);
      const w2 = halfAxes.getColumn(2, scratchVectorW2);
      const cornerVector = scratchVector35.copy(u3).add(v2).add(w2);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
    /** Determines which side of a plane the oriented bounding box is located. */
    intersectPlane(plane) {
      const center = this.center;
      const normal = plane.normal;
      const halfAxes = this.halfAxes;
      const normalX = normal.x;
      const normalY = normal.y;
      const normalZ = normal.z;
      const radEffective = Math.abs(normalX * halfAxes[MATRIX32.COLUMN0ROW0] + normalY * halfAxes[MATRIX32.COLUMN0ROW1] + normalZ * halfAxes[MATRIX32.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX32.COLUMN1ROW0] + normalY * halfAxes[MATRIX32.COLUMN1ROW1] + normalZ * halfAxes[MATRIX32.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX32.COLUMN2ROW0] + normalY * halfAxes[MATRIX32.COLUMN2ROW1] + normalZ * halfAxes[MATRIX32.COLUMN2ROW2]);
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane <= -radEffective) {
        return INTERSECTION2.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return INTERSECTION2.INSIDE;
      }
      return INTERSECTION2.INTERSECTING;
    }
    /** Computes the estimated distance from the closest point on a bounding box to a point. */
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    /**
     * Computes the estimated distance squared from the closest point
     * on a bounding box to a point.
     * See Geometric Tools for Computer Graphics 10.4.2
     */
    distanceSquaredTo(point) {
      const offset = scratchOffset2.from(point).subtract(this.center);
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU2);
      const v2 = halfAxes.getColumn(1, scratchVectorV2);
      const w2 = halfAxes.getColumn(2, scratchVectorW2);
      const uHalf = u3.magnitude();
      const vHalf = v2.magnitude();
      const wHalf = w2.magnitude();
      u3.normalize();
      v2.normalize();
      w2.normalize();
      let distanceSquared = 0;
      let d2;
      d2 = Math.abs(offset.dot(u3)) - uHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(v2)) - vHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(w2)) - wHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      return distanceSquared;
    }
    /**
     * The distances calculated by the vector from the center of the bounding box
     * to position projected onto direction.
     *
     * - If you imagine the infinite number of planes with normal direction,
     *   this computes the smallest distance to the closest and farthest planes
     *   from `position` that intersect the bounding box.
     *
     * @param position The position to calculate the distance from.
     * @param direction The direction from position.
     * @param result An Interval (array of length 2) to store the nearest and farthest distances.
     * @returns Interval (array of length 2) with nearest and farthest distances
     *   on the bounding box from position in direction.
     */
    // eslint-disable-next-line max-statements
    computePlaneDistances(position, direction, result = [-0, -0]) {
      let minDist = Number.POSITIVE_INFINITY;
      let maxDist = Number.NEGATIVE_INFINITY;
      const center = this.center;
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU2);
      const v2 = halfAxes.getColumn(1, scratchVectorV2);
      const w2 = halfAxes.getColumn(2, scratchVectorW2);
      const corner = scratchCorner2.copy(u3).add(v2).add(w2).add(center);
      const toCenter = scratchToCenter2.copy(corner).subtract(position);
      let mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result[0] = minDist;
      result[1] = maxDist;
      return result;
    }
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param transform The transformation matrix to apply to the bounding sphere.
     * @returns itself, i.e. the modified BoundingVolume.
     */
    transform(transformation) {
      this.center.transformAsPoint(transformation);
      const xAxis = this.halfAxes.getColumn(0, scratchVectorU2);
      xAxis.transformAsPoint(transformation);
      const yAxis = this.halfAxes.getColumn(1, scratchVectorV2);
      yAxis.transformAsPoint(transformation);
      const zAxis = this.halfAxes.getColumn(2, scratchVectorW2);
      zAxis.transformAsPoint(transformation);
      this.halfAxes = new Matrix34([...xAxis, ...yAxis, ...zAxis]);
      return this;
    }
    getTransform() {
      throw new Error("not implemented");
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/plane.js
  var scratchPosition3 = new Vector35();
  var scratchNormal5 = new Vector35();
  var Plane2 = class {
    constructor(normal = [0, 0, 1], distance6 = 0) {
      this.normal = new Vector35();
      this.distance = -0;
      this.fromNormalDistance(normal, distance6);
    }
    /** Creates a plane from a normal and a distance from the origin. */
    fromNormalDistance(normal, distance6) {
      assert13(Number.isFinite(distance6));
      this.normal.from(normal).normalize();
      this.distance = distance6;
      return this;
    }
    /** Creates a plane from a normal and a point on the plane. */
    fromPointNormal(point, normal) {
      point = scratchPosition3.from(point);
      this.normal.from(normal).normalize();
      const distance6 = -this.normal.dot(point);
      this.distance = distance6;
      return this;
    }
    /** Creates a plane from the general equation */
    fromCoefficients(a3, b2, c2, d2) {
      this.normal.set(a3, b2, c2);
      assert13(equals10(this.normal.len(), 1));
      this.distance = d2;
      return this;
    }
    /** Duplicates a Plane instance. */
    clone() {
      return new Plane2(this.normal, this.distance);
    }
    /** Compares the provided Planes by normal and distance */
    equals(right) {
      return equals10(this.distance, right.distance) && equals10(this.normal, right.normal);
    }
    /** Computes the signed shortest distance of a point to a plane.
     * The sign of the distance determines which side of the plane the point is on.
     */
    getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
    /** Transforms the plane by the given transformation matrix. */
    transform(matrix4) {
      const normal = scratchNormal5.copy(this.normal).transformAsVector(matrix4).normalize();
      const point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [0, 0, 0]) {
      const scratchPoint2 = scratchPosition3.from(point);
      const pointDistance = this.getPointDistance(scratchPoint2);
      const scaledNormal = scratchNormal5.copy(this.normal).scale(pointDistance);
      return scratchPoint2.subtract(scaledNormal).to(result);
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/culling-volume.js
  var faces2 = [new Vector35([1, 0, 0]), new Vector35([0, 1, 0]), new Vector35([0, 0, 1])];
  var scratchPlaneCenter2 = new Vector35();
  var scratchPlaneNormal3 = new Vector35();
  var CullingVolume2 = class {
    /**
     * Create a new `CullingVolume` bounded by an array of clipping planed
     * @param planes Array of clipping planes.
     * */
    constructor(planes = []) {
      this.planes = planes;
    }
    /**
     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
     * The planes are aligned to the x, y, and z axes in world coordinates.
     */
    fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces2.length;
      const center = boundingSphere.center;
      const radius = boundingSphere.radius;
      let planeIndex = 0;
      for (const faceNormal of faces2) {
        let plane0 = this.planes[planeIndex];
        let plane1 = this.planes[planeIndex + 1];
        if (!plane0) {
          plane0 = this.planes[planeIndex] = new Plane2();
        }
        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new Plane2();
        }
        const plane0Center = scratchPlaneCenter2.copy(faceNormal).scale(-radius).add(center);
        plane0.fromPointNormal(plane0Center, faceNormal);
        const plane1Center = scratchPlaneCenter2.copy(faceNormal).scale(radius).add(center);
        const negatedFaceNormal = scratchPlaneNormal3.copy(faceNormal).negate();
        plane1.fromPointNormal(plane1Center, negatedFaceNormal);
        planeIndex += 2;
      }
      return this;
    }
    /** Determines whether a bounding volume intersects the culling volume. */
    computeVisibility(boundingVolume) {
      let intersect4 = INTERSECTION2.INSIDE;
      for (const plane of this.planes) {
        const result = boundingVolume.intersectPlane(plane);
        switch (result) {
          case INTERSECTION2.OUTSIDE:
            return INTERSECTION2.OUTSIDE;
          case INTERSECTION2.INTERSECTING:
            intersect4 = INTERSECTION2.INTERSECTING;
            break;
          default:
        }
      }
      return intersect4;
    }
    /**
     * Determines whether a bounding volume intersects the culling volume.
     *
     * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
     *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
     *   the parent (and therefore this) volume is completely inside plane[planeIndex]
     *   and that plane check can be skipped.
     */
    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      assert13(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
      if (parentPlaneMask === CullingVolume2.MASK_OUTSIDE || parentPlaneMask === CullingVolume2.MASK_INSIDE) {
        return parentPlaneMask;
      }
      let mask = CullingVolume2.MASK_INSIDE;
      const planes = this.planes;
      for (let k2 = 0; k2 < this.planes.length; ++k2) {
        const flag = k2 < 31 ? 1 << k2 : 0;
        if (k2 < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }
        const plane = planes[k2];
        const result = boundingVolume.intersectPlane(plane);
        if (result === INTERSECTION2.OUTSIDE) {
          return CullingVolume2.MASK_OUTSIDE;
        } else if (result === INTERSECTION2.INTERSECTING) {
          mask |= flag;
        }
      }
      return mask;
    }
  };
  CullingVolume2.MASK_OUTSIDE = 4294967295;
  CullingVolume2.MASK_INSIDE = 0;
  CullingVolume2.MASK_INDETERMINATE = 2147483647;

  // ../../node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
  var scratchPlaneUpVector2 = new Vector35();
  var scratchPlaneRightVector2 = new Vector35();
  var scratchPlaneNearCenter2 = new Vector35();
  var scratchPlaneFarCenter2 = new Vector35();
  var scratchPlaneNormal4 = new Vector35();

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin2 = new Vector35();
  var fromPointsYMin2 = new Vector35();
  var fromPointsZMin2 = new Vector35();
  var fromPointsXMax2 = new Vector35();
  var fromPointsYMax2 = new Vector35();
  var fromPointsZMax2 = new Vector35();
  var fromPointsCurrentPos2 = new Vector35();
  var fromPointsScratch2 = new Vector35();
  var fromPointsRitterCenter2 = new Vector35();
  var fromPointsMinBoxPt2 = new Vector35();
  var fromPointsMaxBoxPt2 = new Vector35();
  var fromPointsNaiveCenterScratch2 = new Vector35();

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
  var scratchMatrix2 = new Matrix34();
  var scratchUnitary2 = new Matrix34();
  var scratchDiagonal2 = new Matrix34();
  var jMatrix2 = new Matrix34();
  var jMatrixTranspose2 = new Matrix34();
  function computeEigenDecomposition2(matrix, result = {}) {
    const EIGEN_TOLERANCE = math_utils_exports3.EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count3 = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary2;
    const diagonalMatrix = scratchDiagonal2;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm2(diagonalMatrix);
    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm2(diagonalMatrix) > epsilon) {
      shurDecomposition2(diagonalMatrix, jMatrix2);
      jMatrixTranspose2.copy(jMatrix2).transpose();
      diagonalMatrix.multiplyRight(jMatrix2);
      diagonalMatrix.multiplyLeft(jMatrixTranspose2);
      unitaryMatrix.multiplyRight(jMatrix2);
      if (++count3 > 2) {
        ++sweep;
        count3 = 0;
      }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
  }
  function computeFrobeniusNorm2(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 9; ++i5) {
      const temp = matrix[i5];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal2 = [1, 0, 0];
  var colVal2 = [2, 2, 1];
  function offDiagonalFrobeniusNorm2(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = matrix[scratchMatrix2.getElementIndex(colVal2[i5], rowVal2[i5])];
      norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition2(matrix, result) {
    const tolerance = math_utils_exports3.EPSILON15;
    let maxDiagonal = 0;
    let rotAxis = 1;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = Math.abs(matrix[scratchMatrix2.getElementIndex(colVal2[i5], rowVal2[i5])]);
      if (temp > maxDiagonal) {
        rotAxis = i5;
        maxDiagonal = temp;
      }
    }
    const p3 = rowVal2[rotAxis];
    const q2 = colVal2[rotAxis];
    let c2 = 1;
    let s3 = 0;
    if (Math.abs(matrix[scratchMatrix2.getElementIndex(q2, p3)]) > tolerance) {
      const qq = matrix[scratchMatrix2.getElementIndex(q2, q2)];
      const pp = matrix[scratchMatrix2.getElementIndex(p3, p3)];
      const qp = matrix[scratchMatrix2.getElementIndex(q2, p3)];
      const tau = (qq - pp) / 2 / qp;
      let t3;
      if (tau < 0) {
        t3 = -1 / (-tau + Math.sqrt(1 + tau * tau));
      } else {
        t3 = 1 / (tau + Math.sqrt(1 + tau * tau));
      }
      c2 = 1 / Math.sqrt(1 + t3 * t3);
      s3 = t3 * c2;
    }
    Matrix34.IDENTITY.to(result);
    result[scratchMatrix2.getElementIndex(p3, p3)] = result[scratchMatrix2.getElementIndex(q2, q2)] = c2;
    result[scratchMatrix2.getElementIndex(q2, p3)] = s3;
    result[scratchMatrix2.getElementIndex(p3, q2)] = -s3;
    return result;
  }

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
  var scratchVector26 = new Vector35();
  var scratchVector36 = new Vector35();
  var scratchVector42 = new Vector35();
  var scratchVector52 = new Vector35();
  var scratchVector62 = new Vector35();
  var scratchCovarianceResult2 = new Matrix34();
  var scratchEigenResult2 = {
    diagonal: new Matrix34(),
    unitary: new Matrix34()
  };
  function makeOrientedBoundingBoxFromPoints2(positions, result = new OrientedBoundingBox2()) {
    if (!positions || positions.length === 0) {
      result.halfAxes = new Matrix34([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      result.center = new Vector35();
      return result;
    }
    const length16 = positions.length;
    const meanPoint = new Vector35(0, 0, 0);
    for (const position of positions) {
      meanPoint.add(position);
    }
    const invLength = 1 / length16;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0;
    let exy = 0;
    let exz = 0;
    let eyy = 0;
    let eyz = 0;
    let ezz = 0;
    for (const position of positions) {
      const p3 = scratchVector26.copy(position).subtract(meanPoint);
      exx += p3.x * p3.x;
      exy += p3.x * p3.y;
      exz += p3.x * p3.z;
      eyy += p3.y * p3.y;
      eyz += p3.y * p3.z;
      ezz += p3.z * p3.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult2;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const { unitary } = computeEigenDecomposition2(covarianceMatrix, scratchEigenResult2);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector42);
    let v2 = rotation.getColumn(1, scratchVector52);
    let v3 = rotation.getColumn(2, scratchVector62);
    let u1 = -Number.MAX_VALUE;
    let u22 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l22 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions) {
      scratchVector26.copy(position);
      u1 = Math.max(scratchVector26.dot(v1), u1);
      u22 = Math.max(scratchVector26.dot(v2), u22);
      u3 = Math.max(scratchVector26.dot(v3), u3);
      l1 = Math.min(scratchVector26.dot(v1), l1);
      l22 = Math.min(scratchVector26.dot(v2), l22);
      l3 = Math.min(scratchVector26.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l22 + u22));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale22 = scratchVector36.set(u1 - l1, u22 - l22, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new Matrix34([scale22[0], 0, 0, 0, scale22[1], 0, 0, 0, scale22[2]]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/frame-state.js
  var scratchVector13 = new Vector33();
  var scratchPosition4 = new Vector33();
  var cullingVolume = new CullingVolume2([
    new Plane2(),
    new Plane2(),
    new Plane2(),
    new Plane2(),
    new Plane2(),
    new Plane2()
  ]);
  function getFrameState(viewport, frameNumber) {
    const { cameraDirection, cameraUp, height } = viewport;
    const { metersPerUnit } = viewport.distanceScales;
    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector33());
    const cameraDirectionCartesian = new Vector33(
      // @ts-ignore
      enuToFixedTransform.transformAsVector(new Vector33(cameraDirection).scale(metersPerUnit))
    ).normalize();
    const cameraUpCartesian = new Vector33(
      // @ts-ignore
      enuToFixedTransform.transformAsVector(new Vector33(cameraUp).scale(metersPerUnit))
    ).normalize();
    commonSpacePlanesToWGS84(viewport);
    const ViewportClass = viewport.constructor;
    const { longitude, latitude, width, bearing, zoom } = viewport;
    const topDownViewport = new ViewportClass({
      longitude,
      latitude,
      height,
      width,
      bearing,
      zoom,
      pitch: 0
    });
    return {
      camera: {
        position: cameraPositionCartesian2,
        direction: cameraDirectionCartesian,
        up: cameraUpCartesian
      },
      viewport,
      topDownViewport,
      height,
      cullingVolume,
      frameNumber,
      // TODO: This can be the same between updates, what number is unique for between updates?
      sseDenominator: 1.15
      // Assumes fovy = 60 degrees
    };
  }
  function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
      return [tiles, []];
    }
    const tuples = [];
    const { longitude: viewportLongitude, latitude: viewportLatitude } = frameState.viewport;
    for (const [index, tile] of tiles.entries()) {
      const [longitude, latitude] = tile.header.mbs;
      const deltaLon = Math.abs(viewportLongitude - longitude);
      const deltaLat = Math.abs(viewportLatitude - latitude);
      const distance6 = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
      tuples.push([index, distance6]);
    }
    const tuplesSorted = tuples.sort((a3, b2) => a3[1] - b2[1]);
    const selectedTiles = [];
    for (let i5 = 0; i5 < maximumTilesSelected; i5++) {
      selectedTiles.push(tiles[tuplesSorted[i5][0]]);
    }
    const unselectedTiles = [];
    for (let i5 = maximumTilesSelected; i5 < tuplesSorted.length; i5++) {
      unselectedTiles.push(tiles[tuplesSorted[i5][0]]);
    }
    return [selectedTiles, unselectedTiles];
  }
  function commonSpacePlanesToWGS84(viewport) {
    const frustumPlanes = viewport.getFrustumPlanes();
    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition4);
    let i5 = 0;
    cullingVolume.planes[i5++].fromPointNormal(nearCenterCartesian, scratchVector13.copy(nearCenterCartesian).subtract(cameraCartesian));
    for (const dir in frustumPlanes) {
      if (dir === "near") {
        continue;
      }
      const plane = frustumPlanes[dir];
      const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition4);
      const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition4);
      cullingVolume.planes[i5++].fromPointNormal(
        cartesianPos,
        // Want the normal to point into the frustum since that's what culling expects
        scratchVector13.copy(nearCenterCartesian).subtract(cartesianPos)
      );
    }
  }
  function closestPointOnPlane(plane, refPoint, out = new Vector33()) {
    const distanceToRef = plane.normal.dot(refPoint);
    out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
    return out;
  }
  function worldToCartesian(viewport, point, out = new Vector33()) {
    const cartographicPos = viewport.unprojectPosition(point);
    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/zoom.js
  var WGS84_RADIUS_X2 = 6378137;
  var WGS84_RADIUS_Y2 = 6378137;
  var WGS84_RADIUS_Z2 = 6356752314245179e-9;
  var scratchVector14 = new Vector33();
  function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
    if (boundingVolume instanceof OrientedBoundingBox2) {
      const { halfAxes } = boundingVolume;
      const obbSize = getObbSize(halfAxes);
      return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
    } else if (boundingVolume instanceof BoundingSphere2) {
      const { radius } = boundingVolume;
      return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
    } else if (boundingVolume.width && boundingVolume.height) {
      const { width, height } = boundingVolume;
      const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
      const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
      return (zoomX + zoomY) / 2;
    }
    return 1;
  }
  function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
    Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector14);
    const extentSize = Math.sqrt(Math.pow(scratchVector14[0] - cartesianCenter[0], 2) + Math.pow(scratchVector14[1] - cartesianCenter[1], 2) + Math.pow(scratchVector14[2] - cartesianCenter[2], 2));
    return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
  }
  function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
    const [xmin, ymin, xmax, ymax] = extent;
    return getZoomFromFullExtent({ xmin, xmax, ymin, ymax, zmin: 0, zmax: 0 }, cartorgraphicCenter, cartesianCenter);
  }
  function getObbSize(halfAxes) {
    halfAxes.getColumn(0, scratchVector14);
    const axeY = halfAxes.getColumn(1);
    const axeZ = halfAxes.getColumn(2);
    const farthestVertex = scratchVector14.add(axeY).add(axeZ);
    const size = farthestVertex.len();
    return size;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/constants.js
  var TILE_CONTENT_STATE = {
    UNLOADED: 0,
    // Has never been requested
    LOADING: 1,
    // Is waiting on a pending request
    PROCESSING: 2,
    // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
    READY: 3,
    // Ready to render.
    EXPIRED: 4,
    // Is expired and will be unloaded once new content is loaded.
    FAILED: 5
    // Request failed.
  };
  var TILE_REFINEMENT;
  (function(TILE_REFINEMENT2) {
    TILE_REFINEMENT2[TILE_REFINEMENT2["ADD"] = 1] = "ADD";
    TILE_REFINEMENT2[TILE_REFINEMENT2["REPLACE"] = 2] = "REPLACE";
  })(TILE_REFINEMENT || (TILE_REFINEMENT = {}));
  var TILE_TYPE;
  (function(TILE_TYPE2) {
    TILE_TYPE2["EMPTY"] = "empty";
    TILE_TYPE2["SCENEGRAPH"] = "scenegraph";
    TILE_TYPE2["POINTCLOUD"] = "pointcloud";
    TILE_TYPE2["MESH"] = "mesh";
  })(TILE_TYPE || (TILE_TYPE = {}));
  var TILESET_TYPE;
  (function(TILESET_TYPE2) {
    TILESET_TYPE2["I3S"] = "I3S";
    TILESET_TYPE2["TILES3D"] = "TILES3D";
  })(TILESET_TYPE || (TILESET_TYPE = {}));
  var LOD_METRIC_TYPE;
  (function(LOD_METRIC_TYPE2) {
    LOD_METRIC_TYPE2["GEOMETRIC_ERROR"] = "geometricError";
    LOD_METRIC_TYPE2["MAX_SCREEN_THRESHOLD"] = "maxScreenThreshold";
  })(LOD_METRIC_TYPE || (LOD_METRIC_TYPE = {}));
  var TILE3D_OPTIMIZATION_HINT = {
    NOT_COMPUTED: -1,
    USE_OPTIMIZATION: 1,
    SKIP_OPTIMIZATION: 0
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/bounding-volume.js
  function defined(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var scratchPoint = new Vector33();
  var scratchScale = new Vector33();
  var scratchNorthWest = new Vector33();
  var scratchSouthEast = new Vector33();
  var scratchCenter = new Vector33();
  var scratchXAxis = new Vector33();
  var scratchYAxis = new Vector33();
  var scratchZAxis = new Vector33();
  function createBoundingVolume(boundingVolumeHeader, transform2, result) {
    assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
    if (boundingVolumeHeader.box) {
      return createBox(boundingVolumeHeader.box, transform2, result);
    }
    if (boundingVolumeHeader.region) {
      return createObbFromRegion(boundingVolumeHeader.region);
    }
    if (boundingVolumeHeader.sphere) {
      return createSphere(boundingVolumeHeader.sphere, transform2, result);
    }
    throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
  }
  function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
    if (boundingVolumeHeader.box) {
      return orientedBoundingBoxToCartographicBounds(boundingVolume);
    }
    if (boundingVolumeHeader.region) {
      const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
      return [
        [degrees2(west), degrees2(south), minHeight],
        [degrees2(east), degrees2(north), maxHeight]
      ];
    }
    if (boundingVolumeHeader.sphere) {
      return boundingSphereToCartographicBounds(boundingVolume);
    }
    throw new Error("Unkown boundingVolume type");
  }
  function createBox(box, transform2, result) {
    const center = new Vector33(box[0], box[1], box[2]);
    transform2.transform(center, center);
    let origin = [];
    if (box.length === 10) {
      const halfSize = box.slice(3, 6);
      const quaternion2 = new Quaternion2();
      quaternion2.fromArray(box, 6);
      const x3 = new Vector33([1, 0, 0]);
      const y3 = new Vector33([0, 1, 0]);
      const z2 = new Vector33([0, 0, 1]);
      x3.transformByQuaternion(quaternion2);
      x3.scale(halfSize[0]);
      y3.transformByQuaternion(quaternion2);
      y3.scale(halfSize[1]);
      z2.transformByQuaternion(quaternion2);
      z2.scale(halfSize[2]);
      origin = [...x3.toArray(), ...y3.toArray(), ...z2.toArray()];
    } else {
      origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
    }
    const xAxis = transform2.transformAsVector(origin.slice(0, 3));
    const yAxis = transform2.transformAsVector(origin.slice(3, 6));
    const zAxis = transform2.transformAsVector(origin.slice(6, 9));
    const halfAxes = new Matrix33([
      xAxis[0],
      xAxis[1],
      xAxis[2],
      yAxis[0],
      yAxis[1],
      yAxis[2],
      zAxis[0],
      zAxis[1],
      zAxis[2]
    ]);
    if (defined(result)) {
      result.center = center;
      result.halfAxes = halfAxes;
      return result;
    }
    return new OrientedBoundingBox2(center, halfAxes);
  }
  function createSphere(sphere, transform2, result) {
    const center = new Vector33(sphere[0], sphere[1], sphere[2]);
    transform2.transform(center, center);
    const scale22 = transform2.getScale(scratchScale);
    const uniformScale = Math.max(Math.max(scale22[0], scale22[1]), scale22[2]);
    const radius = sphere[3] * uniformScale;
    if (defined(result)) {
      result.center = center;
      result.radius = radius;
      return result;
    }
    return new BoundingSphere2(center, radius);
  }
  function createObbFromRegion(region) {
    const [west, south, east, north, minHeight, maxHeight] = region;
    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees2(west), degrees2(north), minHeight], scratchNorthWest);
    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees2(east), degrees2(south), maxHeight], scratchSouthEast);
    const centerInCartesian = new Vector33().addVectors(northWest, southEast).multiplyByScalar(0.5);
    Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);
    Ellipsoid.WGS84.cartographicToCartesian([degrees2(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);
    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees2(north), scratchCenter[2]], scratchYAxis);
    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);
    return createBox([
      ...centerInCartesian,
      ...scratchXAxis.subtract(centerInCartesian),
      ...scratchYAxis.subtract(centerInCartesian),
      ...scratchZAxis.subtract(centerInCartesian)
    ], new Matrix42());
  }
  function orientedBoundingBoxToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const { halfAxes } = boundingVolume;
    const xAxis = new Vector33(halfAxes.getColumn(0));
    const yAxis = new Vector33(halfAxes.getColumn(1));
    const zAxis = new Vector33(halfAxes.getColumn(2));
    for (let x3 = 0; x3 < 2; x3++) {
      for (let y3 = 0; y3 < 2; y3++) {
        for (let z2 = 0; z2 < 2; z2++) {
          scratchPoint.copy(boundingVolume.center);
          scratchPoint.add(xAxis);
          scratchPoint.add(yAxis);
          scratchPoint.add(zAxis);
          addToCartographicBounds(result, scratchPoint);
          zAxis.negate();
        }
        yAxis.negate();
      }
      xAxis.negate();
    }
    return result;
  }
  function boundingSphereToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const { center, radius } = boundingVolume;
    const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);
    let zAxis;
    if (point) {
      zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);
    } else {
      zAxis = new Vector33(0, 0, 1);
    }
    let xAxis = new Vector33(zAxis[2], -zAxis[1], 0);
    if (xAxis.len() > 0) {
      xAxis.normalize();
    } else {
      xAxis = new Vector33(0, 1, 0);
    }
    const yAxis = xAxis.clone().cross(zAxis);
    for (const axis of [xAxis, yAxis, zAxis]) {
      scratchScale.copy(axis).scale(radius);
      for (let dir = 0; dir < 2; dir++) {
        scratchPoint.copy(center);
        scratchPoint.add(scratchScale);
        addToCartographicBounds(result, scratchPoint);
        scratchScale.negate();
      }
    }
    return result;
  }
  function emptyCartographicBounds() {
    return [
      [Infinity, Infinity, Infinity],
      [-Infinity, -Infinity, -Infinity]
    ];
  }
  function addToCartographicBounds(target2, cartesian) {
    Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
    target2[0][0] = Math.min(target2[0][0], scratchPoint[0]);
    target2[0][1] = Math.min(target2[0][1], scratchPoint[1]);
    target2[0][2] = Math.min(target2[0][2], scratchPoint[2]);
    target2[1][0] = Math.max(target2[1][0], scratchPoint[0]);
    target2[1][1] = Math.max(target2[1][1], scratchPoint[1]);
    target2[1][2] = Math.max(target2[1][2], scratchPoint[2]);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/tiles-3d-lod.js
  var scratchPositionNormal = new Vector33();
  var scratchCartographic = new Vector33();
  var scratchMatrix3 = new Matrix42();
  var scratchCenter2 = new Vector33();
  var scratchPosition5 = new Vector33();
  var scratchDirection = new Vector33();
  function fog(distanceToCamera, density) {
    const scalar = distanceToCamera * density;
    return 1 - Math.exp(-(scalar * scalar));
  }
  function getDynamicScreenSpaceError(tileset, distanceToCamera) {
    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
      const density = tileset.dynamicScreenSpaceErrorComputedDensity;
      const factor = tileset.dynamicScreenSpaceErrorFactor;
      const dynamicError = fog(distanceToCamera, density) * factor;
      return dynamicError;
    }
    return 0;
  }
  function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
    const tileset = tile.tileset;
    const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
    if (lodMetricValue === 0) {
      return 0;
    }
    const distance6 = Math.max(tile._distanceToCamera, 1e-7);
    const { height, sseDenominator } = frameState;
    const { viewDistanceScale } = tileset.options;
    let error = lodMetricValue * height * (viewDistanceScale || 1) / (distance6 * sseDenominator);
    error -= getDynamicScreenSpaceError(tileset, distance6);
    return error;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/i3s-lod.js
  var cameraPositionCartesian = new Vector33();
  var toEye = new Vector33();
  var cameraPositionEnu = new Vector33();
  var extraVertexEnu = new Vector33();
  var projectedOriginVector = new Vector33();
  var enuToCartesianMatrix = new Matrix42();
  var cartesianToEnuMatrix = new Matrix42();
  function getLodStatus(tile, frameState) {
    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
      return "DIG";
    }
    const screenSize = 2 * getProjectedRadius(tile, frameState);
    if (screenSize < 2) {
      return "OUT";
    }
    if (!tile.header.children || screenSize <= tile.lodMetricValue) {
      return "DRAW";
    } else if (tile.header.children) {
      return "DIG";
    }
    return "OUT";
  }
  function getProjectedRadius(tile, frameState) {
    const { topDownViewport: viewport } = frameState;
    const mbsLat = tile.header.mbs[1];
    const mbsLon = tile.header.mbs[0];
    const mbsZ = tile.header.mbs[2];
    const mbsR = tile.header.mbs[3];
    const mbsCenterCartesian = [...tile.boundingVolume.center];
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
    const extraZ = projection * projection / cameraPositionEnu[2];
    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
    const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
    return projectedRadius;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/3d-tiles-options.js
  function get3dTilesOptions(tileset) {
    return {
      assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
    };
  }

  // ../../node_modules/@loaders.gl/tiles/dist/utils/managed-array.js
  var ManagedArray = class {
    _map = /* @__PURE__ */ new Map();
    _array;
    _length;
    constructor(length16 = 0) {
      this._array = new Array(length16);
      this._length = length16;
    }
    /**
     * Gets or sets the length of the array.
     * If the set length is greater than the length of the internal array, the internal array is resized.
     *
     * @memberof ManagedArray.prototype
     * @type Number
     */
    get length() {
      return this._length;
    }
    set length(length16) {
      this._length = length16;
      if (length16 > this._array.length) {
        this._array.length = length16;
      }
    }
    /**
     * Gets the internal array.
     *
     * @memberof ManagedArray.prototype
     * @type Array
     * @readonly
     */
    get values() {
      return this._array;
    }
    /**
     * Gets the element at an index.
     *
     * @param {Number} index The index to get.
     */
    get(index) {
      assert2(index < this._array.length);
      return this._array[index];
    }
    /**
     * Sets the element at an index. Resizes the array if index is greater than the length of the array.
     *
     * @param {Number} index The index to set.
     * @param {*} element The element to set at index.
     */
    set(index, element) {
      assert2(index >= 0);
      if (index >= this.length) {
        this.length = index + 1;
      }
      if (this._map.has(this._array[index])) {
        this._map.delete(this._array[index]);
      }
      this._array[index] = element;
      this._map.set(element, index);
    }
    delete(element) {
      const index = this._map.get(element);
      if (index >= 0) {
        this._array.splice(index, 1);
        this._map.delete(element);
        this.length--;
      }
    }
    /**
     * Returns the last element in the array without modifying the array.
     *
     * @returns {*} The last element in the array.
     */
    peek() {
      return this._array[this._length - 1];
    }
    /**
     * Push an element into the array.
     *
     * @param {*} element The element to push.
     */
    push(element) {
      if (!this._map.has(element)) {
        const index = this.length++;
        this._array[index] = element;
        this._map.set(element, index);
      }
    }
    /**
     * Pop an element from the array.
     *
     * @returns {*} The last element in the array.
     */
    pop() {
      const element = this._array[--this.length];
      this._map.delete(element);
      return element;
    }
    /**
     * Resize the internal array if length > _array.length.
     *
     * @param {Number} length The length.
     */
    reserve(length16) {
      assert2(length16 >= 0);
      if (length16 > this._array.length) {
        this._array.length = length16;
      }
    }
    /**
     * Resize the array.
     *
     * @param {Number} length The length.
     */
    resize(length16) {
      assert2(length16 >= 0);
      this.length = length16;
    }
    /**
     * Trim the internal array to the specified length. Defaults to the current length.
     *
     * @param {Number} [length] The length.
     */
    trim(length16) {
      if (length16 === null || length16 === void 0) {
        length16 = this.length;
      }
      this._array.length = length16;
    }
    reset() {
      this._array = [];
      this._map = /* @__PURE__ */ new Map();
      this._length = 0;
    }
    find(target2) {
      return this._map.has(target2);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-traverser.js
  var DEFAULT_PROPS4 = {
    loadSiblings: false,
    skipLevelOfDetail: false,
    updateTransforms: true,
    onTraversalEnd: () => {
    },
    viewportTraversersMap: {},
    basePath: ""
  };
  var TilesetTraverser = class {
    options;
    // fulfill in traverse call
    root = null;
    // tiles should be rendered
    selectedTiles = {};
    // tiles should be loaded from server
    requestedTiles = {};
    // tiles does not have render content
    emptyTiles = {};
    lastUpdate = new Date().getTime();
    updateDebounceTime = 1e3;
    /** temporary storage to hold the traversed tiles during a traversal */
    _traversalStack = new ManagedArray();
    _emptyTraversalStack = new ManagedArray();
    /** set in every traverse cycle */
    _frameNumber = null;
    // RESULT
    traversalFinished(frameState) {
      return true;
    }
    // TODO nested props
    constructor(options) {
      this.options = { ...DEFAULT_PROPS4, ...options };
    }
    // tiles should be visible
    traverse(root, frameState, options) {
      this.root = root;
      this.options = { ...this.options, ...options };
      this.reset();
      this.updateTile(root, frameState);
      this._frameNumber = frameState.frameNumber;
      this.executeTraversal(root, frameState);
    }
    reset() {
      this.requestedTiles = {};
      this.selectedTiles = {};
      this.emptyTiles = {};
      this._traversalStack.reset();
      this._emptyTraversalStack.reset();
    }
    /**
     * Execute traverse
     * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
     * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
     * This is the traditional replacement refinement approach and is called the base traversal.
     * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
     * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
     * and rendering children and parent tiles simultaneously.
     */
    /* eslint-disable-next-line complexity, max-statements */
    executeTraversal(root, frameState) {
      const stack2 = this._traversalStack;
      root._selectionDepth = 1;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        let shouldRefine = false;
        if (this.canTraverse(tile, frameState)) {
          this.updateChildTiles(tile, frameState);
          shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
        }
        const parent = tile.parent;
        const parentRefines = Boolean(!parent || parent._shouldRefine);
        const stoppedRefining = !shouldRefine;
        if (!tile.hasRenderContent) {
          this.emptyTiles[tile.id] = tile;
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        } else if (tile.refine === TILE_REFINEMENT.ADD) {
          this.loadTile(tile, frameState);
          this.selectTile(tile, frameState);
        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        }
        this.touchTile(tile, frameState);
        tile._shouldRefine = shouldRefine && parentRefines;
      }
      const newTime = new Date().getTime();
      if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
        this.lastUpdate = newTime;
        this.options.onTraversalEnd(frameState);
      }
    }
    updateChildTiles(tile, frameState) {
      const children = tile.children;
      for (const child of children) {
        this.updateTile(child, frameState);
      }
    }
    /* eslint-disable complexity, max-statements */
    updateAndPushChildren(tile, frameState, stack2, depth) {
      const { loadSiblings, skipLevelOfDetail } = this.options;
      const children = tile.children;
      children.sort(this.compareDistanceToCamera.bind(this));
      const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
      let hasVisibleChild = false;
      let refines = true;
      for (const child of children) {
        child._selectionDepth = depth;
        if (child.isVisibleAndInRequestVolume) {
          if (stack2.find(child)) {
            stack2.delete(child);
          }
          stack2.push(child);
          hasVisibleChild = true;
        } else if (checkRefines || loadSiblings) {
          this.loadTile(child, frameState);
          this.touchTile(child, frameState);
        }
        if (checkRefines) {
          let childRefines;
          if (!child._inRequestVolume) {
            childRefines = false;
          } else if (!child.hasRenderContent) {
            childRefines = this.executeEmptyTraversal(child, frameState);
          } else {
            childRefines = child.contentAvailable;
          }
          refines = refines && childRefines;
          if (!refines) {
            return false;
          }
        }
      }
      if (!hasVisibleChild) {
        refines = false;
      }
      return refines;
    }
    /* eslint-enable complexity, max-statements */
    updateTile(tile, frameState) {
      this.updateTileVisibility(tile, frameState);
    }
    // tile to render in the browser
    selectTile(tile, frameState) {
      if (this.shouldSelectTile(tile)) {
        tile._selectedFrame = frameState.frameNumber;
        this.selectedTiles[tile.id] = tile;
      }
    }
    // tile to load from server
    loadTile(tile, frameState) {
      if (this.shouldLoadTile(tile)) {
        tile._requestedFrame = frameState.frameNumber;
        tile._priority = tile._getPriority();
        this.requestedTiles[tile.id] = tile;
      }
    }
    // cache tile
    touchTile(tile, frameState) {
      tile.tileset._cache.touch(tile);
      tile._touchedFrame = frameState.frameNumber;
    }
    // tile should be visible
    // tile should have children
    // tile LoD (level of detail) is not sufficient under current viewport
    canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {
      if (!tile.hasChildren) {
        return false;
      }
      if (tile.hasTilesetContent) {
        return !tile.contentExpired;
      }
      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
        return false;
      }
      return this.shouldRefine(tile, frameState, useParentMetric);
    }
    shouldLoadTile(tile) {
      return tile.hasUnloadedContent || tile.contentExpired;
    }
    shouldSelectTile(tile) {
      return tile.contentAvailable && !this.options.skipLevelOfDetail;
    }
    /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
    shouldRefine(tile, frameState, useParentMetric = false) {
      let screenSpaceError = tile._screenSpaceError;
      if (useParentMetric) {
        screenSpaceError = tile.getScreenSpaceError(frameState, true);
      }
      return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;
    }
    updateTileVisibility(tile, frameState) {
      const viewportIds = [];
      if (this.options.viewportTraversersMap) {
        for (const key in this.options.viewportTraversersMap) {
          const value = this.options.viewportTraversersMap[key];
          if (value === frameState.viewport.id) {
            viewportIds.push(key);
          }
        }
      } else {
        viewportIds.push(frameState.viewport.id);
      }
      tile.updateVisibility(frameState, viewportIds);
    }
    // UTILITIES
    compareDistanceToCamera(b2, a3) {
      return b2._distanceToCamera - a3._distanceToCamera;
    }
    anyChildrenVisible(tile, frameState) {
      let anyVisible = false;
      for (const child of tile.children) {
        child.updateVisibility(frameState);
        anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
      }
      return anyVisible;
    }
    // Depth-first traversal that checks if all nearest descendants with content are loaded.
    // Ignores visibility.
    executeEmptyTraversal(root, frameState) {
      let allDescendantsLoaded = true;
      const stack2 = this._emptyTraversalStack;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, false);
        const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;
        if (!traverse && !tile.contentAvailable && !emptyLeaf) {
          allDescendantsLoaded = false;
        }
        this.updateTile(tile, frameState);
        if (!tile.isVisibleAndInRequestVolume) {
          this.loadTile(tile, frameState);
          this.touchTile(tile, frameState);
        }
        if (traverse) {
          const children = tile.children;
          for (const child of children) {
            stack2.push(child);
          }
        }
      }
      return allDescendantsLoaded;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tile-3d.js
  var scratchVector15 = new Vector33();
  function defined2(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var Tile3D = class {
    tileset;
    header;
    id;
    url;
    parent;
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    refine;
    type;
    contentUrl;
    /** Different refinement algorithms used by I3S and 3D tiles */
    lodMetricType = "geometricError";
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    lodMetricValue = 0;
    /** @todo math.gl is not exporting BoundingVolume base type? */
    boundingVolume = null;
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    content = null;
    contentState = TILE_CONTENT_STATE.UNLOADED;
    gpuMemoryUsageInBytes = 0;
    /** The tile's children - an array of Tile3D objects. */
    children = [];
    depth = 0;
    viewportIds = [];
    transform = new Matrix42();
    extensions = null;
    /** TODO Cesium 3d tiles specific */
    implicitTiling = null;
    /** Container to store application specific data */
    userData = {};
    computedTransform;
    hasEmptyContent = false;
    hasTilesetContent = false;
    traverser = new TilesetTraverser({});
    /** Used by TilesetCache */
    _cacheNode = null;
    _frameNumber = null;
    // TODO Cesium 3d tiles specific
    _expireDate = null;
    _expiredContent = null;
    _boundingBox = void 0;
    /** updated every frame for tree traversal and rendering optimizations: */
    _distanceToCamera = 0;
    _screenSpaceError = 0;
    _visibilityPlaneMask;
    _visible = void 0;
    _contentBoundingVolume;
    _viewerRequestVolume;
    _initialTransform = new Matrix42();
    // Used by traverser, cannot be marked private
    _priority = 0;
    _selectedFrame = 0;
    _requestedFrame = 0;
    _selectionDepth = 0;
    _touchedFrame = 0;
    _centerZDepth = 0;
    _shouldRefine = false;
    _stackLength = 0;
    _visitedFrame = 0;
    _inRequestVolume = false;
    _lodJudge = null;
    // TODO i3s specific, needs to remove
    /**
     * @constructs
     * Create a Tile3D instance
     * @param tileset - Tileset3D instance
     * @param header - tile header - JSON loaded from a dataset
     * @param parentHeader - parent Tile3D instance
     * @param extendedId - optional ID to separate copies of a tile for different viewports.
     *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
     */
    // eslint-disable-next-line max-statements
    constructor(tileset, header, parentHeader, extendedId = "") {
      this.header = header;
      this.tileset = tileset;
      this.id = extendedId || header.id;
      this.url = header.url;
      this.parent = parentHeader;
      this.refine = this._getRefine(header.refine);
      this.type = header.type;
      this.contentUrl = header.contentUrl;
      this._initializeLodMetric(header);
      this._initializeTransforms(header);
      this._initializeBoundingVolumes(header);
      this._initializeContent(header);
      this._initializeRenderingState(header);
      Object.seal(this);
    }
    destroy() {
      this.header = null;
    }
    isDestroyed() {
      return this.header === null;
    }
    get selected() {
      return this._selectedFrame === this.tileset._frameNumber;
    }
    get isVisible() {
      return this._visible;
    }
    get isVisibleAndInRequestVolume() {
      return this._visible && this._inRequestVolume;
    }
    /** Returns true if tile is not an empty tile and not an external tileset */
    get hasRenderContent() {
      return !this.hasEmptyContent && !this.hasTilesetContent;
    }
    /** Returns true if tile has children */
    get hasChildren() {
      return this.children.length > 0 || this.header.children && this.header.children.length > 0;
    }
    /**
     * Determines if the tile's content is ready. This is automatically `true` for
     * tiles with empty content.
     */
    get contentReady() {
      return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
    }
    /**
     * Determines if the tile has available content to render.  `true` if the tile's
     * content is ready or if it has expired content this renders while new content loads; otherwise,
     */
    get contentAvailable() {
      return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
    }
    /** Returns true if tile has renderable content but it's unloaded */
    get hasUnloadedContent() {
      return this.hasRenderContent && this.contentUnloaded;
    }
    /**
     * Determines if the tile's content has not be requested. `true` if tile's
     * content has not be requested; otherwise, `false`.
     */
    get contentUnloaded() {
      return this.contentState === TILE_CONTENT_STATE.UNLOADED;
    }
    /**
     * Determines if the tile's content is expired. `true` if tile's
     * content is expired; otherwise, `false`.
     */
    get contentExpired() {
      return this.contentState === TILE_CONTENT_STATE.EXPIRED;
    }
    // Determines if the tile's content failed to load.  `true` if the tile's
    // content failed to load; otherwise, `false`.
    get contentFailed() {
      return this.contentState === TILE_CONTENT_STATE.FAILED;
    }
    /**
     * Distance from the tile's bounding volume center to the camera
     */
    get distanceToCamera() {
      return this._distanceToCamera;
    }
    /**
     * Screen space error for LOD selection
     */
    get screenSpaceError() {
      return this._screenSpaceError;
    }
    /**
     * Get bounding box in cartographic coordinates
     * @returns [min, max] each in [longitude, latitude, altitude]
     */
    get boundingBox() {
      if (!this._boundingBox) {
        this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
      }
      return this._boundingBox;
    }
    /** Get the tile's screen space error. */
    getScreenSpaceError(frameState, useParentLodMetric) {
      switch (this.tileset.type) {
        case TILESET_TYPE.I3S:
          return getProjectedRadius(this, frameState);
        case TILESET_TYPE.TILES3D:
          return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
        default:
          throw new Error("Unsupported tileset type");
      }
    }
    /**
     * Make tile unselected than means it won't be shown
     * but it can be still loaded in memory
     */
    unselect() {
      this._selectedFrame = 0;
    }
    /**
     * Memory usage of tile on GPU
     */
    _getGpuMemoryUsageInBytes() {
      return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
    }
    /*
     * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
     * Tiles are prioritized by screen space error.
     */
    // eslint-disable-next-line complexity
    _getPriority() {
      const traverser = this.tileset._traverser;
      const { skipLevelOfDetail } = traverser.options;
      const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
      if (maySkipTile && !this.isVisible && this._visible !== void 0) {
        return -1;
      }
      if (this.tileset._frameNumber - this._touchedFrame >= 1) {
        return -1;
      }
      if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
        return -1;
      }
      const parent = this.parent;
      const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
      const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
      const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
      return Math.max(rootScreenSpaceError - screenSpaceError, 0);
    }
    /**
     *  Requests the tile's content.
     * The request may not be made if the Request Scheduler can't prioritize it.
     */
    // eslint-disable-next-line max-statements, complexity
    async loadContent() {
      if (this.hasEmptyContent) {
        return false;
      }
      if (this.content) {
        return true;
      }
      const expired = this.contentExpired;
      if (expired) {
        this._expireDate = null;
      }
      this.contentState = TILE_CONTENT_STATE.LOADING;
      const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
      if (!requestToken) {
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        return false;
      }
      try {
        const contentUrl = this.tileset.getTileUrl(this.contentUrl);
        const loader = this.tileset.loader;
        const options = {
          ...this.tileset.loadOptions,
          [loader.id]: {
            // @ts-expect-error
            ...this.tileset.loadOptions[loader.id],
            isTileset: this.type === "json",
            ...this._getLoaderSpecificOptions(loader.id)
          }
        };
        this.content = await load(contentUrl, loader, options);
        if (this.tileset.options.contentLoader) {
          await this.tileset.options.contentLoader(this);
        }
        if (this._isTileset()) {
          this.tileset._initializeTileHeaders(this.content, this);
        }
        this.contentState = TILE_CONTENT_STATE.READY;
        this._onContentLoaded();
        return true;
      } catch (error) {
        this.contentState = TILE_CONTENT_STATE.FAILED;
        throw error;
      } finally {
        requestToken.done();
      }
    }
    // Unloads the tile's content.
    unloadContent() {
      if (this.content && this.content.destroy) {
        this.content.destroy();
      }
      this.content = null;
      if (this.header.content && this.header.content.destroy) {
        this.header.content.destroy();
      }
      this.header.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return true;
    }
    /**
     * Update the tile's visibility
     * @param {Object} frameState - frame state for tile culling
     * @param {string[]} viewportIds - a list of viewport ids that show this tile
     * @return {void}
     */
    updateVisibility(frameState, viewportIds) {
      if (this._frameNumber === frameState.frameNumber) {
        return;
      }
      const parent = this.parent;
      const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume2.MASK_INDETERMINATE;
      if (this.tileset._traverser.options.updateTransforms) {
        const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
        this._updateTransform(parentTransform);
      }
      this._distanceToCamera = this.distanceToTile(frameState);
      this._screenSpaceError = this.getScreenSpaceError(frameState, false);
      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
      this._visible = this._visibilityPlaneMask !== CullingVolume2.MASK_OUTSIDE;
      this._inRequestVolume = this.insideViewerRequestVolume(frameState);
      this._frameNumber = frameState.frameNumber;
      this.viewportIds = viewportIds;
    }
    // Determines whether the tile's bounding volume intersects the culling volume.
    // @param {FrameState} frameState The frame state.
    // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
    // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
    visibility(frameState, parentVisibilityPlaneMask) {
      const { cullingVolume: cullingVolume2 } = frameState;
      const { boundingVolume } = this;
      return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
    }
    // Assuming the tile's bounding volume intersects the culling volume, determines
    // whether the tile's content's bounding volume intersects the culling volume.
    // @param {FrameState} frameState The frame state.
    // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
    contentVisibility() {
      return true;
    }
    /**
     * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
     * @param frameState The frame state.
     * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
     */
    distanceToTile(frameState) {
      const boundingVolume = this.boundingVolume;
      return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
    }
    /**
     * Computes the tile's camera-space z-depth.
     * @param frameState The frame state.
     * @returns The distance, in meters.
     */
    cameraSpaceZDepth({ camera }) {
      const boundingVolume = this.boundingVolume;
      scratchVector15.subVectors(boundingVolume.center, camera.position);
      return camera.direction.dot(scratchVector15);
    }
    /**
     * Checks if the camera is inside the viewer request volume.
     * @param {FrameState} frameState The frame state.
     * @returns {Boolean} Whether the camera is inside the volume.
     */
    insideViewerRequestVolume(frameState) {
      const viewerRequestVolume = this._viewerRequestVolume;
      return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
    }
    // TODO Cesium specific
    // Update whether the tile has expired.
    updateExpiration() {
      if (defined2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
        const now = Date.now();
        if (Date.lessThan(this._expireDate, now)) {
          this.contentState = TILE_CONTENT_STATE.EXPIRED;
          this._expiredContent = this.content;
        }
      }
    }
    get extras() {
      return this.header.extras;
    }
    // INTERNAL METHODS
    _initializeLodMetric(header) {
      if ("lodMetricType" in header) {
        this.lodMetricType = header.lodMetricType;
      } else {
        this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
        console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);
      }
      if ("lodMetricValue" in header) {
        this.lodMetricValue = header.lodMetricValue;
      } else {
        this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
        console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
      }
    }
    _initializeTransforms(tileHeader) {
      this.transform = tileHeader.transform ? new Matrix42(tileHeader.transform) : new Matrix42();
      const parent = this.parent;
      const tileset = this.tileset;
      const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
      this.computedTransform = new Matrix42(parentTransform).multiplyRight(this.transform);
      const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix42();
      this._initialTransform = new Matrix42(parentInitialTransform).multiplyRight(this.transform);
    }
    _initializeBoundingVolumes(tileHeader) {
      this._contentBoundingVolume = null;
      this._viewerRequestVolume = null;
      this._updateBoundingVolume(tileHeader);
    }
    _initializeContent(tileHeader) {
      this.content = { _tileset: this.tileset, _tile: this };
      this.hasEmptyContent = true;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.hasTilesetContent = false;
      if (tileHeader.contentUrl) {
        this.content = null;
        this.hasEmptyContent = false;
      }
    }
    // TODO - remove anything not related to basic visibility detection
    _initializeRenderingState(header) {
      this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
      this._shouldRefine = false;
      this._distanceToCamera = 0;
      this._centerZDepth = 0;
      this._screenSpaceError = 0;
      this._visibilityPlaneMask = CullingVolume2.MASK_INDETERMINATE;
      this._visible = void 0;
      this._inRequestVolume = false;
      this._stackLength = 0;
      this._selectionDepth = 0;
      this._frameNumber = 0;
      this._touchedFrame = 0;
      this._visitedFrame = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._priority = 0;
    }
    _getRefine(refine) {
      return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
    }
    _isTileset() {
      return this.contentUrl.indexOf(".json") !== -1;
    }
    _onContentLoaded() {
      switch (this.content && this.content.type) {
        case "vctr":
        case "geom":
          this.tileset._traverser.disableSkipLevelOfDetail = true;
          break;
        default:
      }
      if (this._isTileset()) {
        this.hasTilesetContent = true;
      } else {
        this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
      }
    }
    _updateBoundingVolume(header) {
      this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
      const content = header.content;
      if (!content) {
        return;
      }
      if (content.boundingVolume) {
        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
      }
      if (header.viewerRequestVolume) {
        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
      }
    }
    // Update the tile's transform. The transform is applied to the tile's bounding volumes.
    _updateTransform(parentTransform = new Matrix42()) {
      const computedTransform = parentTransform.clone().multiplyRight(this.transform);
      const didTransformChange = !computedTransform.equals(this.computedTransform);
      if (!didTransformChange) {
        return;
      }
      this.computedTransform = computedTransform;
      this._updateBoundingVolume(this.header);
    }
    // Get options which are applicable only for the particular loader
    _getLoaderSpecificOptions(loaderId) {
      switch (loaderId) {
        case "i3s":
          return {
            ...this.tileset.options.i3s,
            _tileOptions: {
              attributeUrls: this.header.attributeUrls,
              textureUrl: this.header.textureUrl,
              textureFormat: this.header.textureFormat,
              textureLoaderOptions: this.header.textureLoaderOptions,
              materialDefinition: this.header.materialDefinition,
              isDracoGeometry: this.header.isDracoGeometry,
              mbs: this.header.mbs
            },
            _tilesetOptions: {
              store: this.tileset.tileset.store,
              attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
              fields: this.tileset.tileset.fields
            },
            isTileHeader: false
          };
        case "3d-tiles":
        case "cesium-ion":
        default:
          return get3dTilesOptions(this.tileset.tileset);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-3d-tiles/tileset-3d-traverser.js
  var Tileset3DTraverser = class extends TilesetTraverser {
    compareDistanceToCamera(a3, b2) {
      return b2._distanceToCamera === 0 && a3._distanceToCamera === 0 ? b2._centerZDepth - a3._centerZDepth : b2._distanceToCamera - a3._distanceToCamera;
    }
    updateTileVisibility(tile, frameState) {
      super.updateTileVisibility(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        return;
      }
      const hasChildren = tile.children.length > 0;
      if (tile.hasTilesetContent && hasChildren) {
        const firstChild = tile.children[0];
        this.updateTileVisibility(firstChild, frameState);
        tile._visible = firstChild._visible;
        return;
      }
      if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
        tile._visible = false;
        return;
      }
      const replace = tile.refine === TILE_REFINEMENT.REPLACE;
      const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
      if (replace && useOptimization && hasChildren) {
        if (!this.anyChildrenVisible(tile, frameState)) {
          tile._visible = false;
          return;
        }
      }
    }
    meetsScreenSpaceErrorEarly(tile, frameState) {
      const { parent } = tile;
      if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
        return false;
      }
      return !this.shouldRefine(tile, frameState, true);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-pending-tiles-register.js
  var I3SPendingTilesRegister = class {
    frameNumberMap = /* @__PURE__ */ new Map();
    /**
     * Register a new pending tile header for the particular frameNumber
     * @param viewportId
     * @param frameNumber
     */
    register(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
      const oldCount = viewportMap.get(frameNumber) || 0;
      viewportMap.set(frameNumber, oldCount + 1);
      this.frameNumberMap.set(viewportId, viewportMap);
    }
    /**
     * Deregister a pending tile header for the particular frameNumber
     * @param viewportId
     * @param frameNumber
     */
    deregister(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId);
      if (!viewportMap) {
        return;
      }
      const oldCount = viewportMap.get(frameNumber) || 1;
      viewportMap.set(frameNumber, oldCount - 1);
    }
    /**
     * Check is there are no pending tile headers registered for the particular frameNumber
     * @param viewportId
     * @param frameNumber
     * @returns
     */
    isZero(viewportId, frameNumber) {
      const count3 = this.frameNumberMap.get(viewportId)?.get(frameNumber) || 0;
      return count3 === 0;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tile-manager.js
  var STATUS = {
    REQUESTED: "REQUESTED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR"
  };
  var I3STileManager = class {
    _statusMap;
    pendingTilesRegister = new I3SPendingTilesRegister();
    constructor() {
      this._statusMap = {};
    }
    /**
     * Add request to map
     * @param request - node metadata request
     * @param key - unique key
     * @param callback - callback after request completed
     * @param frameState - frameState data
     */
    add(request, key, callback, frameState) {
      if (!this._statusMap[key]) {
        const { frameNumber, viewport: { id } } = frameState;
        this._statusMap[key] = { request, callback, key, frameState, status: STATUS.REQUESTED };
        this.pendingTilesRegister.register(id, frameNumber);
        request().then((data) => {
          this._statusMap[key].status = STATUS.COMPLETED;
          const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          this._statusMap[key].callback(data, frameState);
        }).catch((error) => {
          this._statusMap[key].status = STATUS.ERROR;
          const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          callback(error);
        });
      }
    }
    /**
     * Update request if it is still actual for the new frameState
     * @param key - unique key
     * @param frameState - frameState data
     */
    update(key, frameState) {
      if (this._statusMap[key]) {
        const { frameNumber, viewport: { id } } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id, frameNumber);
        const { frameNumber: newFrameNumber, viewport: { id: newViewportId } } = frameState;
        this.pendingTilesRegister.register(newViewportId, newFrameNumber);
        this._statusMap[key].frameState = frameState;
      }
    }
    /**
     * Find request in the map
     * @param key - unique key
     * @returns
     */
    find(key) {
      return this._statusMap[key];
    }
    /**
     * Check it there are pending tile headers for the particular frameNumber
     * @param viewportId
     * @param frameNumber
     * @returns
     */
    hasPendingTiles(viewportId, frameNumber) {
      return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tileset-traverser.js
  var I3STilesetTraverser = class extends TilesetTraverser {
    _tileManager;
    constructor(options) {
      super(options);
      this._tileManager = new I3STileManager();
    }
    /**
     * Check if there are no penging tile header requests,
     * that means the traversal is finished and we can call
     * following-up callbacks.
     */
    traversalFinished(frameState) {
      return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
    }
    shouldRefine(tile, frameState) {
      tile._lodJudge = getLodStatus(tile, frameState);
      return tile._lodJudge === "DIG";
    }
    updateChildTiles(tile, frameState) {
      const children = tile.header.children || [];
      const childTiles = tile.children;
      const tileset = tile.tileset;
      for (const child of children) {
        const extendedId = `${child.id}-${frameState.viewport.id}`;
        const childTile = childTiles && childTiles.find((t3) => t3.id === extendedId);
        if (!childTile) {
          let request = () => this._loadTile(child.id, tileset);
          const cachedRequest = this._tileManager.find(extendedId);
          if (!cachedRequest) {
            if (tileset.tileset.nodePages) {
              request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
            }
            this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
          } else {
            this._tileManager.update(extendedId, frameState);
          }
        } else if (childTile) {
          this.updateTile(childTile, frameState);
        }
      }
      return false;
    }
    async _loadTile(nodeId, tileset) {
      const { loader } = tileset;
      const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);
      const options = {
        ...tileset.loadOptions,
        i3s: {
          ...tileset.loadOptions.i3s,
          isTileHeader: true
        }
      };
      return await load(nodeUrl, loader, options);
    }
    /**
     * The callback to init Tile3D instance after loading the tile JSON
     * @param {Object} header - the tile JSON from a dataset
     * @param {Tile3D} tile - the parent Tile3D instance
     * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
     *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
     * @return {void}
     */
    _onTileLoad(header, tile, extendedId) {
      const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
      tile.children.push(childTile);
      const frameState = this._tileManager.find(childTile.id).frameState;
      this.updateTile(childTile, frameState);
      if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {
        this.executeTraversal(childTile, frameState);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-3d.js
  var DEFAULT_PROPS5 = {
    description: "",
    ellipsoid: Ellipsoid.WGS84,
    modelMatrix: new Matrix42(),
    throttleRequests: true,
    maxRequests: 64,
    /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
    maximumMemoryUsage: 32,
    memoryCacheOverflow: 1,
    maximumTilesSelected: 0,
    debounceTime: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    },
    onTraversalComplete: (selectedTiles) => selectedTiles,
    contentLoader: void 0,
    viewDistanceScale: 1,
    maximumScreenSpaceError: 8,
    memoryAdjustedScreenSpaceError: false,
    loadTiles: true,
    updateTransforms: true,
    viewportTraversersMap: null,
    loadOptions: { fetch: {} },
    attributions: [],
    basePath: "",
    i3s: {}
  };
  var TILES_TOTAL = "Tiles In Tileset(s)";
  var TILES_IN_MEMORY = "Tiles In Memory";
  var TILES_IN_VIEW = "Tiles In View";
  var TILES_RENDERABLE = "Tiles To Render";
  var TILES_LOADED = "Tiles Loaded";
  var TILES_LOADING = "Tiles Loading";
  var TILES_UNLOADED = "Tiles Unloaded";
  var TILES_LOAD_FAILED = "Failed Tile Loads";
  var POINTS_COUNT = "Points/Vertices";
  var TILES_GPU_MEMORY = "Tile Memory Use";
  var MAXIMUM_SSE = "Maximum Screen Space Error";
  var Tileset3D = class {
    // props: Tileset3DProps;
    options;
    loadOptions;
    type;
    tileset;
    loader;
    url;
    basePath;
    modelMatrix;
    ellipsoid;
    lodMetricType;
    lodMetricValue;
    refine;
    root = null;
    roots = {};
    /** @todo any->unknown */
    asset = {};
    // Metadata for the entire tileset
    description = "";
    properties;
    extras = null;
    attributions = {};
    credits = {};
    stats;
    /** flags that contain information about data types in nested tiles */
    contentFormats = { draco: false, meshopt: false, dds: false, ktx2: false };
    // view props
    cartographicCenter = null;
    cartesianCenter = null;
    zoom = 1;
    boundingVolume = null;
    /** Updated based on the camera position and direction */
    dynamicScreenSpaceErrorComputedDensity = 0;
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    maximumMemoryUsage = 32;
    /** The total amount of GPU memory in bytes used by the tileset. */
    gpuMemoryUsageInBytes = 0;
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    memoryAdjustedScreenSpaceError = 0;
    _cacheBytes = 0;
    _cacheOverflowBytes = 0;
    /** Update tracker. increase in each update cycle. */
    _frameNumber = 0;
    _queryParams = {};
    _extensionsUsed = [];
    _tiles = {};
    /** counter for tracking tiles requests */
    _pendingCount = 0;
    /** Hold traversal results */
    selectedTiles = [];
    // TRAVERSAL
    traverseCounter = 0;
    geometricError = 0;
    lastUpdatedVieports = null;
    _requestedTiles = [];
    _emptyTiles = [];
    frameStateData = {};
    _traverser;
    _cache = new TilesetCache();
    _requestScheduler;
    // Promise tracking
    updatePromise = null;
    tilesetInitializationPromise;
    /**
     * Create a new Tileset3D
     * @param json
     * @param props
     */
    // eslint-disable-next-line max-statements
    constructor(tileset, options) {
      this.options = { ...DEFAULT_PROPS5, ...options };
      this.tileset = tileset;
      this.loader = tileset.loader;
      this.type = tileset.type;
      this.url = tileset.url;
      this.basePath = tileset.basePath || path_exports.dirname(this.url);
      this.modelMatrix = this.options.modelMatrix;
      this.ellipsoid = this.options.ellipsoid;
      this.lodMetricType = tileset.lodMetricType;
      this.lodMetricValue = tileset.lodMetricValue;
      this.refine = tileset.root.refine;
      this.loadOptions = this.options.loadOptions || {};
      this._traverser = this._initializeTraverser();
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.options.throttleRequests,
        maxRequests: this.options.maxRequests
      });
      this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;
      this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;
      this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;
      this.stats = new Stats({ id: this.url });
      this._initializeStats();
      this.tilesetInitializationPromise = this._initializeTileSet(tileset);
    }
    /** Release resources */
    destroy() {
      this._destroy();
    }
    /** Is the tileset loaded (update needs to have been called at least once) */
    isLoaded() {
      return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
    }
    get tiles() {
      return Object.values(this._tiles);
    }
    get frameNumber() {
      return this._frameNumber;
    }
    get queryParams() {
      return new URLSearchParams(this._queryParams).toString();
    }
    setProps(props) {
      this.options = { ...this.options, ...props };
    }
    /** @deprecated */
    // setOptions(options: Tileset3DProps): void {
    //   this.options = {...this.options, ...options};
    // }
    /**
     * Return a loadable tile url for a specific tile subpath
     * @param tilePath a tile subpath
     */
    getTileUrl(tilePath) {
      const isDataUrl = tilePath.startsWith("data:");
      if (isDataUrl) {
        return tilePath;
      }
      let tileUrl = tilePath;
      if (this.queryParams.length) {
        tileUrl = `${tilePath}${tilePath.includes("?") ? "&" : "?"}${this.queryParams}`;
      }
      return tileUrl;
    }
    // TODO CESIUM specific
    hasExtension(extensionName) {
      return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);
    }
    /**
     * Update visible tiles relying on a list of viewports
     * @param viewports - list of viewports
     * @deprecated
     */
    update(viewports = null) {
      this.tilesetInitializationPromise.then(() => {
        if (!viewports && this.lastUpdatedVieports) {
          viewports = this.lastUpdatedVieports;
        } else {
          this.lastUpdatedVieports = viewports;
        }
        if (viewports) {
          this.doUpdate(viewports);
        }
      });
    }
    /**
     * Update visible tiles relying on a list of viewports.
     * Do it with debounce delay to prevent update spam
     * @param viewports viewports
     * @returns Promise of new frameNumber
     */
    async selectTiles(viewports = null) {
      await this.tilesetInitializationPromise;
      if (viewports) {
        this.lastUpdatedVieports = viewports;
      }
      if (!this.updatePromise) {
        this.updatePromise = new Promise((resolve2) => {
          setTimeout(() => {
            if (this.lastUpdatedVieports) {
              this.doUpdate(this.lastUpdatedVieports);
            }
            resolve2(this._frameNumber);
            this.updatePromise = null;
          }, this.options.debounceTime);
        });
      }
      return this.updatePromise;
    }
    adjustScreenSpaceError() {
      if (this.gpuMemoryUsageInBytes < this._cacheBytes) {
        this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);
      } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {
        this.memoryAdjustedScreenSpaceError *= 1.02;
      }
    }
    /**
     * Update visible tiles relying on a list of viewports
     * @param viewports viewports
     */
    // eslint-disable-next-line max-statements, complexity
    doUpdate(viewports) {
      if ("loadTiles" in this.options && !this.options.loadTiles) {
        return;
      }
      if (this.traverseCounter > 0) {
        return;
      }
      const preparedViewports = viewports instanceof Array ? viewports : [viewports];
      this._cache.reset();
      this._frameNumber++;
      this.traverseCounter = preparedViewports.length;
      const viewportsToTraverse = [];
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (this._needTraverse(id)) {
          viewportsToTraverse.push(id);
        } else {
          this.traverseCounter--;
        }
      }
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (!this.roots[id]) {
          this.roots[id] = this._initializeTileHeaders(this.tileset, null);
        }
        if (!viewportsToTraverse.includes(id)) {
          continue;
        }
        const frameState = getFrameState(viewport, this._frameNumber);
        this._traverser.traverse(this.roots[id], frameState, this.options);
      }
    }
    /**
     * Check if traversal is needed for particular viewport
     * @param {string} viewportId - id of a viewport
     * @return {boolean}
     */
    _needTraverse(viewportId) {
      let traverserId = viewportId;
      if (this.options.viewportTraversersMap) {
        traverserId = this.options.viewportTraversersMap[viewportId];
      }
      if (traverserId !== viewportId) {
        return false;
      }
      return true;
    }
    /**
     * The callback to post-process tiles after traversal procedure
     * @param frameState - frame state for tile culling
     */
    _onTraversalEnd(frameState) {
      const id = frameState.viewport.id;
      if (!this.frameStateData[id]) {
        this.frameStateData[id] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] };
      }
      const currentFrameStateData = this.frameStateData[id];
      const selectedTiles = Object.values(this._traverser.selectedTiles);
      const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
      currentFrameStateData.selectedTiles = filteredSelectedTiles;
      for (const tile of unselectedTiles) {
        tile.unselect();
      }
      currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
      currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
      this.traverseCounter--;
      if (this.traverseCounter > 0) {
        return;
      }
      this._updateTiles();
    }
    /**
     * Update tiles relying on data from all traversers
     */
    _updateTiles() {
      this.selectedTiles = [];
      this._requestedTiles = [];
      this._emptyTiles = [];
      for (const frameStateKey in this.frameStateData) {
        const frameStateDataValue = this.frameStateData[frameStateKey];
        this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
        this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
        this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
      }
      this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
      for (const tile of this.selectedTiles) {
        this._tiles[tile.id] = tile;
      }
      this._loadTiles();
      this._unloadTiles();
      this._updateStats();
    }
    _tilesChanged(oldSelectedTiles, selectedTiles) {
      if (oldSelectedTiles.length !== selectedTiles.length) {
        return true;
      }
      const set1 = new Set(oldSelectedTiles.map((t3) => t3.id));
      const set22 = new Set(selectedTiles.map((t3) => t3.id));
      let changed = oldSelectedTiles.filter((x3) => !set22.has(x3.id)).length > 0;
      changed = changed || selectedTiles.filter((x3) => !set1.has(x3.id)).length > 0;
      return changed;
    }
    _loadTiles() {
      for (const tile of this._requestedTiles) {
        if (tile.contentUnloaded) {
          this._loadTile(tile);
        }
      }
    }
    _unloadTiles() {
      this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
    }
    _updateStats() {
      let tilesRenderable = 0;
      let pointsRenderable = 0;
      for (const tile of this.selectedTiles) {
        if (tile.contentAvailable && tile.content) {
          tilesRenderable++;
          if (tile.content.pointCount) {
            pointsRenderable += tile.content.pointCount;
          } else {
            pointsRenderable += tile.content.vertexCount;
          }
        }
      }
      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
      this.stats.get(POINTS_COUNT).count = pointsRenderable;
      this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;
    }
    async _initializeTileSet(tilesetJson) {
      if (this.type === TILESET_TYPE.I3S) {
        this.calculateViewPropsI3S();
        tilesetJson.root = await tilesetJson.root;
      }
      this.root = this._initializeTileHeaders(tilesetJson, null);
      if (this.type === TILESET_TYPE.TILES3D) {
        this._initializeTiles3DTileset(tilesetJson);
        this.calculateViewPropsTiles3D();
      }
      if (this.type === TILESET_TYPE.I3S) {
        this._initializeI3STileset();
      }
    }
    /**
     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
     * These metrics help apps center view on tileset
     * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
     * @returns
     */
    calculateViewPropsI3S() {
      const fullExtent = this.tileset.fullExtent;
      if (fullExtent) {
        const { xmin, xmax, ymin, ymax, zmin, zmax } = fullExtent;
        this.cartographicCenter = new Vector33(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
        this.cartesianCenter = new Vector33();
        Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
        this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      const extent = this.tileset.store?.extent;
      if (extent) {
        const [xmin, ymin, xmax, ymax] = extent;
        this.cartographicCenter = new Vector33(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
        this.cartesianCenter = new Vector33();
        Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
        this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      console.warn("Extent is not defined in the tileset header");
      this.cartographicCenter = new Vector33();
      this.zoom = 1;
      return;
    }
    /**
     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
     * These metrics help apps center view on tileset.
     * For 3DTiles the root tile data is used to calculate view props.
     * @returns
     */
    calculateViewPropsTiles3D() {
      const root = this.root;
      const { center } = root.boundingVolume;
      if (!center) {
        console.warn("center was not pre-calculated for the root tile");
        this.cartographicCenter = new Vector33();
        this.zoom = 1;
        return;
      }
      if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
        this.cartographicCenter = new Vector33();
        Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);
      } else {
        this.cartographicCenter = new Vector33(0, 0, -Ellipsoid.WGS84.radii[0]);
      }
      this.cartesianCenter = center;
      this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
    }
    _initializeStats() {
      this.stats.get(TILES_TOTAL);
      this.stats.get(TILES_LOADING);
      this.stats.get(TILES_IN_MEMORY);
      this.stats.get(TILES_IN_VIEW);
      this.stats.get(TILES_RENDERABLE);
      this.stats.get(TILES_LOADED);
      this.stats.get(TILES_UNLOADED);
      this.stats.get(TILES_LOAD_FAILED);
      this.stats.get(POINTS_COUNT);
      this.stats.get(TILES_GPU_MEMORY, "memory");
      this.stats.get(MAXIMUM_SSE);
    }
    // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
    // eslint-disable-next-line max-statements
    _initializeTileHeaders(tilesetJson, parentTileHeader) {
      const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
      if (parentTileHeader) {
        parentTileHeader.children.push(rootTile);
        rootTile.depth = parentTileHeader.depth + 1;
      }
      if (this.type === TILESET_TYPE.TILES3D) {
        const stack2 = [];
        stack2.push(rootTile);
        while (stack2.length > 0) {
          const tile = stack2.pop();
          this.stats.get(TILES_TOTAL).incrementCount();
          const children = tile.header.children || [];
          for (const childHeader of children) {
            const childTile = new Tile3D(this, childHeader, tile);
            if (childTile.contentUrl?.includes("?session=")) {
              const url = new URL(childTile.contentUrl);
              const session = url.searchParams.get("session");
              if (session) {
                this._queryParams.session = session;
              }
            }
            tile.children.push(childTile);
            childTile.depth = tile.depth + 1;
            stack2.push(childTile);
          }
        }
      }
      return rootTile;
    }
    _initializeTraverser() {
      let TraverserClass;
      const type = this.type;
      switch (type) {
        case TILESET_TYPE.TILES3D:
          TraverserClass = Tileset3DTraverser;
          break;
        case TILESET_TYPE.I3S:
          TraverserClass = I3STilesetTraverser;
          break;
        default:
          TraverserClass = TilesetTraverser;
      }
      return new TraverserClass({
        basePath: this.basePath,
        onTraversalEnd: this._onTraversalEnd.bind(this)
      });
    }
    _destroyTileHeaders(parentTile) {
      this._destroySubtree(parentTile);
    }
    async _loadTile(tile) {
      let loaded;
      try {
        this._onStartTileLoading();
        loaded = await tile.loadContent();
      } catch (error) {
        this._onTileLoadError(tile, error instanceof Error ? error : new Error("load failed"));
      } finally {
        this._onEndTileLoading();
        this._onTileLoad(tile, loaded);
      }
    }
    _onTileLoadError(tile, error) {
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      const message2 = error.message || error.toString();
      const url = tile.url;
      console.error(`A 3D tile failed to load: ${tile.url} ${message2}`);
      this.options.onTileError(tile, message2, url);
    }
    _onTileLoad(tile, loaded) {
      if (!loaded) {
        return;
      }
      if (this.type === TILESET_TYPE.I3S) {
        const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;
        this.stats.get(TILES_TOTAL).reset();
        this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
      }
      if (tile && tile.content) {
        calculateTransformProps(tile, tile.content);
      }
      this.updateContentTypes(tile);
      this._addTileToCache(tile);
      this.options.onTileLoad(tile);
    }
    /**
     * Update information about data types in nested tiles
     * @param tile instance of a nested Tile3D
     */
    updateContentTypes(tile) {
      if (this.type === TILESET_TYPE.I3S) {
        if (tile.header.isDracoGeometry) {
          this.contentFormats.draco = true;
        }
        switch (tile.header.textureFormat) {
          case "dds":
            this.contentFormats.dds = true;
            break;
          case "ktx2":
            this.contentFormats.ktx2 = true;
            break;
          default:
        }
      } else if (this.type === TILESET_TYPE.TILES3D) {
        const { extensionsRemoved = [] } = tile.content?.gltf || {};
        if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
          this.contentFormats.draco = true;
        }
        if (extensionsRemoved.includes("EXT_meshopt_compression")) {
          this.contentFormats.meshopt = true;
        }
        if (extensionsRemoved.includes("KHR_texture_basisu")) {
          this.contentFormats.ktx2 = true;
        }
      }
    }
    _onStartTileLoading() {
      this._pendingCount++;
      this.stats.get(TILES_LOADING).incrementCount();
    }
    _onEndTileLoading() {
      this._pendingCount--;
      this.stats.get(TILES_LOADING).decrementCount();
    }
    _addTileToCache(tile) {
      this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
    }
    _updateCacheStats(tile) {
      this.stats.get(TILES_LOADED).incrementCount();
      this.stats.get(TILES_IN_MEMORY).incrementCount();
      this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      if (this.options.memoryAdjustedScreenSpaceError) {
        this.adjustScreenSpaceError();
      }
    }
    _unloadTile(tile) {
      this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_IN_MEMORY).decrementCount();
      this.stats.get(TILES_UNLOADED).incrementCount();
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      this.options.onTileUnload(tile);
      tile.unloadContent();
    }
    // Traverse the tree and destroy all tiles
    _destroy() {
      const stack2 = [];
      if (this.root) {
        stack2.push(this.root);
      }
      while (stack2.length > 0) {
        const tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        this._destroyTile(tile);
      }
      this.root = null;
    }
    // Traverse the tree and destroy all sub tiles
    _destroySubtree(tile) {
      const root = tile;
      const stack2 = [];
      stack2.push(root);
      while (stack2.length > 0) {
        tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        if (tile !== root) {
          this._destroyTile(tile);
        }
      }
      root.children = [];
    }
    _destroyTile(tile) {
      this._cache.unloadTile(this, tile);
      this._unloadTile(tile);
      tile.destroy();
    }
    _initializeTiles3DTileset(tilesetJson) {
      if (tilesetJson.queryString) {
        const searchParams = new URLSearchParams(tilesetJson.queryString);
        const queryParams = Object.fromEntries(searchParams.entries());
        this._queryParams = { ...this._queryParams, ...queryParams };
      }
      this.asset = tilesetJson.asset;
      if (!this.asset) {
        throw new Error("Tileset must have an asset property.");
      }
      if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1") {
        throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
      }
      if ("tilesetVersion" in this.asset) {
        this._queryParams.v = this.asset.tilesetVersion;
      }
      this.credits = {
        attributions: this.options.attributions || []
      };
      this.description = this.options.description || "";
      this.properties = tilesetJson.properties;
      this.geometricError = tilesetJson.geometricError;
      this._extensionsUsed = tilesetJson.extensionsUsed || [];
      this.extras = tilesetJson.extras;
    }
    _initializeI3STileset() {
      if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
        this._queryParams.token = this.loadOptions.i3s.token;
      }
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/version.js
  var VERSION11 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/constants.js
  var TILE3D_TYPE = {
    COMPOSITE: "cmpt",
    POINT_CLOUD: "pnts",
    BATCHED_3D_MODEL: "b3dm",
    INSTANCED_3D_MODEL: "i3dm",
    GEOMETRY: "geom",
    VECTOR: "vect",
    GLTF: "glTF"
  };
  var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-utils.js
  function getStringFromArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    assert2(arrayBuffer2 instanceof ArrayBuffer);
    const textDecoder = new TextDecoder("utf8");
    const typedArray = new Uint8Array(arrayBuffer2, byteOffset, byteLength);
    const string = textDecoder.decode(typedArray);
    return string;
  }
  function getMagicString4(arrayBuffer2, byteOffset = 0) {
    const dataView = new DataView(arrayBuffer2);
    return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/constants.js
  var GL_PRIMITIVE_MODE = {
    POINTS: 0,
    // Points. single points.
    LINES: 1,
    // Lines. Each vertex connects to the one after it.
    LINE_LOOP: 2,
    // Lines. Each set of two vertices is treated as a separate line segment.
    LINE_STRIP: 3,
    // Lines/ a connected group of line segments from the first vertex to the last
    TRIANGLES: 4,
    // Triangles. Each set of three vertices creates a separate triangle.
    TRIANGLE_STRIP: 5,
    // Triangles. A connected group of triangles.
    TRIANGLE_FAN: 6
    // Triangles. A connected group of triangles.
    // Each vertex connects to the previous and the first vertex in the fan.
  };
  var GL_TYPE = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130
  };
  var GL2 = {
    ...GL_PRIMITIVE_MODE,
    ...GL_TYPE
  };

  // ../../node_modules/@loaders.gl/math/dist/geometry/gl/gl-type.js
  var GL_TYPE_TO_ARRAY_TYPE = {
    [GL_TYPE.DOUBLE]: Float64Array,
    [GL_TYPE.FLOAT]: Float32Array,
    [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
    [GL_TYPE.UNSIGNED_INT]: Uint32Array,
    [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
    [GL_TYPE.BYTE]: Int8Array,
    [GL_TYPE.SHORT]: Int16Array,
    [GL_TYPE.INT]: Int32Array
  };
  var NAME_TO_GL_TYPE = {
    DOUBLE: GL_TYPE.DOUBLE,
    FLOAT: GL_TYPE.FLOAT,
    UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
    UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
    UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
    BYTE: GL_TYPE.BYTE,
    SHORT: GL_TYPE.SHORT,
    INT: GL_TYPE.INT
  };
  var ERR_TYPE_CONVERSION = "Failed to convert GL type";
  var GLType = class {
    // Signature: fromTypedArray(new Uint8Array())
    // Signature: fromTypedArray(Uint8Array)
    /**
     * Returns the size, in bytes, of the corresponding datatype
     * @param arrayOrType
     * @returns glType a a string
     */
    static fromTypedArray(arrayOrType) {
      arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
      for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
        const ArrayType2 = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (ArrayType2 === arrayOrType) {
          return glType;
        }
      }
      throw new Error(ERR_TYPE_CONVERSION);
    }
    /**
     * Extracts name for glType from array NAME_TO_GL_TYPE
     * @param name
     * @returns glType as a number
     */
    static fromName(name13) {
      const glType = NAME_TO_GL_TYPE[name13];
      if (!glType) {
        throw new Error(ERR_TYPE_CONVERSION);
      }
      return glType;
    }
    // Converts GL constant to corresponding typed array type
    // eslint-disable-next-line complexity
    static getArrayType(glType) {
      switch (glType) {
        case GL_TYPE.UNSIGNED_SHORT_5_6_5:
        case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
        case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
          return Uint16Array;
        default:
          const ArrayType2 = GL_TYPE_TO_ARRAY_TYPE[glType];
          if (!ArrayType2) {
            throw new Error(ERR_TYPE_CONVERSION);
          }
          return ArrayType2;
      }
    }
    /**
     * Returns the size in bytes of one element of the provided WebGL type
     * @param glType
     * @returns size of glType
     */
    static getByteSize(glType) {
      const ArrayType2 = GLType.getArrayType(glType);
      return ArrayType2.BYTES_PER_ELEMENT;
    }
    /**
     * Returns `true` if `glType` is a valid WebGL data type.
     * @param glType
     * @returns boolean
     */
    static validate(glType) {
      return Boolean(GLType.getArrayType(glType));
    }
    /**
     * Creates a typed view of an array of bytes
     * @param glType The type of typed array (ArrayBuffer view) to create
     * @param buffer The buffer storage to use for the view.
     * @param byteOffset The offset, in bytes, to the first element in the view
     * @param length The number of elements in the view. Defaults to buffer length
     * @returns A typed array view of the buffer
     */
    static createTypedArray(glType, buffer, byteOffset = 0, length16) {
      if (length16 === void 0) {
        length16 = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
      }
      const ArrayType2 = GLType.getArrayType(glType);
      return new ArrayType2(buffer, byteOffset, length16);
    }
  };

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES8 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS12 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG6 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG6 } };
  var config6 = globalThis.mathgl.config;
  function formatValue6(value, { precision = config6.precision } = {}) {
    value = round15(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray8(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function clamp6(value, min6, max6) {
    return map5(value, (value2) => Math.max(min6, Math.min(max6, value2)));
  }
  function equals12(a3, b2, epsilon) {
    const oldEpsilon = config6.EPSILON;
    if (epsilon) {
      config6.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray8(a3) && isArray8(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals12(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config6.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config6.EPSILON = oldEpsilon;
    }
  }
  function round15(value) {
    return Math.round(value / config6.EPSILON) * config6.EPSILON;
  }
  function duplicateArray4(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map5(value, func, result) {
    if (isArray8(value)) {
      const array = value;
      result = result || duplicateArray4(array);
      for (let i5 = 0; i5 < result.length && i5 < array.length; ++i5) {
        const val2 = typeof value === "number" ? value : value[i5];
        result[i5] = func(val2, i5, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray6 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray8(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config6);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue6(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals12(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config6.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/lib/validators.js
  function checkNumber6(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/lib/assert.js
  function assert14(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector9 = class extends MathArray6 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber6(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber6(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber6(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber6(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert14(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber6(this[i5]);
    }
    setComponent(i5, value) {
      assert14(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var ARRAY_TYPE6 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree6 = Math.PI / 180;

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create23() {
    const out = new ARRAY_TYPE6(2);
    if (ARRAY_TYPE6 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat22(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    return out;
  }
  function transformMat2d2(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3 + m[4];
    out[1] = m[1] * x3 + m[3] * y3 + m[5];
    return out;
  }
  function transformMat310(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  function transformMat412(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[4] * y3 + m[12];
    out[1] = m[1] * x3 + m[5] * y3 + m[13];
    return out;
  }
  var forEach16 = function() {
    const vec = create23();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector4(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m[3] * x3 + m[7] * y3 || 1;
    out[0] = (m[0] * x3 + m[4] * y3) / w2;
    out[1] = (m[1] * x3 + m[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector6(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat26(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/classes/vector2.js
  var Vector22 = class extends Vector9 {
    // Creates a new, empty vec2
    constructor(x3 = 0, y3 = 0) {
      super(2);
      if (isArray8(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config6.debug) {
          checkNumber6(x3);
          checkNumber6(y3);
        }
        this[0] = x3;
        this[1] = y3;
      }
    }
    set(x3, y3) {
      this[0] = x3;
      this[1] = y3;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config6.debug) {
        checkNumber6(object.x);
        checkNumber6(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 2;
    }
    /**
     * Returns angle from x axis
     * @returns
     */
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    /**
     * Returns angle from y axis
     * @returns
     */
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    // Transforms
    /**
     * Transforms as point
     * @param matrix4
     * @returns
     */
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    /**
     * transforms as point (4th component is implicitly 1)
     * @param matrix4
     * @returns
     */
    transformAsPoint(matrix4) {
      transformMat412(this, this, matrix4);
      return this.check();
    }
    /**
     * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
     * @param matrix4
     * @returns
     */
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector4(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat310(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d2(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat22(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create24() {
    const out = new ARRAY_TYPE6(3);
    if (ARRAY_TYPE6 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function dot13(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross8(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat413(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat311(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat9(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX13(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY13(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ13(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle7(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot13(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var forEach17 = function() {
    const vec = create24();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/math/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN6 = [0, 0, 0];
  var ZERO12;
  var Vector36 = class extends Vector9 {
    static get ZERO() {
      if (!ZERO12) {
        ZERO12 = new Vector36(0, 0, 0);
        Object.freeze(ZERO12);
      }
      return ZERO12;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray8(x3)) {
        this.copy(x3);
      } else {
        if (config6.debug) {
          checkNumber6(x3);
          checkNumber6(y3);
          checkNumber6(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config6.debug) {
        checkNumber6(object.x);
        checkNumber6(object.y);
        checkNumber6(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber6(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle7(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross8(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN6 }) {
      rotateX13(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN6 }) {
      rotateY13(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN6 }) {
      rotateZ13(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat413(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector6(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat311(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat26(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat9(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@loaders.gl/math/dist/geometry/utils/assert.js
  function assert15(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion failed. ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/colors/rgb565.js
  function decodeRGB565(rgb565, target2 = [0, 0, 0]) {
    const r5 = rgb565 >> 11 & 31;
    const g6 = rgb565 >> 5 & 63;
    const b5 = rgb565 & 31;
    target2[0] = r5 << 3;
    target2[1] = g6 << 2;
    target2[2] = b5 << 3;
    return target2;
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/compression/attribute-compression.js
  var RIGHT_SHIFT = 1 / 256;
  var scratchVector27 = new Vector22();
  var scratchVector37 = new Vector36();
  var scratchEncodeVector2 = new Vector22();
  var octEncodeScratch = new Vector22();
  var uint8ForceArray = new Uint8Array(1);
  function fromSNorm(value, rangeMaximum = 255) {
    return clamp6(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
  }
  function signNotZero(value) {
    return value < 0 ? -1 : 1;
  }
  function octDecodeInRange(x3, y3, rangeMax, result) {
    assert15(result);
    if (x3 < 0 || x3 > rangeMax || y3 < 0 || y3 > rangeMax) {
      throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);
    }
    result.x = fromSNorm(x3, rangeMax);
    result.y = fromSNorm(y3, rangeMax);
    result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0) {
      const oldVX = result.x;
      result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
      result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
    }
    return result.normalize();
  }
  function octDecode(x3, y3, result) {
    return octDecodeInRange(x3, y3, 255, result);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES9 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS13 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG7 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG7 } };
  var config7 = globalThis.mathgl.config;
  function formatValue7(value, { precision = config7.precision } = {}) {
    value = round17(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray9(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals13(a3, b2, epsilon) {
    const oldEpsilon = config7.EPSILON;
    if (epsilon) {
      config7.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray9(a3) && isArray9(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals13(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config7.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config7.EPSILON = oldEpsilon;
    }
  }
  function round17(value) {
    return Math.round(value / config7.EPSILON) * config7.EPSILON;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray7 = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray9(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config7);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue7(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals13(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale22) {
      if (typeof scale22 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale22;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale22.length; ++i5) {
          this[i5] *= scale22[i5];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config7.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a3) {
      return this.subtract(a3);
    }
    /** @deprecated */
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    /** @deprecated */
    clampScalar(min6, max6) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min6), max6);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector6(v2, length16) {
    if (v2.length !== length16) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber7(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector6(v2, length16, callerName = "") {
    if (config7.debug && !validateVector6(v2, length16)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/lib/assert.js
  function assert16(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector10 = class extends MathArray7 {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber7(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber7(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length16 += this[i5] * this[i5];
      }
      return length16;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length16 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist5 = this[i5] - mathArray[i5];
        length16 += dist5 * dist5;
      }
      return checkNumber7(length16);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber7(product);
    }
    // MODIFIERS
    normalize() {
      const length16 = this.magnitude();
      if (length16 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length16;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert16(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber7(this[i5]);
    }
    setComponent(i5, value) {
      assert16(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON31 = 1e-6;
  var ARRAY_TYPE7 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree7 = Math.PI / 180;

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create25() {
    const out = new ARRAY_TYPE7(2);
    if (ARRAY_TYPE7 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat312(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[3] * y3 + m[6];
    out[1] = m[1] * x3 + m[4] * y3 + m[7];
    return out;
  }
  function transformMat414(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[4] * y3 + m[12];
    out[1] = m[1] * x3 + m[5] * y3 + m[13];
    return out;
  }
  var forEach18 = function() {
    const vec = create25();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector5(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m[3] * x3 + m[7] * y3 || 1;
    out[0] = (m[0] * x3 + m[4] * y3) / w2;
    out[1] = (m[1] * x3 + m[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector7(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat27(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat24(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m[0] * x3 + m[2] * y3;
    out[1] = m[1] * x3 + m[3] * y3;
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function vec4_transformMat35(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m[0] * x3 + m[3] * y3 + m[6] * z2;
    out[1] = m[1] * x3 + m[4] * y3 + m[7] * z2;
    out[2] = m[2] * x3 + m[5] * y3 + m[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create26() {
    const out = new ARRAY_TYPE7(3);
    if (ARRAY_TYPE7 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length12(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues11(x3, y3, z2) {
    const out = new ARRAY_TYPE7(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function normalize13(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = a3[0] * len8;
    out[1] = a3[1] * len8;
    out[2] = a3[2] * len8;
    return out;
  }
  function dot14(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross9(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat415(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12]) / w2;
    out[1] = (m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13]) / w2;
    out[2] = (m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14]) / w2;
    return out;
  }
  function transformMat313(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  function transformQuat10(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX14(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY14(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ14(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle8(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot14(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var len7 = length12;
  var forEach19 = function() {
    const vec = create26();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN7 = [0, 0, 0];
  var ZERO13;
  var Vector37 = class extends Vector10 {
    static get ZERO() {
      if (!ZERO13) {
        ZERO13 = new Vector37(0, 0, 0);
        Object.freeze(ZERO13);
      }
      return ZERO13;
    }
    /**
     * @class
     * @param x
     * @param y
     * @param z
     */
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray9(x3)) {
        this.copy(x3);
      } else {
        if (config7.debug) {
          checkNumber7(x3);
          checkNumber7(y3);
          checkNumber7(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config7.debug) {
        checkNumber7(object.x);
        checkNumber7(object.y);
        checkNumber7(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber7(value);
    }
    // ACCESSORS
    angle(vector) {
      return angle8(this, vector);
    }
    // MODIFIERS
    cross(vector) {
      cross9(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians6, origin = ORIGIN7 }) {
      rotateX14(this, this, origin, radians6);
      return this.check();
    }
    rotateY({ radians: radians6, origin = ORIGIN7 }) {
      rotateY14(this, this, origin, radians6);
      return this.check();
    }
    rotateZ({ radians: radians6, origin = ORIGIN7 }) {
      rotateZ14(this, this, origin, radians6);
      return this.check();
    }
    // Transforms
    // transforms as point (4th component is implicitly 1)
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    // transforms as point (4th component is implicitly 1)
    transformAsPoint(matrix4) {
      transformMat415(this, this, matrix4);
      return this.check();
    }
    // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector7(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat313(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat27(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat10(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/vector4.js
  var ZERO14;
  var Vector44 = class extends Vector10 {
    static get ZERO() {
      if (!ZERO14) {
        ZERO14 = new Vector44(0, 0, 0, 0);
        Object.freeze(ZERO14);
      }
      return ZERO14;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 0) {
      super(-0, -0, -0, -0);
      if (isArray9(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config7.debug) {
          checkNumber7(x3);
          checkNumber7(y3);
          checkNumber7(z2);
          checkNumber7(w2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
        this[3] = w2;
      }
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config7.debug) {
        checkNumber7(object.x);
        checkNumber7(object.y);
        checkNumber7(object.z);
        checkNumber7(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    // Getters/setters
    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber7(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber7(value);
    }
    transform(matrix4) {
      transformMat415(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat35(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat24(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat10(this, this, quaternion2);
      return this.check();
    }
    // three.js compatibility
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix8 = class extends MathArray7 {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config7.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber7(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function create27() {
    const out = new ARRAY_TYPE7(9);
    if (ARRAY_TYPE7 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose9(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert12(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant9(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply16(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate9(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate10(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale18(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat10(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES8;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES10[INDICES10["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES8 || (INDICES8 = {}));
  var IDENTITY_MATRIX10 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix35 = class extends Matrix8 {
    static get IDENTITY() {
      return getIdentityMatrix8();
    }
    static get ZERO() {
      return getZeroMatrix8();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES8;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    // Constructors
    identity() {
      return this.copy(IDENTITY_MATRIX10);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /** Calculates a 3x3 matrix from the given quaternion
     * q quat  Quaternion to create matrix from
     */
    fromQuaternion(q2) {
      fromQuat10(this, q2);
      return this.check();
    }
    /**
     * accepts column major order, stores in column major order
     */
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    /**
     * accepts row major order, stores as column major
     */
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant9(this);
    }
    // Modifiers
    transpose() {
      transpose9(this, this);
      return this.check();
    }
    /** Invert a matrix. Note that this can fail if the matrix is not invertible */
    invert() {
      invert12(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply16(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply16(this, this, a3);
      return this.check();
    }
    rotate(radians6) {
      rotate10(this, this, radians6);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale18(this, this, factor);
      } else {
        scale18(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate9(this, this, vec);
      return this.check();
    }
    // Transforms
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat312(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat313(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat35(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector6(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    /** @deprecated */
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX35;
  var IDENTITY_MATRIX35 = null;
  function getZeroMatrix8() {
    if (!ZERO_MATRIX35) {
      ZERO_MATRIX35 = new Matrix35([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX35);
    }
    return ZERO_MATRIX35;
  }
  function getIdentityMatrix8() {
    if (!IDENTITY_MATRIX35) {
      IDENTITY_MATRIX35 = new Matrix35();
      Object.freeze(IDENTITY_MATRIX35);
    }
    return IDENTITY_MATRIX35;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity9(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose10(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert13(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant10(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply17(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate10(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale19(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate11(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len8 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len8 < EPSILON31) {
      return null;
    }
    len8 = 1 / len8;
    x3 *= len8;
    y3 *= len8;
    z2 *= len8;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX15(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY15(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ15(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromQuat11(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum5(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO5(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective5 = perspectiveNO5;
  function orthoNO5(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho5 = orthoNO5;
  function lookAt5(out, eye, center, up) {
    let len8;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON31 && Math.abs(eyey - centery) < EPSILON31 && Math.abs(eyez - centerz) < EPSILON31) {
      return identity9(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len8 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len8;
    z1 *= len8;
    z2 *= len8;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len8 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len8) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len8 = 1 / len8;
      x0 *= len8;
      x1 *= len8;
      x22 *= len8;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len8 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len8) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len8 = 1 / len8;
      y0 *= len8;
      y1 *= len8;
      y22 *= len8;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create28() {
    const out = new ARRAY_TYPE7(4);
    if (ARRAY_TYPE7 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add13(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    return out;
  }
  function scale20(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    return out;
  }
  function length13(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredLength10(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function normalize14(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    let len8 = x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
    if (len8 > 0) {
      len8 = 1 / Math.sqrt(len8);
    }
    out[0] = x3 * len8;
    out[1] = y3 * len8;
    out[2] = z2 * len8;
    out[3] = w2 * len8;
    return out;
  }
  function dot15(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
  }
  function lerp16(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    out[3] = aw + t3 * (b2[3] - aw);
    return out;
  }
  function transformMat416(out, a3, m) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    out[0] = m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12] * w2;
    out[1] = m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13] * w2;
    out[2] = m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14] * w2;
    out[3] = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15] * w2;
    return out;
  }
  function transformQuat11(out, a3, q2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  var forEach20 = function() {
    const vec = create28();
    return function(a3, stride, offset, count3, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count3) {
        l3 = Math.min(count3 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES9;
  (function(INDICES10) {
    INDICES10[INDICES10["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES10[INDICES10["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES10[INDICES10["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES10[INDICES10["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES10[INDICES10["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES10[INDICES10["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES10[INDICES10["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES10[INDICES10["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES10[INDICES10["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES10[INDICES10["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES10[INDICES10["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES10[INDICES10["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES10[INDICES10["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES10[INDICES10["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES10[INDICES10["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES10[INDICES10["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES9 || (INDICES9 = {}));
  var DEFAULT_FOVY4 = 45 * Math.PI / 180;
  var DEFAULT_ASPECT4 = 1;
  var DEFAULT_NEAR4 = 0.1;
  var DEFAULT_FAR4 = 500;
  var IDENTITY_MATRIX11 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix45 = class extends Matrix8 {
    static get IDENTITY() {
      return getIdentityMatrix9();
    }
    static get ZERO() {
      return getZeroMatrix9();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES9;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX11);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion2) {
      fromQuat11(this, quaternion2);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR4, far = DEFAULT_FAR4 } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter4(this, left, right, bottom, top, near);
      } else {
        frustum5(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt5(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR4, far = DEFAULT_FAR4 } = view;
      ortho5(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY4, aspect = DEFAULT_ASPECT4, focalDistance = 1, near = DEFAULT_NEAR4, far = DEFAULT_FAR4 } = view;
      checkRadians4(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians4(fovy);
      perspective5(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant10(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale22 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale22[0];
      const inverseScale1 = 1 / scale22[1];
      const inverseScale2 = 1 / scale22[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose10(this, this);
      return this.check();
    }
    invert() {
      invert13(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a3) {
      multiply17(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply17(this, this, a3);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians6) {
      rotateX15(this, this, radians6);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians6) {
      rotateY15(this, this, radians6);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians6) {
      rotateZ15(this, this, radians6);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians6, axis) {
      rotate11(this, this, radians6, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale19(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate10(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat416(result || [-0, -0, -0, -0], vector, this);
        checkVector6(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length: length16 } = vector;
      let out;
      switch (length16) {
        case 2:
          out = transformMat414(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat415(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector6(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector5(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector7(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector6(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians6) {
      return this.identity().rotateX(radians6);
    }
    makeTranslation(x3, y3, z2) {
      return this.identity().translate([x3, y3, z2]);
    }
  };
  var ZERO15;
  var IDENTITY5;
  function getZeroMatrix9() {
    if (!ZERO15) {
      ZERO15 = new Matrix45([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO15);
    }
    return ZERO15;
  }
  function getIdentityMatrix9() {
    if (!IDENTITY5) {
      IDENTITY5 = new Matrix45();
      Object.freeze(IDENTITY5);
    }
    return IDENTITY5;
  }
  function checkRadians4(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter4(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/gl-matrix/quat.js
  function create29() {
    const out = new ARRAY_TYPE7(4);
    if (ARRAY_TYPE7 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity10(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle4(out, axis, rad) {
    rad = rad * 0.5;
    const s3 = Math.sin(rad);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply18(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const bw = b2[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX16(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY16(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ16(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW4(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z2 * z2));
    return out;
  }
  function slerp6(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    let bx = b2[0];
    let by = b2[1];
    let bz = b2[2];
    let bw = b2[3];
    let cosom;
    let omega;
    let scale0;
    let scale1;
    let sinom;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON31) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t3) * omega) / sinom;
      scale1 = Math.sin(t3 * omega) / sinom;
    } else {
      scale0 = 1 - t3;
      scale1 = t3;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert14(out, a3) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const dot17 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    const invDot = dot17 ? 1 / dot17 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate4(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat34(out, m) {
    const fTrace = m[0] + m[4] + m[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m[4] > m[0])
        i5 = 1;
      if (m[8] > m[i5 * 3 + i5])
        i5 = 2;
      const j2 = (i5 + 1) % 3;
      const k2 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m[i5 * 3 + i5] - m[j2 * 3 + j2] - m[k2 * 3 + k2] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j2 * 3 + k2] - m[k2 * 3 + j2]) * fRoot;
      out[j2] = (m[j2 * 3 + i5] + m[i5 * 3 + j2]) * fRoot;
      out[k2] = (m[k2 * 3 + i5] + m[i5 * 3 + k2]) * fRoot;
    }
    return out;
  }
  var add14 = add13;
  var scale21 = scale20;
  var dot16 = dot15;
  var lerp17 = lerp16;
  var length14 = length13;
  var squaredLength11 = squaredLength10;
  var normalize15 = normalize14;
  var rotationTo4 = function() {
    const tmpvec3 = create26();
    const xUnitVec3 = fromValues11(1, 0, 0);
    const yUnitVec3 = fromValues11(0, 1, 0);
    return function(out, a3, b2) {
      const dot17 = dot14(a3, b2);
      if (dot17 < -0.999999) {
        cross9(tmpvec3, xUnitVec3, a3);
        if (len7(tmpvec3) < 1e-6)
          cross9(tmpvec3, yUnitVec3, a3);
        normalize13(tmpvec3, tmpvec3);
        setAxisAngle4(out, tmpvec3, Math.PI);
        return out;
      } else if (dot17 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      cross9(tmpvec3, a3, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot17;
      return normalize15(out, out);
    };
  }();
  var sqlerp4 = function() {
    const temp1 = create29();
    const temp2 = create29();
    return function(out, a3, b2, c2, d2, t3) {
      slerp6(temp1, a3, d2, t3);
      slerp6(temp2, b2, c2, t3);
      slerp6(out, temp1, temp2, 2 * t3 * (1 - t3));
      return out;
    };
  }();
  var setAxes4 = function() {
    const matr = create27();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize15(out, fromMat34(out, matr));
    };
  }();

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/@math.gl/core/dist/classes/quaternion.js
  var IDENTITY_QUATERNION4 = [0, 0, 0, 1];
  var Quaternion4 = class extends MathArray7 {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        this.set(x3, y3, z2, w2);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * NOTE: The resultant quaternion is not normalized, so you should
     * be sure to renormalize the quaternion yourself where necessary.
     * @param m
     * @returns
     */
    fromMatrix3(m) {
      fromMat34(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle4(this, axis, rad);
      return this.check();
    }
    /** Set a quat to the identity quaternion */
    identity() {
      identity10(this);
      return this.check();
    }
    // Set the components of a quat to the given values
    // set(i, j, k, l) {
    //   quat_set(this, i, j, k, l);
    //   return this.check();
    // }
    // Sets a quat from the given angle and rotation axis, then returns it.
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    // Getters/setters
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber7(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber7(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber7(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber7(value);
    }
    // Calculates the length of a quat
    len() {
      return length14(this);
    }
    // Calculates the squared length of a quat
    lengthSquared() {
      return squaredLength11(this);
    }
    // Calculates the dot product of two quat's
    // @return {Number}
    dot(a3) {
      return dot16(this, a3);
    }
    // Gets the rotation axis and angle for a given quaternion.
    // If a quaternion is created with setAxisAngle, this method will
    // return the same values as providied in the original parameter
    // list OR functionally equivalent values.
    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
    // is the same as the quaternion formed by [0, 0, 1] and 270.
    // This method favors the latter.
    // @return {{[x,y,z], Number}}
    // getAxisAngle() {
    //   const axis = [];
    // //   const angle = quat_getAxisAngle(axis, this);
    //   return {axis, angle};
    // }
    // MODIFIERS
    // Sets a quaternion to represent the shortest rotation from one vector
    // to another. Both vectors are assumed to be unit length.
    rotationTo(vectorA, vectorB) {
      rotationTo4(this, vectorA, vectorB);
      return this.check();
    }
    // Sets the specified quaternion with values corresponding to the given axes.
    // Each axis is a vec3 and is expected to be unit length and perpendicular
    // to all other specified axes.
    // setAxes() {
    //   Number
    // }
    // Performs a spherical linear interpolation with two control points
    // sqlerp() {
    //   Number;
    // }
    // Adds two quat's
    add(a3) {
      add14(this, this, a3);
      return this.check();
    }
    // Calculates the W component of a quat from the X, Y, and Z components.
    // Any existing W component will be ignored.
    calculateW() {
      calculateW4(this, this);
      return this.check();
    }
    // Calculates the conjugate of a quat If the quaternion is normalized,
    // this function is faster than quat_invert and produces the same result.
    conjugate() {
      conjugate4(this, this);
      return this.check();
    }
    // Calculates the inverse of a quat
    invert() {
      invert14(this, this);
      return this.check();
    }
    // Performs a linear interpolation between two quat's
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      lerp17(this, a3, b2, t3);
      return this.check();
    }
    // Multiplies two quat's
    multiplyRight(a3) {
      multiply18(this, this, a3);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply18(this, a3, this);
      return this.check();
    }
    // Normalize a quat
    normalize() {
      const length16 = this.len();
      const l3 = length16 > 0 ? 1 / length16 : 0;
      this[0] = this[0] * l3;
      this[1] = this[1] * l3;
      this[2] = this[2] * l3;
      this[3] = this[3] * l3;
      if (length16 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    // Rotates a quaternion by the given angle about the X axis
    rotateX(rad) {
      rotateX16(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Y axis
    rotateY(rad) {
      rotateY16(this, this, rad);
      return this.check();
    }
    // Rotates a quaternion by the given angle about the Z axis
    rotateZ(rad) {
      rotateZ16(this, this, rad);
      return this.check();
    }
    // Scales a quat by a scalar number
    scale(b2) {
      scale21(this, this, b2);
      return this.check();
    }
    // Performs a spherical linear interpolation between two quat
    slerp(arg0, arg1, arg2) {
      let start;
      let target2;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION4,
            target: target2,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target2 = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target2 = arg1;
          ratio = arg2;
      }
      slerp6(this, start, target2, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector44()) {
      transformQuat11(result, vector, this);
      return checkVector6(result, 4);
    }
    // THREE.js Math API compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a3) {
      return this.multiplyLeft(a3);
    }
    multiply(a3) {
      return this.multiplyRight(a3);
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-feature-table.js
  var Tile3DFeatureTable = class {
    json;
    buffer;
    featuresLength = 0;
    _cachedTypedArrays = {};
    constructor(featureTableJson, featureTableBinary) {
      this.json = featureTableJson;
      this.buffer = featureTableBinary;
    }
    getExtension(extensionName) {
      return this.json.extensions && this.json.extensions[extensionName];
    }
    hasProperty(propertyName) {
      return Boolean(this.json[propertyName]);
    }
    getGlobalProperty(propertyName, componentType = GL2.UNSIGNED_INT, componentLength = 1) {
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
      }
      return jsonValue;
    }
    getPropertyArray(propertyName, componentType, componentLength) {
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        if ("componentType" in jsonValue) {
          componentType = GLType.fromName(jsonValue.componentType);
        }
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
      }
      return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
    }
    getProperty(propertyName, componentType, componentLength, featureId, result) {
      const jsonValue = this.json[propertyName];
      if (!jsonValue) {
        return jsonValue;
      }
      const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
      if (componentLength === 1) {
        return typedArray[featureId];
      }
      for (let i5 = 0; i5 < componentLength; ++i5) {
        result[i5] = typedArray[componentLength * featureId + i5];
      }
      return result;
    }
    // HELPERS
    _getTypedArrayFromBinary(propertyName, componentType, componentLength, count3, byteOffset) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count3 * componentLength);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
    _getTypedArrayFromArray(propertyName, componentType, array) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, array);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/helpers/tile-3d-accessor-utils.js
  var COMPONENTS_PER_ATTRIBUTE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var UNPACKER = {
    SCALAR: (values, i5) => values[i5],
    VEC2: (values, i5) => [values[2 * i5 + 0], values[2 * i5 + 1]],
    VEC3: (values, i5) => [values[3 * i5 + 0], values[3 * i5 + 1], values[3 * i5 + 2]],
    VEC4: (values, i5) => [values[4 * i5 + 0], values[4 * i5 + 1], values[4 * i5 + 2], values[4 * i5 + 3]],
    // TODO: check column major
    MAT2: (values, i5) => [
      values[4 * i5 + 0],
      values[4 * i5 + 1],
      values[4 * i5 + 2],
      values[4 * i5 + 3]
    ],
    MAT3: (values, i5) => [
      values[9 * i5 + 0],
      values[9 * i5 + 1],
      values[9 * i5 + 2],
      values[9 * i5 + 3],
      values[9 * i5 + 4],
      values[9 * i5 + 5],
      values[9 * i5 + 6],
      values[9 * i5 + 7],
      values[9 * i5 + 8]
    ],
    MAT4: (values, i5) => [
      values[16 * i5 + 0],
      values[16 * i5 + 1],
      values[16 * i5 + 2],
      values[16 * i5 + 3],
      values[16 * i5 + 4],
      values[16 * i5 + 5],
      values[16 * i5 + 6],
      values[16 * i5 + 7],
      values[16 * i5 + 8],
      values[16 * i5 + 9],
      values[16 * i5 + 10],
      values[16 * i5 + 11],
      values[16 * i5 + 12],
      values[16 * i5 + 13],
      values[16 * i5 + 14],
      values[16 * i5 + 15]
    ]
  };
  var PACKER = {
    SCALAR: (x3, values, i5) => {
      values[i5] = x3;
    },
    VEC2: (x3, values, i5) => {
      values[2 * i5 + 0] = x3[0];
      values[2 * i5 + 1] = x3[1];
    },
    VEC3: (x3, values, i5) => {
      values[3 * i5 + 0] = x3[0];
      values[3 * i5 + 1] = x3[1];
      values[3 * i5 + 2] = x3[2];
    },
    VEC4: (x3, values, i5) => {
      values[4 * i5 + 0] = x3[0];
      values[4 * i5 + 1] = x3[1];
      values[4 * i5 + 2] = x3[2];
      values[4 * i5 + 3] = x3[3];
    },
    // TODO: check column major correctness
    MAT2: (x3, values, i5) => {
      values[4 * i5 + 0] = x3[0];
      values[4 * i5 + 1] = x3[1];
      values[4 * i5 + 2] = x3[2];
      values[4 * i5 + 3] = x3[3];
    },
    MAT3: (x3, values, i5) => {
      values[9 * i5 + 0] = x3[0];
      values[9 * i5 + 1] = x3[1];
      values[9 * i5 + 2] = x3[2];
      values[9 * i5 + 3] = x3[3];
      values[9 * i5 + 4] = x3[4];
      values[9 * i5 + 5] = x3[5];
      values[9 * i5 + 6] = x3[6];
      values[9 * i5 + 7] = x3[7];
      values[9 * i5 + 8] = x3[8];
      values[9 * i5 + 9] = x3[9];
    },
    MAT4: (x3, values, i5) => {
      values[16 * i5 + 0] = x3[0];
      values[16 * i5 + 1] = x3[1];
      values[16 * i5 + 2] = x3[2];
      values[16 * i5 + 3] = x3[3];
      values[16 * i5 + 4] = x3[4];
      values[16 * i5 + 5] = x3[5];
      values[16 * i5 + 6] = x3[6];
      values[16 * i5 + 7] = x3[7];
      values[16 * i5 + 8] = x3[8];
      values[16 * i5 + 9] = x3[9];
      values[16 * i5 + 10] = x3[10];
      values[16 * i5 + 11] = x3[11];
      values[16 * i5 + 12] = x3[12];
      values[16 * i5 + 13] = x3[13];
      values[16 * i5 + 14] = x3[14];
      values[16 * i5 + 15] = x3[15];
    }
  };
  function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length16) {
    const { componentType } = tile3DAccessor;
    assert2(tile3DAccessor.componentType);
    const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
    const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
    const unpacker = UNPACKER[tile3DAccessor.type];
    const packer = PACKER[tile3DAccessor.type];
    byteOffset += tile3DAccessor.byteOffset;
    const values = GLType.createTypedArray(type, buffer, byteOffset, size * length16);
    return {
      values,
      type,
      size,
      unpacker,
      packer
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table-hierarchy.js
  var defined3 = (x3) => x3 !== void 0;
  function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
    if (!jsonHeader) {
      return null;
    }
    let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
    const legacyHierarchy = jsonHeader.HIERARCHY;
    if (legacyHierarchy) {
      console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
      jsonHeader.extensions = jsonHeader.extensions || {};
      jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
      hierarchy = legacyHierarchy;
    }
    if (!hierarchy) {
      return null;
    }
    return initializeHierarchyValues(hierarchy, binaryBody);
  }
  function initializeHierarchyValues(hierarchyJson, binaryBody) {
    let i5;
    let classId;
    let binaryAccessor;
    const instancesLength = hierarchyJson.instancesLength;
    const classes = hierarchyJson.classes;
    let classIds = hierarchyJson.classIds;
    let parentCounts = hierarchyJson.parentCounts;
    let parentIds = hierarchyJson.parentIds;
    let parentIdsLength = instancesLength;
    if (defined3(classIds.byteOffset)) {
      classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
      classIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(classIds);
      classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
    }
    let parentIndexes;
    if (defined3(parentCounts)) {
      if (defined3(parentCounts.byteOffset)) {
        parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
        parentCounts.type = AttributeType.SCALAR;
        binaryAccessor = getBinaryAccessor(parentCounts);
        parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
      }
      parentIndexes = new Uint16Array(instancesLength);
      parentIdsLength = 0;
      for (i5 = 0; i5 < instancesLength; ++i5) {
        parentIndexes[i5] = parentIdsLength;
        parentIdsLength += parentCounts[i5];
      }
    }
    if (defined3(parentIds) && defined3(parentIds.byteOffset)) {
      parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
      parentIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentIds);
      parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
    }
    const classesLength = classes.length;
    for (i5 = 0; i5 < classesLength; ++i5) {
      const classInstancesLength = classes[i5].length;
      const properties = classes[i5].instances;
      const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
      classes[i5].instances = combine(binaryProperties, properties);
    }
    const classCounts = new Array(classesLength).fill(0);
    const classIndexes = new Uint16Array(instancesLength);
    for (i5 = 0; i5 < instancesLength; ++i5) {
      classId = classIds[i5];
      classIndexes[i5] = classCounts[classId];
      ++classCounts[classId];
    }
    const hierarchy = {
      classes,
      classIds,
      classIndexes,
      parentCounts,
      parentIndexes,
      parentIds
    };
    validateHierarchy(hierarchy);
    return hierarchy;
  }
  function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
    if (!hierarchy) {
      return;
    }
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    if (parentIds) {
      return endConditionCallback(hierarchy, instanceIndex);
    }
    if (parentCounts > 0) {
      return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
    }
    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
  }
  function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
    const classIds = hierarchy.classIds;
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const instancesLength = classIds.length;
    const visited = scratchVisited;
    visited.length = Math.max(visited.length, instancesLength);
    const visitedMarker = ++marker;
    const stack2 = scratchStack;
    stack2.length = 0;
    stack2.push(instanceIndex);
    while (stack2.length > 0) {
      instanceIndex = stack2.pop();
      if (visited[instanceIndex] === visitedMarker) {
        continue;
      }
      visited[instanceIndex] = visitedMarker;
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentCount = parentCounts[instanceIndex];
      const parentIndex = parentIndexes[instanceIndex];
      for (let i5 = 0; i5 < parentCount; ++i5) {
        const parentId = parentIds[parentIndex + i5];
        if (parentId !== instanceIndex) {
          stack2.push(parentId);
        }
      }
    }
    return null;
  }
  function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
    let hasParent2 = true;
    while (hasParent2) {
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentId = hierarchy.parentIds[instanceIndex];
      hasParent2 = parentId !== instanceIndex;
      instanceIndex = parentId;
    }
    throw new Error("traverseHierarchySingleParent");
  }
  function validateHierarchy(hierarchy) {
    const scratchValidateStack = [];
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    for (let i5 = 0; i5 < instancesLength; ++i5) {
      validateInstance(hierarchy, i5, stack);
    }
  }
  function validateInstance(hierarchy, instanceIndex, stack2) {
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    if (!defined3(parentIds)) {
      return;
    }
    assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);
    assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
    stack2.push(instanceIndex);
    const parentCount = defined3(parentCounts) ? parentCounts[instanceIndex] : 1;
    const parentIndex = defined3(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
    for (let i5 = 0; i5 < parentCount; ++i5) {
      const parentId = parentIds[parentIndex + i5];
      if (parentId !== instanceIndex) {
        validateInstance(hierarchy, parentId, stack2);
      }
    }
    stack2.pop(instanceIndex);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table.js
  function defined4(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var clone15 = (x3, y3) => x3;
  var IGNORED_PROPERTY_FIELDS = {
    HIERARCHY: true,
    // Deprecated HIERARCHY property
    extensions: true,
    extras: true
  };
  var Tile3DBatchTableParser = class {
    json;
    binary;
    featureCount;
    _extensions;
    // Copy all top-level property fields from the json object, ignoring special fields
    _properties;
    _binaryProperties;
    // TODO: hierarchy support is only partially implemented and not tested
    _hierarchy;
    constructor(json, binary, featureCount, options = {}) {
      assert2(featureCount >= 0);
      this.json = json || {};
      this.binary = binary;
      this.featureCount = featureCount;
      this._extensions = this.json?.extensions || {};
      this._properties = {};
      for (const propertyName in this.json) {
        if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
          this._properties[propertyName] = this.json[propertyName];
        }
      }
      this._binaryProperties = this._initializeBinaryProperties();
      if (options["3DTILES_batch_table_hierarchy"]) {
        this._hierarchy = initializeHierarchy(this, this.json, this.binary);
      }
    }
    getExtension(extensionName) {
      return this.json && this.json.extensions && this.json.extensions[extensionName];
    }
    memorySizeInBytes() {
      return 0;
    }
    isClass(batchId, className) {
      this._checkBatchId(batchId);
      assert2(typeof className === "string", className);
      if (this._hierarchy) {
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          return instanceClass.name === className;
        });
        return defined4(result);
      }
      return false;
    }
    isExactClass(batchId, className) {
      assert2(typeof className === "string", className);
      return this.getExactClassName(batchId) === className;
    }
    getExactClassName(batchId) {
      this._checkBatchId(batchId);
      if (this._hierarchy) {
        const classId = this._hierarchy.classIds[batchId];
        const instanceClass = this._hierarchy.classes[classId];
        return instanceClass.name;
      }
      return void 0;
    }
    hasProperty(batchId, name13) {
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      return defined4(this._properties[name13]) || this._hasPropertyInHierarchy(batchId, name13);
    }
    getPropertyNames(batchId, results) {
      this._checkBatchId(batchId);
      results = defined4(results) ? results : [];
      results.length = 0;
      const propertyNames = Object.keys(this._properties);
      results.push(...propertyNames);
      if (this._hierarchy) {
        this._getPropertyNamesInHierarchy(batchId, results);
      }
      return results;
    }
    getProperty(batchId, name13) {
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name13];
        if (defined4(binaryProperty)) {
          return this._getBinaryProperty(binaryProperty, batchId);
        }
      }
      const propertyValues = this._properties[name13];
      if (defined4(propertyValues)) {
        return clone15(propertyValues[batchId], true);
      }
      if (this._hierarchy) {
        const hierarchyProperty = this._getHierarchyProperty(batchId, name13);
        if (defined4(hierarchyProperty)) {
          return hierarchyProperty;
        }
      }
      return void 0;
    }
    setProperty(batchId, name13, value) {
      const featureCount = this.featureCount;
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name13];
        if (binaryProperty) {
          this._setBinaryProperty(binaryProperty, batchId, value);
          return;
        }
      }
      if (this._hierarchy) {
        if (this._setHierarchyProperty(this, batchId, name13, value)) {
          return;
        }
      }
      let propertyValues = this._properties[name13];
      if (!defined4(propertyValues)) {
        this._properties[name13] = new Array(featureCount);
        propertyValues = this._properties[name13];
      }
      propertyValues[batchId] = clone15(value, true);
    }
    // PRIVATE METHODS
    _checkBatchId(batchId) {
      const valid = batchId >= 0 && batchId < this.featureCount;
      if (!valid) {
        throw new Error("batchId not in range [0, featureCount - 1].");
      }
    }
    _getBinaryProperty(binaryProperty, index) {
      return binaryProperty.unpack(binaryProperty.typedArray, index);
    }
    _setBinaryProperty(binaryProperty, index, value) {
      binaryProperty.pack(value, binaryProperty.typedArray, index);
    }
    _initializeBinaryProperties() {
      let binaryProperties = null;
      for (const name13 in this._properties) {
        const property = this._properties[name13];
        const binaryProperty = this._initializeBinaryProperty(name13, property);
        if (binaryProperty) {
          binaryProperties = binaryProperties || {};
          binaryProperties[name13] = binaryProperty;
        }
      }
      return binaryProperties;
    }
    _initializeBinaryProperty(name13, property) {
      if ("byteOffset" in property) {
        const tile3DAccessor = property;
        assert2(this.binary, `Property ${name13} requires a batch table binary.`);
        assert2(tile3DAccessor.type, `Property ${name13} requires a type.`);
        const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
        return {
          typedArray: accessor.values,
          componentCount: accessor.size,
          unpack: accessor.unpacker,
          pack: accessor.packer
        };
      }
      return null;
    }
    //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
    _hasPropertyInHierarchy(batchId, name13) {
      if (!this._hierarchy) {
        return false;
      }
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        return defined4(instances[name13]);
      });
      return defined4(result);
    }
    _getPropertyNamesInHierarchy(batchId, results) {
      traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        for (const name13 in instances) {
          if (instances.hasOwnProperty(name13)) {
            if (results.indexOf(name13) === -1) {
              results.push(name13);
            }
          }
        }
      });
    }
    _getHierarchyProperty(batchId, name13) {
      return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name13];
        if (defined4(propertyValues)) {
          if (defined4(propertyValues.typedArray)) {
            return this._getBinaryProperty(propertyValues, indexInClass);
          }
          return clone15(propertyValues[indexInClass], true);
        }
        return null;
      });
    }
    _setHierarchyProperty(batchTable, batchId, name13, value) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name13];
        if (defined4(propertyValues)) {
          assert2(instanceIndex === batchId, `Inherited property "${name13}" is read-only.`);
          if (defined4(propertyValues.typedArray)) {
            this._setBinaryProperty(propertyValues, indexInClass, value);
          } else {
            propertyValues[indexInClass] = clone15(value, true);
          }
          return true;
        }
        return false;
      });
      return defined4(result);
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-header.js
  var SIZEOF_UINT32 = 4;
  function parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset = 0) {
    const view = new DataView(arrayBuffer2);
    tile.magic = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.version = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.byteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    if (tile.version !== 1) {
      throw new Error(`3D Tile Version ${tile.version} not supported`);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-tables.js
  var SIZEOF_UINT322 = 4;
  var DEPRECATION_WARNING = "b3dm tile in legacy format.";
  function parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset) {
    const view = new DataView(arrayBuffer2);
    let batchLength;
    tile.header = tile.header || {};
    let featureTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    if (batchTableJsonByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322 * 2;
      batchLength = featureTableJsonByteLength;
      batchTableJsonByteLength = featureTableBinaryByteLength;
      batchTableBinaryByteLength = 0;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    } else if (batchTableBinaryByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322;
      batchLength = batchTableJsonByteLength;
      batchTableJsonByteLength = featureTableJsonByteLength;
      batchTableBinaryByteLength = featureTableBinaryByteLength;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    }
    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
    tile.header.batchLength = batchLength;
    return byteOffset;
  }
  function parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options) {
    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options);
    return byteOffset;
  }
  function parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options) {
    const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};
    tile.featureTableJson = {
      BATCH_LENGTH: batchLength || 0
    };
    if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {
      const featureTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, featureTableJsonByteLength);
      tile.featureTableJson = JSON.parse(featureTableString);
    }
    byteOffset += featureTableJsonByteLength || 0;
    tile.featureTableBinary = new Uint8Array(arrayBuffer2, byteOffset, featureTableBinaryByteLength);
    byteOffset += featureTableBinaryByteLength || 0;
    return byteOffset;
  }
  function parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options) {
    const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};
    if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {
      const batchTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, batchTableJsonByteLength);
      tile.batchTableJson = JSON.parse(batchTableString);
      byteOffset += batchTableJsonByteLength;
      if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {
        tile.batchTableBinary = new Uint8Array(arrayBuffer2, byteOffset, batchTableBinaryByteLength);
        tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
        byteOffset += batchTableBinaryByteLength;
      }
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-colors.js
  function normalize3DTileColorAttribute(tile, colors, batchTable) {
    if (!colors && (!tile || !tile.batchIds || !batchTable)) {
      return null;
    }
    const { batchIds, isRGB565, pointCount = 0 } = tile;
    if (batchIds && batchTable) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i5 = 0; i5 < pointCount; i5++) {
        const batchId = batchIds[i5];
        const dimensions = batchTable.getProperty(batchId, "dimensions");
        const color = dimensions.map((d2) => d2 * 255);
        colorArray[i5 * 3] = color[0];
        colorArray[i5 * 3 + 1] = color[1];
        colorArray[i5 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && isRGB565) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i5 = 0; i5 < pointCount; i5++) {
        const color = decodeRGB565(colors[i5]);
        colorArray[i5 * 3] = color[0];
        colorArray[i5 * 3 + 1] = color[1];
        colorArray[i5 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && colors.length === pointCount * 3) {
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colors,
        size: 3,
        normalized: true
      };
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors || new Uint8ClampedArray(),
      size: 4,
      normalized: true
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-normals.js
  var scratchNormal6 = new Vector37();
  function normalize3DTileNormalAttribute(tile, normals) {
    if (!normals) {
      return null;
    }
    if (tile.isOctEncoded16P) {
      const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);
      for (let i5 = 0; i5 < (tile.pointsLength || 0); i5++) {
        octDecode(normals[i5 * 2], normals[i5 * 2 + 1], scratchNormal6);
        scratchNormal6.toArray(decodedArray, i5 * 3);
      }
      return {
        type: GL2.FLOAT,
        size: 2,
        value: decodedArray
      };
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: normals
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-positions.js
  function normalize3DTilePositionAttribute(tile, positions, options) {
    if (!tile.isQuantized) {
      return positions;
    }
    if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
      tile.isQuantized = false;
      return decodeQuantizedPositions(tile, positions);
    }
    return {
      type: GL2.UNSIGNED_SHORT,
      value: positions,
      size: 3,
      normalized: true
    };
  }
  function decodeQuantizedPositions(tile, positions) {
    const scratchPosition6 = new Vector37();
    const decodedArray = new Float32Array(tile.pointCount * 3);
    for (let i5 = 0; i5 < tile.pointCount; i5++) {
      scratchPosition6.set(positions[i5 * 3], positions[i5 * 3 + 1], positions[i5 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i5 * 3);
    }
    return decodedArray;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-point-cloud.js
  async function parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    initializeTile(tile);
    const { featureTable, batchTable } = parsePointCloudTables(tile);
    await parseDraco(tile, featureTable, batchTable, options, context);
    parsePositions(tile, featureTable, options);
    parseColors(tile, featureTable, batchTable);
    parseNormals(tile, featureTable);
    return byteOffset;
  }
  function initializeTile(tile) {
    tile.attributes = {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    tile.isQuantized = false;
    tile.isTranslucent = false;
    tile.isRGB565 = false;
    tile.isOctEncoded16P = false;
  }
  function parsePointCloudTables(tile) {
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
    if (!Number.isFinite(pointsLength)) {
      throw new Error("POINTS_LENGTH must be defined");
    }
    featureTable.featuresLength = pointsLength;
    tile.featuresLength = pointsLength;
    tile.pointsLength = pointsLength;
    tile.pointCount = pointsLength;
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = parseBatchIds(tile, featureTable);
    return { featureTable, batchTable };
  }
  function parsePositions(tile, featureTable, options) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.positions) {
      if (featureTable.hasProperty("POSITION")) {
        tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
        tile.isQuantized = true;
        tile.quantizedRange = (1 << 16) - 1;
        tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeScale) {
          throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeOffset) {
          throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
      }
    }
    if (!tile.attributes.positions) {
      throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
    }
  }
  function parseColors(tile, featureTable, batchTable) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.colors) {
      let colors = null;
      if (featureTable.hasProperty("RGBA")) {
        colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
        tile.isTranslucent = true;
      } else if (featureTable.hasProperty("RGB")) {
        colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
      } else if (featureTable.hasProperty("RGB565")) {
        colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
        tile.isRGB565 = true;
      }
      tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
    }
    if (featureTable.hasProperty("CONSTANT_RGBA")) {
      tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
    }
  }
  function parseNormals(tile, featureTable) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.normals) {
      let normals = null;
      if (featureTable.hasProperty("NORMAL")) {
        normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
        normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
        tile.isOctEncoded16P = true;
      }
      tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
    }
  }
  function parseBatchIds(tile, featureTable) {
    let batchTable = null;
    if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
      tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
      if (tile.batchIds) {
        const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
        if (!batchFeatureLength) {
          throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
        }
        const { batchTableJson, batchTableBinary } = tile;
        batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
      }
    }
    return batchTable;
  }
  async function parseDraco(tile, featureTable, batchTable, options, context) {
    let dracoBuffer;
    let dracoFeatureTableProperties;
    let dracoBatchTableProperties;
    const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
    if (batchTableDraco) {
      dracoBatchTableProperties = batchTableDraco.properties;
    }
    const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
    if (featureTableDraco) {
      dracoFeatureTableProperties = featureTableDraco.properties;
      const dracoByteOffset = featureTableDraco.byteOffset;
      const dracoByteLength = featureTableDraco.byteLength;
      if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
        throw new Error("Draco properties, byteOffset, and byteLength must be defined");
      }
      dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
      tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
      tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
      tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
      tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
      tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
    }
    if (!dracoBuffer) {
      return true;
    }
    const dracoData = {
      buffer: dracoBuffer,
      properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };
    return await loadDraco(tile, dracoData, options, context);
  }
  async function loadDraco(tile, dracoData, options, context) {
    if (!context) {
      return;
    }
    const dracoOptions = {
      ...options,
      draco: {
        ...options?.draco,
        extraAttributes: dracoData.batchTableProperties || {}
      }
    };
    delete dracoOptions["3d-tiles"];
    const data = await parseFromContext(dracoData.buffer, DracoLoader2, dracoOptions, context);
    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
    if (isQuantizedDraco) {
      const quantization = data.POSITION.data.quantization;
      const range = quantization.range;
      tile.quantizedVolumeScale = new Vector37(range, range, range);
      tile.quantizedVolumeOffset = new Vector37(quantization.minValues);
      tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
      tile.isQuantizedDraco = true;
    }
    if (isOctEncodedDraco) {
      tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
      tile.isOctEncodedDraco = true;
    }
    const batchTableAttributes = {};
    if (dracoData.batchTableProperties) {
      for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
        if (data.attributes[attributeName] && data.attributes[attributeName].value) {
          batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
        }
      }
    }
    tile.attributes = {
      // @ts-expect-error
      positions: decodedPositions,
      // @ts-expect-error
      colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
      // @ts-expect-error
      normals: decodedNormals,
      // @ts-expect-error
      batchIds: decodedBatchIds,
      ...batchTableAttributes
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js
  var GLTF_FORMAT = {
    URI: 0,
    EMBEDDED: 1
  };
  function parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options) {
    tile.rotateYtoZ = true;
    const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;
    if (gltfByteLength === 0) {
      throw new Error("glTF byte length must be greater than 0.");
    }
    tile.gltfUpAxis = options?.["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer2, byteOffset, gltfByteLength);
    tile.gltfByteOffset = 0;
    tile.gltfByteLength = gltfByteLength;
    if (byteOffset % 4 === 0) {
    } else {
      console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
    }
    return (tile.byteOffset || 0) + (tile.byteLength || 0);
  }
  async function extractGLTF(tile, gltfFormat, options, context) {
    const tile3DOptions = options?.["3d-tiles"] || {};
    extractGLTFBufferOrURL(tile, gltfFormat, options);
    if (tile3DOptions.loadGLTF) {
      if (!context) {
        return;
      }
      if (tile.gltfUrl) {
        const { fetch: fetch2 } = context;
        const response = await fetch2(tile.gltfUrl, options);
        tile.gltfArrayBuffer = await response.arrayBuffer();
        tile.gltfByteOffset = 0;
      }
      if (tile.gltfArrayBuffer) {
        const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);
        tile.gltf = postProcessGLTF(gltfWithBuffers);
        tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
      }
    }
  }
  function extractGLTFBufferOrURL(tile, gltfFormat, options) {
    switch (gltfFormat) {
      case GLTF_FORMAT.URI:
        if (tile.gltfArrayBuffer) {
          const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
          const textDecoder = new TextDecoder();
          const gltfUrl = textDecoder.decode(gltfUrlBytes);
          tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
        }
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
        break;
      case GLTF_FORMAT.EMBEDDED:
        break;
      default:
        throw new Error("b3dm: Illegal glTF format field");
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-batched-model.js
  async function parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
    const extensions = tile?.gltf?.extensions;
    if (extensions && extensions.CESIUM_RTC) {
      tile.rtcCenter = extensions.CESIUM_RTC.center;
    }
    return byteOffset;
  }
  function parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-instanced-model.js
  async function parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, tile.gltfFormat || 0, options, context);
    return byteOffset;
  }
  function parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    if (tile.version !== 1) {
      throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
    }
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.gltfFormat = view.getUint32(byteOffset, true);
    byteOffset += 4;
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    if (!tile?.header?.featureTableJsonByteLength || tile.header.featureTableJsonByteLength === 0) {
      throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
    }
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
    featureTable.featuresLength = instancesLength;
    if (!Number.isFinite(instancesLength)) {
      throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
    }
    tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
    return byteOffset;
  }
  function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
    const instances = new Array(instancesLength);
    const instancePosition = new Vector37();
    const instanceNormalRight = new Vector37();
    const instanceNormalUp = new Vector37();
    const instanceNormalForward = new Vector37();
    const instanceRotation = new Matrix35();
    const instanceQuaternion = new Quaternion4();
    const instanceScale = new Vector37();
    const instanceTranslationRotationScale = {};
    const instanceTransform = new Matrix45();
    const scratch1 = [];
    const scratch2 = [];
    const scratch3 = [];
    const scratch4 = [];
    for (let i5 = 0; i5 < instancesLength; i5++) {
      let position;
      if (featureTable.hasProperty("POSITION")) {
        position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i5, instancePosition);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i5, instancePosition);
        const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!quantizedVolumeOffset) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!quantizedVolumeScale) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        const MAX_UNSIGNED_SHORT = 65535;
        for (let j2 = 0; j2 < 3; j2++) {
          position[j2] = position[j2] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j2] + quantizedVolumeOffset[j2];
        }
      }
      if (!position) {
        throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
      }
      instancePosition.copy(position);
      instanceTranslationRotationScale.translation = instancePosition;
      tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i5, scratch1);
      tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i5, scratch2);
      const hasCustomOrientation = false;
      if (tile.normalUp) {
        if (!tile.normalRight) {
          throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
        }
        tile.hasCustomOrientation = true;
      } else {
        tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, i5, scratch1);
        tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, i5, scratch2);
        if (tile.octNormalUp) {
          if (!tile.octNormalRight) {
            throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
          }
          throw new Error("i3dm: oct-encoded orientation not implemented");
        } else if (tile.eastNorthUp) {
          Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
          instanceTransform.getRotationMatrix3(instanceRotation);
        } else {
          instanceRotation.identity();
        }
      }
      if (hasCustomOrientation) {
        instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
        instanceRotation.setColumn(0, instanceNormalRight);
        instanceRotation.setColumn(1, instanceNormalUp);
        instanceRotation.setColumn(2, instanceNormalForward);
      }
      instanceQuaternion.fromMatrix3(instanceRotation);
      instanceTranslationRotationScale.rotation = instanceQuaternion;
      instanceScale.set(1, 1, 1);
      const scale22 = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i5, scratch3);
      if (Number.isFinite(scale22)) {
        instanceScale.multiplyByScalar(scale22);
      }
      const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i5, scratch1);
      if (nonUniformScale) {
        instanceScale.scale(nonUniformScale);
      }
      instanceTranslationRotationScale.scale = instanceScale;
      let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i5, scratch4);
      if (batchId === void 0) {
        batchId = i5;
      }
      const rotationMatrix = new Matrix45().fromQuaternion(instanceTranslationRotationScale.rotation);
      instanceTransform.identity();
      instanceTransform.translate(instanceTranslationRotationScale.translation);
      instanceTransform.multiplyRight(rotationMatrix);
      instanceTransform.scale(instanceTranslationRotationScale.scale);
      const modelMatrix2 = instanceTransform.clone();
      instances[i5] = {
        modelMatrix: modelMatrix2,
        batchId
      };
    }
    tile.instances = instances;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-composite.js
  async function parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile2) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.tilesLength = view.getUint32(byteOffset, true);
    byteOffset += 4;
    tile.tiles = [];
    while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {
      const subtile = { shape: "tile3d" };
      tile.tiles.push(subtile);
      byteOffset = await parse3DTile2(arrayBuffer2, byteOffset, options, context, subtile);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-gltf.js
  async function parseGltf3DTile(tile, arrayBuffer2, options, context) {
    tile.rotateYtoZ = true;
    tile.gltfUpAxis = options?.["3d-tiles"]?.assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    if (options?.["3d-tiles"]?.loadGLTF) {
      if (!context) {
        return arrayBuffer2.byteLength;
      }
      const gltfWithBuffers = await parseFromContext(arrayBuffer2, GLTFLoader, options, context);
      tile.gltf = postProcessGLTF(gltfWithBuffers);
      tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
    } else {
      tile.gltfArrayBuffer = arrayBuffer2;
    }
    return arrayBuffer2.byteLength;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile.js
  async function parse3DTile(arrayBuffer2, byteOffset = 0, options, context, tile = { shape: "tile3d" }) {
    tile.byteOffset = byteOffset;
    tile.type = getMagicString4(arrayBuffer2, byteOffset);
    switch (tile.type) {
      case TILE3D_TYPE.COMPOSITE:
        return await parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile);
      case TILE3D_TYPE.BATCHED_3D_MODEL:
        return await parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.GLTF:
        return await parseGltf3DTile(tile, arrayBuffer2, options, context);
      case TILE3D_TYPE.INSTANCED_3D_MODEL:
        return await parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.POINT_CLOUD:
        return await parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context);
      default:
        throw new Error(`3DTileLoader: unknown type ${tile.type}`);
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-subtree.js
  var SUBTREE_FILE_MAGIC = 1952609651;
  var SUBTREE_FILE_VERSION = 1;
  async function parse3DTilesSubtree(data, options, context) {
    const magic = new Uint32Array(data.slice(0, 4));
    if (magic[0] !== SUBTREE_FILE_MAGIC) {
      throw new Error("Wrong subtree file magic number");
    }
    const version = new Uint32Array(data.slice(4, 8));
    if (version[0] !== SUBTREE_FILE_VERSION) {
      throw new Error("Wrong subtree file verson, must be 1");
    }
    const jsonByteLength = parseUint64Value(data.slice(8, 16));
    const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
    const textDecoder = new TextDecoder("utf8");
    const string = textDecoder.decode(stringAttribute);
    const subtree = JSON.parse(string);
    const binaryByteLength = parseUint64Value(data.slice(16, 24));
    let internalBinaryBuffer = new ArrayBuffer(0);
    if (binaryByteLength) {
      internalBinaryBuffer = data.slice(24 + jsonByteLength);
    }
    await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);
    if (Array.isArray(subtree.contentAvailability)) {
      for (const contentAvailability of subtree.contentAvailability) {
        await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);
      }
    } else {
      await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);
    }
    await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);
    return subtree;
  }
  async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {
    const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;
    if (typeof bufferViewIndex !== "number") {
      return;
    }
    const bufferView = subtree.bufferViews[bufferViewIndex];
    const buffer = subtree.buffers[bufferView.buffer];
    if (!context?.baseUrl) {
      throw new Error("Url is not provided");
    }
    if (!context.fetch) {
      throw new Error("fetch is not provided");
    }
    if (buffer.uri) {
      const bufferUri = `${context?.baseUrl || ""}/${buffer.uri}`;
      const response = await context.fetch(bufferUri);
      const data = await response.arrayBuffer();
      availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
      return;
    }
    const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);
    availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);
  }
  function parseUint64Value(buffer) {
    const dataView = new DataView(buffer);
    const left = dataView.getUint32(0, true);
    const right = dataView.getUint32(4, true);
    return left + 2 ** 32 * right;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/tile-3d-subtree-loader.js
  var Tile3DSubtreeLoader = {
    dataType: null,
    batchType: null,
    id: "3d-tiles-subtree",
    name: "3D Tiles Subtree",
    module: "3d-tiles",
    version: VERSION11,
    extensions: ["subtree"],
    mimeTypes: ["application/octet-stream"],
    tests: ["subtree"],
    parse: parse3DTilesSubtree,
    options: {}
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/long/index.js
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e3) {
  }
  function Long3(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long3.prototype.__isLong__;
  Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c2 = Math.clz32(value & -value);
    return value ? 31 - c2 : c2;
  }
  Long3.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache3;
    if (unsigned) {
      value >>>= 0;
      if (cache3 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache3)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache3 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache3)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long3.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO16;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long3.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long3(lowBits, highBits, unsigned);
  }
  Long3.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str7, unsigned, radix) {
    if (str7.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str7 === "NaN" || str7 === "Infinity" || str7 === "+Infinity" || str7 === "-Infinity")
      return unsigned ? UZERO : ZERO16;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p3;
    if ((p3 = str7.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p3 === 0) {
      return fromString(str7.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO16;
    for (var i5 = 0; i5 < str7.length; i5 += 8) {
      var size = Math.min(8, str7.length - i5), value = parseInt(str7.substring(i5, i5 + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long3.fromString = fromString;
  function fromValue(val2, unsigned) {
    if (typeof val2 === "number")
      return fromNumber(val2, unsigned);
    if (typeof val2 === "string")
      return fromString(val2, unsigned);
    return fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
  }
  Long3.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO16 = fromInt(0);
  Long3.ZERO = ZERO16;
  var UZERO = fromInt(0, true);
  Long3.UZERO = UZERO;
  var ONE = fromInt(1);
  Long3.ONE = ONE;
  var UONE = fromInt(1, true);
  Long3.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long3.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long3.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long3.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long3.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div5 = this.div(radixLong), rem1 = div5.mul(radixLong).sub(this);
        return div5.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val2 = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val2 & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals14(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate5() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add15(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract7(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply19(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO16;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO16;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO16;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide5(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO16;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO16)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO16;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO16;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl(2, log23 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32)
      return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b2;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b2 = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b2, this.high << numBits | this.low >>> b2, this.unsigned);
    }
    numBits -= 32;
    b2 = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b2, this.low << numBits | this.high >>> b2, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b2;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b2 = 32 - numBits;
      return fromBits(this.high << b2 | this.low >>> numBits, this.low << b2 | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b2 = 32 - numBits;
    return fromBits(this.low << b2 | this.high >>> numBits, this.high << b2 | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long3.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
  };
  Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long3(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long3(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  var long_default = Long3;

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-token-functions.js
  var MAXIMUM_TOKEN_LENGTH = 16;
  function getS2CellIdFromToken(token) {
    if (token === "X") {
      token = "";
    }
    const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
    return long_default.fromString(paddedToken, true, 16);
  }
  function getS2TokenFromCellId(cellId) {
    if (cellId.isZero()) {
      return "X";
    }
    let numZeroDigits = cellId.countTrailingZeros();
    const remainder = numZeroDigits % 4;
    numZeroDigits = (numZeroDigits - remainder) / 4;
    const trailingZeroHexChars = numZeroDigits;
    numZeroDigits *= 4;
    const x3 = cellId.shiftRightUnsigned(numZeroDigits);
    const hexString = x3.toString(16).replace(/0+$/, "");
    const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
    return zeroString + hexString;
  }
  function getS2ChildCellId(cellId, index) {
    const newLsb = lsb(cellId).shiftRightUnsigned(2);
    const childCellId = cellId.add(long_default.fromNumber(2 * index + 1 - 4).multiply(newLsb));
    return childCellId;
  }
  function lsb(cellId) {
    return cellId.and(cellId.not().add(1));
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-geometry.js
  var FACE_BITS2 = 3;
  var MAX_LEVEL2 = 30;
  var POS_BITS2 = 2 * MAX_LEVEL2 + 1;
  var RADIAN_TO_DEGREE2 = 180 / Math.PI;
  function getS2CellFromQuadKey(hilbertQuadkey) {
    if (hilbertQuadkey.length === 0) {
      throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);
    }
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    let level = 0;
    const point = [0, 0];
    for (let i5 = maxLevel - 1; i5 >= 0; i5--) {
      level = maxLevel - i5;
      const bit = position[i5];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant2(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t3 = point[0];
      point[0] = point[1];
      point[1] = t3;
    }
    return { face, ij: point, level };
  }
  function getS2QuadkeyFromCellId(cellId) {
    if (cellId.isZero()) {
      return "";
    }
    let bin = cellId.toString(2);
    while (bin.length < FACE_BITS2 + POS_BITS2) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = long_default.fromString(faceB, true, 2).toString(10);
    let posS = "";
    if (levelN !== 0) {
      posS = long_default.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
    }
    return `${faceS}/${posS}`;
  }
  function IJToST2(ij, level, offsets) {
    const maxSize = 1 << level;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV2(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV2(st) {
    return [singleSTtoUV2(st[0]), singleSTtoUV2(st[1])];
  }
  function FaceUVToXYZ2(face, [u3, v2]) {
    switch (face) {
      case 0:
        return [1, u3, v2];
      case 1:
        return [-u3, 1, v2];
      case 2:
        return [-u3, -v2, 1];
      case 3:
        return [-1, -v2, -u3];
      case 4:
        return [v2, -1, -u3];
      case 5:
        return [v2, u3, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat2([x3, y3, z2]) {
    const lat = Math.atan2(z2, Math.sqrt(x3 * x3 + y3 * y3));
    const lng = Math.atan2(y3, x3);
    return [lng * RADIAN_TO_DEGREE2, lat * RADIAN_TO_DEGREE2];
  }
  function rotateAndFlipQuadrant2(n3, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n3 - 1 - point[0];
        point[1] = n3 - 1 - point[1];
      }
      const x3 = point[0];
      point[0] = point[1];
      point[1] = x3;
    }
  }
  function getS2LngLatFromS2Cell(s2Cell) {
    const st = IJToST2(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
    const uv = STToUV2(st);
    const xyz = FaceUVToXYZ2(s2Cell.face, uv);
    return XYZToLngLat2(xyz);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-boundary.js
  var MAX_RESOLUTION2 = 100;
  function getS2BoundaryFlatFromS2Cell(s2cell) {
    const { face, ij, level } = s2cell;
    const offsets = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0]
    ];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i5 = 0; i5 < 4; i5++) {
      const offset = offsets[i5].slice(0);
      const nextOffset = offsets[i5 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j2 = 0; j2 < resolution; j2++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST2(ij, level, offset);
        const uv = STToUV2(st);
        const xyz = FaceUVToXYZ2(face, uv);
        const lngLat = XYZToLngLat2(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-cell-utils.js
  function getS2Cell(tokenOrKey) {
    const key = getS2QuadKey2(tokenOrKey);
    const s2cell = getS2CellFromQuadKey(key);
    return s2cell;
  }
  function getS2QuadKey2(tokenOrKey) {
    if (tokenOrKey.indexOf("/") > 0) {
      return tokenOrKey;
    }
    const id = getS2CellIdFromToken(tokenOrKey);
    return getS2QuadkeyFromCellId(id);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-geometry-functions.js
  function getS2LngLat(s2Token) {
    const s2cell = getS2Cell(s2Token);
    return getS2LngLatFromS2Cell(s2cell);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-region.js
  function getS2Region(s2cell) {
    let region;
    if (s2cell.face === 2 || s2cell.face === 5) {
      let corners = null;
      let len8 = 0;
      for (let i5 = 0; i5 < 4; i5++) {
        const key = `${s2cell.face}/${i5}`;
        const cell = getS2Cell(key);
        const corns = getS2BoundaryFlatFromS2Cell(cell);
        if (typeof corners === "undefined" || corners === null)
          corners = new Float64Array(4 * corns.length);
        corners.set(corns, len8);
        len8 += corns.length;
      }
      region = get2DRegionFromS2Corners(corners);
    } else {
      const corners = getS2BoundaryFlatFromS2Cell(s2cell);
      region = get2DRegionFromS2Corners(corners);
    }
    return region;
  }
  function get2DRegionFromS2Corners(corners) {
    if (corners.length % 2 !== 0) {
      throw new Error("Invalid corners");
    }
    const longitudes = [];
    const latitudes = [];
    for (let i5 = 0; i5 < corners.length; i5 += 2) {
      longitudes.push(corners[i5]);
      latitudes.push(corners[i5 + 1]);
    }
    longitudes.sort((a3, b2) => a3 - b2);
    latitudes.sort((a3, b2) => a3 - b2);
    return {
      west: longitudes[0],
      east: longitudes[longitudes.length - 1],
      north: latitudes[latitudes.length - 1],
      south: latitudes[0]
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-obb-points.js
  function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
    const min6 = heightInfo?.minimumHeight || 0;
    const max6 = heightInfo?.maximumHeight || 0;
    const s2cell = getS2Cell(tokenOrKey);
    const region = getS2Region(s2cell);
    const W = region.west;
    const S2 = region.south;
    const E = region.east;
    const N2 = region.north;
    const points = [];
    points.push(new Vector37(W, N2, min6));
    points.push(new Vector37(E, N2, min6));
    points.push(new Vector37(E, S2, min6));
    points.push(new Vector37(W, S2, min6));
    points.push(new Vector37(W, N2, max6));
    points.push(new Vector37(E, N2, max6));
    points.push(new Vector37(E, S2, max6));
    points.push(new Vector37(W, S2, max6));
    return points;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/obb/s2-corners-to-obb.js
  function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
    const token = s2VolumeInfo.token;
    const heightInfo = {
      minimumHeight: s2VolumeInfo.minimumHeight,
      maximumHeight: s2VolumeInfo.maximumHeight
    };
    const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
    const center = getS2LngLat(token);
    const centerLng = center[0];
    const centerLat = center[1];
    const point = Ellipsoid.WGS84.cartographicToCartesian([
      centerLng,
      centerLat,
      heightInfo.maximumHeight
    ]);
    const centerPointAdditional = new Vector37(point[0], point[1], point[2]);
    corners.push(centerPointAdditional);
    const obb = makeOrientedBoundingBoxFromPoints2(corners);
    const box = [...obb.center, ...obb.halfAxes];
    return box;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
  var QUADTREE_DIVISION_COUNT = 4;
  var OCTREE_DIVISION_COUNT = 8;
  var SUBDIVISION_COUNT_MAP = {
    QUADTREE: QUADTREE_DIVISION_COUNT,
    OCTREE: OCTREE_DIVISION_COUNT
  };
  function getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {
    if (s2VolumeBox?.box) {
      const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
      const childCellId = getS2ChildCellId(cellId, index);
      const childToken = getS2TokenFromCellId(childCellId);
      const s2ChildVolumeInfo = { ...s2VolumeBox.s2VolumeInfo };
      s2ChildVolumeInfo.token = childToken;
      switch (subdivisionScheme) {
        case "OCTREE":
          const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
          const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
          const sizeZ = delta / 2;
          const midZ = s2VolumeInfo.minimumHeight + delta / 2;
          s2VolumeInfo.minimumHeight = midZ - sizeZ;
          s2VolumeInfo.maximumHeight = midZ + sizeZ;
          break;
        default:
          break;
      }
      const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
      const childS2VolumeBox = {
        box,
        s2VolumeInfo: s2ChildVolumeInfo
      };
      return childS2VolumeBox;
    }
    return void 0;
  }
  async function parseImplicitTiles(params) {
    const { implicitOptions, parentData = {
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    }, childIndex = 0, s2VolumeBox, loaderOptions } = params;
    let { subtree, level = 0, globalData = {
      level: 0,
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    } } = params;
    const { subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath } = implicitOptions;
    const tile = { children: [], lodMetricValue: 0, contentUrl: "" };
    if (!maximumLevel) {
      dist_default.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);
      return tile;
    }
    const lev = level + globalData.level;
    if (lev > maximumLevel) {
      return tile;
    }
    const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
    const bitsPerTile = Math.log2(childrenPerTile);
    const childX = childIndex & 1;
    const childY = childIndex >> 1 & 1;
    const childZ = childIndex >> 2 & 1;
    const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
    let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);
    let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
    let childTileX = concatBits(parentData.x, childX, 1);
    let childTileY = concatBits(parentData.y, childY, 1);
    let childTileZ = concatBits(parentData.z, childZ, 1);
    let isChildSubtreeAvailable = false;
    if (level >= subtreeLevels) {
      isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
    }
    const x3 = concatBits(globalData.x, childTileX, level);
    const y3 = concatBits(globalData.y, childTileY, level);
    const z2 = concatBits(globalData.z, childTileZ, level);
    if (isChildSubtreeAvailable) {
      const subtreePath = `${basePath}/${subtreesUriTemplate}`;
      const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x3, y3, z2);
      const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);
      subtree = childSubtree;
      globalData = {
        mortonIndex: childTileMortonIndex,
        x: childTileX,
        y: childTileY,
        z: childTileZ,
        level
      };
      childTileMortonIndex = 0;
      tileAvailabilityIndex = 0;
      childTileX = 0;
      childTileY = 0;
      childTileZ = 0;
      level = 0;
    }
    const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
    if (!isTileAvailable) {
      return tile;
    }
    const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
    if (isContentAvailable) {
      tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x3, y3, z2);
    }
    const childTileLevel = level + 1;
    const pData = { mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ };
    for (let index = 0; index < childrenPerTile; index++) {
      const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);
      const childTileParsed = await parseImplicitTiles({
        subtree,
        implicitOptions,
        loaderOptions,
        parentData: pData,
        childIndex: index,
        level: childTileLevel,
        globalData: { ...globalData },
        s2VolumeBox: childS2VolumeBox
      });
      if (childTileParsed.contentUrl || childTileParsed.children.length) {
        const globalLevel = lev + 1;
        const childCoordinates = { childTileX, childTileY, childTileZ };
        const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, implicitOptions, s2VolumeBox);
        tile.children.push(formattedTile);
      }
    }
    return tile;
  }
  function getAvailabilityResult(availabilityData, index) {
    let availabilityObject;
    if (Array.isArray(availabilityData)) {
      availabilityObject = availabilityData[0];
      if (availabilityData.length > 1) {
        dist_default.once('Not supported extension "3DTILES_multiple_contents" has been detected');
      }
    } else {
      availabilityObject = availabilityData;
    }
    if ("constant" in availabilityObject) {
      return Boolean(availabilityObject.constant);
    }
    if (availabilityObject.explicitBitstream) {
      return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);
    }
    return false;
  }
  function formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {
    const { basePath, refine, getRefine: getRefine2, lodMetricType, getTileType: getTileType2, rootLodMetricValue, rootBoundingVolume } = options;
    const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, "");
    const lodMetricValue = rootLodMetricValue / 2 ** level;
    const boundingVolume = s2VolumeBox?.box ? { box: s2VolumeBox.box } : rootBoundingVolume;
    const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);
    return {
      children: tile.children,
      contentUrl: tile.contentUrl,
      content: { uri },
      id: tile.contentUrl,
      refine: getRefine2(refine),
      type: getTileType2(tile),
      lodMetricType,
      lodMetricValue,
      geometricError: lodMetricValue,
      transform: tile.transform,
      boundingVolume: boundingVolumeForChildTile
    };
  }
  function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
    if (rootBoundingVolume.region) {
      const { childTileX, childTileY, childTileZ } = childCoordinates;
      const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
      const boundingVolumesCount = 2 ** level;
      const sizeX = (east - west) / boundingVolumesCount;
      const sizeY = (north - south) / boundingVolumesCount;
      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
      const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
      const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
      const [childMinimumHeight, childMaximumHeight] = [
        minimumHeight + sizeZ * childTileZ,
        minimumHeight + sizeZ * (childTileZ + 1)
      ];
      return {
        region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
      };
    }
    if (rootBoundingVolume.box) {
      return rootBoundingVolume;
    }
    throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);
  }
  function concatBits(higher, lower, shift) {
    return (higher << shift) + lower;
  }
  function replaceContentUrlTemplate(templateUrl, level, x3, y3, z2) {
    const mapUrl = generateMapUrl({ level, x: x3, y: y3, z: z2 });
    return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
  }
  function generateMapUrl(items) {
    const mapUrl = {};
    for (const key in items) {
      mapUrl[`{${key}}`] = items[key];
    }
    return mapUrl;
  }
  function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
    const byteIndex = Math.floor(availabilityIndex / 8);
    const bitIndex = availabilityIndex % 8;
    const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
    return bitValue === 1;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-header.js
  function getTileType(tile, tileContentUrl = "") {
    if (!tileContentUrl) {
      return TILE_TYPE.EMPTY;
    }
    const contentUrl = tileContentUrl.split("?")[0];
    const fileExtension = contentUrl.split(".").pop();
    switch (fileExtension) {
      case "pnts":
        return TILE_TYPE.POINTCLOUD;
      case "i3dm":
      case "b3dm":
      case "glb":
      case "gltf":
        return TILE_TYPE.SCENEGRAPH;
      default:
        return fileExtension || TILE_TYPE.EMPTY;
    }
  }
  function getRefine(refine) {
    switch (refine) {
      case "REPLACE":
      case "replace":
        return TILE_REFINEMENT.REPLACE;
      case "ADD":
      case "add":
        return TILE_REFINEMENT.ADD;
      default:
        return refine;
    }
  }
  function resolveUri(uri, basePath) {
    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
    if (urlSchemeRegex.test(basePath)) {
      const url = new URL(uri, `${basePath}/`);
      return decodeURI(url.toString());
    } else if (uri.startsWith("/")) {
      return uri;
    }
    return path_exports.resolve(basePath, uri);
  }
  function normalizeTileData(tile, basePath) {
    if (!tile) {
      return null;
    }
    let tileContentUrl;
    if (tile.content) {
      const contentUri = tile.content.uri || tile.content?.url;
      if (typeof contentUri !== "undefined") {
        tileContentUrl = resolveUri(contentUri, basePath);
      }
    }
    const tilePostprocessed = {
      ...tile,
      id: tileContentUrl,
      contentUrl: tileContentUrl,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: tile.geometricError,
      transformMatrix: tile.transform,
      type: getTileType(tile, tileContentUrl),
      refine: getRefine(tile.refine)
    };
    return tilePostprocessed;
  }
  async function normalizeTileHeaders(tileset, basePath, options) {
    let root = null;
    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);
    if (rootImplicitTilingExtension && tileset.root) {
      root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);
    } else {
      root = normalizeTileData(tileset.root, basePath);
    }
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop() || {};
      const children = tile.children || [];
      const childrenPostprocessed = [];
      for (const childHeader of children) {
        const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
        let childHeaderPostprocessed;
        if (childImplicitTilingExtension) {
          childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);
        } else {
          childHeaderPostprocessed = normalizeTileData(childHeader, basePath);
        }
        if (childHeaderPostprocessed) {
          childrenPostprocessed.push(childHeaderPostprocessed);
          stack2.push(childHeaderPostprocessed);
        }
      }
      tile.children = childrenPostprocessed;
    }
    return root;
  }
  async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {
    const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;
    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
    const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
    const tileContentUri = tile.content?.uri;
    const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : "";
    const refine = tileset?.root?.refine;
    const rootLodMetricValue = tile.geometricError;
    const s2VolumeInfo = tile.boundingVolume.extensions?.["3DTILES_bounding_volume_S2"];
    if (s2VolumeInfo) {
      const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
      const s2VolumeBox = { box, s2VolumeInfo };
      tile.boundingVolume = s2VolumeBox;
    }
    const rootBoundingVolume = tile.boundingVolume;
    const implicitOptions = {
      contentUrlTemplate,
      subtreesUriTemplate,
      subdivisionScheme,
      subtreeLevels,
      maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,
      refine,
      basePath,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      rootLodMetricValue,
      rootBoundingVolume,
      getTileType,
      getRefine
    };
    return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);
  }
  async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {
    if (!tile) {
      return null;
    }
    const { children, contentUrl } = await parseImplicitTiles({
      subtree: rootSubtree,
      implicitOptions,
      loaderOptions
    });
    let tileContentUrl;
    let tileContent = null;
    if (contentUrl) {
      tileContentUrl = contentUrl;
      tileContent = { uri: contentUrl.replace(`${basePath}/`, "") };
    }
    const tilePostprocessed = {
      ...tile,
      id: tileContentUrl,
      contentUrl: tileContentUrl,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: tile.geometricError,
      transformMatrix: tile.transform,
      type: getTileType(tile, tileContentUrl),
      refine: getRefine(tile.refine),
      content: tileContent || tile.content,
      children
    };
    return tilePostprocessed;
  }
  function getImplicitTilingExtensionData(tile) {
    return tile?.extensions?.["3DTILES_implicit_tiling"] || tile?.implicitTiling;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/tiles-3d-loader.js
  var Tiles3DLoader = {
    dataType: null,
    batchType: null,
    id: "3d-tiles",
    name: "3D Tiles",
    module: "3d-tiles",
    version: VERSION11,
    extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
    mimeTypes: ["application/octet-stream"],
    tests: ["cmpt", "pnts", "b3dm", "i3dm"],
    parse: parse4,
    options: {
      "3d-tiles": {
        loadGLTF: true,
        decodeQuantizedPositions: false,
        isTileset: "auto",
        assetGltfUpAxis: null
      }
    }
  };
  async function parse4(data, options = {}, context) {
    const loaderOptions = options["3d-tiles"] || {};
    let isTileset;
    if (loaderOptions.isTileset === "auto") {
      isTileset = context?.url && context.url.indexOf(".json") !== -1;
    } else {
      isTileset = loaderOptions.isTileset;
    }
    return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);
  }
  async function parseTileset(data, options, context) {
    const tilesetJson = JSON.parse(new TextDecoder().decode(data));
    const tilesetUrl = context?.url || "";
    const basePath = getBaseUri(tilesetUrl);
    const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});
    const tilesetJsonPostprocessed = {
      ...tilesetJson,
      shape: "tileset3d",
      loader: Tiles3DLoader,
      url: tilesetUrl,
      queryString: context?.queryString || "",
      basePath,
      root: normalizedRoot || tilesetJson.root,
      type: TILESET_TYPE.TILES3D,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: tilesetJson.root?.geometricError || 0
    };
    return tilesetJsonPostprocessed;
  }
  async function parseTile(arrayBuffer2, options, context) {
    const tile = {
      content: {
        shape: "tile3d",
        featureIds: null
      }
    };
    const byteOffset = 0;
    await parse3DTile(arrayBuffer2, byteOffset, options, context, tile.content);
    return tile.content;
  }
  function getBaseUri(tilesetUrl) {
    return path_exports.dirname(tilesetUrl);
  }

  // ../geo-layers/src/tile-3d-layer/tile-3d-layer.ts
  var SINGLE_DATA = [0];
  var defaultProps30 = {
    getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
    pointSize: 1,
    // Disable async data loading (handling it in _loadTileSet)
    data: "",
    loader: Tiles3DLoader,
    onTilesetLoad: { type: "function", value: (tileset3d) => {
    } },
    onTileLoad: { type: "function", value: (tileHeader) => {
    } },
    onTileUnload: { type: "function", value: (tileHeader) => {
    } },
    onTileError: { type: "function", value: (tile, message2, url) => {
    } },
    _getMeshColor: { type: "function", value: (tileHeader) => [255, 255, 255] }
  };
  var Tile3DLayer = class extends CompositeLayer {
    initializeState() {
      if ("onTileLoadFail" in this.props) {
        log_default.removed("onTileLoadFail", "onTileError")();
      }
      this.state = {
        layerMap: {},
        tileset3d: null,
        activeViewports: {},
        lastUpdatedViewports: null
      };
    }
    get isLoaded() {
      return Boolean(this.state?.tileset3d?.isLoaded() && super.isLoaded);
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState({ props, oldProps, changeFlags }) {
      if (props.data && props.data !== oldProps.data) {
        this._loadTileset(props.data);
      }
      if (changeFlags.viewportChanged) {
        const { activeViewports } = this.state;
        const viewportsNumber = Object.keys(activeViewports).length;
        if (viewportsNumber) {
          this._updateTileset(activeViewports);
          this.state.lastUpdatedViewports = activeViewports;
          this.state.activeViewports = {};
        }
      }
      if (changeFlags.propsChanged) {
        const { layerMap } = this.state;
        for (const key in layerMap) {
          layerMap[key].needsUpdate = true;
        }
      }
    }
    activateViewport(viewport) {
      const { activeViewports, lastUpdatedViewports } = this.state;
      this.internalState.viewport = viewport;
      activeViewports[viewport.id] = viewport;
      const lastViewport = lastUpdatedViewports?.[viewport.id];
      if (!lastViewport || !viewport.equals(lastViewport)) {
        this.setChangeFlags({ viewportChanged: true });
        this.setNeedsUpdate();
      }
    }
    getPickingInfo({ info, sourceLayer }) {
      const sourceTile = sourceLayer && sourceLayer.props.tile;
      if (info.picked) {
        info.object = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    filterSubLayer({ layer, viewport }) {
      const { tile } = layer.props;
      const { id: viewportId } = viewport;
      return tile.selected && tile.viewportIds.includes(viewportId);
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      const layerCache = this.state.layerMap[sourceTile?.id];
      if (layerCache && layerCache.layer) {
        layerCache.layer.updateAutoHighlight(info);
      }
    }
    async _loadTileset(tilesetUrl) {
      const { loadOptions = {} } = this.props;
      const loaders = this.props.loader || this.props.loaders;
      const loader = Array.isArray(loaders) ? loaders[0] : loaders;
      const options = { loadOptions: { ...loadOptions } };
      let actualTilesetUrl = tilesetUrl;
      if (loader.preload) {
        const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
        if (preloadOptions.url) {
          actualTilesetUrl = preloadOptions.url;
        }
        if (preloadOptions.headers) {
          options.loadOptions.fetch = {
            ...options.loadOptions.fetch,
            headers: preloadOptions.headers
          };
        }
        Object.assign(options, preloadOptions);
      }
      const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
      const tileset3d = new Tileset3D(tilesetJson, {
        onTileLoad: this._onTileLoad.bind(this),
        onTileUnload: this._onTileUnload.bind(this),
        onTileError: this.props.onTileError,
        ...options
      });
      this.setState({
        tileset3d,
        layerMap: {}
      });
      this._updateTileset(this.state.activeViewports);
      this.props.onTilesetLoad(tileset3d);
    }
    _onTileLoad(tileHeader) {
      const { lastUpdatedViewports } = this.state;
      this.props.onTileLoad(tileHeader);
      this._updateTileset(lastUpdatedViewports);
      this.setNeedsUpdate();
    }
    _onTileUnload(tileHeader) {
      delete this.state.layerMap[tileHeader.id];
      this.props.onTileUnload(tileHeader);
    }
    _updateTileset(viewports) {
      if (!viewports) {
        return;
      }
      const { tileset3d } = this.state;
      const { timeline } = this.context;
      const viewportsNumber = Object.keys(viewports).length;
      if (!timeline || !viewportsNumber || !tileset3d) {
        return;
      }
      tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (tilesetChanged) {
          this.setState({ frameNumber });
        }
      });
    }
    _getSubLayer(tileHeader, oldLayer) {
      if (!tileHeader.content) {
        return null;
      }
      switch (tileHeader.type) {
        case TILE_TYPE.POINTCLOUD:
          return this._makePointCloudLayer(tileHeader, oldLayer);
        case TILE_TYPE.SCENEGRAPH:
          return this._make3DModelLayer(tileHeader);
        case TILE_TYPE.MESH:
          return this._makeSimpleMeshLayer(tileHeader, oldLayer);
        default:
          throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
      }
    }
    _makePointCloudLayer(tileHeader, oldLayer) {
      const { attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
      const { positions, normals, colors } = attributes;
      if (!positions) {
        return null;
      }
      const data = oldLayer && oldLayer.props.data || {
        header: {
          vertexCount: pointCount
        },
        attributes: {
          POSITION: positions,
          NORMAL: normals,
          COLOR_0: colors
        }
      };
      const { pointSize, getPointColor } = this.props;
      const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
      return new SubLayerClass(
        {
          pointSize
        },
        this.getSubLayerProps({
          id: "pointcloud"
        }),
        {
          id: `${this.id}-pointcloud-${tileHeader.id}`,
          tile: tileHeader,
          data,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getColor: constantRGBA || getPointColor,
          _offset: 0
        }
      );
    }
    _make3DModelLayer(tileHeader) {
      const { gltf, instances, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
      const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
      return new SubLayerClass(
        {
          _lighting: "pbr"
        },
        this.getSubLayerProps({
          id: "scenegraph"
        }),
        {
          id: `${this.id}-scenegraph-${tileHeader.id}`,
          tile: tileHeader,
          data: instances || SINGLE_DATA,
          scenegraph: gltf,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getTransformMatrix: (instance) => instance.modelMatrix,
          getPosition: [0, 0, 0],
          _offset: 0
        }
      );
    }
    _makeSimpleMeshLayer(tileHeader, oldLayer) {
      const content = tileHeader.content;
      const {
        attributes,
        indices,
        modelMatrix: modelMatrix2,
        cartographicOrigin,
        coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
        material,
        featureIds
      } = content;
      const { _getMeshColor } = this.props;
      const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
        topology: "triangle-list",
        attributes: getMeshGeometry(attributes),
        indices
      });
      const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
      return new SubLayerClass(
        this.getSubLayerProps({
          id: "mesh"
        }),
        {
          id: `${this.id}-mesh-${tileHeader.id}`,
          tile: tileHeader,
          mesh: geometry,
          data: SINGLE_DATA,
          getColor: _getMeshColor(tileHeader),
          pbrMaterial: material,
          modelMatrix: modelMatrix2,
          coordinateOrigin: cartographicOrigin,
          coordinateSystem,
          featureIds,
          _offset: 0
        }
      );
    }
    renderLayers() {
      const { tileset3d, layerMap } = this.state;
      if (!tileset3d) {
        return null;
      }
      return tileset3d.tiles.map((tile) => {
        const layerCache = layerMap[tile.id] = layerMap[tile.id] || { tile };
        let { layer } = layerCache;
        if (tile.selected) {
          if (!layer) {
            layer = this._getSubLayer(tile);
          } else if (layerCache.needsUpdate) {
            layer = this._getSubLayer(tile, layer);
            layerCache.needsUpdate = false;
          }
        }
        layerCache.layer = layer;
        return layer;
      }).filter(Boolean);
    }
  };
  Tile3DLayer.defaultProps = defaultProps30;
  Tile3DLayer.layerName = "Tile3DLayer";
  function getMeshGeometry(contentAttributes) {
    const attributes = {};
    attributes.positions = {
      ...contentAttributes.positions,
      value: new Float32Array(contentAttributes.positions.value)
    };
    if (contentAttributes.normals) {
      attributes.normals = contentAttributes.normals;
    }
    if (contentAttributes.texCoords) {
      attributes.texCoords = contentAttributes.texCoords;
    }
    if (contentAttributes.colors) {
      attributes.colors = contentAttributes.colors;
    }
    if (contentAttributes.uvRegions) {
      attributes.uvRegions = contentAttributes.uvRegions;
    }
    return attributes;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js
  var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([
    ["centerX", Float64Array.BYTES_PER_ELEMENT],
    ["centerY", Float64Array.BYTES_PER_ELEMENT],
    ["centerZ", Float64Array.BYTES_PER_ELEMENT],
    ["minHeight", Float32Array.BYTES_PER_ELEMENT],
    ["maxHeight", Float32Array.BYTES_PER_ELEMENT],
    ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT],
    ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT],
    ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT],
    ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT],
    ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT],
    ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT],
    ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]
  ]);
  function decodeZigZag(value) {
    return value >> 1 ^ -(value & 1);
  }
  function decodeHeader(dataView) {
    let position = 0;
    const header = {};
    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
      const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
      header[key] = getter.call(dataView, position, true);
      position += bytesCount;
    }
    return { header, headerEndPosition: position };
  }
  function decodeVertexData(dataView, headerEndPosition) {
    let position = headerEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = dataView.getUint32(position, true);
    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
    const elementArrayLength = vertexCount * bytesPerArrayElement;
    const uArrayStartPosition = position;
    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
    let u3 = 0;
    let v2 = 0;
    let height = 0;
    for (let i5 = 0; i5 < vertexCount; i5++) {
      u3 += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i5, true));
      v2 += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i5, true));
      height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i5, true));
      vertexData[i5] = u3;
      vertexData[i5 + vertexCount] = v2;
      vertexData[i5 + vertexCount * 2] = height;
    }
    position += elementArrayLength * 3;
    return { vertexData, vertexDataEndPosition: position };
  }
  function decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {
    let indices;
    if (bytesPerIndex === 2) {
      indices = new Uint16Array(buffer, position, indicesCount);
    } else {
      indices = new Uint32Array(buffer, position, indicesCount);
    }
    if (!encoded) {
      return indices;
    }
    let highest = 0;
    for (let i5 = 0; i5 < indices.length; ++i5) {
      const code = indices[i5];
      indices[i5] = highest - code;
      if (code === 0) {
        ++highest;
      }
    }
    return indices;
  }
  function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
    let position = vertexDataEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    if (position % bytesPerIndex !== 0) {
      position += bytesPerIndex - position % bytesPerIndex;
    }
    const triangleCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const triangleIndicesCount = triangleCount * 3;
    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
    position += triangleIndicesCount * bytesPerIndex;
    return {
      triangleIndicesEndPosition: position,
      triangleIndices
    };
  }
  function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
    let position = triangleIndicesEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    const westVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
    position += westVertexCount * bytesPerIndex;
    const southVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
    position += southVertexCount * bytesPerIndex;
    const eastVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
    position += eastVertexCount * bytesPerIndex;
    const northVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
    position += northVertexCount * bytesPerIndex;
    return {
      edgeIndicesEndPosition: position,
      westIndices,
      southIndices,
      eastIndices,
      northIndices
    };
  }
  function decodeVertexNormalsExtension(extensionDataView) {
    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
  }
  function decodeWaterMaskExtension(extensionDataView) {
    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
  }
  function decodeExtensions2(dataView, indicesEndPosition) {
    const extensions = {};
    if (dataView.byteLength <= indicesEndPosition) {
      return { extensions, extensionsEndPosition: indicesEndPosition };
    }
    let position = indicesEndPosition;
    while (position < dataView.byteLength) {
      const extensionId = dataView.getUint8(position, true);
      position += Uint8Array.BYTES_PER_ELEMENT;
      const extensionLength = dataView.getUint32(position, true);
      position += Uint32Array.BYTES_PER_ELEMENT;
      const extensionView = new DataView(dataView.buffer, position, extensionLength);
      switch (extensionId) {
        case 1: {
          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
          break;
        }
        case 2: {
          extensions.waterMask = decodeWaterMaskExtension(extensionView);
          break;
        }
        default: {
        }
      }
      position += extensionLength;
    }
    return { extensions, extensionsEndPosition: position };
  }
  var DECODING_STEPS = {
    header: 0,
    vertices: 1,
    triangleIndices: 2,
    edgeIndices: 3,
    extensions: 4
  };
  var DEFAULT_OPTIONS3 = {
    maxDecodingStep: DECODING_STEPS.extensions
  };
  function decode11(data, userOptions) {
    const options = Object.assign({}, DEFAULT_OPTIONS3, userOptions);
    const view = new DataView(data);
    const { header, headerEndPosition } = decodeHeader(view);
    if (options.maxDecodingStep < DECODING_STEPS.vertices) {
      return { header };
    }
    const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
      return { header, vertexData };
    }
    const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
      return { header, vertexData, triangleIndices };
    }
    const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.extensions) {
      return {
        header,
        vertexData,
        triangleIndices,
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      };
    }
    const { extensions } = decodeExtensions2(view, edgeIndicesEndPosition);
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices,
      extensions
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js
  function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
    const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
    const newTriangles = new triangles.constructor(outsideEdges.length * 6);
    for (let i5 = 0; i5 < outsideEdges.length; i5++) {
      const edge = outsideEdges[i5];
      updateAttributesForNewEdge({
        edge,
        edgeIndex: i5,
        attributes,
        skirtHeight,
        newPosition,
        newTexcoord0,
        newTriangles
      });
    }
    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
    const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
    return {
      attributes,
      triangles: resultTriangles
    };
  }
  function getOutsideEdgesFromTriangles(triangles) {
    const edges = [];
    for (let i5 = 0; i5 < triangles.length; i5 += 3) {
      edges.push([triangles[i5], triangles[i5 + 1]]);
      edges.push([triangles[i5 + 1], triangles[i5 + 2]]);
      edges.push([triangles[i5 + 2], triangles[i5]]);
    }
    edges.sort((a3, b2) => Math.min(...a3) - Math.min(...b2) || Math.max(...a3) - Math.max(...b2));
    const outsideEdges = [];
    let index = 0;
    while (index < edges.length) {
      if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {
        index += 2;
      } else {
        outsideEdges.push(edges[index]);
        index++;
      }
    }
    return outsideEdges;
  }
  function getOutsideEdgesFromIndices(indices, position) {
    indices.westIndices.sort((a3, b2) => position[3 * a3 + 1] - position[3 * b2 + 1]);
    indices.eastIndices.sort((a3, b2) => position[3 * b2 + 1] - position[3 * a3 + 1]);
    indices.southIndices.sort((a3, b2) => position[3 * b2] - position[3 * a3]);
    indices.northIndices.sort((a3, b2) => position[3 * a3] - position[3 * b2]);
    const edges = [];
    for (const index in indices) {
      const indexGroup = indices[index];
      for (let i5 = 0; i5 < indexGroup.length - 1; i5++) {
        edges.push([indexGroup[i5], indexGroup[i5 + 1]]);
      }
    }
    return edges;
  }
  function updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {
    const positionsLength = attributes.POSITION.value.length;
    const vertex1Offset = edgeIndex * 2;
    const vertex2Offset = edgeIndex * 2 + 1;
    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
    const triangle1Offset = edgeIndex * 2 * 3;
    newTriangles[triangle1Offset] = edge[0];
    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 2] = edge[1];
    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 4] = edge[0];
    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js
  function parseQuantizedMesh(arrayBuffer2, options = {}) {
    const { bounds } = options;
    const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode11(arrayBuffer2, DECODING_STEPS.triangleIndices);
    let triangleIndices = originalTriangleIndices;
    let attributes = getMeshAttributes(vertexData, header, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (options?.skirtHeight) {
      const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      });
      attributes = newAttributes;
      triangleIndices = newTriangles;
    }
    return {
      // Data return by this loader implementation
      loaderData: {
        header: {}
      },
      header: {
        // @ts-ignore
        vertexCount: triangleIndices.length,
        boundingBox
      },
      // TODO
      schema: void 0,
      topology: "triangle-list",
      mode: 4,
      // TRIANGLES
      indices: { value: triangleIndices, size: 1 },
      attributes
    };
  }
  function getMeshAttributes(vertexData, header, bounds) {
    const { minHeight, maxHeight } = header;
    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
    const xScale = maxX - minX;
    const yScale = maxY - minY;
    const zScale = maxHeight - minHeight;
    const nCoords = vertexData.length / 3;
    const positions = new Float32Array(nCoords * 3);
    const texCoords = new Float32Array(nCoords * 2);
    for (let i5 = 0; i5 < nCoords; i5++) {
      const x3 = vertexData[i5] / 32767;
      const y3 = vertexData[i5 + nCoords] / 32767;
      const z2 = vertexData[i5 + nCoords * 2] / 32767;
      positions[3 * i5 + 0] = x3 * xScale + minX;
      positions[3 * i5 + 1] = y3 * yScale + minY;
      positions[3 * i5 + 2] = z2 * zScale + minHeight;
      texCoords[2 * i5 + 0] = x3;
      texCoords[2 * i5 + 1] = y3;
    }
    return {
      POSITION: { value: positions, size: 3 },
      TEXCOORD_0: { value: texCoords, size: 2 }
      // TODO: Parse normals if they exist in the file
      // NORMAL: {}, - optional, but creates the high poly look with lighting
    };
  }

  // ../../node_modules/@mapbox/martini/index.js
  var Martini = class {
    constructor(gridSize = 257) {
      this.gridSize = gridSize;
      const tileSize = gridSize - 1;
      if (tileSize & tileSize - 1)
        throw new Error(
          `Expected grid size to be 2^n+1, got ${gridSize}.`
        );
      this.numTriangles = tileSize * tileSize * 2 - 2;
      this.numParentTriangles = this.numTriangles - tileSize * tileSize;
      this.indices = new Uint32Array(this.gridSize * this.gridSize);
      this.coords = new Uint16Array(this.numTriangles * 4);
      for (let i5 = 0; i5 < this.numTriangles; i5++) {
        let id = i5 + 2;
        let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
        if (id & 1) {
          bx = by = cx = tileSize;
        } else {
          ax = ay = cy = tileSize;
        }
        while ((id >>= 1) > 1) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (id & 1) {
            bx = ax;
            by = ay;
            ax = cx;
            ay = cy;
          } else {
            ax = bx;
            ay = by;
            bx = cx;
            by = cy;
          }
          cx = mx;
          cy = my;
        }
        const k2 = i5 * 4;
        this.coords[k2 + 0] = ax;
        this.coords[k2 + 1] = ay;
        this.coords[k2 + 2] = bx;
        this.coords[k2 + 3] = by;
      }
    }
    createTile(terrain) {
      return new Tile(terrain, this);
    }
  };
  var Tile = class {
    constructor(terrain, martini) {
      const size = martini.gridSize;
      if (terrain.length !== size * size)
        throw new Error(
          `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
        );
      this.terrain = terrain;
      this.martini = martini;
      this.errors = new Float32Array(terrain.length);
      this.update();
    }
    update() {
      const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
      const { terrain, errors } = this;
      for (let i5 = numTriangles - 1; i5 >= 0; i5--) {
        const k2 = i5 * 4;
        const ax = coords[k2 + 0];
        const ay = coords[k2 + 1];
        const bx = coords[k2 + 2];
        const by = coords[k2 + 3];
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        const cx = mx + my - ay;
        const cy = my + ax - mx;
        const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
        const middleIndex = my * size + mx;
        const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
        errors[middleIndex] = Math.max(errors[middleIndex], middleError);
        if (i5 < numParentTriangles) {
          const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
          const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
        }
      }
    }
    getMesh(maxError = 0) {
      const { gridSize: size, indices } = this.martini;
      const { errors } = this;
      let numVertices = 0;
      let numTriangles = 0;
      const max6 = size - 1;
      indices.fill(0);
      function countElements(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          countElements(cx, cy, ax, ay, mx, my);
          countElements(bx, by, cx, cy, mx, my);
        } else {
          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
          numTriangles++;
        }
      }
      countElements(0, 0, max6, max6, max6, 0);
      countElements(max6, max6, 0, 0, 0, max6);
      const vertices = new Uint16Array(numVertices * 2);
      const triangles = new Uint32Array(numTriangles * 3);
      let triIndex = 0;
      function processTriangle(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          processTriangle(cx, cy, ax, ay, mx, my);
          processTriangle(bx, by, cx, cy, mx, my);
        } else {
          const a3 = indices[ay * size + ax] - 1;
          const b2 = indices[by * size + bx] - 1;
          const c2 = indices[cy * size + cx] - 1;
          vertices[2 * a3] = ax;
          vertices[2 * a3 + 1] = ay;
          vertices[2 * b2] = bx;
          vertices[2 * b2 + 1] = by;
          vertices[2 * c2] = cx;
          vertices[2 * c2 + 1] = cy;
          triangles[triIndex++] = a3;
          triangles[triIndex++] = b2;
          triangles[triIndex++] = c2;
        }
      }
      processTriangle(0, 0, max6, max6, max6, 0);
      processTriangle(max6, max6, 0, 0, 0, max6);
      return { vertices, triangles };
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/lib/delatin/index.js
  var Delatin = class {
    constructor(data, width, height = width) {
      this.data = data;
      this.width = width;
      this.height = height;
      this.coords = [];
      this.triangles = [];
      this._halfedges = [];
      this._candidates = [];
      this._queueIndices = [];
      this._queue = [];
      this._errors = [];
      this._rms = [];
      this._pending = [];
      this._pendingLen = 0;
      this._rmsSum = 0;
      const x1 = width - 1;
      const y1 = height - 1;
      const p0 = this._addPoint(0, 0);
      const p1 = this._addPoint(x1, 0);
      const p22 = this._addPoint(0, y1);
      const p3 = this._addPoint(x1, y1);
      const t0 = this._addTriangle(p3, p0, p22, -1, -1, -1);
      this._addTriangle(p0, p3, p1, t0, -1, -1);
      this._flush();
    }
    // refine the mesh until its maximum error gets below the given one
    run(maxError = 1) {
      while (this.getMaxError() > maxError) {
        this.refine();
      }
    }
    // refine the mesh with a single point
    refine() {
      this._step();
      this._flush();
    }
    // max error of the current mesh
    getMaxError() {
      return this._errors[0];
    }
    // root-mean-square deviation of the current mesh
    getRMSD() {
      return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
    }
    // height value at a given position
    heightAt(x3, y3) {
      return this.data[this.width * y3 + x3];
    }
    // rasterize and queue all triangles that got added or updated in _step
    _flush() {
      const coords = this.coords;
      for (let i5 = 0; i5 < this._pendingLen; i5++) {
        const t3 = this._pending[i5];
        const a3 = 2 * this.triangles[t3 * 3 + 0];
        const b2 = 2 * this.triangles[t3 * 3 + 1];
        const c2 = 2 * this.triangles[t3 * 3 + 2];
        this._findCandidate(coords[a3], coords[a3 + 1], coords[b2], coords[b2 + 1], coords[c2], coords[c2 + 1], t3);
      }
      this._pendingLen = 0;
    }
    // rasterize a triangle, find its max error, and queue it for processing
    _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t3) {
      const minX = Math.min(p0x, p1x, p2x);
      const minY = Math.min(p0y, p1y, p2y);
      const maxX = Math.max(p0x, p1x, p2x);
      const maxY = Math.max(p0y, p1y, p2y);
      let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
      let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
      let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
      const a01 = p1y - p0y;
      const b01 = p0x - p1x;
      const a12 = p2y - p1y;
      const b12 = p1x - p2x;
      const a20 = p0y - p2y;
      const b20 = p2x - p0x;
      const a3 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
      const z0 = this.heightAt(p0x, p0y) / a3;
      const z1 = this.heightAt(p1x, p1y) / a3;
      const z2 = this.heightAt(p2x, p2y) / a3;
      let maxError = 0;
      let mx = 0;
      let my = 0;
      let rms = 0;
      for (let y3 = minY; y3 <= maxY; y3++) {
        let dx = 0;
        if (w00 < 0 && a12 !== 0) {
          dx = Math.max(dx, Math.floor(-w00 / a12));
        }
        if (w01 < 0 && a20 !== 0) {
          dx = Math.max(dx, Math.floor(-w01 / a20));
        }
        if (w02 < 0 && a01 !== 0) {
          dx = Math.max(dx, Math.floor(-w02 / a01));
        }
        let w0 = w00 + a12 * dx;
        let w1 = w01 + a20 * dx;
        let w2 = w02 + a01 * dx;
        let wasInside = false;
        for (let x3 = minX + dx; x3 <= maxX; x3++) {
          if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
            wasInside = true;
            const z3 = z0 * w0 + z1 * w1 + z2 * w2;
            const dz = Math.abs(z3 - this.heightAt(x3, y3));
            rms += dz * dz;
            if (dz > maxError) {
              maxError = dz;
              mx = x3;
              my = y3;
            }
          } else if (wasInside) {
            break;
          }
          w0 += a12;
          w1 += a20;
          w2 += a01;
        }
        w00 += b12;
        w01 += b20;
        w02 += b01;
      }
      if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
        maxError = 0;
      }
      this._candidates[2 * t3] = mx;
      this._candidates[2 * t3 + 1] = my;
      this._rms[t3] = rms;
      this._queuePush(t3, maxError, rms);
    }
    // process the next triangle in the queue, splitting it with a new point
    _step() {
      const t3 = this._queuePop();
      const e0 = t3 * 3 + 0;
      const e1 = t3 * 3 + 1;
      const e22 = t3 * 3 + 2;
      const p0 = this.triangles[e0];
      const p1 = this.triangles[e1];
      const p22 = this.triangles[e22];
      const ax = this.coords[2 * p0];
      const ay = this.coords[2 * p0 + 1];
      const bx = this.coords[2 * p1];
      const by = this.coords[2 * p1 + 1];
      const cx = this.coords[2 * p22];
      const cy = this.coords[2 * p22 + 1];
      const px = this._candidates[2 * t3];
      const py = this._candidates[2 * t3 + 1];
      const pn = this._addPoint(px, py);
      if (orient(ax, ay, bx, by, px, py) === 0) {
        this._handleCollinear(pn, e0);
      } else if (orient(bx, by, cx, cy, px, py) === 0) {
        this._handleCollinear(pn, e1);
      } else if (orient(cx, cy, ax, ay, px, py) === 0) {
        this._handleCollinear(pn, e22);
      } else {
        const h0 = this._halfedges[e0];
        const h1 = this._halfedges[e1];
        const h22 = this._halfedges[e22];
        const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
        const t1 = this._addTriangle(p1, p22, pn, h1, -1, t0 + 1);
        const t22 = this._addTriangle(p22, p0, pn, h22, t0 + 2, t1 + 1);
        this._legalize(t0);
        this._legalize(t1);
        this._legalize(t22);
      }
    }
    // add coordinates for a new vertex
    _addPoint(x3, y3) {
      const i5 = this.coords.length >> 1;
      this.coords.push(x3, y3);
      return i5;
    }
    // add or update a triangle in the mesh
    _addTriangle(a3, b2, c2, ab, bc, ca, e3 = this.triangles.length) {
      const t3 = e3 / 3;
      this.triangles[e3 + 0] = a3;
      this.triangles[e3 + 1] = b2;
      this.triangles[e3 + 2] = c2;
      this._halfedges[e3 + 0] = ab;
      this._halfedges[e3 + 1] = bc;
      this._halfedges[e3 + 2] = ca;
      if (ab >= 0) {
        this._halfedges[ab] = e3 + 0;
      }
      if (bc >= 0) {
        this._halfedges[bc] = e3 + 1;
      }
      if (ca >= 0) {
        this._halfedges[ca] = e3 + 2;
      }
      this._candidates[2 * t3 + 0] = 0;
      this._candidates[2 * t3 + 1] = 0;
      this._queueIndices[t3] = -1;
      this._rms[t3] = 0;
      this._pending[this._pendingLen++] = t3;
      return e3;
    }
    _legalize(a3) {
      const b2 = this._halfedges[a3];
      if (b2 < 0) {
        return;
      }
      const a0 = a3 - a3 % 3;
      const b0 = b2 - b2 % 3;
      const al = a0 + (a3 + 1) % 3;
      const ar = a0 + (a3 + 2) % 3;
      const bl = b0 + (b2 + 2) % 3;
      const br = b0 + (b2 + 1) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a3];
      const pl = this.triangles[al];
      const p1 = this.triangles[bl];
      const coords = this.coords;
      if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
        return;
      }
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(a0 / 3);
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
      const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
      this._legalize(t0 + 1);
      this._legalize(t1 + 2);
    }
    // handle a case where new vertex is on the edge of a triangle
    _handleCollinear(pn, a3) {
      const a0 = a3 - a3 % 3;
      const al = a0 + (a3 + 1) % 3;
      const ar = a0 + (a3 + 2) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a3];
      const pl = this.triangles[al];
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const b2 = this._halfedges[a3];
      if (b2 < 0) {
        const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
        const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
        this._legalize(t02 + 1);
        this._legalize(t12 + 2);
        return;
      }
      const b0 = b2 - b2 % 3;
      const bl = b0 + (b2 + 2) % 3;
      const br = b0 + (b2 + 1) % 3;
      const p1 = this.triangles[bl];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
      const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
      const t22 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
      const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t22 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t22);
      this._legalize(t3);
    }
    // priority queue methods
    _queuePush(t3, error, rms) {
      const i5 = this._queue.length;
      this._queueIndices[t3] = i5;
      this._queue.push(t3);
      this._errors.push(error);
      this._rmsSum += rms;
      this._queueUp(i5);
    }
    _queuePop() {
      const n3 = this._queue.length - 1;
      this._queueSwap(0, n3);
      this._queueDown(0, n3);
      return this._queuePopBack();
    }
    _queuePopBack() {
      const t3 = this._queue.pop();
      this._errors.pop();
      this._rmsSum -= this._rms[t3];
      this._queueIndices[t3] = -1;
      return t3;
    }
    _queueRemove(t3) {
      const i5 = this._queueIndices[t3];
      if (i5 < 0) {
        const it = this._pending.indexOf(t3);
        if (it !== -1) {
          this._pending[it] = this._pending[--this._pendingLen];
        } else {
          throw new Error("Broken triangulation (something went wrong).");
        }
        return;
      }
      const n3 = this._queue.length - 1;
      if (n3 !== i5) {
        this._queueSwap(i5, n3);
        if (!this._queueDown(i5, n3)) {
          this._queueUp(i5);
        }
      }
      this._queuePopBack();
    }
    _queueLess(i5, j2) {
      return this._errors[i5] > this._errors[j2];
    }
    _queueSwap(i5, j2) {
      const pi = this._queue[i5];
      const pj = this._queue[j2];
      this._queue[i5] = pj;
      this._queue[j2] = pi;
      this._queueIndices[pi] = j2;
      this._queueIndices[pj] = i5;
      const e3 = this._errors[i5];
      this._errors[i5] = this._errors[j2];
      this._errors[j2] = e3;
    }
    _queueUp(j0) {
      let j2 = j0;
      while (true) {
        const i5 = j2 - 1 >> 1;
        if (i5 === j2 || !this._queueLess(j2, i5)) {
          break;
        }
        this._queueSwap(i5, j2);
        j2 = i5;
      }
    }
    _queueDown(i0, n3) {
      let i5 = i0;
      while (true) {
        const j1 = 2 * i5 + 1;
        if (j1 >= n3 || j1 < 0) {
          break;
        }
        const j2 = j1 + 1;
        let j3 = j1;
        if (j2 < n3 && this._queueLess(j2, j1)) {
          j3 = j2;
        }
        if (!this._queueLess(j3, i5)) {
          break;
        }
        this._queueSwap(i5, j3);
        i5 = j3;
      }
      return i5 > i0;
    }
  };
  function orient(ax, ay, bx, by, cx, cy) {
    return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js
  function makeTerrainMeshFromImage(terrainImage, terrainOptions) {
    const { meshMaxError, bounds, elevationDecoder } = terrainOptions;
    const { data, width, height } = terrainImage;
    let terrain;
    let mesh;
    switch (terrainOptions.tesselator) {
      case "martini":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        break;
      case "delatin":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        break;
      default:
        if (width === height && !(height & width - 1)) {
          terrain = getTerrain(data, width, height, elevationDecoder, "martini");
          mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        } else {
          terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
          mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        }
        break;
    }
    const { vertices } = mesh;
    let { triangles } = mesh;
    let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (terrainOptions.skirtHeight) {
      const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
      attributes = newAttributes;
      triangles = newTriangles;
    }
    return {
      // Data return by this loader implementation
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangles.length,
        boundingBox
      },
      mode: 4,
      // TRIANGLES
      indices: { value: Uint32Array.from(triangles), size: 1 },
      attributes
    };
  }
  function getMartiniTileMesh(meshMaxError, width, terrain) {
    const gridSize = width + 1;
    const martini = new Martini(gridSize);
    const tile = martini.createTile(terrain);
    const { vertices, triangles } = tile.getMesh(meshMaxError);
    return { vertices, triangles };
  }
  function getDelatinTileMesh(meshMaxError, width, height, terrain) {
    const tin = new Delatin(terrain, width + 1, height + 1);
    tin.run(meshMaxError);
    const { coords, triangles } = tin;
    const vertices = coords;
    return { vertices, triangles };
  }
  function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
    const { rScaler, bScaler, gScaler, offset } = elevationDecoder;
    const terrain = new Float32Array((width + 1) * (height + 1));
    for (let i5 = 0, y3 = 0; y3 < height; y3++) {
      for (let x3 = 0; x3 < width; x3++, i5++) {
        const k2 = i5 * 4;
        const r3 = imageData[k2 + 0];
        const g2 = imageData[k2 + 1];
        const b2 = imageData[k2 + 2];
        terrain[i5 + y3] = r3 * rScaler + g2 * gScaler + b2 * bScaler + offset;
      }
    }
    if (tesselator === "martini") {
      for (let i5 = (width + 1) * width, x3 = 0; x3 < width; x3++, i5++) {
        terrain[i5] = terrain[i5 - width - 1];
      }
      for (let i5 = height, y3 = 0; y3 < height + 1; y3++, i5 += height + 1) {
        terrain[i5] = terrain[i5 - 1];
      }
    }
    return terrain;
  }
  function getMeshAttributes2(vertices, terrain, width, height, bounds) {
    const gridSize = width + 1;
    const numOfVerticies = vertices.length / 2;
    const positions = new Float32Array(numOfVerticies * 3);
    const texCoords = new Float32Array(numOfVerticies * 2);
    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
    const xScale = (maxX - minX) / width;
    const yScale = (maxY - minY) / height;
    for (let i5 = 0; i5 < numOfVerticies; i5++) {
      const x3 = vertices[i5 * 2];
      const y3 = vertices[i5 * 2 + 1];
      const pixelIdx = y3 * gridSize + x3;
      positions[3 * i5 + 0] = x3 * xScale + minX;
      positions[3 * i5 + 1] = -y3 * yScale + maxY;
      positions[3 * i5 + 2] = terrain[pixelIdx];
      texCoords[2 * i5 + 0] = x3 / width;
      texCoords[2 * i5 + 1] = y3 / height;
    }
    return {
      POSITION: { value: positions, size: 3 },
      TEXCOORD_0: { value: texCoords, size: 2 }
      // NORMAL: {}, - optional, but creates the high poly look with lighting
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/utils/version.js
  var VERSION12 = true ? "4.2.1" : "latest";

  // ../../node_modules/@loaders.gl/terrain/dist/terrain-loader.js
  var TerrainLoader = {
    dataType: null,
    batchType: null,
    name: "Terrain",
    id: "terrain",
    module: "terrain",
    version: VERSION12,
    worker: true,
    extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
    mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
    options: {
      terrain: {
        tesselator: "auto",
        bounds: void 0,
        meshMaxError: 10,
        elevationDecoder: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        },
        skirtHeight: void 0
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/quantized-mesh-loader.js
  var QuantizedMeshLoader = {
    dataType: null,
    // Mesh,
    batchType: null,
    name: "Quantized Mesh",
    id: "quantized-mesh",
    module: "terrain",
    version: VERSION12,
    worker: true,
    extensions: ["terrain"],
    mimeTypes: ["application/vnd.quantized-mesh"],
    options: {
      "quantized-mesh": {
        bounds: [0, 0, 1, 1],
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/index.js
  var TerrainLoader2 = {
    ...TerrainLoader,
    parse: parseTerrain
  };
  async function parseTerrain(arrayBuffer2, options, context) {
    const loadImageOptions = {
      ...options,
      mimeType: "application/x.image",
      image: { ...options?.image, type: "data" }
    };
    const image = await parseFromContext(arrayBuffer2, [], loadImageOptions, context);
    const terrainOptions = { ...TerrainLoader2.options.terrain, ...options?.terrain };
    return makeTerrainMeshFromImage(image, terrainOptions);
  }
  var QuantizedMeshLoader2 = {
    ...QuantizedMeshLoader,
    parseSync: (arrayBuffer2, options) => parseQuantizedMesh(arrayBuffer2, options?.["quantized-mesh"]),
    parse: async (arrayBuffer2, options) => parseQuantizedMesh(arrayBuffer2, options?.["quantized-mesh"])
  };

  // ../geo-layers/src/terrain-layer/terrain-layer.ts
  var DUMMY_DATA = [1];
  var defaultProps31 = {
    ...TileLayer.defaultProps,
    // Image url that encodes height data
    elevationData: urlType,
    // Image url to use as texture
    texture: { ...urlType, optional: true },
    // Martini error tolerance in meters, smaller number -> more detailed mesh
    meshMaxError: { type: "number", value: 4 },
    // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates
    bounds: { type: "array", value: null, optional: true, compare: true },
    // Color to use if texture is unavailable
    color: { type: "color", value: [255, 255, 255] },
    // Object to decode height data, from (r, g, b) to height in meters
    elevationDecoder: {
      type: "object",
      value: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      }
    },
    // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.
    workerUrl: "",
    // Same as SimpleMeshLayer wireframe
    wireframe: false,
    material: true,
    loaders: [TerrainLoader]
  };
  function urlTemplateToUpdateTrigger(template) {
    if (Array.isArray(template)) {
      return template.join(";");
    }
    return template || "";
  }
  var TerrainLayer = class extends CompositeLayer {
    updateState({ props, oldProps }) {
      const elevationDataChanged = props.elevationData !== oldProps.elevationData;
      if (elevationDataChanged) {
        const { elevationData } = props;
        const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
        this.setState({ isTiled });
      }
      const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
      if (!this.state.isTiled && shouldReload) {
        const terrain = this.loadTerrain(props);
        this.setState({ terrain });
      }
      if (props.workerUrl) {
        log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
      }
    }
    loadTerrain({
      elevationData,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    }) {
      if (!elevationData) {
        return null;
      }
      let loadOptions = this.getLoadOptions();
      loadOptions = {
        ...loadOptions,
        terrain: {
          skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
          ...loadOptions?.terrain,
          bounds,
          meshMaxError,
          elevationDecoder
        }
      };
      const { fetch: fetch2 } = this.props;
      return fetch2(elevationData, { propName: "elevationData", layer: this, loadOptions, signal });
    }
    getTiledTerrainData(tile) {
      const { elevationData, fetch: fetch2, texture, elevationDecoder, meshMaxError } = this.props;
      const { viewport } = this.context;
      const dataUrl = getURLFromTemplate(elevationData, tile);
      const textureUrl = texture && getURLFromTemplate(texture, tile);
      const { signal } = tile;
      let bottomLeft = [0, 0];
      let topRight = [0, 0];
      if (viewport.isGeospatial) {
        const bbox = tile.bbox;
        bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
        topRight = viewport.projectFlat([bbox.east, bbox.north]);
      } else {
        const bbox = tile.bbox;
        bottomLeft = [bbox.left, bbox.bottom];
        topRight = [bbox.right, bbox.top];
      }
      const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
      const terrain = this.loadTerrain({
        elevationData: dataUrl,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      });
      const surface = textureUrl ? (
        // If surface image fails to load, the tile should still be displayed
        fetch2(textureUrl, { propName: "texture", layer: this, loaders: [], signal }).catch((_2) => null)
      ) : Promise.resolve(null);
      return Promise.all([terrain, surface]);
    }
    renderSubLayers(props) {
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      const { color, wireframe, material } = this.props;
      const { data } = props;
      if (!data) {
        return null;
      }
      const [mesh, texture] = data;
      return new SubLayerClass(props, {
        data: DUMMY_DATA,
        mesh,
        texture,
        _instanced: false,
        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
        getPosition: (d2) => [0, 0, 0],
        getColor: color,
        wireframe,
        material
      });
    }
    // Update zRange of viewport
    onViewportLoad(tiles) {
      if (!tiles) {
        return;
      }
      const { zRange } = this.state;
      const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
        const bounds = arr[0].header.boundingBox;
        return bounds.map((bound) => bound[2]);
      });
      if (ranges.length === 0) {
        return;
      }
      const minZ = Math.min(...ranges.map((x3) => x3[0]));
      const maxZ = Math.max(...ranges.map((x3) => x3[1]));
      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
        this.setState({ zRange: [minZ, maxZ] });
      }
    }
    renderLayers() {
      const {
        color,
        material,
        elevationData,
        texture,
        wireframe,
        meshMaxError,
        elevationDecoder,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      } = this.props;
      if (this.state.isTiled) {
        return new TileLayer(
          this.getSubLayerProps({
            id: "tiles"
          }),
          {
            getTileData: this.getTiledTerrainData.bind(this),
            renderSubLayers: this.renderSubLayers.bind(this),
            updateTriggers: {
              getTileData: {
                elevationData: urlTemplateToUpdateTrigger(elevationData),
                texture: urlTemplateToUpdateTrigger(texture),
                meshMaxError,
                elevationDecoder
              }
            },
            onViewportLoad: this.onViewportLoad.bind(this),
            zRange: this.state.zRange || null,
            tileSize,
            maxZoom,
            minZoom,
            extent,
            maxRequests,
            onTileLoad,
            onTileUnload,
            onTileError,
            maxCacheSize,
            maxCacheByteSize,
            refinementStrategy
          }
        );
      }
      if (!elevationData) {
        return null;
      }
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      return new SubLayerClass(
        this.getSubLayerProps({
          id: "mesh"
        }),
        {
          data: DUMMY_DATA,
          mesh: this.state.terrain,
          texture,
          _instanced: false,
          getPosition: (d2) => [0, 0, 0],
          getColor: color,
          material,
          wireframe
        }
      );
    }
  };
  TerrainLayer.defaultProps = defaultProps31;
  TerrainLayer.layerName = "TerrainLayer";

  // ../extensions/src/brushing/shader-module.ts
  var uniformBlock20 = (
    /* glsl */
    `uniform brushingUniforms {
  bool enabled;
  highp int target;
  vec2 mousePos;
  float radius;
} brushing;
`
  );
  var vertex2 = (
    /* glsl */
    `
  in vec2 brushingTargets;

  out float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing.enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing.mousePos);
    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);

    return distance <= brushing.radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`
  );
  var vs9 = `
${uniformBlock20}
${vertex2}
`;
  var fragment2 = (
    /* glsl */
    `
  in float brushing_isVisible;
`
  );
  var fs7 = `
${uniformBlock20}
${fragment2}
`;
  var TARGET = {
    source: 0,
    target: 1,
    custom: 2,
    source_target: 3
  };
  var inject = {
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing.target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing.target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing.target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      brushingTarget = brushingTargets;
    }
    bool visible;
    if (brushing.target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `
    ),
    "fs:DECKGL_FILTER_COLOR": `
    if (brushing.enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
  };
  var shader_module_default = {
    name: "brushing",
    dependencies: [project_default],
    vs: vs9,
    fs: fs7,
    inject,
    getUniforms: (opts) => {
      if (!opts || !("viewport" in opts)) {
        return {};
      }
      const {
        brushingEnabled = true,
        brushingRadius = 1e4,
        brushingTarget = "source",
        mousePosition,
        viewport
      } = opts;
      return {
        enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
        radius: brushingRadius,
        target: TARGET[brushingTarget] || 0,
        mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
      };
    },
    uniformTypes: {
      enabled: "i32",
      target: "i32",
      mousePos: "vec2<f32>",
      radius: "f32"
    }
  };

  // ../extensions/src/brushing/brushing-extension.ts
  var defaultProps32 = {
    getBrushingTarget: { type: "accessor", value: [0, 0] },
    brushingTarget: "source",
    brushingEnabled: true,
    brushingRadius: 1e4
  };
  var BrushingExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [shader_module_default]
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.add({
          brushingTargets: {
            size: 2,
            stepMode: "dynamic",
            accessor: "getBrushingTarget"
          }
        });
      }
      const onMouseMove = () => {
        this.getCurrentLayer()?.setNeedsRedraw();
      };
      this.state.onMouseMove = onMouseMove;
      if (context.deck) {
        context.deck.eventManager.on({
          pointermove: onMouseMove,
          pointerleave: onMouseMove
        });
      }
    }
    finalizeState(context, extension) {
      if (context.deck) {
        const onMouseMove = this.state.onMouseMove;
        context.deck.eventManager.off({
          pointermove: onMouseMove,
          pointerleave: onMouseMove
        });
      }
    }
    draw(params, extension) {
      const { viewport, mousePosition } = params.context;
      const { brushingEnabled, brushingRadius, brushingTarget } = this.props;
      const brushingProps = {
        viewport,
        mousePosition,
        brushingEnabled,
        brushingRadius,
        brushingTarget
      };
      this.setShaderModuleProps({ brushing: brushingProps });
    }
  };
  BrushingExtension.defaultProps = defaultProps32;
  BrushingExtension.extensionName = "BrushingExtension";

  // ../extensions/src/data-filter/shader-module.ts
  var uniformBlock21 = (
    /* glsl */
    `uniform dataFilterUniforms {
  bool useSoftMargin;
  bool enabled;
  bool transformSize;
  bool transformColor;
#ifdef DATAFILTER_TYPE
  DATAFILTER_TYPE min;
  DATAFILTER_TYPE softMin;
  DATAFILTER_TYPE softMax;
  DATAFILTER_TYPE max;
#ifdef DATAFILTER_DOUBLE
  DATAFILTER_TYPE min64High;
  DATAFILTER_TYPE max64High;
#endif
#endif
#ifdef DATACATEGORY_TYPE
  highp uvec4 categoryBitMask;
#endif
} dataFilter;
`
  );
  var vertex3 = (
    /* glsl */
    `
#ifdef DATAFILTER_TYPE
  in DATAFILTER_TYPE filterValues;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE filterValues64Low;
#endif
#endif

#ifdef DATACATEGORY_TYPE
  in DATACATEGORY_TYPE filterCategoryValues;
#endif

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}

#ifdef DATAFILTER_TYPE
  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
    if (dataFilter.useSoftMargin) {
      // smoothstep results are undefined if edge0 \u2265 edge1
      // Fallback to ignore filterSoftRange if it is truncated by filterRange
      DATAFILTER_TYPE leftInRange = mix(
        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),
        step(dataFilter.min, valueFromMin),
        step(dataFilter.softMin, dataFilter.min)
      );
      DATAFILTER_TYPE rightInRange = mix(
        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),
        step(valueFromMax, dataFilter.max),
        step(dataFilter.max, dataFilter.softMax)
      );
      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)
      );
    }
  }
#endif

#ifdef DATACATEGORY_TYPE
  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {
    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
    uvec2 dataFilter_masks = uvec2(
      dataFilter.categoryBitMask[category.x / 32u],
      dataFilter.categoryBitMask[category.y / 32u + 2u]
    );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;
    #else // Four 32-bit masks
    uvec4 dataFilter_masks = dataFilter.categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);
    dataFilter_bits &= 1u;

    #if DATACATEGORY_CHANNELS == 1
    if(dataFilter_bits == 0u) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;
    #endif
  }
#endif
`
  );
  var vs10 = `
${uniformBlock21}
${vertex3}
`;
  var fragment3 = (
    /* glsl */
    `
in float dataFilter_value;
`
  );
  var fs8 = `
${uniformBlock21}
${fragment3}
`;
  function getUniforms6(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const {
      filterRange = [-1, 1],
      filterEnabled = true,
      filterTransformSize = true,
      filterTransformColor = true,
      categoryBitMask
    } = opts;
    const filterSoftRange = opts.filterSoftRange || filterRange;
    return {
      ...Number.isFinite(filterRange[0]) ? {
        min: filterRange[0],
        softMin: filterSoftRange[0],
        softMax: filterSoftRange[1],
        max: filterRange[1]
      } : {
        min: filterRange.map((r3) => r3[0]),
        softMin: filterSoftRange.map((r3) => r3[0]),
        softMax: filterSoftRange.map((r3) => r3[1]),
        max: filterRange.map((r3) => r3[1])
      },
      enabled: filterEnabled,
      useSoftMargin: Boolean(opts.filterSoftRange),
      transformSize: filterEnabled && filterTransformSize,
      transformColor: filterEnabled && filterTransformColor,
      ...categoryBitMask && { categoryBitMask }
    };
  }
  function getUniforms64(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const uniforms = getUniforms6(opts);
    if (Number.isFinite(uniforms.min)) {
      const min64High = Math.fround(uniforms.min);
      uniforms.min -= min64High;
      uniforms.softMin -= min64High;
      uniforms.min64High = min64High;
      const max64High = Math.fround(uniforms.max);
      uniforms.max -= max64High;
      uniforms.softMax -= max64High;
      uniforms.max64High = max64High;
    } else {
      const min64High = uniforms.min.map(Math.fround);
      uniforms.min = uniforms.min.map((x3, i5) => x3 - min64High[i5]);
      uniforms.softMin = uniforms.softMin.map((x3, i5) => x3 - min64High[i5]);
      uniforms.min64High = min64High;
      const max64High = uniforms.max.map(Math.fround);
      uniforms.max = uniforms.max.map((x3, i5) => x3 - max64High[i5]);
      uniforms.softMax = uniforms.softMax.map((x3, i5) => x3 - max64High[i5]);
      uniforms.max64High = max64High;
    }
    return uniforms;
  }
  var inject2 = {
    "vs:#main-start": (
      /* glsl */
      `
    dataFilter_value = 1.0;
    if (dataFilter.enabled) {
      #ifdef DATAFILTER_TYPE
        #ifdef DATAFILTER_DOUBLE
          dataFilter_setValue(
            filterValues - dataFilter.min64High + filterValues64Low,
            filterValues - dataFilter.max64High + filterValues64Low
          );
        #else
          dataFilter_setValue(filterValues, filterValues);
        #endif
      #endif

      #ifdef DATACATEGORY_TYPE
        dataFilter_setCategoryValue(filterCategoryValues);
      #endif
    }
  `
    ),
    "vs:#main-end": (
      /* glsl */
      `
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `
    ),
    "vs:DECKGL_FILTER_SIZE": (
      /* glsl */
      `
    if (dataFilter.transformSize) {
      size = size * dataFilter_value;
    }
  `
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
    if (dataFilter_value == 0.0) discard;
    if (dataFilter.transformColor) {
      color.a *= dataFilter_value;
    }
  `
    )
  };
  function uniformTypesFromOptions(opts) {
    const { categorySize, filterSize, fp64: fp642 } = opts;
    const uniformTypes = {
      useSoftMargin: "i32",
      enabled: "i32",
      transformSize: "i32",
      transformColor: "i32"
    };
    if (filterSize) {
      const uniformFormat = filterSize === 1 ? "f32" : `vec${filterSize}<f32>`;
      uniformTypes.min = uniformFormat;
      uniformTypes.softMin = uniformFormat;
      uniformTypes.softMax = uniformFormat;
      uniformTypes.max = uniformFormat;
      if (fp642) {
        uniformTypes.min64High = uniformFormat;
        uniformTypes.max64High = uniformFormat;
      }
    }
    if (categorySize) {
      uniformTypes.categoryBitMask = "vec4<i32>";
    }
    return uniformTypes;
  }
  var dataFilter = {
    name: "dataFilter",
    vs: vs10,
    fs: fs8,
    inject: inject2,
    getUniforms: getUniforms6,
    uniformTypesFromOptions
  };
  var dataFilter64 = {
    name: "dataFilter",
    vs: vs10,
    fs: fs8,
    inject: inject2,
    getUniforms: getUniforms64,
    uniformTypesFromOptions
  };

  // ../extensions/src/data-filter/aggregator.ts
  var AGGREGATE_VS = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
  var AGGREGATE_FS = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;
  var FLOAT_TARGET_FEATURES = [
    "float32-renderable-webgl",
    // ability to render to float texture
    "texture-blend-float-webgl"
    // ability to blend when rendering to float texture
  ];
  function supportsFloatTarget(device) {
    return FLOAT_TARGET_FEATURES.every((feature) => device.features.has(feature));
  }
  function getFramebuffer4(device, useFloatTarget) {
    if (useFloatTarget) {
      return device.createFramebuffer({
        width: 1,
        height: 1,
        colorAttachments: [
          device.createTexture({
            format: "rgba32float",
            mipmaps: false
          })
        ]
      });
    }
    return device.createFramebuffer({
      width: 256,
      height: 64,
      colorAttachments: [device.createTexture({ format: "rgba8unorm", mipmaps: false })]
    });
  }
  function getModel(device, bufferLayout, shaderOptions, useFloatTarget) {
    shaderOptions.defines.NON_INSTANCED_MODEL = 1;
    if (useFloatTarget) {
      shaderOptions.defines.FLOAT_TARGET = 1;
    }
    return new Model(device, {
      id: "data-filter-aggregation-model",
      vertexCount: 1,
      isInstanced: false,
      topology: "point-list",
      disableWarnings: true,
      vs: AGGREGATE_VS,
      fs: AGGREGATE_FS,
      bufferLayout,
      ...shaderOptions
    });
  }
  var parameters = {
    blend: true,
    blendColorSrcFactor: "one",
    blendColorDstFactor: "one",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one",
    blendColorOperation: "add",
    blendAlphaOperation: "add",
    depthCompare: "never"
  };

  // ../extensions/src/data-filter/data-filter-extension.ts
  var defaultProps33 = {
    getFilterValue: { type: "accessor", value: 0 },
    getFilterCategory: { type: "accessor", value: 0 },
    onFilteredItemsChange: { type: "function", value: null, optional: true },
    filterEnabled: true,
    filterRange: [-1, 1],
    filterSoftRange: null,
    filterCategories: [0],
    filterTransformSize: true,
    filterTransformColor: true
  };
  var defaultOptions2 = {
    categorySize: 0,
    filterSize: 1,
    fp64: false,
    countItems: false
  };
  var CATEGORY_TYPE_FROM_SIZE = {
    1: "uint",
    2: "uvec2",
    3: "uvec3",
    4: "uvec4"
  };
  var DATA_TYPE_FROM_SIZE = {
    1: "float",
    2: "vec2",
    3: "vec3",
    4: "vec4"
  };
  var DataFilterExtension = class extends LayerExtension {
    constructor(opts = {}) {
      super({ ...defaultOptions2, ...opts });
    }
    getShaders(extension) {
      const { categorySize, filterSize, fp64: fp642 } = extension.opts;
      const defines2 = {};
      if (categorySize) {
        defines2.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];
        defines2.DATACATEGORY_CHANNELS = categorySize;
      }
      if (filterSize) {
        defines2.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];
        defines2.DATAFILTER_DOUBLE = Boolean(fp642);
      }
      const module = fp642 ? dataFilter64 : dataFilter;
      module.uniformTypes = module.uniformTypesFromOptions(extension.opts);
      return { modules: [module], defines: defines2 };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      const { categorySize, filterSize, fp64: fp642 } = extension.opts;
      if (attributeManager) {
        if (filterSize) {
          attributeManager.add({
            filterValues: {
              size: filterSize,
              type: fp642 ? "float64" : "float32",
              stepMode: "dynamic",
              accessor: "getFilterValue"
            }
          });
        }
        if (categorySize) {
          attributeManager.add({
            filterCategoryValues: {
              size: categorySize,
              stepMode: "dynamic",
              accessor: "getFilterCategory",
              type: "uint32",
              transform: categorySize === 1 ? (d2) => extension._getCategoryKey.call(this, d2, 0) : (d2) => d2.map((x3, i5) => extension._getCategoryKey.call(this, x3, i5))
            }
          });
        }
      }
      const { device } = this.context;
      if (attributeManager && extension.opts.countItems) {
        const useFloatTarget = supportsFloatTarget(device);
        attributeManager.add({
          filterVertexIndices: {
            size: useFloatTarget ? 1 : 2,
            vertexOffset: 1,
            type: "unorm8",
            accessor: (object, { index }) => {
              const i5 = object && object.__source ? object.__source.index : index;
              return useFloatTarget ? (i5 + 1) % 255 : [(i5 + 1) % 255, Math.floor(i5 / 255) % 255];
            },
            shaderAttributes: {
              filterPrevIndices: {
                vertexOffset: 0
              },
              filterIndices: {
                vertexOffset: 1
              }
            }
          }
        });
        const filterFBO = getFramebuffer4(device, useFloatTarget);
        const filterModel = getModel(
          device,
          attributeManager.getBufferLayouts({ isInstanced: false }),
          extension.getShaders.call(this, extension),
          useFloatTarget
        );
        this.setState({ filterFBO, filterModel });
      }
    }
    // eslint-disable-next-line complexity
    updateState({ props, oldProps, changeFlags }, extension) {
      const attributeManager = this.getAttributeManager();
      const { categorySize } = extension.opts;
      if (this.state.filterModel) {
        const filterNeedsUpdate = (
          // attributeManager must be defined for filterModel to be set
          attributeManager.attributes.filterValues?.needsUpdate() || attributeManager.attributes.filterCategoryValues?.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories
        );
        if (filterNeedsUpdate) {
          this.setState({ filterNeedsUpdate });
        }
      }
      if (attributeManager?.attributes.filterCategoryValues) {
        const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual2(props.filterCategories, oldProps.filterCategories, 2);
        if (categoryBitMaskNeedsUpdate) {
          this.setState({ categoryBitMask: null });
        }
        const resetCategories = changeFlags.dataChanged;
        if (resetCategories) {
          this.setState({
            categoryMap: Array(categorySize).fill(0).map(() => ({}))
          });
          attributeManager.attributes.filterCategoryValues.setNeedsUpdate("categoryMap");
        }
      }
    }
    // eslint-disable-next-line max-statements
    draw(params, extension) {
      const filterFBO = this.state.filterFBO;
      const filterModel = this.state.filterModel;
      const filterNeedsUpdate = this.state.filterNeedsUpdate;
      if (!this.state.categoryBitMask) {
        extension._updateCategoryBitMask.call(this, params, extension);
      }
      const {
        onFilteredItemsChange,
        extensions,
        filterEnabled,
        filterRange,
        filterSoftRange,
        filterTransformSize,
        filterTransformColor,
        filterCategories
      } = this.props;
      const dataFilterProps = {
        extensions,
        filterEnabled,
        filterRange,
        filterSoftRange,
        filterTransformSize,
        filterTransformColor,
        filterCategories
      };
      if (this.state.categoryBitMask) {
        dataFilterProps.categoryBitMask = this.state.categoryBitMask;
      }
      this.setShaderModuleProps({ dataFilter: dataFilterProps });
      if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
        const attributeManager = this.getAttributeManager();
        const {
          attributes: { filterValues, filterCategoryValues, filterVertexIndices }
        } = attributeManager;
        filterModel.setVertexCount(this.getNumInstances());
        const attributes = {
          ...filterValues?.getValue(),
          ...filterCategoryValues?.getValue(),
          ...filterVertexIndices?.getValue()
        };
        filterModel.setAttributes(attributes);
        filterModel.shaderInputs.setProps({
          dataFilter: dataFilterProps
        });
        const viewport = [0, 0, filterFBO.width, filterFBO.height];
        const renderPass = filterModel.device.beginRenderPass({
          id: "data-filter-aggregation",
          framebuffer: filterFBO,
          parameters: { viewport },
          clearColor: [0, 0, 0, 0]
        });
        filterModel.setParameters(parameters);
        filterModel.draw(renderPass);
        renderPass.end();
        const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
        let count3 = 0;
        for (let i5 = 0; i5 < color.length; i5++) {
          count3 += color[i5];
        }
        onFilteredItemsChange({ id: this.id, count: count3 });
        this.state.filterNeedsUpdate = false;
      }
    }
    finalizeState() {
      const filterFBO = this.state.filterFBO;
      const filterModel = this.state.filterModel;
      filterFBO?.destroy();
      filterModel?.destroy();
    }
    /**
     * Updates the bitmask used on the GPU to perform the filter based on the
     * `filterCategories` prop. The mapping between categories and bit in the bitmask
     * is performed by `_getCategoryKey()`
     */
    _updateCategoryBitMask(params, extension) {
      const { categorySize } = extension.opts;
      if (!categorySize)
        return;
      const { filterCategories } = this.props;
      const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
      const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;
      const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
      for (let c2 = 0; c2 < categoryFilters.length; c2++) {
        const categoryFilter = categoryFilters[c2];
        for (const category of categoryFilter) {
          const key = extension._getCategoryKey.call(this, category, c2);
          if (key < maxCategories) {
            const channel = c2 * (maxCategories / 32) + Math.floor(key / 32);
            categoryBitMask[channel] += Math.pow(2, key % 32);
          } else {
            log_default.warn(`Exceeded maximum number of categories (${maxCategories})`)();
          }
        }
      }
      this.state.categoryBitMask = categoryBitMask;
    }
    /**
     * Returns an index of bit in the bitmask for a given category. If the category has
     * not yet been assigned a bit, a new one is assigned.
     */
    _getCategoryKey(category, channel) {
      const categoryMap = this.state.categoryMap[channel];
      if (!(category in categoryMap)) {
        categoryMap[category] = Object.keys(categoryMap).length;
      }
      return categoryMap[category];
    }
  };
  DataFilterExtension.defaultProps = defaultProps33;
  DataFilterExtension.extensionName = "DataFilterExtension";

  // ../extensions/src/fp64/project64.glsl.ts
  var project64_glsl_default = `
const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);

uniform project64Uniforms {
  vec2 scale;
  mat4 viewProjectionMatrix;
  mat4 viewProjectionMatrix64Low;
} project64;

// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {

#if defined(NVIDIA_FP64_WORKAROUND)
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
  out_val[1] = sum_fp64(PI_FP64,
    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
  return;
}

void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
  vec2 pos_fp64[2];
  mercatorProject_fp64(position_fp64, pos_fp64);
  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);

  return;
}

void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
  vec4 position64xy = vec4(
    position.x, position64xyLow.x,
    position.y, position64xyLow.y);

  project_position_fp64(position64xy, out_val);
}

vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
  vec2 vertex_pos_clipspace[4];
  vec2 viewProjectionMatrixFP64[16];
  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      viewProjectionMatrixFP64[4 * i + j] = vec2(
        project64.viewProjectionMatrix[j][i],
        project64.viewProjectionMatrix64Low[j][i]
      );
    }   
  }
  mat4_vec4_mul_fp64(viewProjectionMatrixFP64, vertex_pos_modelspace,
    vertex_pos_clipspace);
  return vec4(
    vertex_pos_clipspace[0].x,
    vertex_pos_clipspace[1].x,
    vertex_pos_clipspace[2].x,
    vertex_pos_clipspace[3].x
    );
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
  // This is the local offset to the instance position
  vec2 offset64[4];
  vec4_fp64(vec4(offset, 0.0), offset64);

  float z = project_size(position.z);

  // Apply web mercator projection (depends on coordinate system imn use)
  vec2 projectedPosition64xy[2];
  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);

  vec2 commonPosition64[4];
  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
  commonPosition64[3] = vec2(1.0, 0.0);

  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);

  return project_common_position_to_clipspace_fp64(commonPosition64);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(
    position, position64xyLow, offset, commonPosition
  );
}
`;

  // ../extensions/src/fp64/project64.ts
  var { fp64ify: fp64ify2, fp64ifyMatrix4: fp64ifyMatrix42 } = fp64;
  var project64_default = {
    name: "project64",
    dependencies: [project_default, fp64],
    vs: project64_glsl_default,
    getUniforms: getUniforms7,
    uniformTypes: {
      scale: "vec2<f32>",
      // Cannot pass as vec2[16], so instead split into 2 mat4x4
      viewProjectionMatrix: "mat4x4<f32>",
      viewProjectionMatrix64Low: "mat4x4<f32>"
    }
  };
  var getMemoizedUniforms = memoize(calculateUniforms);
  function getUniforms7(opts) {
    if (opts && "viewport" in opts) {
      const { viewProjectionMatrix, scale: scale22 } = opts.viewport;
      return getMemoizedUniforms({ viewProjectionMatrix, scale: scale22 });
    }
    return {};
  }
  function calculateUniforms({
    viewProjectionMatrix,
    scale: scale22
  }) {
    const glViewProjectionMatrixFP64 = fp64ifyMatrix42(viewProjectionMatrix);
    const viewProjectionMatrix64High = new Float32Array(16);
    const viewProjectionMatrix64Low = new Float32Array(16);
    for (let i5 = 0; i5 < 4; i5++) {
      for (let j2 = 0; j2 < 4; j2++) {
        const from = 4 * i5 + j2;
        const to = 4 * j2 + i5;
        viewProjectionMatrix64High[to] = glViewProjectionMatrixFP64[2 * from];
        viewProjectionMatrix64Low[to] = glViewProjectionMatrixFP64[2 * from + 1];
      }
    }
    return {
      scale: fp64ify2(scale22),
      viewProjectionMatrix: [...viewProjectionMatrix64High],
      viewProjectionMatrix64Low: [...viewProjectionMatrix64Low]
    };
  }

  // ../extensions/src/fp64/fp64-extension.ts
  var Fp64Extension = class extends LayerExtension {
    getShaders() {
      const { coordinateSystem } = this.props;
      if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
        throw new Error("fp64: coordinateSystem must be LNGLAT");
      }
      return {
        modules: [project64_default]
      };
    }
    draw(params, extension) {
      const { viewport } = params.context;
      this.setShaderModuleProps({ project64: { viewport } });
    }
  };
  Fp64Extension.extensionName = "Fp64Extension";

  // ../extensions/src/path-style/shaders.glsl.ts
  var dashShaders = {
    inject: {
      "vs:#decl": `
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,
      "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
      "fs:#decl": `
uniform pathStyleUniforms {
  float dashAlignMode;
  bool dashGapPickable;
} pathStyle;

in vec2 vDashArray;
in float vDashOffset;
`,
      // if given position is in the gap part of the dashed line
      // dashArray.x: solid stroke length, relative to width
      // dashArray.y: gap length, relative to width
      // alignMode:
      // 0 - no adjustment
      // o----     ----     ----     ---- o----     -o----     ----     o
      // 1 - stretch to fit, draw half dash at each end for nicer joints
      // o--    ----    ----    ----    --o--      --o--     ----     --o
      "fs:#main-start": `
  float solidLength = vDashArray.x;
  float gapLength = vDashArray.y;
  float unitLength = solidLength + gapLength;

  float offset;

  if (unitLength > 0.0) {
    if (pathStyle.dashAlignMode == 0.0) {
      offset = vDashOffset;
    } else {
      unitLength = vPathLength / round(vPathLength / unitLength);
      offset = solidLength / 2.0;
    }

    float unitOffset = mod(vPathPosition.y + offset, unitLength);

    if (gapLength > 0.0 && unitOffset > solidLength) {
      if (path.capType <= 0.5) {
        if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
          discard;
        }
      } else {
        // caps are rounded, test the distance to solid ends
        float distToEnd = length(vec2(
          min(unitOffset - solidLength, unitLength - unitOffset),
          vPathPosition.x
        ));
        if (distToEnd > 1.0) {
          if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
            discard;
          }
        }
      }
    }
  }
`
    }
  };
  var offsetShaders = {
    inject: {
      "vs:#decl": `
in float instanceOffsets;
`,
      "vs:DECKGL_FILTER_SIZE": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  size *= offsetWidth;
`,
      "vs:#main-end": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  float offsetDir = sign(instanceOffsets);
  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
  vPathPosition.y *= offsetWidth;
  vPathLength *= offsetWidth;
`,
      "fs:#main-start": `
  float isInside;
  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
  if (isInside == 0.0) {
    discard;
  }
`
    }
  };

  // ../extensions/src/path-style/path-style-extension.ts
  var defaultProps34 = {
    getDashArray: { type: "accessor", value: [0, 0] },
    getOffset: { type: "accessor", value: 0 },
    dashJustified: false,
    dashGapPickable: false
  };
  var PathStyleExtension = class extends LayerExtension {
    constructor({
      dash = false,
      offset = false,
      highPrecisionDash = false
    } = {}) {
      super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });
    }
    isEnabled(layer) {
      return "pathTesselator" in layer.state;
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      let result = {};
      if (extension.opts.dash) {
        result = mergeShaders(result, dashShaders);
      }
      if (extension.opts.offset) {
        result = mergeShaders(result, offsetShaders);
      }
      const { inject: inject6 } = result;
      const pathStyle = {
        name: "pathStyle",
        inject: inject6,
        uniformTypes: {
          dashAlignMode: "f32",
          dashGapPickable: "i32"
        }
      };
      return {
        modules: [pathStyle]
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager || !extension.isEnabled(this)) {
        return;
      }
      if (extension.opts.dash) {
        attributeManager.addInstanced({
          instanceDashArrays: { size: 2, accessor: "getDashArray" },
          instanceDashOffsets: extension.opts.highPrecisionDash ? {
            size: 1,
            accessor: "getPath",
            transform: extension.getDashOffsets.bind(this)
          } : {
            size: 1,
            update: (attribute) => {
              attribute.constant = true;
              attribute.value = [0];
            }
          }
        });
      }
      if (extension.opts.offset) {
        attributeManager.addInstanced({
          instanceOffsets: { size: 1, accessor: "getOffset" }
        });
      }
    }
    updateState(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      if (extension.opts.dash) {
        const pathStyleProps = {
          dashAlignMode: this.props.dashJustified ? 1 : 0,
          dashGapPickable: Boolean(this.props.dashGapPickable)
        };
        this.setShaderModuleProps({ pathStyle: pathStyleProps });
      }
    }
    getDashOffsets(path) {
      const result = [0];
      const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
      const isNested2 = Array.isArray(path[0]);
      const geometrySize = isNested2 ? path.length : path.length / positionSize;
      let p3;
      let prevP;
      for (let i5 = 0; i5 < geometrySize - 1; i5++) {
        p3 = isNested2 ? path[i5] : path.slice(i5 * positionSize, i5 * positionSize + positionSize);
        p3 = this.projectPosition(p3);
        if (i5 > 0) {
          result[i5] = result[i5 - 1] + vec3_exports.dist(prevP, p3);
        }
        prevP = p3;
      }
      result[geometrySize - 1] = 0;
      return result;
    }
  };
  PathStyleExtension.defaultProps = defaultProps34;
  PathStyleExtension.extensionName = "PathStyleExtension";

  // ../extensions/src/fill-style/shader-module.ts
  var uniformBlock22 = (
    /* glsl */
    `uniform fillUniforms {
  vec2 patternTextureSize;
  bool patternEnabled;
  bool patternMask;
  vec2 uvCoordinateOrigin;
  vec2 uvCoordinateOrigin64Low;
} fill;
`
  );
  var patternVs = (
    /* glsl */
    `
in vec4 fillPatternFrames;
in float fillPatternScales;
in vec2 fillPatternOffsets;

out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`
  );
  var vs11 = `
${uniformBlock22}
${patternVs}
`;
  var patternFs = (
    /* glsl */
    `
uniform sampler2D fill_patternTexture;

in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`
  );
  var fs9 = `
${uniformBlock22}
${patternFs}
`;
  var inject3 = {
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
    fill_uv = geometry.position.xy;
  `
    ),
    "vs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
    if (fill.patternEnabled) {
      fill_patternBounds = fillPatternFrames / vec4(fill.patternTextureSize, fill.patternTextureSize);
      fill_patternPlacement.xy = fillPatternOffsets;
      fill_patternPlacement.zw = fillPatternScales * fillPatternFrames.zw;
    }
  `
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
    if (fill.patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill.uvCoordinateOrigin, scale) + fill.uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill.patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `
    )
  };
  function getPatternUniforms(opts) {
    if (!opts) {
      return {};
    }
    const uniforms = {};
    if ("fillPatternTexture" in opts) {
      const { fillPatternTexture } = opts;
      uniforms.fill_patternTexture = fillPatternTexture;
      uniforms.patternTextureSize = [fillPatternTexture.width, fillPatternTexture.height];
    }
    if ("project" in opts) {
      const { fillPatternMask = true, fillPatternEnabled = true } = opts;
      const projectUniforms = project_default.getUniforms(opts.project);
      const { commonOrigin: coordinateOriginCommon } = projectUniforms;
      const coordinateOriginCommon64Low = [
        fp64LowPart2(coordinateOriginCommon[0]),
        fp64LowPart2(coordinateOriginCommon[1])
      ];
      uniforms.uvCoordinateOrigin = coordinateOriginCommon.slice(0, 2);
      uniforms.uvCoordinateOrigin64Low = coordinateOriginCommon64Low;
      uniforms.patternMask = fillPatternMask;
      uniforms.patternEnabled = fillPatternEnabled;
    }
    return uniforms;
  }
  var patternShaders = {
    name: "fill",
    vs: vs11,
    fs: fs9,
    inject: inject3,
    dependencies: [project_default],
    getUniforms: getPatternUniforms,
    uniformTypes: {
      patternTextureSize: "vec2<f32>",
      patternEnabled: "i32",
      patternMask: "i32",
      uvCoordinateOrigin: "vec2<f32>",
      uvCoordinateOrigin64Low: "vec2<f32>"
    }
  };

  // ../extensions/src/fill-style/fill-style-extension.ts
  var defaultProps35 = {
    fillPatternEnabled: true,
    fillPatternAtlas: {
      type: "image",
      value: null,
      async: true,
      parameters: { lodMaxClamp: 0 }
    },
    fillPatternMapping: { type: "object", value: {}, async: true },
    fillPatternMask: true,
    getFillPattern: { type: "accessor", value: (d2) => d2.pattern },
    getFillPatternScale: { type: "accessor", value: 1 },
    getFillPatternOffset: { type: "accessor", value: [0, 0] }
  };
  var FillStyleExtension = class extends LayerExtension {
    constructor({ pattern = false } = {}) {
      super({ pattern });
    }
    isEnabled(layer) {
      return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      return {
        modules: [extension.opts.pattern && patternShaders].filter(Boolean)
      };
    }
    initializeState(context, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const attributeManager = this.getAttributeManager();
      if (extension.opts.pattern) {
        attributeManager.add({
          fillPatternFrames: {
            size: 4,
            stepMode: "dynamic",
            accessor: "getFillPattern",
            transform: extension.getPatternFrame.bind(this)
          },
          fillPatternScales: {
            size: 1,
            stepMode: "dynamic",
            accessor: "getFillPatternScale",
            defaultValue: 1
          },
          fillPatternOffsets: {
            size: 2,
            stepMode: "dynamic",
            accessor: "getFillPatternOffset"
          }
        });
      }
      this.setState({
        emptyTexture: this.context.device.createTexture({
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState({ props, oldProps }, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
        this.getAttributeManager().invalidate("getFillPattern");
      }
    }
    draw(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const { fillPatternAtlas, fillPatternEnabled, fillPatternMask } = this.props;
      const fillProps = {
        project: params.shaderModuleProps.project,
        fillPatternEnabled,
        fillPatternMask,
        fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
      };
      this.setShaderModuleProps({ fill: fillProps });
    }
    finalizeState() {
      const emptyTexture = this.state.emptyTexture;
      emptyTexture?.delete();
    }
    getPatternFrame(name13) {
      const { fillPatternMapping } = this.getCurrentLayer().props;
      const def = fillPatternMapping && fillPatternMapping[name13];
      return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
    }
  };
  FillStyleExtension.defaultProps = defaultProps35;
  FillStyleExtension.extensionName = "FillStyleExtension";

  // ../extensions/src/clip/clip-extension.ts
  var defaultProps36 = {
    clipBounds: [0, 0, 1, 1],
    clipByInstance: void 0
  };
  var shaderFunction = (
    /* glsl */
    `
uniform clipUniforms {
  vec4 bounds;
} clip;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];
}
`
  );
  var shaderModuleVs = {
    name: "clip",
    vs: shaderFunction,
    uniformTypes: {
      bounds: "vec4<f32>"
    }
  };
  var injectionVs = {
    "vs:#decl": (
      /* glsl */
      `
out float clip_isVisible;
`
    ),
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`
    ),
    "fs:#decl": (
      /* glsl */
      `
in float clip_isVisible;
`
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
  if (clip_isVisible < 0.5) discard;
`
    )
  };
  var shaderModuleFs = {
    name: "clip",
    fs: shaderFunction,
    uniformTypes: {
      bounds: "vec4<f32>"
    }
  };
  var injectionFs = {
    "vs:#decl": (
      /* glsl */
      `
out vec2 clip_commonPosition;
`
    ),
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
  clip_commonPosition = geometry.position.xy;
`
    ),
    "fs:#decl": (
      /* glsl */
      `
in vec2 clip_commonPosition;
`
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
    )
  };
  var ClipExtension = class extends LayerExtension {
    getShaders() {
      let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.clipByInstance !== void 0) {
        clipByInstance = Boolean(this.props.clipByInstance);
      }
      this.state.clipByInstance = clipByInstance;
      return clipByInstance ? {
        modules: [shaderModuleVs],
        inject: injectionVs
      } : {
        modules: [shaderModuleFs],
        inject: injectionFs
      };
    }
    /* eslint-disable camelcase */
    draw() {
      const { clipBounds } = this.props;
      const clipProps = {};
      if (this.state.clipByInstance) {
        clipProps.bounds = clipBounds;
      } else {
        const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
        const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
        clipProps.bounds = [
          Math.min(corner0[0], corner1[0]),
          Math.min(corner0[1], corner1[1]),
          Math.max(corner0[0], corner1[0]),
          Math.max(corner0[1], corner1[1])
        ];
      }
      this.setShaderModuleProps({ clip: clipProps });
    }
  };
  ClipExtension.defaultProps = defaultProps36;
  ClipExtension.extensionName = "ClipExtension";

  // ../extensions/src/collision-filter/shader-module.ts
  var vs12 = (
    /* glsl */
    `
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`
  );
  var inject4 = {
    "vs:#decl": (
      /* glsl */
      `
  float collision_fade = 1.0;
`
    ),
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `
    ),
    "vs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
  color.a *= collision_fade;
  `
    )
  };
  var getCollisionUniforms = (opts) => {
    if (!opts || !("dummyCollisionMap" in opts)) {
      return {};
    }
    const { enabled, collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
    return {
      enabled: enabled && !drawToCollisionMap,
      sort: Boolean(drawToCollisionMap),
      collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
    };
  };
  var shader_module_default2 = {
    name: "collision",
    dependencies: [project_default],
    vs: vs12,
    inject: inject4,
    getUniforms: getCollisionUniforms,
    uniformTypes: {
      sort: "i32",
      enabled: "i32"
    }
  };

  // ../extensions/src/collision-filter/collision-filter-pass.ts
  var CollisionFilterPass = class extends LayersPass {
    renderCollisionMap(target2, options) {
      const padding = 1;
      const clearColor = [0, 0, 0, 0];
      const scissorRect = [padding, padding, target2.width - 2 * padding, target2.height - 2 * padding];
      this.render({ ...options, clearColor, scissorRect, target: target2, pass: "collision" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: false,
        depthWriteEnabled: true,
        depthCompare: "less-equal"
      };
    }
    getShaderModuleProps() {
      return {
        collision: {
          drawToCollisionMap: true
        },
        picking: {
          isActive: 1,
          isAttribute: false
        },
        lighting: { enabled: false }
      };
    }
  };

  // ../extensions/src/collision-filter/collision-filter-effect.ts
  var DOWNSCALE = 2;
  var CollisionFilterEffect = class {
    constructor() {
      this.id = "collision-filter-effect";
      this.props = null;
      this.useInPicking = true;
      this.order = 1;
      this.channels = {};
      this.collisionFBOs = {};
    }
    setup(context) {
      this.context = context;
      const { device } = context;
      this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });
      this.collisionFilterPass = new CollisionFilterPass(device, { id: "default-collision-filter" });
    }
    preRender({
      effects: allEffects,
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking,
      preRenderStats = {}
    }) {
      const { device } = this.context;
      if (isPicking) {
        return;
      }
      const collisionLayers = layers.filter(
        // @ts-ignore
        ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled
      );
      if (collisionLayers.length === 0) {
        this.channels = {};
        return;
      }
      const effects = allEffects?.filter((e3) => e3.useInPicking && preRenderStats[e3.id]);
      const maskEffectRendered = preRenderStats["mask-effect"]?.didRender;
      const channels = this._groupByCollisionGroup(device, collisionLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
      for (const collisionGroup in channels) {
        const collisionFBO = this.collisionFBOs[collisionGroup];
        const renderInfo = channels[collisionGroup];
        const [width, height] = device.canvasContext.getPixelSize();
        collisionFBO.resize({
          width: width / DOWNSCALE,
          height: height / DOWNSCALE
        });
        this._render(renderInfo, {
          effects,
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
      }
    }
    _render(renderInfo, {
      effects,
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      const { collisionGroup } = renderInfo;
      const oldRenderInfo = this.channels[collisionGroup];
      if (!oldRenderInfo) {
        return;
      }
      const needsRender = viewportChanged || // If render info is new
      renderInfo === oldRenderInfo || // If sublayers have changed
      !deepEqual2(oldRenderInfo.layers, renderInfo.layers, 1) || // If a sublayer's bounds have been updated
      renderInfo.layerBounds.some((b2, i5) => !equals(b2, oldRenderInfo.layerBounds[i5])) || // If a sublayer's isLoaded state has been updated
      renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || // Some prop is in transition
      renderInfo.layers.some((layer) => layer.props.transitions);
      this.channels[collisionGroup] = renderInfo;
      if (needsRender) {
        this.lastViewport = viewport;
        const collisionFBO = this.collisionFBOs[collisionGroup];
        this.collisionFilterPass.renderCollisionMap(collisionFBO, {
          pass: "collision-filter",
          isPicking: true,
          layers: renderInfo.layers,
          effects,
          layerFilter,
          viewports: viewport ? [viewport] : [],
          onViewportActive,
          views,
          shaderModuleProps: {
            collision: {
              enabled: true,
              // To avoid feedback loop forming between Framebuffer and active Texture.
              dummyCollisionMap: this.dummyCollisionMap
            },
            project: {
              // @ts-expect-error TODO - assuming WebGL context
              devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
            }
          }
        });
      }
    }
    /**
     * Group layers by collisionGroup
     * Returns a map from collisionGroup to render info
     */
    _groupByCollisionGroup(device, collisionLayers) {
      const channelMap = {};
      for (const layer of collisionLayers) {
        const collisionGroup = layer.props.collisionGroup;
        let channelInfo = channelMap[collisionGroup];
        if (!channelInfo) {
          channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };
          channelMap[collisionGroup] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
        if (!layer.isLoaded) {
          channelInfo.allLayersLoaded = false;
        }
      }
      for (const collisionGroup of Object.keys(channelMap)) {
        if (!this.collisionFBOs[collisionGroup]) {
          this.createFBO(device, collisionGroup);
        }
        if (!this.channels[collisionGroup]) {
          this.channels[collisionGroup] = channelMap[collisionGroup];
        }
      }
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        if (!channelMap[collisionGroup]) {
          this.destroyFBO(collisionGroup);
        }
      }
      return channelMap;
    }
    getShaderModuleProps(layer) {
      const { collisionGroup, collisionEnabled } = layer.props;
      const { collisionFBOs, dummyCollisionMap } = this;
      const collisionFBO = collisionFBOs[collisionGroup];
      const enabled = collisionEnabled && Boolean(collisionFBO);
      return {
        collision: {
          enabled,
          collisionFBO,
          dummyCollisionMap
        }
      };
    }
    cleanup() {
      if (this.dummyCollisionMap) {
        this.dummyCollisionMap.delete();
        this.dummyCollisionMap = void 0;
      }
      this.channels = {};
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        this.destroyFBO(collisionGroup);
      }
      this.collisionFBOs = {};
      this.lastViewport = void 0;
    }
    createFBO(device, collisionGroup) {
      const { width, height } = device.gl.canvas;
      const collisionMap = device.createTexture({
        format: "rgba8unorm",
        width,
        height,
        sampler: {
          minFilter: "nearest",
          magFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      });
      const depthStencilAttachment = device.createTexture({
        format: "depth16unorm",
        width,
        height,
        mipmaps: false
      });
      this.collisionFBOs[collisionGroup] = device.createFramebuffer({
        id: `collision-${collisionGroup}`,
        width,
        height,
        colorAttachments: [collisionMap],
        depthStencilAttachment
      });
    }
    destroyFBO(collisionGroup) {
      const fbo = this.collisionFBOs[collisionGroup];
      fbo.colorAttachments[0]?.destroy();
      fbo.depthStencilAttachment?.destroy();
      fbo.destroy();
      delete this.collisionFBOs[collisionGroup];
    }
  };

  // ../extensions/src/collision-filter/collision-filter-extension.ts
  var defaultProps37 = {
    getCollisionPriority: { type: "accessor", value: 0 },
    collisionEnabled: true,
    collisionGroup: { type: "string", value: "default" },
    collisionTestProps: {}
  };
  var CollisionFilterExtension = class extends LayerExtension {
    getShaders() {
      return { modules: [shader_module_default2] };
    }
    /* eslint-disable camelcase */
    draw({ shaderModuleProps }) {
      if (shaderModuleProps.collision?.drawToCollisionMap) {
        this.props = this.clone(this.props.collisionTestProps).props;
      }
    }
    initializeState(context, extension) {
      if (this.getAttributeManager() === null) {
        return;
      }
      this.context.deck?._addDefaultEffect(new CollisionFilterEffect());
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        collisionPriorities: {
          size: 1,
          stepMode: "dynamic",
          accessor: "getCollisionPriority"
        }
      });
    }
    getNeedsPickingBuffer() {
      return this.props.collisionEnabled;
    }
  };
  CollisionFilterExtension.defaultProps = defaultProps37;
  CollisionFilterExtension.extensionName = "CollisionFilterExtension";

  // ../extensions/src/mask/shader-module.ts
  var uniformBlock23 = (
    /* glsl */
    `uniform maskUniforms {
  vec4 bounds;
  highp int channel;
  bool enabled;
  bool inverted;
  bool maskByInstance;
} mask;
`
  );
  var vertex4 = (
    /* glsl */
    `
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);
}
`
  );
  var vs13 = `
${uniformBlock23}
${vertex4}
`;
  var fragment4 = (
    /* glsl */
    `
uniform sampler2D mask_texture;

bool mask_isInBounds(vec2 texCoords) {
  if (!mask.enabled) {
    return true;
  }
  vec4 maskColor = texture(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask.channel == 0) {
    maskValue = maskColor.r;
  } else if (mask.channel == 1) {
    maskValue = maskColor.g;
  } else if (mask.channel == 2) {
    maskValue = maskColor.b;
  } else if (mask.channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask.inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`
  );
  var fs10 = `
${uniformBlock23}
${fragment4}
`;
  var inject5 = {
    "vs:#decl": (
      /* glsl */
      `
out vec2 mask_texCoords;
`
    ),
    "vs:#main-end": (
      /* glsl */
      `
   vec4 mask_common_position;
   if (mask.maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`
    ),
    "fs:#decl": (
      /* glsl */
      `
in vec2 mask_texCoords;
`
    ),
    "fs:#main-start": (
      /* glsl */
      `
  if (mask.enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // fragColor = vec4(mask_texCoords, 0.0, 1.0);
    // fragColor = texture(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`
    )
  };
  var getMaskUniforms = (opts) => {
    if (opts && "maskMap" in opts) {
      return {
        mask_texture: opts.maskMap
      };
    }
    return opts || {};
  };
  var shader_module_default3 = {
    name: "mask",
    dependencies: [project_default],
    vs: vs13,
    fs: fs10,
    inject: inject5,
    getUniforms: getMaskUniforms,
    uniformTypes: {
      bounds: "vec4<f32>",
      channel: "i32",
      enabled: "i32",
      inverted: "i32",
      maskByInstance: "i32"
    }
  };

  // ../extensions/src/mask/mask-pass.ts
  var MASK_BLENDING = {
    blendColorOperation: "subtract",
    blendColorSrcFactor: "zero",
    blendColorDstFactor: "one",
    blendAlphaOperation: "subtract",
    blendAlphaSrcFactor: "zero",
    blendAlphaDstFactor: "one"
  };
  var MaskPass = class extends LayersPass {
    constructor(device, props) {
      super(device, props);
      const { mapSize = 2048 } = props;
      this.maskMap = device.createTexture({
        format: "rgba8unorm",
        width: mapSize,
        height: mapSize,
        sampler: {
          minFilter: "linear",
          magFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      });
      this.fbo = device.createFramebuffer({
        id: "maskmap",
        width: mapSize,
        height: mapSize,
        colorAttachments: [this.maskMap]
      });
    }
    render(options) {
      const colorMask = 2 ** options.channel;
      const clearColor = [255, 255, 255, 255];
      super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: "mask" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: true,
        depthCompare: "always",
        ...MASK_BLENDING
      };
    }
    shouldDrawLayer(layer) {
      return layer.props.operation.includes("mask");
    }
    delete() {
      this.fbo.delete();
      this.maskMap.delete();
    }
  };

  // ../extensions/src/utils/projection-utils.ts
  function joinLayerBounds(layers, viewport) {
    const bounds = [Infinity, Infinity, -Infinity, -Infinity];
    for (const layer of layers) {
      const layerBounds = layer.getBounds();
      if (layerBounds) {
        const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });
        const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });
        bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
        bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
        bounds[2] = Math.max(bounds[2], topRightCommon[0]);
        bounds[3] = Math.max(bounds[3], topRightCommon[1]);
      }
    }
    if (Number.isFinite(bounds[0])) {
      return bounds;
    }
    return null;
  }
  var MAX_VIEWPORT_SIZE = 2048;
  function makeViewport(opts) {
    const { bounds, viewport, border = 0 } = opts;
    const { isGeospatial } = viewport;
    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
      return null;
    }
    const centerWorld = viewport.unprojectPosition([
      (bounds[0] + bounds[2]) / 2,
      (bounds[1] + bounds[3]) / 2,
      0
    ]);
    let { width, height, zoom } = opts;
    if (zoom === void 0) {
      width = width - border * 2;
      height = height - border * 2;
      const scale22 = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
      zoom = Math.min(Math.log2(scale22), 20);
    } else if (!width || !height) {
      const scale22 = 2 ** zoom;
      width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale22);
      height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale22);
      const maxSize = MAX_VIEWPORT_SIZE - border * 2;
      if (width > maxSize || height > maxSize) {
        const r3 = maxSize / Math.max(width, height);
        width = Math.round(width * r3);
        height = Math.round(height * r3);
        zoom += Math.log2(r3);
      }
    }
    return isGeospatial ? new WebMercatorViewport2({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      longitude: centerWorld[0],
      latitude: centerWorld[1],
      zoom,
      orthographic: true
    }) : new OrthographicViewport({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      target: centerWorld,
      zoom,
      flipY: false
    });
  }
  function getViewportBounds(viewport, zRange) {
    let viewportBoundsWorld;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({ z: minZ });
      const bounds1 = viewport.getBounds({ z: maxZ });
      viewportBoundsWorld = [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
      ];
    } else {
      viewportBoundsWorld = viewport.getBounds();
    }
    const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
    const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
    return [
      viewportBottomLeftCommon[0],
      viewportBottomLeftCommon[1],
      viewportTopRightCommon[0],
      viewportTopRightCommon[1]
    ];
  }
  function getRenderBounds(layerBounds, viewport, zRange) {
    if (!layerBounds) {
      return [0, 0, 1, 1];
    }
    const viewportBounds = getViewportBounds(viewport, zRange);
    const paddedBounds = doubleBounds(viewportBounds);
    if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
      return layerBounds;
    }
    return [
      Math.max(layerBounds[0], paddedBounds[0]),
      Math.max(layerBounds[1], paddedBounds[1]),
      Math.min(layerBounds[2], paddedBounds[2]),
      Math.min(layerBounds[3], paddedBounds[3])
    ];
  }
  function doubleBounds(bounds) {
    const dx = bounds[2] - bounds[0];
    const dy = bounds[3] - bounds[1];
    const centerX = (bounds[0] + bounds[2]) / 2;
    const centerY = (bounds[1] + bounds[3]) / 2;
    return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
  }

  // ../extensions/src/mask/mask-effect.ts
  var MaskEffect = class {
    constructor() {
      this.id = "mask-effect";
      this.props = null;
      this.useInPicking = true;
      this.order = 0;
      this.channels = [];
      this.masks = null;
    }
    setup({ device }) {
      this.dummyMaskMap = device.createTexture({
        width: 1,
        height: 1
      });
      this.maskPass = new MaskPass(device, { id: "default-mask" });
      this.maskMap = this.maskPass.maskMap;
    }
    preRender({
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking
    }) {
      let didRender = false;
      if (isPicking) {
        return { didRender };
      }
      const maskLayers = layers.filter((l3) => l3.props.visible && l3.props.operation.includes("mask"));
      if (maskLayers.length === 0) {
        this.masks = null;
        this.channels.length = 0;
        return { didRender };
      }
      this.masks = {};
      const channelMap = this._sortMaskChannels(maskLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
      if (viewport.resolution !== void 0) {
        log_default.warn("MaskExtension is not supported in GlobeView")();
        return { didRender };
      }
      for (const maskId in channelMap) {
        const result = this._renderChannel(channelMap[maskId], {
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
        didRender ||= result;
      }
      return { didRender };
    }
    /* eslint-disable-next-line complexity */
    _renderChannel(channelInfo, {
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      let didRender = false;
      const oldChannelInfo = this.channels[channelInfo.index];
      if (!oldChannelInfo) {
        return didRender;
      }
      const maskChanged = (
        // If a channel is new
        channelInfo === oldChannelInfo || // If sublayers have changed
        channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some(
          (layer, i5) => (
            // Layer instance is updated
            // Layer props might have changed
            // Undetermined props could have an effect on the output geometry of a mask layer,
            // for example getRadius+updateTriggers, radiusScale, modelMatrix
            layer !== oldChannelInfo.layers[i5] || // Some prop is in transition
            layer.props.transitions
          )
        ) || // If a sublayer's positions have been updated, the cached bounds will change shallowly
        channelInfo.layerBounds.some((b2, i5) => b2 !== oldChannelInfo.layerBounds[i5])
      );
      channelInfo.bounds = oldChannelInfo.bounds;
      channelInfo.maskBounds = oldChannelInfo.maskBounds;
      this.channels[channelInfo.index] = channelInfo;
      if (maskChanged || viewportChanged) {
        this.lastViewport = viewport;
        const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
        channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
        if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
          const { maskPass, maskMap } = this;
          const maskViewport = layerBounds && makeViewport({
            bounds: channelInfo.bounds,
            viewport,
            width: maskMap.width,
            height: maskMap.height,
            border: 1
          });
          channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
          maskPass.render({
            pass: "mask",
            channel: channelInfo.index,
            layers: channelInfo.layers,
            layerFilter,
            viewports: maskViewport ? [maskViewport] : [],
            onViewportActive,
            views,
            shaderModuleProps: {
              project: {
                devicePixelRatio: 1
              }
            }
          });
          didRender = true;
        }
      }
      this.masks[channelInfo.id] = {
        index: channelInfo.index,
        bounds: channelInfo.maskBounds,
        coordinateOrigin: channelInfo.coordinateOrigin,
        coordinateSystem: channelInfo.coordinateSystem
      };
      return didRender;
    }
    /**
     * Find a channel to render each mask into
     * If a maskId already exists, diff and update the existing channel
     * Otherwise replace a removed mask
     * Otherwise create a new channel
     * Returns a map from mask layer id to channel info
     */
    _sortMaskChannels(maskLayers) {
      const channelMap = {};
      let channelCount = 0;
      for (const layer of maskLayers) {
        const { id } = layer.root;
        let channelInfo = channelMap[id];
        if (!channelInfo) {
          if (++channelCount > 4) {
            log_default.warn("Too many mask layers. The max supported is 4")();
            continue;
          }
          channelInfo = {
            id,
            index: this.channels.findIndex((c2) => c2?.id === id),
            layers: [],
            layerBounds: [],
            coordinateOrigin: layer.root.props.coordinateOrigin,
            coordinateSystem: layer.root.props.coordinateSystem
          };
          channelMap[id] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
      }
      for (let i5 = 0; i5 < 4; i5++) {
        const channelInfo = this.channels[i5];
        if (!channelInfo || !(channelInfo.id in channelMap)) {
          this.channels[i5] = null;
        }
      }
      for (const maskId in channelMap) {
        const channelInfo = channelMap[maskId];
        if (channelInfo.index < 0) {
          channelInfo.index = this.channels.findIndex((c2) => !c2);
          this.channels[channelInfo.index] = channelInfo;
        }
      }
      return channelMap;
    }
    getShaderModuleProps() {
      return {
        mask: {
          maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
          maskChannels: this.masks
        }
      };
    }
    cleanup() {
      if (this.dummyMaskMap) {
        this.dummyMaskMap.delete();
        this.dummyMaskMap = void 0;
      }
      if (this.maskPass) {
        this.maskPass.delete();
        this.maskPass = void 0;
        this.maskMap = void 0;
      }
      this.lastViewport = void 0;
      this.masks = null;
      this.channels.length = 0;
    }
  };

  // ../extensions/src/mask/mask-extension.ts
  var defaultProps38 = {
    maskId: "",
    maskByInstance: void 0,
    maskInverted: false
  };
  var MaskExtension = class extends LayerExtension {
    initializeState() {
      this.context.deck?._addDefaultEffect(new MaskEffect());
    }
    getShaders() {
      let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.maskByInstance !== void 0) {
        maskByInstance = Boolean(this.props.maskByInstance);
      }
      this.state.maskByInstance = maskByInstance;
      return {
        modules: [shader_module_default3]
      };
    }
    /* eslint-disable camelcase */
    draw({ context, shaderModuleProps }) {
      const maskProps = {};
      maskProps.maskByInstance = Boolean(this.state.maskByInstance);
      const { maskId, maskInverted } = this.props;
      const { maskChannels } = shaderModuleProps.mask || {};
      const { viewport } = context;
      if (maskChannels && maskChannels[maskId]) {
        const { index, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];
        let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];
        maskProps.enabled = true;
        maskProps.channel = index;
        maskProps.inverted = maskInverted;
        if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
          fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
        }
        const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };
        const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
        const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
        maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];
      } else {
        if (maskId) {
          log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
        }
        maskProps.enabled = false;
      }
      this.setShaderModuleProps({ mask: maskProps });
    }
  };
  MaskExtension.defaultProps = defaultProps38;
  MaskExtension.extensionName = "MaskExtension";

  // ../extensions/src/terrain/shader-module.ts
  var TERRAIN_MODE = {
    NONE: 0,
    /** A terrain layer rendering encoded ground elevation into the height map */
    WRITE_HEIGHT_MAP: 1,
    /** An offset layer reading encoded ground elevation from the height map */
    USE_HEIGHT_MAP: 2,
    /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */
    USE_COVER: 3,
    /** A terrain layer rendering to screen, using the cover fbo as texture */
    USE_COVER_ONLY: 4,
    /** Draped layer is rendered into a texture, and never to screen */
    SKIP: 5
  };
  var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
  var uniformBlock24 = (
    // eslint-disable-next-line prefer-template
    TERRAIN_MODE_CONSTANTS + /* glsl */
    `
uniform terrainUniforms {
  float mode;
  vec4 bounds;
} terrain;

uniform sampler2D terrain_map;
`
  );
  var terrainModule = {
    name: "terrain",
    dependencies: [project_default],
    // eslint-disable-next-line prefer-template
    vs: uniformBlock24 + /* glsl */
    "out vec3 commonPos;",
    // eslint-disable-next-line prefer-template
    fs: uniformBlock24 + /* glsl */
    "in vec3 commonPos;",
    inject: {
      "vs:#main-start": (
        /* glsl */
        `
if (terrain.mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`
      ),
      "vs:DECKGL_FILTER_GL_POSITION": (
        /* glsl */
        `
commonPos = geometry.position.xyz;
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project.commonOrigin.z;
}
if (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `
      ),
      "fs:#main-start": (
        /* glsl */
        `
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `
      ),
      "fs:DECKGL_FILTER_COLOR": (
        /* glsl */
        `
if ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  vec4 pixel = texture(terrain_map, texCoords);
  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `
      )
    },
    // eslint-disable-next-line complexity
    getUniforms: (opts = {}) => {
      if ("dummyHeightMap" in opts) {
        const {
          drawToTerrainHeightMap,
          heightMap,
          heightMapBounds,
          dummyHeightMap,
          terrainCover,
          useTerrainHeightMap,
          terrainSkipRender
        } = opts;
        const projectUniforms = project_default.getUniforms(opts.project);
        const { commonOrigin } = projectUniforms;
        let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
        let sampler = dummyHeightMap;
        let bounds = null;
        if (drawToTerrainHeightMap) {
          mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
          bounds = heightMapBounds;
        } else if (useTerrainHeightMap && heightMap) {
          mode = TERRAIN_MODE.USE_HEIGHT_MAP;
          sampler = heightMap;
          bounds = heightMapBounds;
        } else if (terrainCover) {
          const fbo = opts.isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
          sampler = fbo?.colorAttachments[0].texture;
          if (opts.isPicking) {
            mode = TERRAIN_MODE.SKIP;
          }
          if (sampler) {
            mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
            bounds = terrainCover.bounds;
          } else {
            sampler = dummyHeightMap;
          }
        }
        return {
          mode,
          terrain_map: sampler,
          // Convert bounds to the common space, as [minX, minY, width, height]
          bounds: bounds ? [
            bounds[0] - commonOrigin[0],
            bounds[1] - commonOrigin[1],
            bounds[2] - bounds[0],
            bounds[3] - bounds[1]
          ] : [0, 0, 0, 0]
        };
      }
      return {};
    },
    uniformTypes: {
      mode: "f32",
      bounds: "vec4<f32>"
    }
  };

  // ../extensions/src/terrain/utils.ts
  function createRenderTarget(device, opts) {
    return device.createFramebuffer({
      id: opts.id,
      colorAttachments: [
        device.createTexture({
          id: opts.id,
          ...opts.float && {
            format: "rgba32float",
            type: GLEnum.FLOAT
          },
          mipmaps: false,
          sampler: opts.interpolate === false ? {
            minFilter: "nearest",
            magFilter: "nearest"
          } : {
            minFilter: "linear",
            magFilter: "linear"
          }
        })
      ]
    });
  }

  // ../extensions/src/terrain/terrain-cover.ts
  var TerrainCover = class {
    constructor(targetLayer) {
      this.isDirty = true;
      /** Viewport used to draw into the texture */
      this.renderViewport = null;
      /** Bounds of the terrain cover texture, in cartesian space */
      this.bounds = null;
      this.layers = [];
      /** Cached version of targetLayer.getBounds() */
      this.targetBounds = null;
      /** targetBounds in cartesian space */
      this.targetBoundsCommon = null;
      this.targetLayer = targetLayer;
      this.tile = getTile(targetLayer);
    }
    get id() {
      return this.targetLayer.id;
    }
    /** returns true if the target layer is still in use (i.e. not finalized) */
    get isActive() {
      return Boolean(this.targetLayer.getCurrentLayer());
    }
    shouldUpdate({
      targetLayer,
      viewport,
      layers,
      layerNeedsRedraw
    }) {
      if (targetLayer) {
        this.targetLayer = targetLayer;
      }
      const sizeChanged = viewport ? this._updateViewport(viewport) : false;
      let layersChanged = layers ? this._updateLayers(layers) : false;
      if (layerNeedsRedraw) {
        for (const id of this.layers) {
          if (layerNeedsRedraw[id]) {
            layersChanged = true;
            break;
          }
        }
      }
      return layersChanged || sizeChanged;
    }
    /** Compare layers with the last version. Only rerender if necessary. */
    _updateLayers(layers) {
      let needsRedraw = false;
      layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
      if (layers.length !== this.layers.length) {
        needsRedraw = true;
      } else {
        for (let i5 = 0; i5 < layers.length; i5++) {
          const id = layers[i5].id;
          if (id !== this.layers[i5]) {
            needsRedraw = true;
            break;
          }
        }
      }
      if (needsRedraw) {
        this.layers = layers.map((layer) => layer.id);
      }
      return needsRedraw;
    }
    /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */
    // eslint-disable-next-line max-statements
    _updateViewport(viewport) {
      const targetLayer = this.targetLayer;
      let shouldRedraw = false;
      if (this.tile && "boundingBox" in this.tile) {
        if (!this.targetBounds) {
          shouldRedraw = true;
          this.targetBounds = this.tile.boundingBox;
          const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
          const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
          this.targetBoundsCommon = [
            bottomLeftCommon[0],
            bottomLeftCommon[1],
            topRightCommon[0],
            topRightCommon[1]
          ];
        }
      } else if (this.targetBounds !== targetLayer.getBounds()) {
        shouldRedraw = true;
        this.targetBounds = targetLayer.getBounds();
        this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
      }
      if (!this.targetBoundsCommon) {
        return false;
      }
      const newZoom = Math.ceil(viewport.zoom + 0.5);
      if (this.tile) {
        this.bounds = this.targetBoundsCommon;
      } else {
        const oldZoom = this.renderViewport?.zoom;
        shouldRedraw = shouldRedraw || newZoom !== oldZoom;
        const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
        const oldBounds = this.bounds;
        shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x3, i5) => x3 !== oldBounds[i5]);
        this.bounds = newBounds;
      }
      if (shouldRedraw) {
        this.renderViewport = makeViewport({
          bounds: this.bounds,
          zoom: newZoom,
          viewport
        });
      }
      return shouldRedraw;
    }
    getRenderFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });
      }
      return this.fbo;
    }
    getPickingFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
        return null;
      }
      if (!this.pickingFbo) {
        this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {
          id: `${this.id}-picking`,
          interpolate: false
        });
      }
      return this.pickingFbo;
    }
    filterLayers(layers) {
      return layers.filter(({ id }) => this.layers.includes(id));
    }
    delete() {
      const { fbo, pickingFbo } = this;
      if (fbo) {
        fbo.colorAttachments[0].destroy();
        fbo.destroy();
      }
      if (pickingFbo) {
        pickingFbo.colorAttachments[0].destroy();
        pickingFbo.destroy();
      }
    }
  };
  function getIntersectingLayers(sourceTile, layers) {
    return layers.filter((layer) => {
      const tile = getTile(layer);
      if (tile) {
        return intersect2(sourceTile.boundingBox, tile.boundingBox);
      }
      return true;
    });
  }
  function getTile(layer) {
    while (layer) {
      const { tile } = layer.props;
      if (tile) {
        return tile;
      }
      layer = layer.parent;
    }
    return null;
  }
  function intersect2(b1, b2) {
    if (b1 && b2) {
      return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
    }
    return false;
  }

  // ../extensions/src/terrain/terrain-pass.ts
  var TERRAIN_BLENDING = {
    blendColorOperation: "max",
    blendColorSrcFactor: "one",
    blendColorDstFactor: "one",
    blendAlphaOperation: "max",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one"
  };
  var TerrainPass = class extends LayersPass {
    getRenderableLayers(viewport, opts) {
      const { layers } = opts;
      const result = [];
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
      for (let i5 = 0; i5 < layers.length; i5++) {
        const layer = layers[i5];
        if (!layer.isComposite && drawParamsByIndex[i5].shouldDrawLayer) {
          result.push(layer);
        }
      }
      return result;
    }
    renderHeightMap(heightMap, opts) {
      const target2 = heightMap.getRenderFramebuffer();
      const viewport = heightMap.renderViewport;
      if (!target2 || !viewport) {
        return;
      }
      target2.resize(viewport);
      this.render({
        ...opts,
        target: target2,
        pass: "terrain-height-map",
        layers: opts.layers,
        viewports: [viewport],
        effects: [],
        clearColor: [0, 0, 0, 0]
      });
    }
    renderTerrainCover(terrainCover, opts) {
      const target2 = terrainCover.getRenderFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target2 || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      target2.resize(viewport);
      this.render({
        ...opts,
        target: target2,
        pass: `terrain-cover-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport],
        clearColor: [0, 0, 0, 0]
      });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: true,
        depthCompare: "always",
        ...layer.props.operation.includes("terrain") && TERRAIN_BLENDING
      };
    }
    getShaderModuleProps(layer, effects, otherShaderModuleProps) {
      return {
        terrain: {
          project: otherShaderModuleProps.project
        }
      };
    }
  };

  // ../extensions/src/terrain/terrain-picking-pass.ts
  var TerrainPickingPass = class extends PickLayersPass {
    constructor() {
      super(...arguments);
      /** Save layer index for use when drawing to terrain cover.
       * When a terrain cover's picking buffer is rendered,
       * we need to make sure each layer receives a consistent index (encoded in the alpha channel)
       * so that a picked color can be decoded back to the correct layer.
       * Updated in getRenderableLayers which is called in TerrainEffect.preRender
       */
      this.drawParameters = {};
    }
    getRenderableLayers(viewport, opts) {
      const { layers } = opts;
      const result = [];
      this.drawParameters = {};
      this._resetColorEncoder(opts.pickZ);
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
      for (let i5 = 0; i5 < layers.length; i5++) {
        const layer = layers[i5];
        if (!layer.isComposite && drawParamsByIndex[i5].shouldDrawLayer) {
          result.push(layer);
          this.drawParameters[layer.id] = drawParamsByIndex[i5].layerParameters;
        }
      }
      return result;
    }
    renderTerrainCover(terrainCover, opts) {
      const target2 = terrainCover.getPickingFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target2 || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      const terrainLayer = terrainCover.targetLayer;
      if (terrainLayer.props.pickable) {
        layers.unshift(terrainLayer);
      }
      target2.resize(viewport);
      this.render({
        ...opts,
        pickingFBO: target2,
        pass: `terrain-cover-picking-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport],
        // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,
        // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`
        cullRect: void 0,
        deviceRect: viewport,
        pickZ: false
      });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      let parameters2;
      if (this.drawParameters[layer.id]) {
        parameters2 = this.drawParameters[layer.id];
      } else {
        parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
        parameters2.blend = true;
      }
      return { ...parameters2, depthCompare: "always" };
    }
    getShaderModuleProps(layer, effects, otherShaderModuleProps) {
      return {
        terrain: {
          project: otherShaderModuleProps.project
        }
      };
    }
  };

  // ../extensions/src/terrain/height-map-builder.ts
  var MAP_MAX_SIZE = 2048;
  var HeightMapBuilder = class {
    constructor(device) {
      /** Viewport used to draw into the texture */
      this.renderViewport = null;
      /** Bounds of the height map texture, in cartesian space */
      this.bounds = null;
      /** Last rendered layers */
      this.layers = [];
      /** Last layer.getBounds() */
      this.layersBounds = [];
      /** The union of layersBounds in cartesian space */
      this.layersBoundsCommon = null;
      this.lastViewport = null;
      this.device = device;
    }
    static isSupported(device) {
      return device.isTextureFormatRenderable("rgba32float");
    }
    /** Returns the height map framebuffer for read/write access.
     * Returns null when the texture is invalid.
     */
    getRenderFramebuffer() {
      if (!this.renderViewport) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.device, { id: "height-map", float: true });
      }
      return this.fbo;
    }
    /** Called every render cycle to check if the framebuffer needs update */
    shouldUpdate({ layers, viewport }) {
      const layersChanged = layers.length !== this.layers.length || layers.some(
        (layer, i5) => (
          // Layer instance is updated
          // Layer props might have changed
          // Undetermined props could have an effect on the output geometry of a terrain source,
          // for example getElevation+updateTriggers, elevationScale, modelMatrix
          layer !== this.layers[i5] || // Some prop is in transition
          layer.props.transitions || // Layer's geometry bounds have changed
          layer.getBounds() !== this.layersBounds[i5]
        )
      );
      if (layersChanged) {
        this.layers = layers;
        this.layersBounds = layers.map((layer) => layer.getBounds());
        this.layersBoundsCommon = joinLayerBounds(layers, viewport);
      }
      const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
      if (!this.layersBoundsCommon) {
        this.renderViewport = null;
      } else if (layersChanged || viewportChanged) {
        const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
        if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
          this.renderViewport = null;
          return false;
        }
        this.bounds = bounds;
        this.lastViewport = viewport;
        const scale22 = viewport.scale;
        const pixelWidth = (bounds[2] - bounds[0]) * scale22;
        const pixelHeight = (bounds[3] - bounds[1]) * scale22;
        this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
          // It's not important whether the geometry is visible in this viewport, because
          // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader
          // However the viewport must have the same center and zoom as the screen viewport
          // So that projection uniforms used for calculating z are the same
          bounds: [
            viewport.center[0] - 1,
            viewport.center[1] - 1,
            viewport.center[0] + 1,
            viewport.center[1] + 1
          ],
          zoom: viewport.zoom,
          width: Math.min(pixelWidth, MAP_MAX_SIZE),
          height: Math.min(pixelHeight, MAP_MAX_SIZE),
          viewport
        }) : null;
        return true;
      }
      return false;
    }
    delete() {
      if (this.fbo) {
        this.fbo.colorAttachments[0].delete();
        this.fbo.delete();
      }
    }
  };

  // ../extensions/src/terrain/terrain-effect.ts
  var TerrainEffect = class {
    constructor() {
      this.id = "terrain-effect";
      this.props = null;
      this.useInPicking = true;
      /** true if picking in the current pass */
      this.isPicking = false;
      /** true if should use in the current pass */
      this.isDrapingEnabled = false;
      /** One texture for each primitive terrain layer, into which the draped layers render */
      this.terrainCovers = /* @__PURE__ */ new Map();
    }
    setup({ device, deck }) {
      this.dummyHeightMap = device.createTexture({
        width: 1,
        height: 1,
        data: new Uint8Array([0, 0, 0, 0])
      });
      this.terrainPass = new TerrainPass(device, { id: "terrain" });
      this.terrainPickingPass = new TerrainPickingPass(device, { id: "terrain-picking" });
      if (HeightMapBuilder.isSupported(device)) {
        this.heightMap = new HeightMapBuilder(device);
      } else {
        log_default.warn("Terrain offset mode is not supported by this browser")();
      }
      deck._addDefaultShaderModule(terrainModule);
    }
    preRender(opts) {
      if (opts.pickZ) {
        this.isDrapingEnabled = false;
        return;
      }
      const { viewports } = opts;
      const isPicking = opts.pass.startsWith("picking");
      this.isPicking = isPicking;
      this.isDrapingEnabled = true;
      const viewport = viewports[0];
      const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(
        viewport,
        opts
      );
      const terrainLayers = layers.filter((l3) => l3.props.operation.includes("terrain"));
      if (terrainLayers.length === 0) {
        return;
      }
      if (!isPicking) {
        const offsetLayers = layers.filter((l3) => l3.state.terrainDrawMode === "offset");
        if (offsetLayers.length > 0) {
          this._updateHeightMap(terrainLayers, viewport, opts);
        }
      }
      const drapeLayers = layers.filter((l3) => l3.state.terrainDrawMode === "drape");
      this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
    }
    getShaderModuleProps(layer, otherShaderModuleProps) {
      const { terrainDrawMode } = layer.state;
      return {
        terrain: {
          project: otherShaderModuleProps.project,
          isPicking: this.isPicking,
          heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,
          heightMapBounds: this.heightMap?.bounds,
          dummyHeightMap: this.dummyHeightMap,
          terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
          useTerrainHeightMap: terrainDrawMode === "offset",
          terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
        }
      };
    }
    cleanup({ deck }) {
      if (this.dummyHeightMap) {
        this.dummyHeightMap.delete();
        this.dummyHeightMap = void 0;
      }
      if (this.heightMap) {
        this.heightMap.delete();
        this.heightMap = void 0;
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.delete();
      }
      this.terrainCovers.clear();
      deck._removeDefaultShaderModule(terrainModule);
    }
    _updateHeightMap(terrainLayers, viewport, opts) {
      if (!this.heightMap) {
        return;
      }
      const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });
      if (!shouldUpdate) {
        return;
      }
      this.terrainPass.renderHeightMap(this.heightMap, {
        ...opts,
        layers: terrainLayers,
        shaderModuleProps: {
          terrain: {
            heightMapBounds: this.heightMap.bounds,
            dummyHeightMap: this.dummyHeightMap,
            drawToTerrainHeightMap: true
          },
          project: {
            devicePixelRatio: 1
          }
        }
      });
    }
    _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
      const layerNeedsRedraw = {};
      for (const layer of drapeLayers) {
        if (layer.state.terrainCoverNeedsRedraw) {
          layerNeedsRedraw[layer.id] = true;
          layer.state.terrainCoverNeedsRedraw = false;
        }
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });
      }
      for (const layer of terrainLayers) {
        this._updateTerrainCover(layer, drapeLayers, viewport, opts);
      }
      if (!this.isPicking) {
        this._pruneTerrainCovers();
      }
    }
    _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
      const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
      let terrainCover = this.terrainCovers.get(terrainLayer.id);
      if (!terrainCover) {
        terrainCover = new TerrainCover(terrainLayer);
        this.terrainCovers.set(terrainLayer.id, terrainCover);
      }
      try {
        const isDirty = terrainCover.shouldUpdate({
          targetLayer: terrainLayer,
          viewport,
          layers: drapeLayers
        });
        if (this.isPicking || terrainCover.isDirty || isDirty) {
          renderPass.renderTerrainCover(terrainCover, {
            ...opts,
            layers: drapeLayers,
            shaderModuleProps: {
              terrain: {
                dummyHeightMap: this.dummyHeightMap,
                terrainSkipRender: false
              },
              project: {
                devicePixelRatio: 1
              }
            }
          });
          if (!this.isPicking) {
            terrainCover.isDirty = false;
          }
        }
      } catch (err) {
        terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
      }
    }
    _pruneTerrainCovers() {
      const idsToRemove = [];
      for (const [id, terrainCover] of this.terrainCovers) {
        if (!terrainCover.isActive) {
          idsToRemove.push(id);
        }
      }
      for (const id of idsToRemove) {
        this.terrainCovers.delete(id);
      }
    }
  };

  // ../extensions/src/terrain/terrain-extension.ts
  var defaultProps39 = {
    terrainDrawMode: void 0
  };
  var TerrainExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [terrainModule]
      };
    }
    initializeState() {
      this.context.deck?._addDefaultEffect(new TerrainEffect());
    }
    updateState(params) {
      const { props, oldProps } = params;
      if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && // @ts-ignore `extruded` may not exist in props
      props.extruded === oldProps.extruded) {
        return;
      }
      let { terrainDrawMode } = props;
      if (!terrainDrawMode) {
        const is3d = this.props.extruded;
        const attributes = this.getAttributeManager()?.attributes;
        const hasAnchor = attributes && "instancePositions" in attributes;
        terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
      }
      this.setState({ terrainDrawMode });
    }
    onNeedsRedraw() {
      const state = this.state;
      if (state.terrainDrawMode === "drape") {
        state.terrainCoverNeedsRedraw = true;
      }
    }
  };
  TerrainExtension.defaultProps = defaultProps39;
  TerrainExtension.extensionName = "TerrainExtension";

  // ../../node_modules/@math.gl/polygon/dist/polygon-utils.js
  var DimIndex2 = {
    x: 0,
    y: 1,
    z: 2
  };
  function getPolygonSignedArea2(points, options = {}) {
    const { start = 0, end = points.length, plane = "xy" } = options;
    const dim = options.size || 2;
    let area2 = 0;
    const i0 = DimIndex2[plane[0]];
    const i1 = DimIndex2[plane[1]];
    for (let i5 = start, j2 = end - dim; i5 < end; i5 += dim) {
      area2 += (points[i5 + i0] - points[j2 + i0]) * (points[i5 + i1] + points[j2 + i1]);
      j2 = i5;
    }
    return area2 / 2;
  }

  // ../../node_modules/@math.gl/polygon/dist/earcut.js
  function earcut3(positions, holeIndices, dim = 2, areas, plane = "xy") {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x3;
    let y3;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i5 = dim; i5 < outerLen; i5 += dim) {
        x3 = positions[i5];
        y3 = positions[i5 + 1];
        if (x3 < minX)
          minX = x3;
        if (y3 < minY)
          minY = y3;
        if (x3 > maxX)
          maxX = x3;
        if (y3 > maxY)
          maxY = y3;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2, plane) {
    let i5;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea2(data, { start, end, size: dim, plane });
    }
    let i0 = DimIndex2[plane[0]];
    let i1 = DimIndex2[plane[1]];
    if (clockwise === area2 < 0) {
      for (i5 = start; i5 < end; i5 += dim)
        last = insertNode(i5, data[i5 + i0], data[i5 + i1], last);
    } else {
      for (i5 = end - dim; i5 >= start; i5 -= dim)
        last = insertNode(i5, data[i5 + i0], data[i5 + i1], last);
    }
    if (last && equals15(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p3 = start;
    let again;
    do {
      again = false;
      if (!p3.steiner && (equals15(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
        removeNode(p3);
        p3 = end = p3.prev;
        if (p3 === p3.next)
          break;
        again = true;
      } else {
        p3 = p3.next;
      }
    } while (again || p3 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a3 = ear.prev;
    const b2 = ear;
    const c2 = ear.next;
    if (area(a3, b2, c2) >= 0)
      return false;
    const ax = a3.x;
    const bx = b2.x;
    const cx = c2.x;
    const ay = a3.y;
    const by = b2.y;
    const cy = c2.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p3 = c2.next;
    while (p3 !== a3) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a3 = ear.prev;
    const b2 = ear;
    const c2 = ear.next;
    if (area(a3, b2, c2) >= 0)
      return false;
    const ax = a3.x;
    const bx = b2.x;
    const cx = c2.x;
    const ay = a3.y;
    const by = b2.y;
    const cy = c2.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p3 = ear.prevZ;
    let n3 = ear.nextZ;
    while (p3 && p3.z >= minZ && n3 && n3.z <= maxZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.prevZ;
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    while (p3 && p3.z >= minZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.prevZ;
    }
    while (n3 && n3.z <= maxZ) {
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p3 = start;
    do {
      const a3 = p3.prev;
      const b2 = p3.next.next;
      if (!equals15(a3, b2) && intersects(a3, p3, p3.next, b2) && locallyInside(a3, b2) && locallyInside(b2, a3)) {
        triangles.push(a3.i / dim | 0);
        triangles.push(p3.i / dim | 0);
        triangles.push(b2.i / dim | 0);
        removeNode(p3);
        removeNode(p3.next);
        p3 = start = b2;
      }
      p3 = p3.next;
    } while (p3 !== start);
    return filterPoints(p3);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a3 = start;
    do {
      let b2 = a3.next.next;
      while (b2 !== a3.prev) {
        if (a3.i !== b2.i && isValidDiagonal(a3, b2)) {
          let c2 = splitPolygon(a3, b2);
          a3 = filterPoints(a3, a3.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a3, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a3 = a3.next;
    } while (a3 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i5;
    let len8;
    let start;
    let end;
    let list;
    for (i5 = 0, len8 = holeIndices.length; i5 < len8; i5++) {
      start = holeIndices[i5] * dim;
      end = i5 < len8 - 1 ? holeIndices[i5 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i5 + 1], plane);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i5 = 0; i5 < queue.length; i5++) {
      outerNode = eliminateHole(queue[i5], outerNode);
    }
    return outerNode;
  }
  function compareX(a3, b2) {
    return a3.x - b2.x;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p3 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
        const x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
        if (x3 <= hx && x3 > qx) {
          qx = x3;
          m = p3.x < p3.next.x ? p3 : p3.next;
          if (x3 === hx)
            return m;
        }
      }
      p3 = p3.next;
    } while (p3 !== outerNode);
    if (!m)
      return null;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan6;
    p3 = m;
    do {
      if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
        tan6 = Math.abs(hy - p3.y) / (hx - p3.x);
        if (locallyInside(p3, hole) && (tan6 < tanMin || tan6 === tanMin && (p3.x > m.x || p3.x === m.x && sectorContainsSector(m, p3)))) {
          m = p3;
          tanMin = tan6;
        }
      }
      p3 = p3.next;
    } while (p3 !== stop);
    return m;
  }
  function sectorContainsSector(m, p3) {
    return area(m.prev, m, p3.prev) < 0 && area(p3.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p3 = start;
    do {
      if (p3.z === 0)
        p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
      p3.prevZ = p3.prev;
      p3.nextZ = p3.next;
      p3 = p3.next;
    } while (p3 !== start);
    p3.prevZ.nextZ = null;
    p3.prevZ = null;
    sortLinked(p3);
  }
  function sortLinked(list) {
    let e3;
    let i5;
    let inSize = 1;
    let numMerges;
    let p3;
    let pSize;
    let q2;
    let qSize;
    let tail;
    do {
      p3 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p3) {
        numMerges++;
        q2 = p3;
        pSize = 0;
        for (i5 = 0; i5 < inSize; i5++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
            e3 = p3;
            p3 = p3.nextZ;
            pSize--;
          } else {
            e3 = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e3;
          else
            list = e3;
          e3.prevZ = tail;
          tail = e3;
        }
        p3 = q2;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x3, y3, minX, minY, invSize) {
    x3 = (x3 - minX) * invSize | 0;
    y3 = (y3 - minY) * invSize | 0;
    x3 = (x3 | x3 << 8) & 16711935;
    x3 = (x3 | x3 << 4) & 252645135;
    x3 = (x3 | x3 << 2) & 858993459;
    x3 = (x3 | x3 << 1) & 1431655765;
    y3 = (y3 | y3 << 8) & 16711935;
    y3 = (y3 | y3 << 4) & 252645135;
    y3 = (y3 | y3 << 2) & 858993459;
    y3 = (y3 | y3 << 1) & 1431655765;
    return x3 | y3 << 1;
  }
  function getLeftmost(start) {
    let p3 = start;
    let leftmost = start;
    do {
      if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
        leftmost = p3;
      p3 = p3.next;
    } while (p3 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a3, b2) {
    return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon(a3, b2) && // dones't intersect other edges
    (locallyInside(a3, b2) && locallyInside(b2, a3) && middleInside(a3, b2) && // locally visible
    (area(a3.prev, a3, b2.prev) || area(a3, b2.prev, b2)) || // does not create opposite-facing sectors
    equals15(a3, b2) && area(a3.prev, a3, a3.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p3, q2, r3) {
    return (q2.y - p3.y) * (r3.x - q2.x) - (q2.x - p3.x) * (r3.y - q2.y);
  }
  function equals15(p1, p22) {
    return p1.x === p22.x && p1.y === p22.y;
  }
  function intersects(p1, q1, p22, q2) {
    const o1 = sign(area(p1, q1, p22));
    const o22 = sign(area(p1, q1, q2));
    const o3 = sign(area(p22, q2, p1));
    const o4 = sign(area(p22, q2, q1));
    if (o1 !== o22 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p22, q1))
      return true;
    if (o22 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p22, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p22, q1, q2))
      return true;
    return false;
  }
  function onSegment(p3, q2, r3) {
    return q2.x <= Math.max(p3.x, r3.x) && q2.x >= Math.min(p3.x, r3.x) && q2.y <= Math.max(p3.y, r3.y) && q2.y >= Math.min(p3.y, r3.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a3, b2) {
    let p3 = a3;
    do {
      if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a3, b2))
        return true;
      p3 = p3.next;
    } while (p3 !== a3);
    return false;
  }
  function locallyInside(a3, b2) {
    return area(a3.prev, a3, a3.next) < 0 ? area(a3, b2, a3.next) >= 0 && area(a3, a3.prev, b2) >= 0 : area(a3, b2, a3.prev) < 0 || area(a3, a3.next, b2) < 0;
  }
  function middleInside(a3, b2) {
    let p3 = a3;
    let inside = false;
    const px = (a3.x + b2.x) / 2;
    const py = (a3.y + b2.y) / 2;
    do {
      if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
        inside = !inside;
      p3 = p3.next;
    } while (p3 !== a3);
    return inside;
  }
  function splitPolygon(a3, b2) {
    const a22 = new Vertex(a3.i, a3.x, a3.y);
    const b22 = new Vertex(b2.i, b2.x, b2.y);
    const an = a3.next;
    const bp = b2.prev;
    a3.next = b2;
    b2.prev = a3;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i5, x3, y3, last) {
    const p3 = new Vertex(i5, x3, y3);
    if (!last) {
      p3.prev = p3;
      p3.next = p3;
    } else {
      p3.next = last.next;
      p3.prev = last;
      last.next.prev = p3;
      last.next = p3;
    }
    return p3;
  }
  function removeNode(p3) {
    p3.next.prev = p3.prev;
    p3.prev.next = p3.next;
    if (p3.prevZ)
      p3.prevZ.nextZ = p3.nextZ;
    if (p3.nextZ)
      p3.nextZ.prevZ = p3.prevZ;
  }
  var Vertex = class {
    constructor(i5, x3, y3) {
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
      this.i = i5;
      this.x = x3;
      this.y = y3;
    }
  };

  // ../../node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k2) => propArrayTypes[k2] !== Array);
    return fillArrays(features, {
      propArrayTypes,
      ...geometryInfo
    }, {
      numericPropKeys: options && options.numericPropKeys || numericPropKeys,
      PositionDataType: options ? options.PositionDataType : Float32Array,
      triangulate: options ? options.triangulate : true
    });
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val2 = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    if (triangulate) {
      polygons.triangles = [];
    }
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T2 = propArrayTypes[propName];
        object.numericProps[propName] = new T2(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({ id: feature.id });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({ id: feature.id });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({ id: feature.id });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for (let i5 = 0, il = geometry.indices.length; i5 < il; ++i5) {
      const start = geometry.indices[i5];
      const end = i5 === il - 1 ? geometry.data.length : geometry.indices[i5 + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    for (let l3 = 0, ll = geometry.indices.length; l3 < ll; ++l3) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l3];
      const indices = geometry.indices[l3];
      const nextIndices = geometry.indices[l3 + 1];
      for (let i5 = 0, il = indices.length; i5 < il; ++i5) {
        const start = indices[i5];
        const end = i5 === il - 1 ? (
          // last line, so either read to:
          nextIndices === void 0 ? geometry.data.length : nextIndices[0]
        ) : indices[i5 + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
    }
  }
  function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
    if (!polygons.triangles) {
      return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n3) => (n3 - offset) / coordLength);
    const triangles = earcut3(polygonPositions, holes, coordLength, areas);
    for (let t3 = 0, tl = triangles.length; t3 < tl; ++t3) {
      polygons.triangles.push(startPosition + triangles[t3]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = { value: obj[key], size };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
      shape: "binary-feature-collection",
      points: {
        ...points,
        positions: { value: points.positions, size: coordLength },
        globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
        featureIds: { value: points.featureIds, size: 1 },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: { value: lines.positions, size: coordLength },
        pathIndices: { value: lines.pathIndices, size: 1 },
        globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
        featureIds: { value: lines.featureIds, size: 1 },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: { value: polygons.positions, size: coordLength },
        polygonIndices: { value: polygons.polygonIndices, size: 1 },
        primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
        globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
        featureIds: { value: polygons.featureIds, size: 1 },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
      // triangles not expected
    };
    if (binaryFeatures.polygons && polygons.triangles) {
      binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
    }
    return binaryFeatures;
  }
  function fillNumericProperties(object, properties, index, length16) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length16);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x3, constructor) {
    if (constructor === Array || !Number.isFinite(x3)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x3) !== x3 ? Float64Array : Float32Array;
  }

  // ../../node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
  function binaryToGeojson(data, options) {
    const globalFeatureId = options?.globalFeatureId;
    if (globalFeatureId !== void 0) {
      return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options?.type);
  }
  function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data2 of dataArray) {
      let lastIndex = 0;
      let lastValue = data2.featureIds.value[0];
      for (let i5 = 0; i5 < data2.featureIds.value.length; i5++) {
        const currValue = data2.featureIds.value[i5];
        if (currValue === lastValue) {
          continue;
        }
        if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
          return parseFeature(data2, lastIndex, i5);
        }
        lastIndex = i5;
        lastValue = currValue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, data2.featureIds.value.length);
      }
    }
    throw new Error(`featureId:${globalFeatureId} not found`);
  }
  function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
  }
  function binaryToGeometry(data, startIndex, endIndex) {
    switch (data.type) {
      case "Point":
        return pointToGeoJson(data, startIndex, endIndex);
      case "LineString":
        return lineStringToGeoJson(data, startIndex, endIndex);
      case "Polygon":
        return polygonToGeoJson(data, startIndex, endIndex);
      default:
        const unexpectedInput = data;
        throw new Error(`Unsupported geometry type: ${unexpectedInput?.type}`);
    }
  }
  function normalizeInput(data, type) {
    const features = [];
    if (data.points) {
      data.points.type = "Point";
      features.push(data.points);
    }
    if (data.lines) {
      data.lines.type = "LineString";
      features.push(data.lines);
    }
    if (data.polygons) {
      data.polygons.type = "Polygon";
      features.push(data.polygons);
    }
    return features;
  }
  function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray) {
      if (data.featureIds.value.length === 0) {
        continue;
      }
      let lastIndex = 0;
      let lastValue = data.featureIds.value[0];
      for (let i5 = 0; i5 < data.featureIds.value.length; i5++) {
        const currValue = data.featureIds.value[i5];
        if (currValue === lastValue) {
          continue;
        }
        features.push(parseFeature(data, lastIndex, i5));
        lastIndex = i5;
        lastValue = currValue;
      }
      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
  }
  function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return { type: "Feature", geometry, properties, ...fields };
  }
  function parseFields(data, startIndex = 0, endIndex) {
    return data.fields && data.fields[data.featureIds.value[startIndex]];
  }
  function parseProperties(data, startIndex = 0, endIndex) {
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for (const key in data.numericProps) {
      properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
  }
  function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const polygonIndices = data.polygonIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const multi = polygonIndices.length > 2;
    if (!multi) {
      const coordinates2 = [];
      for (let i5 = 0; i5 < primitivePolygonIndices.length - 1; i5++) {
        const startRingIndex = primitivePolygonIndices[i5];
        const endRingIndex = primitivePolygonIndices[i5 + 1];
        const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
        coordinates2.push(ringCoordinates);
      }
      return { type: "Polygon", coordinates: coordinates2 };
    }
    const coordinates = [];
    for (let i5 = 0; i5 < polygonIndices.length - 1; i5++) {
      const startPolygonIndex = polygonIndices[i5];
      const endPolygonIndex = polygonIndices[i5 + 1];
      const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
      coordinates.push(polygonCoordinates);
    }
    return { type: "MultiPolygon", coordinates };
  }
  function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const pathIndices = data.pathIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
      const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
      return { type: "LineString", coordinates: coordinates2 };
    }
    const coordinates = [];
    for (let i5 = 0; i5 < pathIndices.length - 1; i5++) {
      const ringCoordinates = ringToGeoJson(positions, pathIndices[i5], pathIndices[i5 + 1]);
      coordinates.push(ringCoordinates);
    }
    return { type: "MultiLineString", coordinates };
  }
  function pointToGeoJson(data, startIndex, endIndex) {
    const { positions } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
      return { type: "MultiPoint", coordinates };
    }
    return { type: "Point", coordinates: coordinates[0] };
  }
  function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for (let j2 = startIndex; j2 < endIndex; j2++) {
      const coord = Array();
      for (let k2 = j2 * positions.size; k2 < (j2 + 1) * positions.size; k2++) {
        coord.push(Number(positions.value[k2]));
      }
      ringCoordinates.push(coord);
    }
    return ringCoordinates;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
  var import_pbf = __toESM(require_pbf(), 1);

  // ../../node_modules/@loaders.gl/mvt/dist/helpers/mapbox-util-functions.js
  function classifyRings(rings) {
    const len8 = rings.length;
    if (len8 <= 1)
      return [rings];
    const polygons = [];
    let polygon;
    let ccw;
    for (let i5 = 0; i5 < len8; i5++) {
      const area2 = signedArea(rings[i5]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i5]];
      } else if (polygon)
        polygon.push(rings[i5]);
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function signedArea(ring) {
    let sum2 = 0;
    for (let i5 = 0, j2 = ring.length - 1, p1, p22; i5 < ring.length; j2 = i5++) {
      p1 = ring[i5];
      p22 = ring[j2];
      sum2 += (p22[0] - p1[0]) * (p1[1] + p22[1]);
    }
    return sum2;
  }
  function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-feature.js
  var VectorTileFeature = class {
    properties;
    extent;
    type;
    id;
    _pbf;
    _geometry;
    _keys;
    _values;
    static get types() {
      return ["Unknown", "Point", "LineString", "Polygon"];
    }
    constructor(pbf, end, extent, keys, values) {
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      pbf.readFields(readFeature, this, end);
    }
    // eslint-disable-next-line complexity, max-statements
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length16 = 0;
      let x3 = 0;
      let y3 = 0;
      const lines = [];
      let line;
      while (pbf.pos < end) {
        if (length16 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length16 = cmdLen2 >> 3;
        }
        length16--;
        if (cmd2 === 1 || cmd2 === 2) {
          x3 += pbf.readSVarint();
          y3 += pbf.readSVarint();
          if (cmd2 === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x3, y3]);
        } else if (cmd2 === 7) {
          if (line) {
            line.push(line[0].slice());
          }
        } else {
          throw new Error(`unknown command ${cmd2}`);
        }
      }
      if (line)
        lines.push(line);
      return lines;
    }
    // eslint-disable-next-line max-statements
    bbox() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length16 = 0;
      let x3 = 0;
      let y3 = 0;
      let x1 = Infinity;
      let x22 = -Infinity;
      let y1 = Infinity;
      let y22 = -Infinity;
      while (pbf.pos < end) {
        if (length16 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length16 = cmdLen2 >> 3;
        }
        length16--;
        if (cmd2 === 1 || cmd2 === 2) {
          x3 += pbf.readSVarint();
          y3 += pbf.readSVarint();
          if (x3 < x1)
            x1 = x3;
          if (x3 > x22)
            x22 = x3;
          if (y3 < y1)
            y1 = y3;
          if (y3 > y22)
            y22 = y3;
        } else if (cmd2 !== 7) {
          throw new Error(`unknown command ${cmd2}`);
        }
      }
      return [x1, y1, x22, y22];
    }
    _toGeoJSON(transform2) {
      let coords = this.loadGeometry();
      let type = VectorTileFeature.types[this.type];
      let i5;
      let j2;
      switch (this.type) {
        case 1:
          const points = [];
          for (i5 = 0; i5 < coords.length; i5++) {
            points[i5] = coords[i5][0];
          }
          coords = points;
          transform2(coords, this);
          break;
        case 2:
          for (i5 = 0; i5 < coords.length; i5++) {
            transform2(coords[i5], this);
          }
          break;
        case 3:
          coords = classifyRings(coords);
          for (i5 = 0; i5 < coords.length; i5++) {
            for (j2 = 0; j2 < coords[i5].length; j2++) {
              transform2(coords[i5][j2], this);
            }
          }
          break;
      }
      if (coords.length === 1) {
        coords = coords[0];
      } else {
        type = `Multi${type}`;
      }
      const result = {
        type: "Feature",
        geometry: {
          type,
          coordinates: coords
        },
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toGeoJSON(options) {
      if (typeof options === "function") {
        return this._toGeoJSON(options);
      }
      const { x: x3, y: y3, z: z2 } = options;
      const size = this.extent * Math.pow(2, z2);
      const x0 = this.extent * x3;
      const y0 = this.extent * y3;
      function project2(line) {
        for (let j2 = 0; j2 < line.length; j2++) {
          const p3 = line[j2];
          p3[0] = (p3[0] + x0) * 360 / size - 180;
          const y22 = 180 - (p3[1] + y0) * 360 / size;
          p3[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
        }
      }
      return this._toGeoJSON(project2);
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-layer.js
  var VectorTileLayer = class {
    version;
    name;
    extent;
    length;
    _pbf;
    _keys;
    _values;
    _features;
    constructor(pbf, end) {
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    /**
     * return feature `i` from this layer as a `VectorTileFeature`
     * @param index
     * @returns feature
     */
    feature(i5) {
      if (i5 < 0 || i5 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i5];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    }
  };
  function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile.js
  var VectorTile = class {
    layers;
    constructor(pbf, end) {
      this.layers = pbf.readFields(readTile, {}, end);
    }
  };
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/helpers/binary-util-functions.js
  function classifyRings2(geom) {
    const len8 = geom.indices.length;
    const type = "Polygon";
    if (len8 <= 1) {
      return {
        type,
        data: geom.data,
        areas: [[getPolygonSignedArea2(geom.data)]],
        indices: [geom.indices]
      };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for (let endIndex, i5 = 0, startIndex; i5 < len8; i5++) {
      startIndex = geom.indices[i5] - offset;
      endIndex = geom.indices[i5 + 1] - offset || geom.data.length;
      const shape = geom.data.slice(startIndex, endIndex);
      const area2 = getPolygonSignedArea2(shape);
      if (area2 === 0) {
        const before = geom.data.slice(0, startIndex);
        const after = geom.data.slice(endIndex);
        geom.data = before.concat(after);
        offset += endIndex - startIndex;
        continue;
      }
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon.length) {
          areas.push(ringAreas);
          polygons.push(polygon);
        }
        polygon = [startIndex];
        ringAreas = [area2];
      } else {
        ringAreas.push(area2);
        polygon.push(startIndex);
      }
    }
    if (ringAreas)
      areas.push(ringAreas);
    if (polygon.length)
      polygons.push(polygon);
    return { type, areas, indices: polygons, data: geom.data };
  }
  function project(data, x0, y0, size) {
    for (let j2 = 0, jl = data.length; j2 < jl; j2 += 2) {
      data[j2] = (data[j2] + x0) * 360 / size - 180;
      const y22 = 180 - (data[j2 + 1] + y0) * 360 / size;
      data[j2 + 1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
    }
  }
  function readFeature2(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag2(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag2(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-feature.js
  var endPos;
  var cmd;
  var cmdLen;
  var length15;
  var x;
  var y;
  var i2;
  var BinaryVectorTileFeature = class {
    properties;
    extent;
    type;
    id;
    _pbf;
    _geometry;
    _keys;
    _values;
    _geometryInfo;
    // eslint-disable-next-line max-params
    constructor(pbf, end, extent, keys, values, geometryInfo) {
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      this._geometryInfo = geometryInfo;
      pbf.readFields(readFeature2, this, end);
    }
    // eslint-disable-next-line complexity, max-statements
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      endPos = pbf.readVarint() + pbf.pos;
      cmd = 1;
      length15 = 0;
      x = 0;
      y = 0;
      i2 = 0;
      const indices = [];
      const data = [];
      while (pbf.pos < endPos) {
        if (length15 <= 0) {
          cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length15 = cmdLen >> 3;
        }
        length15--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            indices.push(i2);
          }
          data.push(x, y);
          i2 += 2;
        } else if (cmd === 7) {
          if (i2 > 0) {
            const start = indices[indices.length - 1];
            data.push(data[start], data[start + 1]);
            i2 += 2;
          }
        } else {
          throw new Error(`unknown command ${cmd}`);
        }
      }
      return { data, indices };
    }
    /**
     *
     * @param transform
     * @returns result
     */
    _toBinaryCoordinates(transform2) {
      const geom = this.loadGeometry();
      let geometry;
      transform2(geom.data, this);
      const coordLength = 2;
      switch (this.type) {
        case 1:
          this._geometryInfo.pointFeaturesCount++;
          this._geometryInfo.pointPositionsCount += geom.indices.length;
          geometry = { type: "Point", ...geom };
          break;
        case 2:
          this._geometryInfo.lineFeaturesCount++;
          this._geometryInfo.linePathsCount += geom.indices.length;
          this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
          geometry = { type: "LineString", ...geom };
          break;
        case 3:
          geometry = classifyRings2(geom);
          this._geometryInfo.polygonFeaturesCount++;
          this._geometryInfo.polygonObjectsCount += geometry.indices.length;
          for (const indices of geometry.indices) {
            this._geometryInfo.polygonRingsCount += indices.length;
          }
          this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
          break;
        default:
          throw new Error(`Invalid geometry type: ${this.type}`);
      }
      const result = { type: "Feature", geometry, properties: this.properties };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toBinaryCoordinates(options) {
      if (typeof options === "function") {
        return this._toBinaryCoordinates(options);
      }
      const { x: x3, y: y3, z: z2 } = options;
      const size = this.extent * Math.pow(2, z2);
      const x0 = this.extent * x3;
      const y0 = this.extent * y3;
      return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-layer.js
  var BinaryVectorTileLayer = class {
    version;
    name;
    extent;
    length;
    _pbf;
    _keys;
    _values;
    _features;
    constructor(pbf, end) {
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer2, this, end);
      this.length = this._features.length;
    }
    /**
     * return feature `i` from this layer as a `BinaryVectorTileFeature`
     *
     * @param index
     * @param geometryInfo
     * @returns {BinaryVectorTileFeature}
     */
    feature(i5, geometryInfo) {
      if (i5 < 0 || i5 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i5];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new BinaryVectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
    }
  };
  function readLayer2(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage2(pbf));
    }
  }
  function readValueMessage2(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile.js
  var BinaryVectorTile = class {
    layers;
    constructor(pbf, end) {
      this.layers = pbf.readFields(readTile2, {}, end);
    }
  };
  function readTile2(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new BinaryVectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
  function parseMVT(arrayBuffer2, options) {
    const mvtOptions = normalizeOptions2(options);
    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;
    switch (shape) {
      case "columnar-table":
        return { shape: "columnar-table", data: parseToBinary(arrayBuffer2, mvtOptions) };
      case "geojson-table": {
        const table = {
          shape: "geojson-table",
          type: "FeatureCollection",
          features: parseToGeojsonFeatures(arrayBuffer2, mvtOptions)
        };
        return table;
      }
      case "geojson":
        return parseToGeojsonFeatures(arrayBuffer2, mvtOptions);
      case "binary-geometry":
        return parseToBinary(arrayBuffer2, mvtOptions);
      case "binary":
        return parseToBinary(arrayBuffer2, mvtOptions);
      default:
        throw new Error(shape || "undefined shape");
    }
  }
  function parseToBinary(arrayBuffer2, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer2, options);
    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
    binaryData.byteLength = arrayBuffer2.byteLength;
    return binaryData;
  }
  function parseToFlatGeoJson(arrayBuffer2, options) {
    const features = [];
    const geometryInfo = {
      coordLength: 2,
      pointPositionsCount: 0,
      pointFeaturesCount: 0,
      linePositionsCount: 0,
      linePathsCount: 0,
      lineFeaturesCount: 0,
      polygonPositionsCount: 0,
      polygonObjectsCount: 0,
      polygonRingsCount: 0,
      polygonFeaturesCount: 0
    };
    if (arrayBuffer2.byteLength <= 0) {
      return [features, geometryInfo];
    }
    const tile = new BinaryVectorTile(new import_pbf.default(arrayBuffer2));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i5 = 0; i5 < vectorTileLayer.length; i5++) {
        const vectorTileFeature = vectorTileLayer.feature(i5, geometryInfo);
        const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return [features, geometryInfo];
  }
  function parseToGeojsonFeatures(arrayBuffer2, options) {
    if (arrayBuffer2.byteLength <= 0) {
      return [];
    }
    const features = [];
    const tile = new VectorTile(new import_pbf.default(arrayBuffer2));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i5 = 0; i5 < vectorTileLayer.length; i5++) {
        const vectorTileFeature = vectorTileLayer.feature(i5);
        const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return features;
  }
  function normalizeOptions2(options) {
    if (!options?.mvt) {
      throw new Error("mvt options required");
    }
    const wgs84Coordinates = options.mvt?.coordinates === "wgs84";
    const { tileIndex } = options.mvt;
    const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
    if (wgs84Coordinates && !hasTileIndex) {
      throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
    }
    return options.mvt;
  }
  function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSON(
      // @ts-expect-error What is going on here?
      options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates
    );
    if (options.layerProperty) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryCoordinates(
      // @ts-expect-error
      options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary
    );
    if (options.layerProperty && decodedFeature.properties) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function transformToLocalCoordinates(line, feature) {
    const { extent } = feature;
    for (let i5 = 0; i5 < line.length; i5++) {
      const p3 = line[i5];
      p3[0] /= extent;
      p3[1] /= extent;
    }
  }
  function transformToLocalCoordinatesBinary(data, feature) {
    const { extent } = feature;
    for (let i5 = 0, il = data.length; i5 < il; ++i5) {
      data[i5] /= extent;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/mvt-loader.js
  var VERSION13 = true ? "4.2.1" : "latest";
  var MVTWorkerLoader = {
    dataType: null,
    batchType: null,
    name: "Mapbox Vector Tile",
    id: "mvt",
    module: "mvt",
    version: VERSION13,
    // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
    extensions: ["mvt", "pbf"],
    mimeTypes: [
      // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
      // 'application/octet-stream'
    ],
    worker: true,
    category: "geometry",
    options: {
      mvt: {
        shape: "geojson",
        coordinates: "local",
        layerProperty: "layerName",
        layers: void 0,
        tileIndex: null
      }
    }
  };
  var MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer2, options) => parseMVT(arrayBuffer2, options),
    parseSync: parseMVT,
    binary: true
  };

  // ../geo-layers/src/mvt-layer/coordinate-transform.ts
  var availableTransformations = {
    Point,
    MultiPoint,
    LineString,
    MultiLineString,
    Polygon: Polygon3,
    MultiPolygon
  };
  function Point([pointX, pointY], [nw, se], viewport) {
    const x3 = lerp(nw[0], se[0], pointX);
    const y3 = lerp(nw[1], se[1], pointY);
    return viewport.unprojectFlat([x3, y3]);
  }
  function getPoints(geometry, bbox, viewport) {
    return geometry.map((g2) => Point(g2, bbox, viewport));
  }
  function MultiPoint(multiPoint, bbox, viewport) {
    return getPoints(multiPoint, bbox, viewport);
  }
  function LineString(line, bbox, viewport) {
    return getPoints(line, bbox, viewport);
  }
  function MultiLineString(multiLineString, bbox, viewport) {
    return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
  }
  function Polygon3(polygon, bbox, viewport) {
    return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
  }
  function MultiPolygon(multiPolygon, bbox, viewport) {
    return multiPolygon.map((polygon) => Polygon3(polygon, bbox, viewport));
  }
  function transform(geometry, bbox, viewport) {
    const nw = viewport.projectFlat([bbox.west, bbox.north]);
    const se = viewport.projectFlat([bbox.east, bbox.south]);
    const projectedBbox = [nw, se];
    return {
      ...geometry,
      coordinates: availableTransformations[geometry.type](
        geometry.coordinates,
        projectedBbox,
        viewport
      )
    };
  }

  // ../geo-layers/src/mvt-layer/find-index-binary.ts
  var GEOM_TYPES = ["points", "lines", "polygons"];
  function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
    for (const gt of GEOM_TYPES) {
      const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
      if (index >= 0) {
        return index;
      }
    }
    return -1;
  }
  function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
    const featureIds = geomData.featureIds.value;
    if (!featureIds.length) {
      return -1;
    }
    let startFeatureIndex = 0;
    let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
    if (layerName) {
      const layerRange = getLayerRange(geomData, layerName);
      if (layerRange) {
        startFeatureIndex = layerRange[0];
        endFeatureIndex = layerRange[1] + 1;
      } else {
        return -1;
      }
    }
    let featureIndex = -1;
    if (uniqueIdProperty in geomData.numericProps) {
      const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(
        (x3, i5) => x3 === featureId && featureIds[i5] >= startFeatureIndex && featureIds[i5] < endFeatureIndex
      );
      return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
    } else if (uniqueIdProperty) {
      featureIndex = findIndex(
        geomData.properties,
        (elem) => elem[uniqueIdProperty] === featureId,
        startFeatureIndex,
        endFeatureIndex
      );
    } else if (geomData.fields) {
      featureIndex = findIndex(
        geomData.fields,
        (elem) => elem.id === featureId,
        startFeatureIndex,
        endFeatureIndex
      );
    }
    return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
  }
  function getLayerRange(geomData, layerName) {
    if (!geomData.__layers) {
      const layerNames = {};
      const { properties } = geomData;
      for (let i5 = 0; i5 < properties.length; i5++) {
        const { layerName: key } = properties[i5];
        if (!key) {
        } else if (layerNames[key]) {
          layerNames[key][1] = i5;
        } else {
          layerNames[key] = [i5, i5];
        }
      }
      geomData.__layers = layerNames;
    }
    return geomData.__layers[layerName];
  }
  function getGlobalFeatureId(geomData, featureIndex) {
    if (!geomData.__ids) {
      const result = [];
      const featureIds = geomData.featureIds.value;
      const globalFeatureIds = geomData.globalFeatureIds.value;
      for (let i5 = 0; i5 < featureIds.length; i5++) {
        result[featureIds[i5]] = globalFeatureIds[i5];
      }
      geomData.__ids = result;
    }
    return geomData.__ids[featureIndex];
  }
  function findIndex(array, predicate, startIndex, endIndex) {
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      if (predicate(array[i5], i5)) {
        return i5;
      }
    }
    return -1;
  }

  // ../geo-layers/src/mvt-layer/mvt-layer.ts
  var WORLD_SIZE = 512;
  var defaultProps40 = {
    ...GeoJsonLayer.defaultProps,
    data: urlType,
    onDataLoad: { type: "function", value: null, optional: true, compare: false },
    uniqueIdProperty: "",
    highlightedFeatureId: null,
    loaders: [MVTWorkerLoader],
    binary: true
  };
  var MVTLayer = class extends TileLayer {
    initializeState() {
      super.initializeState();
      const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
      this.setState({
        binary,
        data: null,
        tileJSON: null,
        hoveredFeatureId: null,
        hoveredFeatureLayerName: null
      });
    }
    get isLoaded() {
      return Boolean(this.state?.data && super.isLoaded);
    }
    updateState({ props, oldProps, context, changeFlags }) {
      if (changeFlags.dataChanged) {
        this._updateTileData();
      }
      if (this.state?.data) {
        super.updateState({ props, oldProps, context, changeFlags });
        this._setWGS84PropertyForTiles();
      }
      const { highlightColor } = props;
      if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
        this.setState({ highlightColor });
      }
    }
    /* eslint-disable complexity */
    async _updateTileData() {
      let data = this.props.data;
      let tileJSON = null;
      if (typeof data === "string" && !isURLTemplate(data)) {
        const { onDataLoad, fetch: fetch2 } = this.props;
        this.setState({ data: null, tileJSON: null });
        try {
          tileJSON = await fetch2(data, { propName: "data", layer: this, loaders: [] });
        } catch (error) {
          this.raiseError(error, "loading TileJSON");
          data = null;
        }
        if (onDataLoad) {
          onDataLoad(tileJSON, { propName: "data", layer: this });
        }
      } else if (data && typeof data === "object" && "tilejson" in data) {
        tileJSON = data;
      }
      if (tileJSON) {
        data = tileJSON.tiles;
      }
      this.setState({ data, tileJSON });
    }
    _getTilesetOptions() {
      const opts = super._getTilesetOptions();
      const tileJSON = this.state.tileJSON;
      const { minZoom, maxZoom } = this.props;
      if (tileJSON) {
        if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
          opts.minZoom = tileJSON.minzoom;
        }
        if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
          opts.maxZoom = tileJSON.maxzoom;
        }
      }
      return opts;
    }
    /* eslint-disable complexity */
    renderLayers() {
      if (!this.state?.data)
        return null;
      return super.renderLayers();
    }
    getTileData(loadProps) {
      const { data, binary } = this.state;
      const { index, signal } = loadProps;
      const url = getURLFromTemplate(data, loadProps);
      if (!url) {
        return Promise.reject("Invalid URL");
      }
      let loadOptions = this.getLoadOptions();
      const { fetch: fetch2 } = this.props;
      loadOptions = {
        ...loadOptions,
        mimeType: "application/x-protobuf",
        mvt: {
          ...loadOptions?.mvt,
          coordinates: this.context.viewport.resolution ? "wgs84" : "local",
          tileIndex: index
          // Local worker debug
          // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`
          // Set worker to null to skip web workers
          // workerUrl: null
        },
        gis: binary ? { format: "binary" } : {}
      };
      return fetch2(url, { propName: "data", layer: this, loadOptions, signal });
    }
    renderSubLayers(props) {
      const { x: x3, y: y3, z: z2 } = props.tile.index;
      const worldScale = Math.pow(2, z2);
      const xScale = WORLD_SIZE / worldScale;
      const yScale = -xScale;
      const xOffset = WORLD_SIZE * x3 / worldScale;
      const yOffset = WORLD_SIZE * (1 - y3 / worldScale);
      const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
      props.autoHighlight = false;
      if (!this.context.viewport.resolution) {
        props.modelMatrix = modelMatrix2;
        props.coordinateOrigin = [xOffset, yOffset, 0];
        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
        props.extensions = [...props.extensions || [], new ClipExtension()];
      }
      const subLayers = super.renderSubLayers(props);
      if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
        log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
      }
      return subLayers;
    }
    _updateAutoHighlight(info) {
      const { uniqueIdProperty } = this.props;
      const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
      const hoveredFeature = info.object;
      let newHoveredFeatureId = null;
      let newHoveredFeatureLayerName = null;
      if (hoveredFeature) {
        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
        newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
      }
      let { highlightColor } = this.props;
      if (typeof highlightColor === "function") {
        highlightColor = highlightColor(info);
      }
      if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
        this.setState({
          highlightColor,
          hoveredFeatureId: newHoveredFeatureId,
          hoveredFeatureLayerName: newHoveredFeatureLayerName
        });
      }
    }
    _isWGS84() {
      return Boolean(this.context.viewport.resolution);
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      if (this.state.binary && info.index !== -1) {
        const { data } = params.sourceLayer.props;
        info.object = binaryToGeojson(data, {
          globalFeatureId: info.index
        });
      }
      if (info.object && !this._isWGS84()) {
        info.object = transformTileCoordsToWGS84(
          info.object,
          info.tile.bbox,
          // eslint-disable-line
          this.context.viewport
        );
      }
      return info;
    }
    getSubLayerPropsByTile(tile) {
      return {
        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
        highlightColor: this.state.highlightColor
      };
    }
    getHighlightedObjectIndex(tile) {
      const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
      const { uniqueIdProperty, highlightedFeatureId } = this.props;
      const data = tile.content;
      const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
      const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
      if (!isFeatureIdPresent) {
        return -1;
      }
      const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
      if (Array.isArray(data)) {
        return data.findIndex((feature) => {
          const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
          const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
          return isMatchingId && isMatchingLayer;
        });
      } else if (data && binary) {
        return findIndexBinary(
          data,
          uniqueIdProperty,
          featureIdToHighlight,
          isHighlighted ? "" : hoveredFeatureLayerName
        );
      }
      return -1;
    }
    _pickObjects(maxObjects) {
      const { deck, viewport } = this.context;
      const width = viewport.width;
      const height = viewport.height;
      const x3 = viewport.x;
      const y3 = viewport.y;
      const layerIds = [this.id];
      return deck.pickObjects({ x: x3, y: y3, width, height, layerIds, maxObjects });
    }
    /** Get the rendered features in the current viewport. */
    getRenderedFeatures(maxFeatures = null) {
      const features = this._pickObjects(maxFeatures);
      const featureCache = /* @__PURE__ */ new Set();
      const renderedFeatures = [];
      for (const f4 of features) {
        const featureId = getFeatureUniqueId(f4.object, this.props.uniqueIdProperty);
        if (featureId === void 0) {
          renderedFeatures.push(f4.object);
        } else if (!featureCache.has(featureId)) {
          featureCache.add(featureId);
          renderedFeatures.push(f4.object);
        }
      }
      return renderedFeatures;
    }
    _setWGS84PropertyForTiles() {
      const propName = "dataInWGS84";
      const tileset = this.state.tileset;
      tileset.selectedTiles.forEach((tile) => {
        if (!tile.hasOwnProperty(propName)) {
          Object.defineProperty(tile, propName, {
            get: () => {
              if (!tile.content) {
                return null;
              }
              if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                return [];
              }
              const { bbox } = tile;
              if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                tile._contentWGS84 = content.map(
                  (feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport)
                );
              }
              return tile._contentWGS84;
            }
          });
        }
      });
    }
  };
  MVTLayer.layerName = "MVTLayer";
  MVTLayer.defaultProps = defaultProps40;
  function getFeatureUniqueId(feature, uniqueIdProperty) {
    if (feature.properties && uniqueIdProperty) {
      return feature.properties[uniqueIdProperty];
    }
    if ("id" in feature) {
      return feature.id;
    }
    return void 0;
  }
  function getFeatureLayerName(feature) {
    return feature.properties?.layerName || null;
  }
  function isFeatureIdDefined(value) {
    return value !== void 0 && value !== null && value !== "";
  }
  function transformTileCoordsToWGS84(object, bbox, viewport) {
    const feature = {
      ...object,
      geometry: {
        type: object.geometry.type
      }
    };
    Object.defineProperty(feature.geometry, "coordinates", {
      get: () => {
        const wgs84Geom = transform(object.geometry, bbox, viewport);
        return wgs84Geom.coordinates;
      }
    });
    return feature;
  }

  // ../geo-layers/src/geohash-layer/geohash-utils.ts
  var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
  var BASE32_CODES_DICT = {};
  for (let i5 = 0; i5 < BASE32_CODES.length; i5++) {
    BASE32_CODES_DICT[BASE32_CODES.charAt(i5)] = i5;
  }
  var MIN_LAT = -90;
  var MAX_LAT = 90;
  var MIN_LON = -180;
  var MAX_LON = 180;
  function getGeohashBounds(geohash) {
    let isLon = true;
    let maxLat = MAX_LAT;
    let minLat = MIN_LAT;
    let maxLon = MAX_LON;
    let minLon = MIN_LON;
    let mid;
    let hashValue = 0;
    for (let i5 = 0, l3 = geohash.length; i5 < l3; i5++) {
      const code = geohash[i5].toLowerCase();
      hashValue = BASE32_CODES_DICT[code];
      for (let bits = 4; bits >= 0; bits--) {
        const bit = hashValue >> bits & 1;
        if (isLon) {
          mid = (maxLon + minLon) / 2;
          if (bit === 1) {
            minLon = mid;
          } else {
            maxLon = mid;
          }
        } else {
          mid = (maxLat + minLat) / 2;
          if (bit === 1) {
            minLat = mid;
          } else {
            maxLat = mid;
          }
        }
        isLon = !isLon;
      }
    }
    return [minLat, minLon, maxLat, maxLon];
  }
  function getGeohashPolygon(geohash) {
    const [s3, w2, n3, e3] = getGeohashBounds(geohash);
    return [e3, n3, e3, s3, w2, s3, w2, n3, e3, n3];
  }

  // ../geo-layers/src/geohash-layer/geohash-layer.ts
  var defaultProps41 = {
    getGeohash: { type: "accessor", value: (d2) => d2.geohash }
  };
  var GeohashLayer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, getGeohash } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getGeohashPolygon(getGeohash(x3, objectInfo))
      };
    }
  };
  GeohashLayer.layerName = "GeohashLayer";
  GeohashLayer.defaultProps = defaultProps41;

  // ../core/src/scripting/lumagl.ts
  var lumagl_exports = {};
  __export(lumagl_exports, {
    Buffer: () => Buffer2,
    BufferTransform: () => BufferTransform,
    CubeGeometry: () => CubeGeometry,
    Device: () => Device,
    Framebuffer: () => Framebuffer,
    Geometry: () => Geometry,
    GroupNode: () => GroupNode,
    Model: () => Model,
    ModelNode: () => ModelNode,
    ScenegraphNode: () => ScenegraphNode,
    SphereGeometry: () => SphereGeometry,
    Texture: () => Texture,
    TextureTransform: () => TextureTransform,
    attachDevice: () => attachDevice,
    createDevice: () => createDevice,
    enforceWebGL2: () => enforceWebGL22,
    getBestAvailableAdapter: () => getBestAvailableAdapter,
    getSupportedAdapters: () => getSupportedAdapters,
    registerDevices: () => registerDevices,
    setDefaultDeviceProps: () => setDefaultDeviceProps,
    stats: () => stats
  });
  var {
    stats,
    registerDevices,
    getSupportedAdapters,
    getBestAvailableAdapter,
    setDefaultDeviceProps,
    attachDevice,
    createDevice,
    enforceWebGL2: enforceWebGL22
  } = luma;

  // ../core/src/scripting/loadersgl.ts
  var loadersgl_exports = {};
  __export(loadersgl_exports, {
    fetchFile: () => fetchFile,
    load: () => load,
    parse: () => parse,
    registerLoaders: () => registerLoaders
  });

  // ../core/src/scripting/map-wrapper.ts
  var MapWrapper = class {
    constructor(props) {
      this.map = null;
      this.width = 0;
      this.height = 0;
      this.props = { ...props };
      this._initialize(this.props);
    }
    finalize() {
      this.map?.remove();
      this.map = null;
    }
    setProps(props) {
      const oldProps = this.props;
      const newProps = { ...this.props, ...props };
      this.props = newProps;
      if (!this.map) {
        return;
      }
      const needsRedraw = this._update(oldProps, newProps);
      if (needsRedraw) {
        this.redraw();
      }
    }
    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next
    // render cycle, which is managed by Mapbox's animation loop.
    // This removes the synchronization issue caused by requestAnimationFrame.
    redraw() {
      const map6 = this.map;
      if (map6.style) {
        if (map6._frame) {
          map6._frame.cancel();
          map6._frame = null;
        }
        map6._render();
      }
    }
    // External apps can access map this way
    getMap() {
      return this.map;
    }
    _initialize(props) {
      const { mapLib, container } = props;
      mapLib.accessToken = props.mapboxApiAccessToken || "";
      this.map = new props.mapLib.Map({
        container,
        maxZoom: 24,
        ...props.mapOptions,
        ...viewStateToMapboxProps(props.viewState),
        style: props.mapStyle,
        interactive: false,
        trackResize: false
      });
      Object.defineProperty(container, "offsetWidth", { get: () => this.width });
      Object.defineProperty(container, "clientWidth", { get: () => this.width });
      Object.defineProperty(container, "offsetHeight", {
        get: () => this.height
      });
      Object.defineProperty(container, "clientHeight", {
        get: () => this.height
      });
      this.map.resize();
    }
    _update(oldProps, newProps) {
      const styleChanged = oldProps.mapStyle !== newProps.mapStyle;
      if (styleChanged) {
        this.map.setStyle(newProps.mapStyle);
      }
      const sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
      if (sizeChanged) {
        this.width = newProps.width;
        this.height = newProps.height;
        this.map.resize();
      }
      const oldViewState = oldProps.viewState;
      const newViewState = newProps.viewState;
      const viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing;
      if (viewportChanged) {
        this.map.jumpTo(viewStateToMapboxProps(newViewState));
      }
      return sizeChanged || viewportChanged;
    }
  };
  function viewStateToMapboxProps(viewState) {
    return {
      center: [viewState.longitude, viewState.latitude],
      zoom: viewState.zoom,
      bearing: viewState.bearing ?? 0,
      pitch: viewState.pitch ?? 0
    };
  }

  // ../core/src/scripting/deckgl.ts
  var CANVAS_STYLE = {
    position: "absolute",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  };
  function createCanvas2(props) {
    let { container = document.body } = props;
    if (typeof container === "string") {
      container = document.getElementById(container);
    }
    if (!container) {
      throw Error("Deck: container not found");
    }
    const containerStyle = window.getComputedStyle(container);
    if (containerStyle.position === "static") {
      container.style.position = "relative";
    }
    const mapCanvas = document.createElement("div");
    container.appendChild(mapCanvas);
    Object.assign(mapCanvas.style, CANVAS_STYLE);
    const deckCanvas = document.createElement("canvas");
    container.appendChild(deckCanvas);
    Object.assign(deckCanvas.style, CANVAS_STYLE);
    return { container, mapCanvas, deckCanvas };
  }
  var DeckGL = class extends Deck {
    constructor(props) {
      if (typeof document === "undefined") {
        throw Error("Deck can only be used in the browser");
      }
      const { mapCanvas, deckCanvas } = createCanvas2(props);
      const viewState = props.viewState || props.initialViewState;
      const isMap = Number.isFinite(viewState && viewState.latitude);
      const { map: map6 = globalThis.mapboxgl || globalThis.maplibregl } = props;
      super({ canvas: deckCanvas, ...props });
      if (map6 && map6.Map) {
        this._map = isMap && new MapWrapper({
          ...props,
          width: 0,
          height: 0,
          viewState,
          container: mapCanvas,
          mapLib: map6
        });
      } else {
        this._map = map6;
      }
    }
    getMapboxMap() {
      return this._map && this._map.getMap();
    }
    finalize() {
      if (this._map) {
        this._map.finalize();
      }
      super.finalize();
    }
    setProps(props) {
      if ("mapStyle" in props && this._map) {
        this._map.setProps({ mapStyle: props.mapStyle });
      }
      super.setProps(props);
    }
    _drawLayers(redrawReason, options) {
      if (this._map) {
        const viewport = this.getViewports()[0];
        if (viewport) {
          this._map.setProps({
            width: viewport.width,
            height: viewport.height,
            viewState: viewport
          });
        }
      }
      super._drawLayers(redrawReason, options);
    }
  };

  // ../core/bundle/index.ts
  globalThis.luma = globalThis.luma || {};
  globalThis.loaders = globalThis.loaders || {};
  Object.assign(globalThis.luma, lumagl_exports);
  Object.assign(globalThis.loaders, loadersgl_exports);

  // ../aggregation-layers/src/common/aggregator/cpu-aggregator/sort-bins.ts
  function sortBins({
    pointCount,
    getBinId
  }) {
    const binsById = /* @__PURE__ */ new Map();
    for (let i5 = 0; i5 < pointCount; i5++) {
      const id = getBinId(i5);
      if (id === null) {
        continue;
      }
      let bin = binsById.get(String(id));
      if (bin) {
        bin.points.push(i5);
      } else {
        bin = {
          id,
          index: binsById.size,
          points: [i5]
        };
        binsById.set(String(id), bin);
      }
    }
    return Array.from(binsById.values());
  }
  function packBinIds({
    bins,
    dimensions,
    target: target2
  }) {
    const targetLength = bins.length * dimensions;
    if (!target2 || target2.length < targetLength) {
      target2 = new Float32Array(targetLength);
    }
    for (let i5 = 0; i5 < bins.length; i5++) {
      const { id } = bins[i5];
      if (Array.isArray(id)) {
        target2.set(id, i5 * dimensions);
      } else {
        target2[i5] = id;
      }
    }
    return target2;
  }

  // ../aggregation-layers/src/common/aggregator/cpu-aggregator/aggregate.ts
  var count2 = (pointIndices) => {
    return pointIndices.length;
  };
  var sum = (pointIndices, getValue2) => {
    let result = 0;
    for (const i5 of pointIndices) {
      result += getValue2(i5);
    }
    return result;
  };
  var mean = (pointIndices, getValue2) => {
    if (pointIndices.length === 0) {
      return NaN;
    }
    return sum(pointIndices, getValue2) / pointIndices.length;
  };
  var min5 = (pointIndices, getValue2) => {
    let result = Infinity;
    for (const i5 of pointIndices) {
      const value = getValue2(i5);
      if (value < result) {
        result = value;
      }
    }
    return result;
  };
  var max5 = (pointIndices, getValue2) => {
    let result = -Infinity;
    for (const i5 of pointIndices) {
      const value = getValue2(i5);
      if (value > result) {
        result = value;
      }
    }
    return result;
  };
  var BUILT_IN_OPERATIONS = {
    COUNT: count2,
    SUM: sum,
    MEAN: mean,
    MIN: min5,
    MAX: max5
  };
  function aggregate({
    bins,
    getValue: getValue2,
    operation,
    target: target2
  }) {
    if (!target2 || target2.length < bins.length) {
      target2 = new Float32Array(bins.length);
    }
    let min6 = Infinity;
    let max6 = -Infinity;
    for (let j2 = 0; j2 < bins.length; j2++) {
      const { points } = bins[j2];
      target2[j2] = operation(points, getValue2);
      if (target2[j2] < min6)
        min6 = target2[j2];
      if (target2[j2] > max6)
        max6 = target2[j2];
    }
    return { value: target2, domain: [min6, max6] };
  }

  // ../aggregation-layers/src/common/aggregator/cpu-aggregator/vertex-accessor.ts
  function evaluateVertexAccessor(accessor, attributes, options) {
    const vertexReaders = {};
    for (const id of accessor.sources || []) {
      const attribute = attributes[id];
      if (attribute) {
        vertexReaders[id] = getVertexReader(attribute);
      } else {
        throw new Error(`Cannot find attribute ${id}`);
      }
    }
    const data = {};
    return (vertexIndex) => {
      for (const id in vertexReaders) {
        data[id] = vertexReaders[id](vertexIndex);
      }
      return accessor.getValue(data, vertexIndex, options);
    };
  }
  function getVertexReader(attribute) {
    const value = attribute.value;
    const { offset = 0, stride, size } = attribute.getAccessor();
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementOffset = offset / bytesPerElement;
    const elementStride = stride ? stride / bytesPerElement : size;
    if (size === 1) {
      if (attribute.isConstant) {
        return () => value[0];
      }
      return (vertexIndex) => {
        const i5 = elementOffset + elementStride * vertexIndex;
        return value[i5];
      };
    }
    let result;
    if (attribute.isConstant) {
      result = Array.from(value);
      return () => result;
    }
    result = new Array(size);
    return (vertexIndex) => {
      const i5 = elementOffset + elementStride * vertexIndex;
      for (let j2 = 0; j2 < size; j2++) {
        result[j2] = value[i5 + j2];
      }
      return result;
    };
  }

  // ../aggregation-layers/src/common/aggregator/cpu-aggregator/cpu-aggregator.ts
  var CPUAggregator = class {
    constructor(props) {
      this.bins = [];
      this.binIds = null;
      this.results = [];
      this.dimensions = props.dimensions;
      this.channelCount = props.getValue.length;
      this.props = {
        ...props,
        binOptions: {},
        pointCount: 0,
        operations: [],
        customOperations: [],
        attributes: {}
      };
      this.needsUpdate = true;
      this.setProps(props);
    }
    destroy() {
    }
    get binCount() {
      return this.bins.length;
    }
    /** Update aggregation props */
    // eslint-disable-next-line complexity
    setProps(props) {
      const oldProps = this.props;
      if (props.binOptions) {
        if (!deepEqual2(props.binOptions, oldProps.binOptions, 2)) {
          this.setNeedsUpdate();
        }
      }
      if (props.operations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (props.operations[channel] !== oldProps.operations[channel]) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.customOperations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.pointCount !== void 0 && props.pointCount !== oldProps.pointCount) {
        this.setNeedsUpdate();
      }
      if (props.attributes) {
        props.attributes = { ...oldProps.attributes, ...props.attributes };
      }
      Object.assign(this.props, props);
    }
    /** Flags a channel to need update
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */
    setNeedsUpdate(channel) {
      if (channel === void 0) {
        this.needsUpdate = true;
      } else if (this.needsUpdate !== true) {
        this.needsUpdate = this.needsUpdate || [];
        this.needsUpdate[channel] = true;
      }
    }
    /** Run aggregation */
    update() {
      if (this.needsUpdate === true) {
        this.bins = sortBins({
          pointCount: this.props.pointCount,
          getBinId: evaluateVertexAccessor(
            this.props.getBin,
            this.props.attributes,
            this.props.binOptions
          )
        });
        const value = packBinIds({
          bins: this.bins,
          dimensions: this.dimensions,
          // Reuse allocated typed array
          target: this.binIds?.value
        });
        this.binIds = { value, type: "float32", size: this.dimensions };
      }
      for (let channel = 0; channel < this.channelCount; channel++) {
        if (this.needsUpdate === true || this.needsUpdate[channel]) {
          const operation = this.props.customOperations[channel] || BUILT_IN_OPERATIONS[this.props.operations[channel]];
          const { value, domain } = aggregate({
            bins: this.bins,
            getValue: evaluateVertexAccessor(
              this.props.getValue[channel],
              this.props.attributes,
              void 0
            ),
            operation,
            // Reuse allocated typed array
            target: this.results[channel]?.value
          });
          this.results[channel] = { value, domain, type: "float32", size: 1 };
          this.props.onUpdate?.({ channel });
        }
      }
      this.needsUpdate = false;
    }
    preDraw() {
    }
    /** Returns an accessor to the bins. */
    getBins() {
      return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */
    getResult(channel) {
      return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */
    getResultDomain(channel) {
      return this.results[channel]?.domain ?? [Infinity, -Infinity];
    }
    /** Returns the information for a given bin. */
    getBin(index) {
      const bin = this.bins[index];
      if (!bin) {
        return null;
      }
      const value = new Array(this.channelCount);
      for (let i5 = 0; i5 < value.length; i5++) {
        const result = this.results[i5];
        value[i5] = result?.value[index];
      }
      return {
        id: bin.id,
        value,
        count: bin.points.length,
        pointIndices: bin.points
      };
    }
  };

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/utils.ts
  function createRenderTarget2(device, width, height) {
    return device.createFramebuffer({
      width,
      height,
      colorAttachments: [
        device.createTexture({
          width,
          height,
          format: "rgba32float",
          mipmaps: false,
          sampler: {
            minFilter: "nearest",
            magFilter: "nearest"
          }
        })
      ]
    });
  }

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/bin-sorter-uniforms.ts
  var uniformBlock25 = (
    /* glsl */
    `uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`
  );
  var binSorterUniforms = {
    name: "binSorter",
    vs: uniformBlock25,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      targetSize: "vec2<i32>"
    }
  };

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-bin-sorter.ts
  var COLOR_CHANNELS2 = [1, 2, 4, 8];
  var MAX_FLOAT32 = 3e38;
  var EMPTY_MASKS = { SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0 };
  var TEXTURE_WIDTH = 1024;
  var WebGLBinSorter = class {
    constructor(device, props) {
      /**
       * A packed texture in which each pixel represents a bin.
       * The index of the pixel in the memory layout is the bin index.
       * Alpha value is the count of data points that fall into this bin
       * R,G,B values are the aggregated values of each channel:
       *   - Sum of all data points if operation is 'SUM', or 'MEAN'
       *   - Min of all data points if operation is 'MIN'
       *   - Max of all data points if operation is 'MAX'
       */
      this.binsFBO = null;
      this.device = device;
      this.model = createModel(device, props);
    }
    get texture() {
      return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
    }
    destroy() {
      this.model.destroy();
      this.binsFBO?.colorAttachments[0].texture.destroy();
      this.binsFBO?.destroy();
    }
    getBinValues(index) {
      if (!this.binsFBO) {
        return null;
      }
      const x3 = index % TEXTURE_WIDTH;
      const y3 = Math.floor(index / TEXTURE_WIDTH);
      const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {
        sourceX: x3,
        sourceY: y3,
        sourceWidth: 1,
        sourceHeight: 1
      }).buffer;
      return new Float32Array(buffer);
    }
    setDimensions(binCount, binIdRange) {
      const width = TEXTURE_WIDTH;
      const height = Math.ceil(binCount / width);
      if (!this.binsFBO) {
        this.binsFBO = createRenderTarget2(this.device, width, height);
      } else if (this.binsFBO.height < height) {
        this.binsFBO.resize({ width, height });
      }
      const binSorterProps = {
        binIdRange: [
          binIdRange[0][0],
          binIdRange[0][1],
          binIdRange[1]?.[0] || 0,
          binIdRange[1]?.[1] || 0
        ],
        targetSize: [this.binsFBO.width, this.binsFBO.height]
      };
      this.model.shaderInputs.setProps({ binSorter: binSorterProps });
    }
    setModelProps(props) {
      const model = this.model;
      if (props.attributes) {
        model.setAttributes(props.attributes);
      }
      if (props.constantAttributes) {
        model.setConstantAttributes(props.constantAttributes);
      }
      if (props.vertexCount !== void 0) {
        model.setVertexCount(props.vertexCount);
      }
      if (props.shaderModuleProps) {
        model.shaderInputs.setProps(props.shaderModuleProps);
      }
    }
    /** Update aggregation */
    update(operations) {
      if (!this.binsFBO) {
        return;
      }
      const masks = getMaskByOperation(operations);
      this._updateBins("SUM", masks.SUM + masks.MEAN);
      this._updateBins("MIN", masks.MIN);
      this._updateBins("MAX", masks.MAX);
    }
    /** Recalculate aggregation on the given channels using the given operation */
    _updateBins(operation, colorMask) {
      if (colorMask === 0) {
        return;
      }
      colorMask |= COLOR_CHANNELS2[3];
      const model = this.model;
      const target2 = this.binsFBO;
      const initialValue = operation === "MAX" ? -MAX_FLOAT32 : operation === "MIN" ? MAX_FLOAT32 : 0;
      const renderPass = this.device.beginRenderPass({
        id: `gpu-aggregation-${operation}`,
        framebuffer: target2,
        parameters: {
          viewport: [0, 0, target2.width, target2.height],
          colorMask
        },
        clearColor: [initialValue, initialValue, initialValue, 0],
        clearDepth: false,
        clearStencil: false
      });
      model.setParameters({
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendColorOperation: operation === "MAX" ? "max" : operation === "MIN" ? "min" : "add",
        blendAlphaOperation: "add"
      });
      model.draw(renderPass);
      renderPass.end();
    }
  };
  function getMaskByOperation(operations) {
    const result = { ...EMPTY_MASKS };
    for (let channel = 0; channel < operations.length; channel++) {
      const op = operations[channel];
      if (op) {
        result[op] += COLOR_CHANNELS2[channel];
      }
    }
    return result;
  }
  function createModel(device, props) {
    let userVs = props.vs;
    if (props.dimensions === 2) {
      userVs += /* glsl */
      `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`;
    }
    const vs14 = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${userVs}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`;
    const fs11 = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`
    );
    const model = new Model(device, {
      bufferLayout: props.bufferLayout,
      modules: [...props.modules || [], binSorterUniforms],
      defines: { ...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount },
      isInstanced: false,
      vs: vs14,
      fs: fs11,
      topology: "point-list",
      disableWarnings: true
    });
    return model;
  }

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.ts
  var uniformBlock26 = (
    /* glsl */
    `uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`
  );
  var aggregatorTransformUniforms = {
    name: "aggregatorTransform",
    vs: uniformBlock26,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      isCount: "vec3<f32>",
      isMean: "vec3<f32>"
    }
  };

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-aggregation-transform.ts
  var MAX_FLOAT322 = 3e38;
  var WebGLAggregationTransform = class {
    constructor(device, props) {
      /** Packed from bin ids */
      this.binBuffer = null;
      /** Packed values from each channel of each bin
       * Stride is number of channels * 4 bytes (float32)
       */
      this.valueBuffer = null;
      /** Aggregated [min, max] for each channel */
      this._domains = null;
      this.device = device;
      this.channelCount = props.channelCount;
      this.transform = createTransform(device, props);
      this.domainFBO = createRenderTarget2(device, 2, 1);
    }
    destroy() {
      this.transform.destroy();
      this.binBuffer?.destroy();
      this.valueBuffer?.destroy();
      this.domainFBO.colorAttachments[0].texture.destroy();
      this.domainFBO.destroy();
    }
    get domains() {
      if (!this._domains) {
        const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;
        const domain = new Float32Array(buffer);
        this._domains = [
          [-domain[4], domain[0]],
          [-domain[5], domain[1]],
          [-domain[6], domain[2]]
        ].slice(0, this.channelCount);
      }
      return this._domains;
    }
    setDimensions(binCount, binIdRange) {
      const { model, transformFeedback } = this.transform;
      model.setVertexCount(binCount);
      const aggregatorTransformProps = {
        binIdRange: [
          binIdRange[0][0],
          binIdRange[0][1],
          binIdRange[1]?.[0] || 0,
          binIdRange[1]?.[1] || 0
        ]
      };
      model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });
      const binBufferByteLength = binCount * binIdRange.length * 4;
      if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {
        this.binBuffer?.destroy();
        this.binBuffer = this.device.createBuffer({ byteLength: binBufferByteLength });
        transformFeedback.setBuffer("binIds", this.binBuffer);
      }
      const valueBufferByteLength = binCount * this.channelCount * 4;
      if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {
        this.valueBuffer?.destroy();
        this.valueBuffer = this.device.createBuffer({ byteLength: valueBufferByteLength });
        transformFeedback.setBuffer("values", this.valueBuffer);
      }
    }
    update(bins, operations) {
      if (!bins) {
        return;
      }
      const transform2 = this.transform;
      const target2 = this.domainFBO;
      const isCount = [0, 1, 2].map((i5) => operations[i5] === "COUNT" ? 1 : 0);
      const isMean = [0, 1, 2].map((i5) => operations[i5] === "MEAN" ? 1 : 0);
      const aggregatorTransformProps = {
        isCount,
        isMean,
        bins
      };
      transform2.model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });
      transform2.run({
        id: "gpu-aggregation-domain",
        framebuffer: target2,
        parameters: {
          viewport: [0, 0, 2, 1]
        },
        clearColor: [-MAX_FLOAT322, -MAX_FLOAT322, -MAX_FLOAT322, 0],
        clearDepth: false,
        clearStencil: false
      });
      this._domains = null;
    }
  };
  function createTransform(device, props) {
    const vs14 = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`
    );
    const fs11 = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`
    );
    return new BufferTransform(device, {
      vs: vs14,
      fs: fs11,
      topology: "point-list",
      modules: [aggregatorTransformUniforms],
      parameters: {
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendColorOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendAlphaOperation: "max"
      },
      defines: {
        NUM_DIMS: props.dimensions,
        NUM_CHANNELS: props.channelCount,
        SAMPLER_WIDTH: TEXTURE_WIDTH
      },
      varyings: ["binIds", "values"],
      disableWarnings: true
    });
  }

  // ../aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-aggregator.ts
  var WebGLAggregator = class {
    constructor(device, props) {
      this.binCount = 0;
      /** Cached outputs */
      this.binIds = null;
      this.results = [];
      this.device = device;
      this.dimensions = props.dimensions;
      this.channelCount = props.channelCount;
      this.props = {
        ...props,
        pointCount: 0,
        binIdRange: [[0, 0]],
        operations: [],
        attributes: {},
        binOptions: {}
      };
      this.needsUpdate = new Array(this.channelCount).fill(true);
      this.binSorter = new WebGLBinSorter(device, props);
      this.aggregationTransform = new WebGLAggregationTransform(device, props);
      this.setProps(props);
    }
    /** Checks if the current device supports GPU aggregation */
    static isSupported(device) {
      return device.features.has("float32-renderable-webgl") && device.features.has("texture-blend-float-webgl");
    }
    getBins() {
      const buffer = this.aggregationTransform.binBuffer;
      if (!buffer) {
        return null;
      }
      if (this.binIds?.buffer !== buffer) {
        this.binIds = { buffer, type: "float32", size: this.dimensions };
      }
      return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */
    getResult(channel) {
      const buffer = this.aggregationTransform.valueBuffer;
      if (!buffer || channel >= this.channelCount) {
        return null;
      }
      if (this.results[channel]?.buffer !== buffer) {
        this.results[channel] = {
          buffer,
          type: "float32",
          size: 1,
          stride: this.channelCount * 4,
          offset: channel * 4
        };
      }
      return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */
    getResultDomain(channel) {
      return this.aggregationTransform.domains[channel];
    }
    /** Returns the information for a given bin. */
    getBin(index) {
      if (index < 0 || index >= this.binCount) {
        return null;
      }
      const { binIdRange } = this.props;
      let id;
      if (this.dimensions === 1) {
        id = [index + binIdRange[0][0]];
      } else {
        const [[x0, x1], [y0]] = binIdRange;
        const width = x1 - x0;
        id = [index % width + x0, Math.floor(index / width) + y0];
      }
      const pixel = this.binSorter.getBinValues(index);
      if (!pixel) {
        return null;
      }
      const count3 = pixel[3];
      const value = [];
      for (let channel = 0; channel < this.channelCount; channel++) {
        const operation = this.props.operations[channel];
        if (operation === "COUNT") {
          value[channel] = count3;
        } else if (count3 === 0) {
          value[channel] = NaN;
        } else {
          value[channel] = operation === "MEAN" ? pixel[channel] / count3 : pixel[channel];
        }
      }
      return { id, value, count: count3 };
    }
    /** Release GPU resources */
    destroy() {
      this.binSorter.destroy();
      this.aggregationTransform.destroy();
    }
    /** Update aggregation props. Normalize prop values and set change flags. */
    // eslint-disable-next-line complexity, max-statements
    setProps(props) {
      const oldProps = this.props;
      if ("binIdRange" in props && !deepEqual2(props.binIdRange, oldProps.binIdRange, 2)) {
        const binIdRange = props.binIdRange;
        log_default.assert(binIdRange.length === this.dimensions);
        if (this.dimensions === 1) {
          const [[x0, x1]] = binIdRange;
          this.binCount = x1 - x0;
        } else {
          const [[x0, x1], [y0, y1]] = binIdRange;
          this.binCount = (x1 - x0) * (y1 - y0);
        }
        this.binSorter.setDimensions(this.binCount, binIdRange);
        this.aggregationTransform.setDimensions(this.binCount, binIdRange);
        this.setNeedsUpdate();
      }
      if (props.operations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (props.operations[channel] !== oldProps.operations[channel]) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.pointCount !== void 0 && props.pointCount !== oldProps.pointCount) {
        this.binSorter.setModelProps({ vertexCount: props.pointCount });
        this.setNeedsUpdate();
      }
      if (props.binOptions) {
        if (!deepEqual2(props.binOptions, oldProps.binOptions, 2)) {
          this.setNeedsUpdate();
        }
        this.binSorter.model.shaderInputs.setProps({ binOptions: props.binOptions });
      }
      if (props.attributes) {
        const attributeBuffers = {};
        const constantAttributes = {};
        for (const attribute of Object.values(props.attributes)) {
          for (const [attributeName, value] of Object.entries(attribute.getValue())) {
            if (ArrayBuffer.isView(value)) {
              constantAttributes[attributeName] = value;
            } else if (value) {
              attributeBuffers[attributeName] = value;
            }
          }
        }
        this.binSorter.setModelProps({ attributes: attributeBuffers, constantAttributes });
      }
      if (props.shaderModuleProps) {
        this.binSorter.setModelProps({ shaderModuleProps: props.shaderModuleProps });
      }
      Object.assign(this.props, props);
    }
    /** Flags a channel to need update.
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */
    setNeedsUpdate(channel) {
      if (channel === void 0) {
        this.needsUpdate.fill(true);
      } else {
        this.needsUpdate[channel] = true;
      }
    }
    update() {
    }
    /** Run aggregation */
    preDraw() {
      if (!this.needsUpdate.some(Boolean)) {
        return;
      }
      const { operations } = this.props;
      const operationsToUpdate = this.needsUpdate.map(
        (needsUpdate, i5) => needsUpdate ? operations[i5] : null
      );
      this.binSorter.update(operationsToUpdate);
      this.aggregationTransform.update(this.binSorter.texture, operations);
      for (let i5 = 0; i5 < this.channelCount; i5++) {
        if (this.needsUpdate[i5]) {
          this.needsUpdate[i5] = false;
          this.props.onUpdate?.({ channel: i5 });
        }
      }
    }
  };

  // ../aggregation-layers/src/common/aggregation-layer.ts
  var AggregationLayer = class extends CompositeLayer {
    /** Allow this layer to participates in the draw cycle */
    get isDrawable() {
      return true;
    }
    initializeState() {
      this.getAttributeManager().remove(["instancePickingColors"]);
    }
    // Extend Layer.updateState to update the Aggregator instance
    // returns true if aggregator is changed
    updateState(params) {
      super.updateState(params);
      const aggregatorType = this.getAggregatorType();
      if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {
        this.state.aggregator?.destroy();
        const aggregator = this.createAggregator(aggregatorType);
        aggregator.setProps({
          attributes: this.getAttributeManager()?.attributes
        });
        this.setState({ aggregator, aggregatorType });
        return true;
      }
      return false;
    }
    // Override Layer.finalizeState to dispose the Aggregator instance
    finalizeState(context) {
      super.finalizeState(context);
      this.state.aggregator.destroy();
    }
    // Override Layer.updateAttributes to update the aggregator
    updateAttributes(changedAttributes) {
      const { aggregator } = this.state;
      aggregator.setProps({
        attributes: changedAttributes
      });
      for (const id in changedAttributes) {
        this.onAttributeChange(id);
      }
      aggregator.update();
    }
    draw({ shaderModuleProps }) {
      const { aggregator } = this.state;
      aggregator.setProps({ shaderModuleProps });
      aggregator.preDraw();
    }
    // override CompositeLayer._getAttributeManager to create AttributeManager instance
    _getAttributeManager() {
      return new AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AggregationLayer.layerName = "AggregationLayer";

  // ../aggregation-layers/src/common/utils/color-utils.ts
  var defaultColorRange = [
    [255, 255, 178],
    [254, 217, 118],
    [254, 178, 76],
    [253, 141, 60],
    [240, 59, 32],
    [189, 0, 38]
  ];
  function colorRangeToFlatArray(colorRange, normalize16 = false, ArrayType2 = Float32Array) {
    let flatArray;
    if (Number.isFinite(colorRange[0])) {
      flatArray = new ArrayType2(colorRange);
    } else {
      flatArray = new ArrayType2(colorRange.length * 4);
      let index = 0;
      for (let i5 = 0; i5 < colorRange.length; i5++) {
        const color = colorRange[i5];
        flatArray[index++] = color[0];
        flatArray[index++] = color[1];
        flatArray[index++] = color[2];
        flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
      }
    }
    if (normalize16) {
      for (let i5 = 0; i5 < flatArray.length; i5++) {
        flatArray[i5] /= 255;
      }
    }
    return flatArray;
  }
  var COLOR_RANGE_FILTER = {
    linear: "linear",
    quantile: "nearest",
    quantize: "nearest",
    ordinal: "nearest"
  };
  function updateColorRangeTexture(texture, type) {
    texture.setSampler({
      minFilter: COLOR_RANGE_FILTER[type],
      magFilter: COLOR_RANGE_FILTER[type]
    });
  }
  function createColorRangeTexture(device, colorRange, type = "linear") {
    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
    return device.createTexture({
      format: "rgba8unorm",
      mipmaps: false,
      sampler: {
        minFilter: COLOR_RANGE_FILTER[type],
        magFilter: COLOR_RANGE_FILTER[type],
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      data: colors,
      width: colors.length / 4,
      height: 1
    });
  }

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts
  var screen_grid_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6

in vec2 positions;
in vec2 instancePositions;
in float instanceWeights;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

out vec4 vColor;

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  if (isnan(instanceWeights)) {
    gl_Position = vec4(0.);
    return;
  }

  vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;
  pos.x = pos.x - 1.0;
  pos.y = 1.0 - pos.y;

  gl_Position = vec4(pos, 0., 1.);

  vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);
  vColor.a *= layer.opacity;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`
  );

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts
  var screen_grid_layer_fragment_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
  );

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-uniforms.ts
  var uniformBlock27 = (
    /* glsl */
    `uniform screenGridUniforms {
  vec2 cellSizeClipspace;
  vec2 gridSizeClipspace;
  vec2 colorDomain;
} screenGrid;
`
  );
  var screenGridUniforms = {
    name: "screenGrid",
    vs: uniformBlock27,
    uniformTypes: {
      cellSizeClipspace: "vec2<f32>",
      gridSizeClipspace: "vec2<f32>",
      colorDomain: "vec2<f32>"
    }
  };

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.ts
  var ScreenGridCellLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: screen_grid_layer_vertex_glsl_default, fs: screen_grid_layer_fragment_glsl_default, modules: [picking_default, screenGridUniforms] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceWeights: {
          size: 1,
          type: "float32",
          accessor: "getWeight"
        }
      });
      this.state.model = this._getModel();
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const model = this.state.model;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const screenGridProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ screenGrid: screenGridProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
        const { width, height } = this.context.viewport;
        const { cellSizePixels: gridSize, cellMarginPixels } = this.props;
        const cellSize = Math.max(gridSize - cellMarginPixels, 0);
        const screenGridProps = {
          gridSizeClipspace: [gridSize / width * 2, gridSize / height * 2],
          cellSizeClipspace: [cellSize / width * 2, cellSize / height * 2]
        };
        model.shaderInputs.setProps({ screenGrid: screenGridProps });
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
      const colorDomain = this.props.colorDomain();
      const model = this.state.model;
      const screenGridProps = { colorDomain };
      model.shaderInputs.setProps({ screenGrid: screenGridProps });
      model.draw(this.context.renderPass);
    }
    // Private Methods
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: {
              value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
              size: 2
            }
          }
        }),
        isInstanced: true
      });
    }
  };
  ScreenGridCellLayer.layerName = "ScreenGridCellLayer";

  // ../aggregation-layers/src/screen-grid-layer/bin-options-uniforms.ts
  var uniformBlock28 = (
    /* glsl */
    `uniform binOptionsUniforms {
  float cellSizePixels;
} binOptions;
`
  );
  var binOptionsUniforms = {
    name: "binOptions",
    vs: uniformBlock28,
    uniformTypes: {
      cellSizePixels: "f32"
    }
  };

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts
  var defaultProps42 = {
    cellSizePixels: { type: "number", value: 100, min: 1 },
    cellMarginPixels: { type: "number", value: 2, min: 0 },
    colorRange: defaultColorRange,
    colorScaleType: "linear",
    getPosition: { type: "accessor", value: (d2) => d2.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: true,
    aggregation: "SUM"
  };
  var ScreenGridLayer = class extends AggregationLayer {
    getAggregatorType() {
      return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? "gpu" : "cpu";
    }
    createAggregator(type) {
      if (type === "cpu" || !WebGLAggregator.isSupported(this.context.device)) {
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              const viewport = this.context.viewport;
              const p3 = viewport.project(positions);
              const cellSizePixels = opts.cellSizePixels;
              if (p3[0] < 0 || p3[0] >= viewport.width || p3[1] < 0 || p3[1] >= viewport.height) {
                return null;
              }
              return [Math.floor(p3[0] / cellSizePixels), Math.floor(p3[1] / cellSizePixels)];
            }
          },
          getValue: [{ sources: ["counts"], getValue: ({ counts }) => counts }]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 1,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [project32_default, binOptionsUniforms],
          vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;
  
  void getBin(out ivec2 binId) {
    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));
    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;
    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);
    binId = ivec2(gridCoords);
  }
  void getValue(out float weight) {
    weight = counts;
  }
  `
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        // this attribute is used in gpu aggregation path only
        counts: { size: 1, accessor: "getWeight" }
      });
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { cellSizePixels, aggregation } = props;
      if (aggregatorChanged || changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.viewportChanged || aggregation !== oldProps.aggregation || cellSizePixels !== oldProps.cellSizePixels) {
        const { width, height } = this.context.viewport;
        const { aggregator } = this.state;
        if (aggregator instanceof WebGLAggregator) {
          aggregator.setProps({
            binIdRange: [
              [0, Math.ceil(width / cellSizePixels)],
              [0, Math.ceil(height / cellSizePixels)]
            ]
          });
        }
        aggregator.setProps({
          pointCount: this.getNumInstances(),
          operations: [aggregation],
          binOptions: {
            cellSizePixels
          }
        });
      }
      if (changeFlags.viewportChanged) {
        this.state.aggregator.setNeedsUpdate();
      }
      return aggregatorChanged;
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          break;
        case "counts":
          aggregator.setNeedsUpdate(0);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator } = this.state;
      const CellLayerClass = this.getSubLayerClass("cells", ScreenGridCellLayer);
      const binAttribute = aggregator.getBins();
      const weightAttribute = aggregator.getResult(0);
      return new CellLayerClass(
        this.props,
        this.getSubLayerProps({
          id: "cell-layer"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getWeight: weightAttribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getWeight: [weightAttribute]
          },
          parameters: {
            depthWriteEnabled: false,
            ...this.props.parameters
          },
          // Evaluate domain at draw() time
          colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          object = {
            col: bin.id[0],
            row: bin.id[1],
            value: bin.value[0],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i5) => this.props.data[i5]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  ScreenGridLayer.layerName = "ScreenGridLayer";
  ScreenGridLayer.defaultProps = defaultProps42;

  // ../aggregation-layers/src/common/utils/scale-utils.ts
  var AttributeWithScale = class {
    constructor(input, inputLength) {
      this.props = {
        scaleType: "linear",
        lowerPercentile: 0,
        upperPercentile: 100
      };
      /** [min, max] of attribute values, or null if unknown */
      this.domain = null;
      /** Valid domain if lower/upper percentile are defined */
      this.cutoff = null;
      this.input = input;
      this.inputLength = inputLength;
      this.attribute = input;
    }
    getScalePercentile() {
      if (!this._percentile) {
        const value = getAttributeValue(this.input, this.inputLength);
        this._percentile = applyScaleQuantile(value);
      }
      return this._percentile;
    }
    getScaleOrdinal() {
      if (!this._ordinal) {
        const value = getAttributeValue(this.input, this.inputLength);
        this._ordinal = applyScaleOrdinal(value);
      }
      return this._ordinal;
    }
    /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */
    getCutoff({
      scaleType,
      lowerPercentile,
      upperPercentile
    }) {
      if (scaleType === "quantile") {
        return [lowerPercentile, upperPercentile - 1];
      }
      if (lowerPercentile > 0 || upperPercentile < 100) {
        const { domain: thresholds } = this.getScalePercentile();
        let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;
        let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;
        if (scaleType === "ordinal") {
          const { domain: sortedUniqueValues } = this.getScaleOrdinal();
          lowValue = sortedUniqueValues.findIndex((x3) => x3 >= lowValue);
          highValue = sortedUniqueValues.findIndex((x3) => x3 > highValue) - 1;
          if (highValue === -2) {
            highValue = sortedUniqueValues.length - 1;
          }
        }
        return [lowValue, highValue];
      }
      return null;
    }
    update(props) {
      const oldProps = this.props;
      if (props.scaleType !== oldProps.scaleType) {
        switch (props.scaleType) {
          case "quantile": {
            const { attribute } = this.getScalePercentile();
            this.attribute = attribute;
            this.domain = [0, 99];
            break;
          }
          case "ordinal": {
            const { attribute, domain } = this.getScaleOrdinal();
            this.attribute = attribute;
            this.domain = [0, domain.length - 1];
            break;
          }
          default:
            this.attribute = this.input;
            this.domain = null;
        }
      }
      if (props.scaleType !== oldProps.scaleType || props.lowerPercentile !== oldProps.lowerPercentile || props.upperPercentile !== oldProps.upperPercentile) {
        this.cutoff = this.getCutoff(props);
      }
      this.props = props;
      return this;
    }
  };
  function applyScaleOrdinal(values) {
    const uniqueValues = /* @__PURE__ */ new Set();
    for (const x3 of values) {
      if (Number.isFinite(x3)) {
        uniqueValues.add(x3);
      }
    }
    const sortedUniqueValues = Array.from(uniqueValues).sort();
    const domainMap = /* @__PURE__ */ new Map();
    for (let i5 = 0; i5 < sortedUniqueValues.length; i5++) {
      domainMap.set(sortedUniqueValues[i5], i5);
    }
    return {
      attribute: {
        value: values.map((x3) => Number.isFinite(x3) ? domainMap.get(x3) : NaN),
        type: "float32",
        size: 1
      },
      domain: sortedUniqueValues
    };
  }
  function applyScaleQuantile(values, rangeLength = 100) {
    const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);
    let i5 = 0;
    const n3 = Math.max(1, rangeLength);
    const thresholds = new Array(n3 - 1);
    while (++i5 < n3) {
      thresholds[i5 - 1] = threshold(sortedValues, i5 / n3);
    }
    return {
      attribute: {
        value: values.map((x3) => Number.isFinite(x3) ? bisectRight(thresholds, x3) : NaN),
        type: "float32",
        size: 1
      },
      domain: thresholds
    };
  }
  function getAttributeValue(attribute, length16) {
    const elementStride = (attribute.stride ?? 4) / 4;
    const elementOffset = (attribute.offset ?? 0) / 4;
    let value = attribute.value;
    if (!value) {
      const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length16);
      if (bytes) {
        value = new Float32Array(bytes.buffer);
        attribute.value = value;
      }
    }
    if (elementStride === 1) {
      return value.subarray(0, length16);
    }
    const result = new Float32Array(length16);
    for (let i5 = 0; i5 < length16; i5++) {
      result[i5] = value[i5 * elementStride + elementOffset];
    }
    return result;
  }
  function ascending(a3, b2) {
    return a3 - b2;
  }
  function threshold(domain, fraction) {
    const domainLength = domain.length;
    if (fraction <= 0 || domainLength < 2) {
      return domain[0];
    }
    if (fraction >= 1) {
      return domain[domainLength - 1];
    }
    const domainFraction = (domainLength - 1) * fraction;
    const lowIndex = Math.floor(domainFraction);
    const low = domain[lowIndex];
    const high = domain[lowIndex + 1];
    return low + (high - low) * (domainFraction - lowIndex);
  }
  function bisectRight(a3, x3) {
    let lo = 0;
    let hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (a3[mid] > x3) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }

  // ../aggregation-layers/src/common/utils/bounds-utils.ts
  function getBinIdRange({
    dataBounds,
    getBinId,
    padding = 0
  }) {
    const corners = [
      dataBounds[0],
      dataBounds[1],
      [dataBounds[0][0], dataBounds[1][1]],
      [dataBounds[1][0], dataBounds[0][1]]
    ].map((p3) => getBinId(p3));
    const minX = Math.min(...corners.map((p3) => p3[0])) - padding;
    const minY = Math.min(...corners.map((p3) => p3[1])) - padding;
    const maxX = Math.max(...corners.map((p3) => p3[0])) + padding + 1;
    const maxY = Math.max(...corners.map((p3) => p3[1])) + padding + 1;
    return [
      [minX, maxX],
      [minY, maxY]
    ];
  }

  // ../aggregation-layers/src/hexagon-layer/hexbin.ts
  var THIRD_PI = Math.PI / 3;
  var DIST_X = 2 * Math.sin(THIRD_PI);
  var DIST_Y = 1.5;
  var HexbinVertices = Array.from({ length: 6 }, (_2, i5) => {
    const angle9 = i5 * THIRD_PI;
    return [Math.sin(angle9), -Math.cos(angle9)];
  });
  function pointToHexbin([px, py], radius) {
    let pj = Math.round(py = py / radius / DIST_Y);
    let pi = Math.round(px = px / radius / DIST_X - (pj & 1) / 2);
    const py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
      const px1 = px - pi;
      const pi2 = pi + (px < pi ? -1 : 1) / 2;
      const pj2 = pj + (py < pj ? -1 : 1);
      const px2 = px - pi2;
      const py2 = py - pj2;
      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {
        pi = pi2 + (pj & 1 ? 1 : -1) / 2;
        pj = pj2;
      }
    }
    return [pi, pj];
  }
  var pointToHexbinGLSL = (
    /* glsl */
    `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`
  );
  function getHexbinCentroid([i5, j2], radius) {
    return [(i5 + (j2 & 1) / 2) * radius * DIST_X, j2 * radius * DIST_Y];
  }
  var getHexbinCentroidGLSL = `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`;

  // ../aggregation-layers/src/hexagon-layer/hexagon-cell-layer-vertex.glsl.ts
  var hexagon_cell_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

// Result
out vec4 vColor;

${getHexbinCentroidGLSL}

float interp(float value, vec2 domain, vec2 range) {
  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
  return mix(range.x, range.y, r);
}

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  geometry.pickingColor = instancePickingColors;

  if (isnan(instanceColorValues) ||
    instanceColorValues < hexagon.colorDomain.z ||
    instanceColorValues > hexagon.colorDomain.w ||
    instanceElevationValues < hexagon.elevationDomain.z ||
    instanceElevationValues > hexagon.elevationDomain.w
  ) {
    gl_Position = vec4(0.);
    return;
  }
  
  vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
  commonPosition += positions.xy * column.radius * column.coverage;
  geometry.position = vec4(commonPosition, 0.0, 1.0);
  geometry.normal = project_normal(normals);

  // calculate z, if 3d not enabled set to 0
  float elevation = 0.0;
  if (column.extruded) {
    elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
    elevation = project_size(elevation);
    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
  }

  gl_Position = project_common_position_to_clipspace(geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
  vColor.a *= layer.opacity;
  if (column.extruded) {
    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`
  );

  // ../aggregation-layers/src/hexagon-layer/hexagon-layer-uniforms.ts
  var uniformBlock29 = (
    /* glsl */
    `uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`
  );
  var hexagonUniforms = {
    name: "hexagon",
    vs: uniformBlock29,
    uniformTypes: {
      colorDomain: "vec4<f32>",
      elevationDomain: "vec4<f32>",
      elevationRange: "vec2<f32>",
      originCommon: "vec2<f32>"
    }
  };

  // ../aggregation-layers/src/hexagon-layer/hexagon-cell-layer.ts
  var HexagonCellLayer = class extends ColumnLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.modules.push(hexagonUniforms);
      return { ...shaders, vs: hexagon_cell_layer_vertex_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.remove([
        "instanceElevations",
        "instanceFillColors",
        "instanceLineColors",
        "instanceStrokeWidths"
      ]);
      attributeManager.addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceColorValues: {
          size: 1,
          type: "float32",
          accessor: "getColorValue"
        },
        instanceElevationValues: {
          size: 1,
          type: "float32",
          accessor: "getElevationValue"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      const model = this.state.fillModel;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const hexagonProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ hexagon: hexagonProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
      const {
        radius,
        hexOriginCommon,
        elevationRange,
        elevationScale,
        extruded,
        coverage,
        colorDomain,
        elevationDomain
      } = this.props;
      const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];
      const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];
      const fillModel = this.state.fillModel;
      if (fillModel.vertexArray.indexBuffer) {
        fillModel.setIndexBuffer(null);
      }
      fillModel.setVertexCount(this.state.fillVertexCount);
      const hexagonProps = {
        colorDomain: [
          Math.max(colorDomain[0], colorCutoff[0]),
          // instanceColorValue that maps to colorRange[0]
          Math.min(colorDomain[1], colorCutoff[1]),
          // instanceColorValue that maps to colorRange[colorRange.length - 1]
          Math.max(colorDomain[0] - 1, colorCutoff[0]),
          // hide cell if instanceColorValue is less than this
          Math.min(colorDomain[1] + 1, colorCutoff[1])
          // hide cell if instanceColorValue is greater than this
        ],
        elevationDomain: [
          Math.max(elevationDomain[0], elevationCutoff[0]),
          // instanceElevationValue that maps to elevationRange[0]
          Math.min(elevationDomain[1], elevationCutoff[1]),
          // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
          Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
          // hide cell if instanceElevationValue is less than this
          Math.min(elevationDomain[1] + 1, elevationCutoff[1])
          // hide cell if instanceElevationValue is greater than this
        ],
        elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],
        originCommon: hexOriginCommon
      };
      fillModel.shaderInputs.setProps({
        column: { extruded, coverage, radius },
        hexagon: hexagonProps
      });
      fillModel.draw(this.context.renderPass);
    }
  };
  HexagonCellLayer.layerName = "HexagonCellLayer";

  // ../aggregation-layers/src/hexagon-layer/bin-options-uniforms.ts
  var uniformBlock30 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`
  );
  var binOptionsUniforms2 = {
    name: "binOptions",
    vs: uniformBlock30,
    uniformTypes: {
      hexOriginCommon: "vec2<f32>",
      radiusCommon: "f32"
    }
  };

  // ../aggregation-layers/src/hexagon-layer/hexagon-layer.ts
  function noop5() {
  }
  var defaultProps43 = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    // default value is calculated from `getColorWeight` and `colorAggregation`
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: noop5,
    // elevation
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    // default value is calculated from `getElevationWeight` and `elevationAggregation`
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    elevationScaleType: "linear",
    onSetElevationDomain: noop5,
    // hexbin
    radius: { type: "number", min: 1, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    hexagonAggregator: { type: "function", optional: true, value: null },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
  };
  var HexagonLayer = class extends AggregationLayer {
    getAggregatorType() {
      const { gpuAggregation, hexagonAggregator, getColorValue, getElevationValue } = this.props;
      if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {
        log_default.warn("Features not supported by GPU aggregation, falling back to CPU")();
        return "cpu";
      }
      if (
        // GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        WebGLAggregator.isSupported(this.context.device)
      ) {
        return "gpu";
      }
      return "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        const { hexagonAggregator, radius } = this.props;
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              if (hexagonAggregator) {
                return hexagonAggregator(positions, radius);
              }
              const viewport = this.state.aggregatorViewport;
              const p3 = viewport.projectPosition(positions);
              const { radiusCommon, hexOriginCommon } = opts;
              return pointToHexbin(
                [p3[0] - hexOriginCommon[0], p3[1] - hexOriginCommon[1]],
                radiusCommon
              );
            }
          },
          getValue: [
            { sources: ["colorWeights"], getValue: ({ colorWeights }) => colorWeights },
            { sources: ["elevationWeights"], getValue: ({ elevationWeights }) => elevationWeights }
          ]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 2,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [project32_default, binOptionsUniforms2],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${pointToHexbinGLSL}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
          )
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        colorWeights: { size: 1, accessor: "getColorWeight" },
        elevationWeights: { size: 1, accessor: "getElevationWeight" }
      });
    }
    // eslint-disable-next-line complexity
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
        this.state.dataAsArray = Array.from(createIterable(props.data).iterable);
      }
      if (aggregatorChanged || changeFlags.dataChanged || props.radius !== oldProps.radius || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
        this._updateBinOptions();
        const { radiusCommon, hexOriginCommon, binIdRange, dataAsArray } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.colorAggregation, props.elevationAggregation],
          binOptions: {
            radiusCommon,
            hexOriginCommon
          },
          onUpdate: this._onAggregationUpdate.bind(this)
        });
        if (dataAsArray) {
          const { getColorValue, getElevationValue } = this.props;
          aggregator.setProps({
            // @ts-expect-error only used by CPUAggregator
            customOperations: [
              getColorValue && ((indices) => getColorValue(
                indices.map((i5) => dataAsArray[i5]),
                { indices, data: props.data }
              )),
              getElevationValue && ((indices) => getElevationValue(
                indices.map((i5) => dataAsArray[i5]),
                { indices, data: props.data }
              ))
            ]
          });
        }
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
        aggregator.setNeedsUpdate(0);
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
        aggregator.setNeedsUpdate(1);
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      let radiusCommon = 1;
      let hexOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { radius } = this.props;
        const { unitsPerMeter: unitsPerMeter2 } = viewport.getDistanceScales(centroid);
        radiusCommon = unitsPerMeter2[0] * radius;
        const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);
        centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p3) => {
            const positionCommon = viewport.projectFlat(p3);
            positionCommon[0] -= hexOriginCommon[0];
            positionCommon[1] -= hexOriginCommon[1];
            return pointToHexbin(positionCommon, radiusCommon);
          },
          padding: 1
        });
      }
      this.setState({ radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
      const props = this.getCurrentLayer().props;
      const { aggregator } = this.state;
      if (channel === 0) {
        const result = aggregator.getResult(0);
        this.setState({
          colors: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetColorDomain(aggregator.getResultDomain(0));
      } else if (channel === 1) {
        const result = aggregator.getResult(1);
        this.setState({
          elevations: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetElevationDomain(aggregator.getResultDomain(1));
      }
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { radiusCommon, hexOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              radiusCommon,
              hexOriginCommon
            }
          });
          break;
        case "colorWeights":
          aggregator.setNeedsUpdate(0);
          break;
        case "elevationWeights":
          aggregator.setNeedsUpdate(1);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator, radiusCommon, hexOriginCommon } = this.state;
      const {
        elevationScale,
        colorRange,
        elevationRange,
        extruded,
        coverage,
        material,
        transitions,
        colorScaleType,
        lowerPercentile,
        upperPercentile,
        colorDomain,
        elevationScaleType,
        elevationLowerPercentile,
        elevationUpperPercentile,
        elevationDomain
      } = this.props;
      const CellLayerClass = this.getSubLayerClass("cells", HexagonCellLayer);
      const binAttribute = aggregator.getBins();
      const colors = this.state.colors?.update({
        scaleType: colorScaleType,
        lowerPercentile,
        upperPercentile
      });
      const elevations = this.state.elevations?.update({
        scaleType: elevationScaleType,
        lowerPercentile: elevationLowerPercentile,
        upperPercentile: elevationUpperPercentile
      });
      if (!colors || !elevations) {
        return null;
      }
      return new CellLayerClass(
        this.getSubLayerProps({
          id: "cells"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getColorValue: colors.attribute,
              getElevationValue: elevations.attribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getColorValue: [colors.attribute],
            getElevationValue: [elevations.attribute]
          },
          diskResolution: 6,
          vertices: HexbinVertices,
          radius: radiusCommon,
          hexOriginCommon,
          elevationScale,
          colorRange,
          colorScaleType,
          elevationRange,
          extruded,
          coverage,
          material,
          colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
          elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
          colorCutoff: colors.cutoff,
          elevationCutoff: elevations.cutoff,
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          },
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          const centroidCommon = getHexbinCentroid(
            bin.id,
            this.state.radiusCommon
          );
          const centroid = this.context.viewport.unprojectFlat(centroidCommon);
          object = {
            col: bin.id[0],
            row: bin.id[1],
            position: centroid,
            colorValue: bin.value[0],
            elevationValue: bin.value[1],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i5) => this.props.data[i5]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  HexagonLayer.layerName = "HexagonLayer";
  HexagonLayer.defaultProps = defaultProps43;

  // ../aggregation-layers/src/contour-layer/marching-squares-codes.ts
  var HALF = 0.5;
  var ONE6TH = 1 / 6;
  var OFFSET = {
    N: [0, HALF],
    // NORTH
    E: [HALF, 0],
    // EAST
    S: [0, -HALF],
    // SOUTH
    W: [-HALF, 0],
    // WEST
    // CORNERS
    NE: [HALF, HALF],
    NW: [-HALF, HALF],
    SE: [HALF, -HALF],
    SW: [-HALF, -HALF]
  };
  var SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
  var SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
  var NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];
  var SW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF]
  ];
  var SE_TRAPEZOID = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var NE_TRAPEZOID = [
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
  var E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
  var W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
  var EW_RECTANGEL = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var SN_RECTANGEL = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];
  var SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
  var SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
  var NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];
  var NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
  var SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
  var NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];
  var S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
  var W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];
  var NE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
  ];
  var SW_HEPTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_HEPTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    OFFSET.N
  ];
  var SE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var OCTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var ISOLINES_CODE_OFFSET_MAP = {
    // key is equal to the code of 4 vertices (invert the code specified in wiki)
    // value can be an array or an Object
    // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]
    // Object : to handle saddle cases, whos output depends on mean value of all 4 corners
    //  key: code of mean value (0 or 1)
    //  value: Array , as above defines one or two line segments
    0: [],
    1: [[OFFSET.W, OFFSET.S]],
    2: [[OFFSET.S, OFFSET.E]],
    3: [[OFFSET.W, OFFSET.E]],
    4: [[OFFSET.N, OFFSET.E]],
    5: {
      0: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ]
    },
    6: [[OFFSET.N, OFFSET.S]],
    7: [[OFFSET.W, OFFSET.N]],
    8: [[OFFSET.W, OFFSET.N]],
    9: [[OFFSET.N, OFFSET.S]],
    10: {
      0: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ]
    },
    11: [[OFFSET.N, OFFSET.E]],
    12: [[OFFSET.W, OFFSET.E]],
    13: [[OFFSET.S, OFFSET.E]],
    14: [[OFFSET.W, OFFSET.S]],
    15: []
  };
  function ternaryToIndex(ternary) {
    return parseInt(ternary, 4);
  }
  var ISOBANDS_CODE_OFFSET_MAP = {
    // Below list of cases, follow the same order as in above mentioned wiki page.
    // Each case has its code on first commented line // T,TR,R,C
    // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2
    // final code is binary representation of above code , where takes 2 digits
    // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169
    // no contours
    [ternaryToIndex("0000")]: [],
    [ternaryToIndex("2222")]: [],
    // single triangle
    [ternaryToIndex("2221")]: [SW_TRIANGLE],
    [ternaryToIndex("2212")]: [SE_TRIANGLE],
    [ternaryToIndex("2122")]: [NE_TRIANGLE],
    [ternaryToIndex("1222")]: [NW_TRIANGLE],
    [ternaryToIndex("0001")]: [SW_TRIANGLE],
    [ternaryToIndex("0010")]: [SE_TRIANGLE],
    [ternaryToIndex("0100")]: [NE_TRIANGLE],
    [ternaryToIndex("1000")]: [NW_TRIANGLE],
    // single trapezoid
    [ternaryToIndex("2220")]: [SW_TRAPEZOID],
    [ternaryToIndex("2202")]: [SE_TRAPEZOID],
    [ternaryToIndex("2022")]: [NE_TRAPEZOID],
    [ternaryToIndex("0222")]: [NW_TRAPEZOID],
    [ternaryToIndex("0002")]: [SW_TRAPEZOID],
    [ternaryToIndex("0020")]: [SE_TRAPEZOID],
    [ternaryToIndex("0200")]: [NE_TRAPEZOID],
    [ternaryToIndex("2000")]: [NW_TRAPEZOID],
    // single rectangle
    [ternaryToIndex("0011")]: [S_RECTANGLE],
    [ternaryToIndex("0110")]: [E_RECTANGLE],
    [ternaryToIndex("1100")]: [N_RECTANGLE],
    [ternaryToIndex("1001")]: [W_RECTANGLE],
    [ternaryToIndex("2211")]: [S_RECTANGLE],
    [ternaryToIndex("2112")]: [E_RECTANGLE],
    [ternaryToIndex("1122")]: [N_RECTANGLE],
    [ternaryToIndex("1221")]: [W_RECTANGLE],
    [ternaryToIndex("2200")]: [EW_RECTANGEL],
    [ternaryToIndex("2002")]: [SN_RECTANGEL],
    [ternaryToIndex("0022")]: [EW_RECTANGEL],
    [ternaryToIndex("0220")]: [SN_RECTANGEL],
    // single square
    // 1111
    [ternaryToIndex("1111")]: [SQUARE],
    // single pentagon
    [ternaryToIndex("1211")]: [SW_PENTAGON],
    [ternaryToIndex("2111")]: [SE_PENTAGON],
    [ternaryToIndex("1112")]: [NE_PENTAGON],
    [ternaryToIndex("1121")]: [NW_PENTAGON],
    [ternaryToIndex("1011")]: [SW_PENTAGON],
    [ternaryToIndex("0111")]: [SE_PENTAGON],
    [ternaryToIndex("1110")]: [NE_PENTAGON],
    [ternaryToIndex("1101")]: [NW_PENTAGON],
    [ternaryToIndex("1200")]: [NW_N_PENTAGON],
    [ternaryToIndex("0120")]: [NE_E_PENTAGON],
    [ternaryToIndex("0012")]: [SE_S_PENTAGON],
    [ternaryToIndex("2001")]: [SW_W_PENTAGON],
    [ternaryToIndex("1022")]: [NW_N_PENTAGON],
    [ternaryToIndex("2102")]: [NE_E_PENTAGON],
    [ternaryToIndex("2210")]: [SE_S_PENTAGON],
    [ternaryToIndex("0221")]: [SW_W_PENTAGON],
    [ternaryToIndex("1002")]: [NW_W_PENTAGON],
    [ternaryToIndex("2100")]: [NE_N_PENTAGON],
    [ternaryToIndex("0210")]: [SE_E_PENTAGON],
    [ternaryToIndex("0021")]: [SW_S_PENTAGON],
    [ternaryToIndex("1220")]: [NW_W_PENTAGON],
    [ternaryToIndex("0122")]: [NE_N_PENTAGON],
    [ternaryToIndex("2012")]: [SE_E_PENTAGON],
    [ternaryToIndex("2201")]: [SW_S_PENTAGON],
    // single hexagon
    [ternaryToIndex("0211")]: [S_HEXAGON],
    [ternaryToIndex("2110")]: [E_HEXAGON],
    [ternaryToIndex("1102")]: [N_HEXAGON],
    [ternaryToIndex("1021")]: [W_HEXAGON],
    [ternaryToIndex("2011")]: [S_HEXAGON],
    [ternaryToIndex("0112")]: [E_HEXAGON],
    [ternaryToIndex("1120")]: [N_HEXAGON],
    [ternaryToIndex("1201")]: [W_HEXAGON],
    [ternaryToIndex("2101")]: [SW_NE_HEXAGON],
    [ternaryToIndex("0121")]: [SW_NE_HEXAGON],
    [ternaryToIndex("1012")]: [NW_SE_HEXAGON],
    [ternaryToIndex("1210")]: [NW_SE_HEXAGON],
    // 6-sided polygons based on mean weight
    // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)
    [ternaryToIndex("0101")]: {
      0: [SW_TRIANGLE, NE_TRIANGLE],
      1: [SW_NE_HEXAGON],
      2: [SW_NE_HEXAGON]
    },
    [ternaryToIndex("1010")]: {
      0: [NW_TRIANGLE, SE_TRIANGLE],
      1: [NW_SE_HEXAGON],
      2: [NW_SE_HEXAGON]
    },
    [ternaryToIndex("2121")]: {
      0: [SW_NE_HEXAGON],
      1: [SW_NE_HEXAGON],
      2: [SW_TRIANGLE, NE_TRIANGLE]
    },
    [ternaryToIndex("1212")]: {
      0: [NW_SE_HEXAGON],
      1: [NW_SE_HEXAGON],
      2: [NW_TRIANGLE, SE_TRIANGLE]
    },
    // 7-sided polygons based on mean weight
    [ternaryToIndex("2120")]: {
      0: [NE_HEPTAGON],
      1: [NE_HEPTAGON],
      2: [SW_TRAPEZOID, NE_TRIANGLE]
    },
    [ternaryToIndex("2021")]: {
      0: [SW_HEPTAGON],
      1: [SW_HEPTAGON],
      2: [SW_TRIANGLE, NE_TRAPEZOID]
    },
    [ternaryToIndex("1202")]: {
      0: [NW_HEPTAGON],
      1: [NW_HEPTAGON],
      2: [NW_TRIANGLE, SE_TRAPEZOID]
    },
    [ternaryToIndex("0212")]: {
      0: [SE_HEPTAGON],
      1: [SE_HEPTAGON],
      2: [SE_TRIANGLE, NW_TRAPEZOID]
    },
    [ternaryToIndex("0102")]: {
      0: [SW_TRAPEZOID, NE_TRIANGLE],
      1: [NE_HEPTAGON],
      2: [NE_HEPTAGON]
    },
    [ternaryToIndex("0201")]: {
      0: [SW_TRIANGLE, NE_TRAPEZOID],
      1: [SW_HEPTAGON],
      2: [SW_HEPTAGON]
    },
    [ternaryToIndex("1020")]: {
      0: [NW_TRIANGLE, SE_TRAPEZOID],
      1: [NW_HEPTAGON],
      2: [NW_HEPTAGON]
    },
    [ternaryToIndex("2010")]: {
      0: [SE_TRIANGLE, NW_TRAPEZOID],
      1: [SE_HEPTAGON],
      2: [SE_HEPTAGON]
    },
    // 8-sided polygons based on mean weight
    [ternaryToIndex("2020")]: {
      0: [NW_TRAPEZOID, SE_TRAPEZOID],
      1: [OCTAGON],
      2: [SW_TRAPEZOID, NE_TRAPEZOID]
    },
    [ternaryToIndex("0202")]: {
      0: [NE_TRAPEZOID, SW_TRAPEZOID],
      1: [OCTAGON],
      2: [NW_TRAPEZOID, SE_TRAPEZOID]
    }
  };

  // ../aggregation-layers/src/contour-layer/marching-squares.ts
  function getVertexCode(weight, threshold2) {
    if (Number.isNaN(weight)) {
      return 0;
    }
    if (Array.isArray(threshold2)) {
      if (weight < threshold2[0]) {
        return 0;
      }
      return weight < threshold2[1] ? 1 : 2;
    }
    return weight >= threshold2 ? 1 : 0;
  }
  function getCode(opts) {
    const { x: x3, y: y3, xRange, yRange, getValue: getValue2, threshold: threshold2 } = opts;
    const isLeftBoundary = x3 < xRange[0];
    const isRightBoundary = x3 >= xRange[1] - 1;
    const isBottomBoundary = y3 < yRange[0];
    const isTopBoundary = y3 >= yRange[1] - 1;
    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
    let weights = 0;
    let current;
    let right;
    let top;
    let topRight;
    if (isLeftBoundary || isTopBoundary) {
      top = 0;
    } else {
      const w2 = getValue2(x3, y3 + 1);
      top = getVertexCode(w2, threshold2);
      weights += w2;
    }
    if (isRightBoundary || isTopBoundary) {
      topRight = 0;
    } else {
      const w2 = getValue2(x3 + 1, y3 + 1);
      topRight = getVertexCode(w2, threshold2);
      weights += w2;
    }
    if (isRightBoundary || isBottomBoundary) {
      right = 0;
    } else {
      const w2 = getValue2(x3 + 1, y3);
      right = getVertexCode(w2, threshold2);
      weights += w2;
    }
    if (isLeftBoundary || isBottomBoundary) {
      current = 0;
    } else {
      const w2 = getValue2(x3, y3);
      current = getVertexCode(w2, threshold2);
      weights += w2;
    }
    let code = -1;
    if (Number.isFinite(threshold2)) {
      code = top << 3 | topRight << 2 | right << 1 | current;
    }
    if (Array.isArray(threshold2)) {
      code = top << 6 | topRight << 4 | right << 2 | current;
    }
    let meanCode = 0;
    if (!isBoundary) {
      meanCode = getVertexCode(weights / 4, threshold2);
    }
    return { code, meanCode };
  }
  function getPolygons(opts) {
    const { x: x3, y: y3, z: z2, code, meanCode } = opts;
    let offsets = ISOBANDS_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const rX = x3 + 1;
    const rY = y3 + 1;
    const polygons = [];
    offsets.forEach((polygonOffsets) => {
      const polygon = [];
      polygonOffsets.forEach((xyOffset) => {
        const vX = rX + xyOffset[0];
        const vY = rY + xyOffset[1];
        polygon.push([vX, vY, z2]);
      });
      polygons.push(polygon);
    });
    return polygons;
  }
  function getLines(opts) {
    const { x: x3, y: y3, z: z2, code, meanCode } = opts;
    let offsets = ISOLINES_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const rX = x3 + 1;
    const rY = y3 + 1;
    const lines = [];
    offsets.forEach((xyOffsets) => {
      xyOffsets.forEach((offset) => {
        const vX = rX + offset[0];
        const vY = rY + offset[1];
        lines.push([vX, vY, z2]);
      });
    });
    return lines;
  }

  // ../aggregation-layers/src/contour-layer/contour-utils.ts
  function generateContours({
    contours,
    getValue: getValue2,
    xRange,
    yRange
  }) {
    const contourLines = [];
    const contourPolygons = [];
    let segmentIndex = 0;
    let polygonIndex = 0;
    for (let i5 = 0; i5 < contours.length; i5++) {
      const contour = contours[i5];
      const z2 = contour.zIndex ?? i5;
      const { threshold: threshold2 } = contour;
      for (let x3 = xRange[0] - 1; x3 < xRange[1]; x3++) {
        for (let y3 = yRange[0] - 1; y3 < yRange[1]; y3++) {
          const { code, meanCode } = getCode({
            getValue: getValue2,
            threshold: threshold2,
            x: x3,
            y: y3,
            xRange,
            yRange
          });
          const opts = {
            x: x3,
            y: y3,
            z: z2,
            code,
            meanCode
          };
          if (Array.isArray(threshold2)) {
            const polygons = getPolygons(opts);
            for (const polygon of polygons) {
              contourPolygons[polygonIndex++] = {
                vertices: polygon,
                contour
              };
            }
          } else {
            const path = getLines(opts);
            if (path.length > 0) {
              contourLines[segmentIndex++] = {
                vertices: path,
                contour
              };
            }
          }
        }
      }
    }
    return { lines: contourLines, polygons: contourPolygons };
  }

  // ../aggregation-layers/src/contour-layer/value-reader.ts
  function getAggregatorValueReader(opts) {
    const { aggregator, binIdRange, channel } = opts;
    if (aggregator instanceof WebGLAggregator) {
      const buffer = aggregator.getResult(channel)?.buffer;
      if (buffer) {
        const values = new Float32Array(buffer.readSyncWebGL().buffer);
        return getWebGLAggregatorValueReader(values, binIdRange);
      }
    }
    if (aggregator instanceof CPUAggregator) {
      const values = aggregator.getResult(channel)?.value;
      const ids = aggregator.getBins()?.value;
      if (ids && values) {
        return getCPUAggregatorValueReader(values, ids, aggregator.binCount);
      }
    }
    return null;
  }
  function getWebGLAggregatorValueReader(values, binIdRange) {
    const [[minX, maxX], [minY, maxY]] = binIdRange;
    const width = maxX - minX;
    const height = maxY - minY;
    return (x3, y3) => {
      x3 -= minX;
      y3 -= minY;
      if (x3 < 0 || x3 >= width || y3 < 0 || y3 >= height) {
        return NaN;
      }
      return values[y3 * width + x3];
    };
  }
  function getCPUAggregatorValueReader(values, ids, count3) {
    const idMap = {};
    for (let i5 = 0; i5 < count3; i5++) {
      const x3 = ids[i5 * 2];
      const y3 = ids[i5 * 2 + 1];
      idMap[x3] = idMap[x3] || {};
      idMap[x3][y3] = values[i5];
    }
    return (x3, y3) => idMap[x3]?.[y3] ?? NaN;
  }

  // ../aggregation-layers/src/contour-layer/bin-options-uniforms.ts
  var uniformBlock31 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
  );
  var binOptionsUniforms3 = {
    name: "binOptions",
    vs: uniformBlock31,
    uniformTypes: {
      cellOriginCommon: "vec2<f32>",
      cellSizeCommon: "vec2<f32>"
    }
  };

  // ../aggregation-layers/src/contour-layer/contour-layer.ts
  var DEFAULT_COLOR12 = [255, 255, 255, 255];
  var DEFAULT_STROKE_WIDTH = 1;
  var defaultProps44 = {
    // grid aggregation
    cellSize: { type: "number", min: 1, value: 1e3 },
    gridOrigin: { type: "array", compare: true, value: [0, 0] },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: true,
    aggregation: "SUM",
    // contour lines
    contours: {
      type: "object",
      value: [{ threshold: 1 }],
      optional: true,
      compare: 3
    },
    zOffset: 5e-3
  };
  var GridLayer = class extends AggregationLayer {
    getAggregatorType() {
      return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? "gpu" : "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              const viewport = this.state.aggregatorViewport;
              const p3 = viewport.projectPosition(positions);
              const { cellSizeCommon, cellOriginCommon } = opts;
              return [
                Math.floor((p3[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                Math.floor((p3[1] - cellOriginCommon[1]) / cellSizeCommon[1])
              ];
            }
          },
          getValue: [{ sources: ["counts"], getValue: ({ counts }) => counts }],
          onUpdate: this._onAggregationUpdate.bind(this)
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 1,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [project32_default, binOptionsUniforms3],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out float value) {
    value = counts;
  }
  `
          )
        }),
        onUpdate: this._onAggregationUpdate.bind(this)
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        counts: { size: 1, accessor: "getWeight" }
      });
    }
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || !deepEqual2(props.gridOrigin, oldProps.gridOrigin, 1) || props.aggregation !== oldProps.aggregation) {
        this._updateBinOptions();
        const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.aggregation],
          binOptions: {
            cellSizeCommon,
            cellOriginCommon
          }
        });
      }
      if (!deepEqual2(oldProps.contours, props.contours, 2)) {
        this.setState({ contourData: null });
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      const cellSizeCommon = [1, 1];
      let cellOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { cellSize, gridOrigin } = this.props;
        const { unitsPerMeter: unitsPerMeter2 } = viewport.getDistanceScales(centroid);
        cellSizeCommon[0] = unitsPerMeter2[0] * cellSize;
        cellSizeCommon[1] = unitsPerMeter2[1] * cellSize;
        const centroidCommon = viewport.projectFlat(centroid);
        cellOriginCommon = [
          Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] + gridOrigin[0],
          Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] + gridOrigin[1]
        ];
        centroid = viewport.unprojectFlat(cellOriginCommon);
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p3) => {
            const positionCommon = viewport.projectFlat(p3);
            return [
              Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
              Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
            ];
          }
        });
      }
      this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate() {
      const { aggregator, binIdRange } = this.state;
      this.setState({
        aggregatedValueReader: getAggregatorValueReader({ aggregator, binIdRange, channel: 0 }),
        contourData: null
      });
    }
    _getContours() {
      const { aggregatedValueReader } = this.state;
      if (!aggregatedValueReader) {
        return null;
      }
      if (!this.state.contourData) {
        const { binIdRange } = this.state;
        const { contours } = this.props;
        const contourData = generateContours({
          contours,
          getValue: aggregatedValueReader,
          xRange: binIdRange[0],
          yRange: binIdRange[1]
        });
        this.state.contourData = contourData;
      }
      return this.state.contourData;
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              cellSizeCommon,
              cellOriginCommon
            }
          });
          break;
        case "counts":
          aggregator.setNeedsUpdate(0);
          break;
        default:
      }
    }
    renderLayers() {
      const contourData = this._getContours();
      if (!contourData) {
        return null;
      }
      const { lines, polygons } = contourData;
      const { zOffset } = this.props;
      const { cellOriginCommon, cellSizeCommon } = this.state;
      const LinesSubLayerClass = this.getSubLayerClass("lines", PathLayer);
      const BandsSubLayerClass = this.getSubLayerClass("bands", SolidPolygonLayer);
      const modelMatrix2 = new Matrix4().translate([cellOriginCommon[0], cellOriginCommon[1], 0]).scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);
      const lineLayer = lines && lines.length > 0 && new LinesSubLayerClass(
        this.getSubLayerProps({
          id: "lines"
        }),
        {
          data: lines,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          modelMatrix: modelMatrix2,
          getPath: (d2) => d2.vertices,
          getColor: (d2) => d2.contour.color ?? DEFAULT_COLOR12,
          getWidth: (d2) => d2.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,
          widthUnits: "pixels"
        }
      );
      const bandsLayer = polygons && polygons.length > 0 && new BandsSubLayerClass(
        this.getSubLayerProps({
          id: "bands"
        }),
        {
          data: polygons,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          modelMatrix: modelMatrix2,
          getPolygon: (d2) => d2.vertices,
          getFillColor: (d2) => d2.contour.color ?? DEFAULT_COLOR12
        }
      );
      return [lineLayer, bandsLayer];
    }
    getPickingInfo(params) {
      const info = params.info;
      const { object } = info;
      if (object) {
        info.object = {
          contour: object.contour
        };
      }
      return info;
    }
  };
  GridLayer.layerName = "ContourLayer";
  GridLayer.defaultProps = defaultProps44;

  // ../aggregation-layers/src/grid-layer/grid-cell-layer-vertex.glsl.ts
  var grid_cell_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es

#define SHADER_NAME grid-cell-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

// Result
out vec4 vColor;

float interp(float value, vec2 domain, vec2 range) {
  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
  return mix(range.x, range.y, r);
}

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  geometry.pickingColor = instancePickingColors;

  if (isnan(instanceColorValues) ||
    instanceColorValues < grid.colorDomain.z ||
    instanceColorValues > grid.colorDomain.w ||
    instanceElevationValues < grid.elevationDomain.z ||
    instanceElevationValues > grid.elevationDomain.w
  ) {
    gl_Position = vec4(0.);
    return;
  }
  
  vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;
  geometry.position = vec4(commonPosition, 0.0, 1.0);
  geometry.normal = project_normal(normals);

  // calculate z, if 3d not enabled set to 0
  float elevation = 0.0;
  if (column.extruded) {
    elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);
    elevation = project_size(elevation);
    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
  }

  gl_Position = project_common_position_to_clipspace(geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);
  vColor.a *= layer.opacity;
  if (column.extruded) {
    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`
  );

  // ../aggregation-layers/src/grid-layer/grid-layer-uniforms.ts
  var uniformBlock32 = (
    /* glsl */
    `uniform gridUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
  vec2 sizeCommon;
} grid;
`
  );
  var gridUniforms = {
    name: "grid",
    vs: uniformBlock32,
    uniformTypes: {
      colorDomain: "vec4<f32>",
      elevationDomain: "vec4<f32>",
      elevationRange: "vec2<f32>",
      originCommon: "vec2<f32>",
      sizeCommon: "vec2<f32>"
    }
  };

  // ../aggregation-layers/src/grid-layer/grid-cell-layer.ts
  var GridCellLayer2 = class extends ColumnLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.modules.push(gridUniforms);
      return { ...shaders, vs: grid_cell_layer_vertex_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.remove([
        "instanceElevations",
        "instanceFillColors",
        "instanceLineColors",
        "instanceStrokeWidths"
      ]);
      attributeManager.addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceColorValues: {
          size: 1,
          type: "float32",
          accessor: "getColorValue"
        },
        instanceElevationValues: {
          size: 1,
          type: "float32",
          accessor: "getElevationValue"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      const model = this.state.fillModel;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const gridProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ grid: gridProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    _updateGeometry() {
      const geometry = new CubeGeometry();
      this.state.fillModel.setGeometry(geometry);
    }
    draw({ uniforms }) {
      const {
        cellOriginCommon,
        cellSizeCommon,
        elevationRange,
        elevationScale,
        extruded,
        coverage,
        colorDomain,
        elevationDomain
      } = this.props;
      const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];
      const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];
      const fillModel = this.state.fillModel;
      const gridProps = {
        colorDomain: [
          Math.max(colorDomain[0], colorCutoff[0]),
          // instanceColorValue that maps to colorRange[0]
          Math.min(colorDomain[1], colorCutoff[1]),
          // instanceColorValue that maps to colorRange[colorRange.length - 1]
          Math.max(colorDomain[0] - 1, colorCutoff[0]),
          // hide cell if instanceColorValue is less than this
          Math.min(colorDomain[1] + 1, colorCutoff[1])
          // hide cell if instanceColorValue is greater than this
        ],
        elevationDomain: [
          Math.max(elevationDomain[0], elevationCutoff[0]),
          // instanceElevationValue that maps to elevationRange[0]
          Math.min(elevationDomain[1], elevationCutoff[1]),
          // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
          Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
          // hide cell if instanceElevationValue is less than this
          Math.min(elevationDomain[1] + 1, elevationCutoff[1])
          // hide cell if instanceElevationValue is greater than this
        ],
        elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],
        originCommon: cellOriginCommon,
        sizeCommon: cellSizeCommon
      };
      fillModel.shaderInputs.setProps({
        column: { extruded, coverage },
        grid: gridProps
      });
      fillModel.draw(this.context.renderPass);
    }
  };
  GridCellLayer2.layerName = "GridCellLayer";

  // ../aggregation-layers/src/grid-layer/bin-options-uniforms.ts
  var uniformBlock33 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
  );
  var binOptionsUniforms4 = {
    name: "binOptions",
    vs: uniformBlock33,
    uniformTypes: {
      cellOriginCommon: "vec2<f32>",
      cellSizeCommon: "vec2<f32>"
    }
  };

  // ../aggregation-layers/src/grid-layer/grid-layer.ts
  function noop6() {
  }
  var defaultProps45 = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    // default value is calculated from `getColorWeight` and `colorAggregation`
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: noop6,
    // elevation
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    // default value is calculated from `getElevationWeight` and `elevationAggregation`
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    elevationScaleType: "linear",
    onSetElevationDomain: noop6,
    // grid
    cellSize: { type: "number", min: 0, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    gridAggregator: { type: "function", optional: true, value: null },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
  };
  var GridLayer2 = class extends AggregationLayer {
    getAggregatorType() {
      const { gpuAggregation, gridAggregator, getColorValue, getElevationValue } = this.props;
      if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {
        log_default.warn("Features not supported by GPU aggregation, falling back to CPU")();
        return "cpu";
      }
      if (
        // GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        WebGLAggregator.isSupported(this.context.device)
      ) {
        return "gpu";
      }
      return "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        const { gridAggregator, cellSize } = this.props;
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              if (gridAggregator) {
                return gridAggregator(positions, cellSize);
              }
              const viewport = this.state.aggregatorViewport;
              const p3 = viewport.projectPosition(positions);
              const { cellSizeCommon, cellOriginCommon } = opts;
              return [
                Math.floor((p3[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                Math.floor((p3[1] - cellOriginCommon[1]) / cellSizeCommon[1])
              ];
            }
          },
          getValue: [
            { sources: ["colorWeights"], getValue: ({ colorWeights }) => colorWeights },
            { sources: ["elevationWeights"], getValue: ({ elevationWeights }) => elevationWeights }
          ]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 2,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [project32_default, binOptionsUniforms4],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
          )
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        colorWeights: { size: 1, accessor: "getColorWeight" },
        elevationWeights: { size: 1, accessor: "getElevationWeight" }
      });
    }
    // eslint-disable-next-line complexity
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
        this.state.dataAsArray = Array.from(createIterable(props.data).iterable);
      }
      if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
        this._updateBinOptions();
        const { cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.colorAggregation, props.elevationAggregation],
          binOptions: {
            cellSizeCommon,
            cellOriginCommon
          },
          onUpdate: this._onAggregationUpdate.bind(this)
        });
        if (dataAsArray) {
          const { getColorValue, getElevationValue } = this.props;
          aggregator.setProps({
            // @ts-expect-error only used by CPUAggregator
            customOperations: [
              getColorValue && ((indices) => getColorValue(
                indices.map((i5) => dataAsArray[i5]),
                { indices, data: props.data }
              )),
              getElevationValue && ((indices) => getElevationValue(
                indices.map((i5) => dataAsArray[i5]),
                { indices, data: props.data }
              ))
            ]
          });
        }
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
        aggregator.setNeedsUpdate(0);
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
        aggregator.setNeedsUpdate(1);
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      const cellSizeCommon = [1, 1];
      let cellOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { cellSize } = this.props;
        const { unitsPerMeter: unitsPerMeter2 } = viewport.getDistanceScales(centroid);
        cellSizeCommon[0] = unitsPerMeter2[0] * cellSize;
        cellSizeCommon[1] = unitsPerMeter2[1] * cellSize;
        const centroidCommon = viewport.projectFlat(centroid);
        cellOriginCommon = [
          Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],
          Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]
        ];
        centroid = viewport.unprojectFlat(cellOriginCommon);
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p3) => {
            const positionCommon = viewport.projectFlat(p3);
            return [
              Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
              Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
            ];
          }
        });
      }
      this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
      const props = this.getCurrentLayer().props;
      const { aggregator } = this.state;
      if (channel === 0) {
        const result = aggregator.getResult(0);
        this.setState({
          colors: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetColorDomain(aggregator.getResultDomain(0));
      } else if (channel === 1) {
        const result = aggregator.getResult(1);
        this.setState({
          elevations: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetElevationDomain(aggregator.getResultDomain(1));
      }
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              cellSizeCommon,
              cellOriginCommon
            }
          });
          break;
        case "colorWeights":
          aggregator.setNeedsUpdate(0);
          break;
        case "elevationWeights":
          aggregator.setNeedsUpdate(1);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator, cellOriginCommon, cellSizeCommon } = this.state;
      const {
        elevationScale,
        colorRange,
        elevationRange,
        extruded,
        coverage,
        material,
        transitions,
        colorScaleType,
        lowerPercentile,
        upperPercentile,
        colorDomain,
        elevationScaleType,
        elevationLowerPercentile,
        elevationUpperPercentile,
        elevationDomain
      } = this.props;
      const CellLayerClass = this.getSubLayerClass("cells", GridCellLayer2);
      const binAttribute = aggregator.getBins();
      const colors = this.state.colors?.update({
        scaleType: colorScaleType,
        lowerPercentile,
        upperPercentile
      });
      const elevations = this.state.elevations?.update({
        scaleType: elevationScaleType,
        lowerPercentile: elevationLowerPercentile,
        upperPercentile: elevationUpperPercentile
      });
      if (!colors || !elevations) {
        return null;
      }
      return new CellLayerClass(
        this.getSubLayerProps({
          id: "cells"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getColorValue: colors.attribute,
              getElevationValue: elevations.attribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getColorValue: [colors.attribute],
            getElevationValue: [elevations.attribute]
          },
          cellOriginCommon,
          cellSizeCommon,
          elevationScale,
          colorRange,
          colorScaleType,
          elevationRange,
          extruded,
          coverage,
          material,
          colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
          elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
          colorCutoff: colors.cutoff,
          elevationCutoff: elevations.cutoff,
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          },
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          object = {
            col: bin.id[0],
            row: bin.id[1],
            colorValue: bin.value[0],
            elevationValue: bin.value[1],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i5) => this.props.data[i5]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  GridLayer2.layerName = "GridLayer";
  GridLayer2.defaultProps = defaultProps45;

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer-utils.ts
  function getBounds2(points) {
    const x3 = points.map((p3) => p3[0]);
    const y3 = points.map((p3) => p3[1]);
    const xMin = Math.min.apply(null, x3);
    const xMax = Math.max.apply(null, x3);
    const yMin = Math.min.apply(null, y3);
    const yMax = Math.max.apply(null, y3);
    return [xMin, yMin, xMax, yMax];
  }
  function boundsContain(currentBounds, targetBounds) {
    if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
      return true;
    }
    return false;
  }
  var scratchArray2 = new Float32Array(12);
  function packVertices(points, dimensions = 2) {
    let index = 0;
    for (const point of points) {
      for (let i5 = 0; i5 < dimensions; i5++) {
        scratchArray2[index++] = point[i5] || 0;
      }
    }
    return scratchArray2;
  }
  function scaleToAspectRatio(boundingBox, width, height) {
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const currentWidth = xMax - xMin;
    const currentHeight = yMax - yMin;
    let newWidth = currentWidth;
    let newHeight = currentHeight;
    if (currentWidth / currentHeight < width / height) {
      newWidth = width / height * currentHeight;
    } else {
      newHeight = height / width * currentWidth;
    }
    if (newWidth < width) {
      newWidth = width;
      newHeight = height;
    }
    const xCenter = (xMax + xMin) / 2;
    const yCenter = (yMax + yMin) / 2;
    return [
      xCenter - newWidth / 2,
      yCenter - newHeight / 2,
      xCenter + newWidth / 2,
      yCenter + newHeight / 2
    ];
  }
  function getTextureCoordinates(point, bounds) {
    const [xMin, yMin, xMax, yMax] = bounds;
    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
  }

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-vertex.glsl.ts
  var triangle_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader

uniform sampler2D maxTexture;

in vec3 positions;
in vec2 texCoords;

out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
  vTexCoords = texCoords;
  vec4 maxTexture = texture(maxTexture, vec2(0.5));
  float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
  float minValue = maxValue * triangle.threshold;
  if (triangle.colorDomain[1] > 0.) {
    // if user specified custom domain use it.
    maxValue = triangle.colorDomain[1];
    minValue = triangle.colorDomain[0];
  }
  vIntensityMax = triangle.intensity / maxValue;
  vIntensityMin = triangle.intensity / minValue;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-fragment.glsl.ts
  var triangle_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader

precision highp float;

uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;

in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;

out vec4 fragColor;

vec4 getLinearColor(float value) {
  float factor = clamp(value * vIntensityMax, 0., 1.);
  vec4 color = texture(colorTexture, vec2(factor, 0.5));
  color.a *= min(value * vIntensityMin, 1.0);
  return color;
}

void main(void) {
  vec4 weights = texture(weightsTexture, vTexCoords);
  float weight = weights.r;

  if (triangle.aggregationMode > 0.5) {
    weight /= max(1.0, weights.a);
  }

  // discard pixels with 0 weight.
  if (weight <= 0.) {
     discard;
  }

  vec4 linearColor = getLinearColor(weight);
  linearColor.a *= layer.opacity;
  fragColor = linearColor;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-uniforms.ts
  var uniformBlock34 = `uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`;
  var triangleUniforms = {
    name: "triangle",
    vs: uniformBlock34,
    fs: uniformBlock34,
    uniformTypes: {
      aggregationMode: "f32",
      colorDomain: "vec2<f32>",
      intensity: "f32",
      threshold: "f32"
    }
  };

  // ../aggregation-layers/src/heatmap-layer/triangle-layer.ts
  var TriangleLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: triangle_layer_vertex_glsl_default, fs: triangle_layer_fragment_glsl_default, modules: [project32_default, triangleUniforms] });
    }
    initializeState({ device }) {
      this.setState({ model: this._getModel(device) });
    }
    _getModel(device) {
      const { vertexCount, data } = this.props;
      return new Model(device, {
        ...this.getShaders(),
        id: this.props.id,
        attributes: data.attributes,
        bufferLayout: [
          { name: "positions", format: "float32x3" },
          { name: "texCoords", format: "float32x2" }
        ],
        topology: "triangle-strip",
        vertexCount
      });
    }
    draw() {
      const { model } = this.state;
      const {
        aggregationMode,
        colorDomain,
        intensity,
        threshold: threshold2,
        colorTexture,
        maxTexture,
        weightsTexture
      } = this.props;
      const triangleProps = {
        aggregationMode,
        colorDomain,
        intensity,
        threshold: threshold2,
        colorTexture,
        maxTexture,
        weightsTexture
      };
      model.shaderInputs.setProps({ triangle: triangleProps });
      model.draw(this.context.renderPass);
    }
  };
  TriangleLayer.layerName = "TriangleLayer";

  // ../aggregation-layers/src/common/utils/prop-utils.ts
  function filterProps(props, filterKeys) {
    const filteredProps = {};
    for (const key in props) {
      if (!filterKeys.includes(key)) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // ../aggregation-layers/src/heatmap-layer/aggregation-layer.ts
  var AggregationLayer2 = class extends CompositeLayer {
    initializeAggregationLayer(dimensions) {
      super.initializeState(this.context);
      this.setState({
        // Layer props , when changed doesn't require updating aggregation
        ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),
        dimensions
      });
    }
    updateState(opts) {
      super.updateState(opts);
      const { changeFlags } = opts;
      if (changeFlags.extensionsChanged) {
        const shaders = this.getShaders({});
        if (shaders && shaders.defines) {
          shaders.defines.NON_INSTANCED_MODEL = 1;
        }
        this.updateShaders(shaders);
      }
      this._updateAttributes();
    }
    updateAttributes(changedAttributes) {
      this.setState({ changedAttributes });
    }
    getAttributes() {
      return this.getAttributeManager().getAttributes();
    }
    getModuleSettings() {
      const { viewport, mousePosition, device } = this.context;
      const moduleSettings = Object.assign(Object.create(this.props), {
        viewport,
        mousePosition,
        picking: {
          isActive: 0
        },
        // @ts-expect-error TODO - assuming WebGL context
        devicePixelRatio: device.canvasContext.cssToDeviceRatio()
      });
      return moduleSettings;
    }
    updateShaders(shaders) {
    }
    /**
     * Checks if aggregation is dirty
     * @param {Object} updateOpts - object {props, oldProps, changeFlags}
     * @param {Object} params - object {dimension, compareAll}
     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
     **/
    isAggregationDirty(updateOpts, params = {}) {
      const { props, oldProps, changeFlags } = updateOpts;
      const { compareAll = false, dimension } = params;
      const { ignoreProps } = this.state;
      const { props: dataProps, accessors = [] } = dimension;
      const { updateTriggersChanged } = changeFlags;
      if (changeFlags.dataChanged) {
        return true;
      }
      if (updateTriggersChanged) {
        if (updateTriggersChanged.all) {
          return true;
        }
        for (const accessor of accessors) {
          if (updateTriggersChanged[accessor]) {
            return true;
          }
        }
      }
      if (compareAll) {
        if (changeFlags.extensionsChanged) {
          return true;
        }
        return compareProps({
          oldProps,
          newProps: props,
          ignoreProps,
          propTypes: this.constructor._propTypes
        });
      }
      for (const name13 of dataProps) {
        if (props[name13] !== oldProps[name13]) {
          return true;
        }
      }
      return false;
    }
    /**
     * Checks if an attribute is changed
     * @param {String} name - name of the attribute
     * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
     *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
     **/
    isAttributeChanged(name13) {
      const { changedAttributes } = this.state;
      if (!name13) {
        return !isObjectEmpty5(changedAttributes);
      }
      return changedAttributes && changedAttributes[name13] !== void 0;
    }
    // Private
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
      return new AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AggregationLayer2.layerName = "AggregationLayer";
  function isObjectEmpty5(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../aggregation-layers/src/heatmap-layer/weights-vs.glsl.ts
  var weights_vs_glsl_default = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;

void main()
{
  weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);

  float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
  gl_PointSize = radiusTexels * 2.;

  vec3 commonPosition = project_position(positions, positions64Low);

  // // map xy from commonBounds to [-1, 1]
  gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
  gl_Position.xy = (gl_Position.xy * 2.) - (1.);
  gl_Position.w = 1.0;
}
`;

  // ../aggregation-layers/src/heatmap-layer/weights-fs.glsl.ts
  var weights_fs_glsl_default = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
// Epanechnikov function, keeping for reference
// float epanechnikovKDE(float u) {
//   return 0.75 * (1.0 - u * u);
// }
float gaussianKDE(float u){
  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
  float dist = length(gl_PointCoord - vec2(0.5, 0.5));
  if (dist > 0.5) {
    discard;
  }
  fragColor = weightsTexture * gaussianKDE(2. * dist);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-vs.glsl.ts
  var max_vs_glsl_default = `#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;

void main()
{
  // Sample every pixel in texture
  int yIndex = gl_VertexID / int(maxWeight.textureSize);
  int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
  vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
  outTexture = texture(inTexture, uv);

  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-fs.glsl.ts
  var max_fs_glsl_default = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
  fragColor = outTexture;
  fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer-uniforms.ts
  var uniformBlock35 = `uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`;
  var weightUniforms = {
    name: "weight",
    vs: uniformBlock35,
    uniformTypes: {
      commonBounds: "vec4<f32>",
      radiusPixels: "f32",
      textureWidth: "f32",
      weightsScale: "f32"
    }
  };
  var maxWeightUniforms = {
    name: "maxWeight",
    vs: `uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
    uniformTypes: {
      textureSize: "f32"
    }
  };

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer.ts
  var RESOLUTION = 2;
  var TEXTURE_PROPS = {
    format: "rgba8unorm",
    mipmaps: false,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  var DEFAULT_COLOR_DOMAIN = [0, 0];
  var AGGREGATION_MODE = {
    SUM: 0,
    MEAN: 1
  };
  var defaultProps46 = {
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getWeight: { type: "accessor", value: 1 },
    intensity: { type: "number", min: 0, value: 1 },
    radiusPixels: { type: "number", min: 1, max: 100, value: 50 },
    colorRange: defaultColorRange,
    threshold: { type: "number", min: 0, max: 1, value: 0.05 },
    colorDomain: { type: "array", value: null, optional: true },
    // 'SUM' or 'MEAN'
    aggregation: "SUM",
    weightsTextureSize: { type: "number", min: 128, max: 2048, value: 2048 },
    debounceTimeout: { type: "number", min: 0, max: 1e3, value: 500 }
  };
  var FLOAT_TARGET_FEATURES2 = [
    "float32-renderable-webgl",
    // ability to render to float texture
    "texture-blend-float-webgl"
    // ability to blend when rendering to float texture
  ];
  var DIMENSIONS = {
    data: {
      props: ["radiusPixels"]
    }
  };
  var HeatmapLayer = class extends AggregationLayer2 {
    getShaders(shaders) {
      let modules = [project32_default];
      if (shaders.modules) {
        modules = [...modules, ...shaders.modules];
      }
      return super.getShaders({ ...shaders, modules });
    }
    initializeState() {
      super.initializeAggregationLayer(DIMENSIONS);
      this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });
      this._setupTextureParams();
      this._setupAttributes();
      this._setupResources();
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    /* eslint-disable max-statements,complexity */
    updateState(opts) {
      super.updateState(opts);
      this._updateHeatmapState(opts);
    }
    _updateHeatmapState(opts) {
      const { props, oldProps } = opts;
      const changeFlags = this._getChangeFlags(opts);
      if (changeFlags.dataChanged || changeFlags.viewportChanged) {
        changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
        this._updateTextureRenderingBounds();
      }
      if (changeFlags.dataChanged || changeFlags.boundsChanged) {
        clearTimeout(this.state.updateTimer);
        this.setState({ isWeightMapDirty: true });
      } else if (changeFlags.viewportZoomChanged) {
        this._debouncedUpdateWeightmap();
      }
      if (props.colorRange !== oldProps.colorRange) {
        this._updateColorTexture(opts);
      }
      if (this.state.isWeightMapDirty) {
        this._updateWeightmap();
      }
      this.setState({ zoom: opts.context.viewport.zoom });
    }
    renderLayers() {
      const {
        weightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        maxWeightsTexture,
        colorTexture,
        colorDomain
      } = this.state;
      const { updateTriggers, intensity, threshold: threshold2, aggregation } = this.props;
      const TriangleLayerClass = this.getSubLayerClass("triangle", TriangleLayer);
      return new TriangleLayerClass(
        this.getSubLayerProps({
          id: "triangle-layer",
          updateTriggers
        }),
        {
          // position buffer is filled with world coordinates generated from viewport.unproject
          // i.e. LNGLAT if geospatial, CARTESIAN otherwise
          coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
          data: {
            attributes: {
              positions: triPositionBuffer,
              texCoords: triTexCoordBuffer
            }
          },
          vertexCount: 4,
          maxTexture: maxWeightsTexture,
          colorTexture,
          aggregationMode: AGGREGATION_MODE[aggregation] || 0,
          weightsTexture,
          intensity,
          threshold: threshold2,
          colorDomain
        }
      );
    }
    finalizeState(context) {
      super.finalizeState(context);
      const {
        weightsTransform,
        weightsTexture,
        maxWeightTransform,
        maxWeightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        colorTexture,
        updateTimer
      } = this.state;
      weightsTransform?.destroy();
      weightsTexture?.destroy();
      maxWeightTransform?.destroy();
      maxWeightsTexture?.destroy();
      triPositionBuffer?.destroy();
      triTexCoordBuffer?.destroy();
      colorTexture?.destroy();
      if (updateTimer) {
        clearTimeout(updateTimer);
      }
    }
    // PRIVATE
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
      return new AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
    _getChangeFlags(opts) {
      const changeFlags = {};
      const { dimensions } = this.state;
      changeFlags.dataChanged = this.isAttributeChanged() && "attribute changed" || // if any attribute is changed
      this.isAggregationDirty(opts, {
        compareAll: true,
        dimension: dimensions.data
      }) && "aggregation is dirty";
      changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
      const { zoom } = this.state;
      if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
        changeFlags.viewportZoomChanged = true;
      }
      return changeFlags;
    }
    _createTextures() {
      const { textureSize, format } = this.state;
      this.setState({
        weightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: textureSize,
          height: textureSize,
          format
        }),
        maxWeightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: 1,
          height: 1,
          format
        })
      });
    }
    _setupAttributes() {
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: { size: 3, type: "float64", accessor: "getPosition" },
        weights: { size: 1, accessor: "getWeight" }
      });
      this.setState({ positionAttributeName: "positions" });
    }
    _setupTextureParams() {
      const { device } = this.context;
      const { weightsTextureSize } = this.props;
      const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);
      const floatTargetSupport = FLOAT_TARGET_FEATURES2.every((feature) => device.features.has(feature));
      const format = floatTargetSupport ? "rgba32float" : "rgba8unorm";
      const weightsScale = floatTargetSupport ? 1 : 1 / 255;
      this.setState({ textureSize, format, weightsScale });
      if (!floatTargetSupport) {
        log_default.warn(
          `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`
        )();
      }
    }
    _createWeightsTransform(shaders) {
      let { weightsTransform } = this.state;
      const { weightsTexture } = this.state;
      const attributeManager = this.getAttributeManager();
      weightsTransform?.destroy();
      weightsTransform = new TextureTransform(this.context.device, {
        id: `${this.id}-weights-transform`,
        bufferLayout: attributeManager.getBufferLayouts(),
        vertexCount: 1,
        targetTexture: weightsTexture,
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "add",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        },
        topology: "point-list",
        ...shaders,
        modules: [...shaders.modules, weightUniforms]
      });
      this.setState({ weightsTransform });
    }
    _setupResources() {
      this._createTextures();
      const { device } = this.context;
      const { textureSize, weightsTexture, maxWeightsTexture } = this.state;
      const weightsTransformShaders = this.getShaders({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default
      });
      this._createWeightsTransform(weightsTransformShaders);
      const maxWeightsTransformShaders = this.getShaders({
        vs: max_vs_glsl_default,
        fs: max_fs_glsl_default,
        modules: [maxWeightUniforms]
      });
      const maxWeightTransform = new TextureTransform(device, {
        id: `${this.id}-max-weights-transform`,
        targetTexture: maxWeightsTexture,
        ...maxWeightsTransformShaders,
        vertexCount: textureSize * textureSize,
        topology: "point-list",
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "max",
          blendAlphaOperation: "max",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        }
      });
      const maxWeightProps = { inTexture: weightsTexture, textureSize };
      maxWeightTransform.model.shaderInputs.setProps({
        maxWeight: maxWeightProps
      });
      this.setState({
        weightsTexture,
        maxWeightsTexture,
        maxWeightTransform,
        zoom: null,
        triPositionBuffer: device.createBuffer({ byteLength: 48 }),
        triTexCoordBuffer: device.createBuffer({ byteLength: 48 })
      });
    }
    // overwrite super class method to update transform model
    updateShaders(shaderOptions) {
      this._createWeightsTransform({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default,
        ...shaderOptions
      });
    }
    _updateMaxWeightValue() {
      const { maxWeightTransform } = this.state;
      maxWeightTransform.run({
        parameters: { viewport: [0, 0, 1, 1] },
        clearColor: [0, 0, 0, 0]
      });
    }
    // Computes world bounds area that needs to be processed for generate heatmap
    _updateBounds(forceUpdate = false) {
      const { viewport } = this.context;
      const viewportCorners = [
        viewport.unproject([0, 0]),
        viewport.unproject([viewport.width, 0]),
        viewport.unproject([0, viewport.height]),
        viewport.unproject([viewport.width, viewport.height])
      ].map((p3) => p3.map(Math.fround));
      const visibleWorldBounds = getBounds2(viewportCorners);
      const newState = { visibleWorldBounds, viewportCorners };
      let boundsChanged = false;
      if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
        const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
        const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
        if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          worldBounds[1] = Math.max(worldBounds[1], -85.051129);
          worldBounds[3] = Math.min(worldBounds[3], 85.051129);
          worldBounds[0] = Math.max(worldBounds[0], -360);
          worldBounds[2] = Math.min(worldBounds[2], 360);
        }
        const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
        newState.worldBounds = worldBounds;
        newState.normalizedCommonBounds = normalizedCommonBounds;
        boundsChanged = true;
      }
      this.setState(newState);
      return boundsChanged;
    }
    _updateTextureRenderingBounds() {
      const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;
      const { viewport } = this.context;
      triPositionBuffer.write(packVertices(viewportCorners, 3));
      const textureBounds = viewportCorners.map(
        (p3) => getTextureCoordinates(viewport.projectPosition(p3), normalizedCommonBounds)
      );
      triTexCoordBuffer.write(packVertices(textureBounds, 2));
    }
    _updateColorTexture(opts) {
      const { colorRange } = opts.props;
      let { colorTexture } = this.state;
      const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
      if (colorTexture && colorTexture?.width === colorRange.length) {
        colorTexture.setTexture2DData({ data: colors });
      } else {
        colorTexture?.destroy();
        colorTexture = this.context.device.createTexture({
          ...TEXTURE_PROPS,
          data: colors,
          width: colorRange.length,
          height: 1
        });
      }
      this.setState({ colorTexture });
    }
    _updateWeightmap() {
      const { radiusPixels, colorDomain, aggregation } = this.props;
      const { worldBounds, textureSize, weightsScale, weightsTexture } = this.state;
      const weightsTransform = this.state.weightsTransform;
      this.state.isWeightMapDirty = false;
      const commonBounds = this._worldToCommonBounds(worldBounds, {
        useLayerCoordinateSystem: true
      });
      if (colorDomain && aggregation === "SUM") {
        const { viewport: viewport2 } = this.context;
        const metersPerPixel = viewport2.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
        this.state.colorDomain = colorDomain.map((x3) => x3 * metersPerPixel * weightsScale);
      } else {
        this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
      }
      const attributeManager = this.getAttributeManager();
      const attributes = attributeManager.getAttributes();
      const moduleSettings = this.getModuleSettings();
      this._setModelAttributes(weightsTransform.model, attributes);
      weightsTransform.model.setVertexCount(this.getNumInstances());
      const weightProps = {
        radiusPixels,
        commonBounds,
        textureWidth: textureSize,
        weightsScale,
        weightsTexture
      };
      const { viewport, devicePixelRatio, coordinateSystem, coordinateOrigin } = moduleSettings;
      const { modelMatrix: modelMatrix2 } = this.props;
      weightsTransform.model.shaderInputs.setProps({
        project: { viewport, devicePixelRatio, modelMatrix: modelMatrix2, coordinateSystem, coordinateOrigin },
        weight: weightProps
      });
      weightsTransform.run({
        parameters: { viewport: [0, 0, textureSize, textureSize] },
        clearColor: [0, 0, 0, 0]
      });
      this._updateMaxWeightValue();
    }
    _debouncedUpdateWeightmap(fromTimer = false) {
      let { updateTimer } = this.state;
      const { debounceTimeout } = this.props;
      if (fromTimer) {
        updateTimer = null;
        this._updateBounds(true);
        this._updateTextureRenderingBounds();
        this.setState({ isWeightMapDirty: true });
      } else {
        this.setState({ isWeightMapDirty: false });
        clearTimeout(updateTimer);
        updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
      }
      this.setState({ updateTimer });
    }
    // input: worldBounds: [minLong, minLat, maxLong, maxLat]
    // input: opts.useLayerCoordinateSystem : layers coordiante system is used
    // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture
    _worldToCommonBounds(worldBounds, opts = {}) {
      const { useLayerCoordinateSystem = false } = opts;
      const [minLong, minLat, maxLong, maxLat] = worldBounds;
      const { viewport } = this.context;
      const { textureSize } = this.state;
      const { coordinateSystem } = this.props;
      const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);
      const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];
      const size = textureSize * RESOLUTION / viewport.scale;
      let bottomLeftCommon;
      let topRightCommon;
      if (useLayerCoordinateSystem && !offsetMode) {
        bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
        topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
      } else {
        bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
        topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
      }
      return scaleToAspectRatio(
        [
          bottomLeftCommon[0] - offsetOriginCommon[0],
          bottomLeftCommon[1] - offsetOriginCommon[1],
          topRightCommon[0] - offsetOriginCommon[0],
          topRightCommon[1] - offsetOriginCommon[1]
        ],
        size,
        size
      );
    }
    // input commonBounds: [xMin, yMin, xMax, yMax]
    // output worldBounds: [minLong, minLat, maxLong, maxLat]
    _commonToWorldBounds(commonBounds) {
      const [xMin, yMin, xMax, yMax] = commonBounds;
      const { viewport } = this.context;
      const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
      const topRightWorld = viewport.unprojectPosition([xMax, yMax]);
      return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
    }
  };
  HeatmapLayer.layerName = "HeatmapLayer";
  HeatmapLayer.defaultProps = defaultProps46;

  // ../google-maps/src/utils.ts
  var MAX_LATITUDE2 = 85.05113;
  function createDeckInstance(map6, overlay, deck, props) {
    if (deck) {
      if (deck.userData._googleMap === map6) {
        return deck;
      }
      destroyDeckInstance(deck);
    }
    const eventListeners = {
      click: null,
      rightclick: null,
      dblclick: null,
      mousemove: null,
      mouseout: null
    };
    const newDeck = new Deck({
      ...props,
      useDevicePixels: props.interleaved ? true : props.useDevicePixels,
      style: props.interleaved ? null : { pointerEvents: "none" },
      parent: getContainer2(overlay, props.style),
      views: new MapView({ repeat: true }),
      initialViewState: {
        longitude: 0,
        latitude: 0,
        zoom: 1
      },
      controller: false
    });
    for (const eventType in eventListeners) {
      eventListeners[eventType] = map6.addListener(
        eventType,
        (evt) => handleMouseEvent(newDeck, eventType, evt)
      );
    }
    newDeck.userData._googleMap = map6;
    newDeck.userData._eventListeners = eventListeners;
    return newDeck;
  }
  function getContainer2(overlay, style) {
    const container = document.createElement("div");
    container.style.position = "absolute";
    Object.assign(container.style, style);
    if ("getPanes" in overlay) {
      overlay.getPanes()?.overlayLayer.appendChild(container);
    } else {
      overlay.getMap()?.getDiv().appendChild(container);
    }
    return container;
  }
  function destroyDeckInstance(deck) {
    const { _eventListeners: eventListeners } = deck.userData;
    for (const eventType in eventListeners) {
      if (eventListeners[eventType]) {
        eventListeners[eventType].remove();
      }
    }
    deck.finalize();
  }
  function getViewPropsFromOverlay(map6, overlay) {
    const { width, height } = getMapSize(map6);
    const projection = overlay.getProjection();
    const bounds = map6.getBounds();
    if (!bounds) {
      return { width, height, left: 0, top: 0 };
    }
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    const topRight = projection.fromLatLngToDivPixel(ne);
    const bottomLeft = projection.fromLatLngToDivPixel(sw);
    const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);
    const centerH = new google.maps.LatLng(0, centerLngLat[0]);
    const centerContainerPx = projection.fromLatLngToContainerPixel(centerH);
    const centerDivPx = projection.fromLatLngToDivPixel(centerH);
    if (!topRight || !bottomLeft || !centerDivPx || !centerContainerPx) {
      return { width, height, left: 0, top: 0 };
    }
    const leftOffset = Math.round(centerDivPx.x - centerContainerPx.x);
    let topOffset = centerDivPx.y - centerContainerPx.y;
    const topLngLat = pixelToLngLat(projection, width / 2, 0);
    const bottomLngLat = pixelToLngLat(projection, width / 2, height);
    let latitude = centerLngLat[1];
    const longitude = centerLngLat[0];
    if (Math.abs(latitude) > MAX_LATITUDE2) {
      latitude = latitude > 0 ? MAX_LATITUDE2 : -MAX_LATITUDE2;
      const center = new google.maps.LatLng(latitude, longitude);
      const centerPx = projection.fromLatLngToContainerPixel(center);
      topOffset += centerPx.y - height / 2;
    }
    topOffset = Math.round(topOffset);
    const delta = new Vector2(topLngLat).sub(bottomLngLat);
    let bearing = 180 * delta.verticalAngle() / Math.PI;
    if (bearing < 0)
      bearing += 360;
    const heading = map6.getHeading() || 0;
    let zoom = map6.getZoom() - 1;
    let scale22;
    if (bearing === 0) {
      scale22 = height ? (bottomLeft.y - topRight.y) / height : 1;
    } else if (bearing === heading) {
      const viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();
      const mapDiagonal = new Vector2([width, -height]).len();
      scale22 = mapDiagonal ? viewDiagonal / mapDiagonal : 1;
    }
    zoom += Math.log2(scale22 || 1);
    return {
      width,
      height,
      left: leftOffset,
      top: topOffset,
      zoom,
      bearing,
      pitch: map6.getTilt(),
      latitude,
      longitude
    };
  }
  function getViewPropsFromCoordinateTransformer(map6, transformer) {
    const { width, height } = getMapSize(map6);
    const { center, heading: bearing, tilt: pitch, zoom } = transformer.getCameraParams();
    const fovy = 25;
    const aspect = height ? width / height : 1;
    const near = 0.75;
    const far = 3e14;
    const projectionMatrix = new Matrix4().perspective({
      fovy: fovy * Math.PI / 180,
      aspect,
      near,
      far
    });
    const focalDistance = 0.5 * projectionMatrix[5];
    return {
      width,
      height,
      viewState: {
        altitude: focalDistance,
        bearing,
        latitude: center.lat(),
        longitude: center.lng(),
        pitch,
        projectionMatrix,
        repeat: true,
        zoom: zoom - 1
      }
    };
  }
  function getMapSize(map6) {
    const container = map6.getDiv().firstChild;
    return {
      // @ts-ignore (TS2531) Object is possibly 'null'
      width: container.offsetWidth,
      // @ts-ignore (TS2531) Object is possibly 'null'
      height: container.offsetHeight
    };
  }
  function pixelToLngLat(projection, x3, y3) {
    const point = new google.maps.Point(x3, y3);
    const latLng = projection.fromContainerPixelToLatLng(point);
    return [latLng.lng(), latLng.lat()];
  }
  function getEventPixel(event, deck) {
    if (event.pixel) {
      return event.pixel;
    }
    const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);
    return {
      x: point[0],
      y: point[1]
    };
  }
  function handleMouseEvent(deck, type, event) {
    if (!deck.isInitialized) {
      return;
    }
    const mockEvent = {
      type,
      offsetCenter: getEventPixel(event, deck),
      srcEvent: event
    };
    switch (type) {
      case "click":
      case "rightclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 1;
        deck._onPointerDown(mockEvent);
        deck._onEvent(mockEvent);
        break;
      case "dblclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 2;
        deck._onEvent(mockEvent);
        break;
      case "mousemove":
        mockEvent.type = "pointermove";
        deck._onPointerMove(mockEvent);
        break;
      case "mouseout":
        mockEvent.type = "pointerleave";
        deck._onPointerMove(mockEvent);
        break;
      default:
        return;
    }
  }

  // ../google-maps/src/google-maps-overlay.ts
  var HIDE_ALL_LAYERS = () => false;
  var GL_STATE = {
    depthMask: true,
    depthTest: true,
    blend: true,
    blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
    blendEquation: GLEnum.FUNC_ADD
  };
  function noop7() {
  }
  var defaultProps47 = {
    interleaved: true
  };
  var GoogleMapsOverlay = class {
    constructor(props) {
      this.props = {};
      this._map = null;
      this._deck = null;
      this._overlay = null;
      this.setProps({ ...defaultProps47, ...props });
    }
    /* Public API */
    /** Add/remove the overlay from a map. */
    setMap(map6) {
      if (map6 === this._map) {
        return;
      }
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      if (this._map) {
        if (!map6 && this._map.getRenderingType() === VECTOR && this.props.interleaved) {
          this._overlay.requestRedraw();
        }
        this._overlay?.setMap(null);
        this._map = null;
      }
      if (map6) {
        this._map = map6;
        const renderingType = map6.getRenderingType();
        if (renderingType !== UNINITIALIZED) {
          this._createOverlay(map6);
        } else {
          map6.addListener("renderingtype_changed", () => {
            this._createOverlay(map6);
          });
        }
      }
    }
    /**
     * Update (partial) props.
     */
    setProps(props) {
      Object.assign(this.props, props);
      if (this._deck) {
        const canvas2 = this._deck.getCanvas();
        if (props.style && canvas2?.parentElement) {
          const parentStyle = canvas2.parentElement.style;
          Object.assign(parentStyle, props.style);
          props.style = null;
        }
        this._deck.setProps(props);
      }
    }
    /** Equivalent of `deck.pickObject`. */
    pickObject(params) {
      return this._deck && this._deck.pickObject(params);
    }
    /** Equivalent of `deck.pickObjects`.  */
    pickMultipleObjects(params) {
      return this._deck && this._deck.pickMultipleObjects(params);
    }
    /** Equivalent of `deck.pickMultipleObjects`. */
    pickObjects(params) {
      return this._deck && this._deck.pickObjects(params);
    }
    /** Remove the overlay and release all underlying resources. */
    finalize() {
      this.setMap(null);
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    /* Private API */
    _createOverlay(map6) {
      const { interleaved } = this.props;
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      const renderingType = map6.getRenderingType();
      if (renderingType === UNINITIALIZED) {
        return;
      }
      const isVectorMap = renderingType === VECTOR && google.maps.WebGLOverlayView;
      const OverlayView = isVectorMap ? google.maps.WebGLOverlayView : google.maps.OverlayView;
      const overlay = new OverlayView();
      if (overlay instanceof google.maps.WebGLOverlayView) {
        if (interleaved) {
          overlay.onAdd = noop7;
          overlay.onContextRestored = this._onContextRestored.bind(this);
          overlay.onDraw = this._onDrawVectorInterleaved.bind(this);
        } else {
          overlay.onAdd = this._onAdd.bind(this);
          overlay.onContextRestored = noop7;
          overlay.onDraw = this._onDrawVectorOverlay.bind(this);
        }
        overlay.onContextLost = this._onContextLost.bind(this);
      } else {
        overlay.onAdd = this._onAdd.bind(this);
        overlay.draw = this._onDrawRaster.bind(this);
      }
      overlay.onRemove = this._onRemove.bind(this);
      this._overlay = overlay;
      this._overlay.setMap(map6);
    }
    _onAdd() {
      this._deck = createDeckInstance(this._map, this._overlay, this._deck, this.props);
    }
    _onContextRestored({ gl }) {
      if (!this._map || !this._overlay) {
        return;
      }
      const _customRender = () => {
        if (this._overlay) {
          this._overlay.requestRedraw();
        }
      };
      const deck = createDeckInstance(this._map, this._overlay, this._deck, {
        gl,
        _customRender,
        ...this.props
      });
      this._deck = deck;
      const animationLoop = deck.animationLoop;
      animationLoop._renderFrame = () => {
        const ab = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
        const device = deck.device;
        device.withParametersWebGL({}, () => {
          animationLoop.props.onRender(animationLoop.animationProps);
        });
        gl.bindBuffer(gl.ARRAY_BUFFER, ab);
      };
    }
    _onContextLost() {
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _onRemove() {
      this._deck?.setProps({ layerFilter: HIDE_ALL_LAYERS });
    }
    _onDrawRaster() {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      const { width, height, left, top, ...rest } = getViewPropsFromOverlay(
        this._map,
        this._overlay
      );
      const canvas2 = deck.getCanvas();
      const parent = canvas2?.parentElement || deck.props.parent;
      if (parent) {
        const parentStyle = parent.style;
        parentStyle.left = `${left}px`;
        parentStyle.top = `${top}px`;
      }
      const altitude = 1e4;
      deck.setProps({
        width,
        height,
        // @ts-expect-error altitude is accepted by WebMercatorViewport but not exposed by type
        viewState: { altitude, ...rest }
      });
      deck.redraw();
    }
    // Vector code path
    _onDrawVectorInterleaved({ gl, transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer),
        // Using external gl context - do not set css size
        width: null,
        height: null
      });
      if (deck.isInitialized) {
        const device = deck.device;
        if (device instanceof WebGLDevice) {
          const _framebuffer = device.getParametersWebGL(GLEnum.FRAMEBUFFER_BINDING);
          deck.setProps({ _framebuffer });
        }
        deck.needsRedraw({ clearRedrawFlags: true });
        if (device instanceof WebGLDevice) {
          device.setParametersWebGL({
            viewport: [0, 0, gl.canvas.width, gl.canvas.height],
            scissor: [0, 0, gl.canvas.width, gl.canvas.height],
            stencilFunc: [gl.ALWAYS, 0, 255, gl.ALWAYS, 0, 255]
          });
          device.withParametersWebGL(GL_STATE, () => {
            deck._drawLayers("google-vector", {
              clearCanvas: false
            });
          });
        }
      }
    }
    _onDrawVectorOverlay({ transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer)
      });
      deck.redraw();
    }
  };

  // ../mapbox/src/deck-utils.ts
  var TILE_SIZE6 = 512;
  var DEGREES_TO_RADIANS14 = Math.PI / 180;
  function getDeckInstance({
    map: map6,
    gl,
    deck
  }) {
    if (map6.__deck) {
      return map6.__deck;
    }
    const customRender = deck?.props._customRender;
    const onLoad = deck?.props.onLoad;
    const deckProps = {
      ...deck?.props,
      _customRender: () => {
        map6.triggerRepaint();
        customRender?.("");
      }
    };
    deckProps.parameters = { ...getDefaultParameters(map6, true), ...deckProps.parameters };
    deckProps.views ||= getDefaultView(map6);
    let deckInstance;
    if (!deck || deck.props.gl === gl) {
      Object.assign(deckProps, {
        gl,
        width: null,
        height: null,
        touchAction: "unset",
        viewState: getViewState(map6)
      });
      if (deck?.isInitialized) {
        watchMapMove(deck, map6);
      } else {
        deckProps.onLoad = () => {
          onLoad?.();
          watchMapMove(deckInstance, map6);
        };
      }
    }
    if (deck) {
      deckInstance = deck;
      deck.setProps(deckProps);
      deck.userData.isExternal = true;
    } else {
      deckInstance = new Deck(deckProps);
      map6.on("remove", () => {
        removeDeckInstance(map6);
      });
    }
    deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
    map6.__deck = deckInstance;
    map6.on("render", () => {
      if (deckInstance.isInitialized)
        afterRender(deckInstance, map6);
    });
    return deckInstance;
  }
  function watchMapMove(deck, map6) {
    const _handleMapMove = () => {
      if (deck.isInitialized) {
        onMapMove(deck, map6);
      } else {
        map6.off("move", _handleMapMove);
      }
    };
    map6.on("move", _handleMapMove);
  }
  function removeDeckInstance(map6) {
    map6.__deck?.finalize();
    map6.__deck = null;
  }
  function getDefaultParameters(map6, interleaved) {
    const result = interleaved ? {
      depthWriteEnabled: true,
      depthCompare: "less-equal",
      depthBias: 0,
      blend: true,
      blendColorSrcFactor: "src-alpha",
      blendColorDstFactor: "one-minus-src-alpha",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one-minus-src-alpha",
      blendColorOperation: "add",
      blendAlphaOperation: "add"
    } : {};
    if (getProjection(map6) === "globe") {
      result.cullMode = "back";
    }
    return result;
  }
  function addLayer(deck, layer) {
    deck.userData.mapboxLayers.add(layer);
    updateLayers(deck);
  }
  function removeLayer(deck, layer) {
    deck.userData.mapboxLayers.delete(layer);
    updateLayers(deck);
  }
  function updateLayer(deck, layer) {
    updateLayers(deck);
  }
  function drawLayer(deck, map6, layer, renderParameters) {
    let { currentViewport } = deck.userData;
    let clearStack = false;
    if (!currentViewport) {
      currentViewport = getViewport(deck, map6, renderParameters);
      deck.userData.currentViewport = currentViewport;
      clearStack = true;
    }
    if (!deck.isInitialized) {
      return;
    }
    deck._drawLayers("mapbox-repaint", {
      viewports: [currentViewport],
      layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (layer.id === params.layer.id || params.layer.props.operation.includes("terrain")),
      clearStack,
      clearCanvas: false
    });
  }
  function getProjection(map6) {
    const projection = map6.getProjection?.();
    const type = (
      // maplibre projection spec
      projection?.type || // mapbox projection spec
      projection?.name
    );
    if (type === "globe") {
      return "globe";
    }
    if (type && type !== "mercator") {
      throw new Error("Unsupported projection");
    }
    return "mercator";
  }
  function getDefaultView(map6) {
    if (getProjection(map6) === "globe") {
      return new GlobeView({ id: "mapbox" });
    }
    return new MapView({ id: "mapbox" });
  }
  function getViewState(map6) {
    const { lng, lat } = map6.getCenter();
    const viewState = {
      // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
      // https://github.com/visgl/deck.gl/issues/6894
      longitude: (lng + 540) % 360 - 180,
      latitude: lat,
      zoom: map6.getZoom(),
      bearing: map6.getBearing(),
      pitch: map6.getPitch(),
      padding: map6.getPadding(),
      repeat: map6.getRenderWorldCopies()
    };
    if (map6.getTerrain?.()) {
      centerCameraOnTerrain(map6, viewState);
    }
    return viewState;
  }
  function centerCameraOnTerrain(map6, viewState) {
    if (map6.getFreeCameraOptions) {
      const { position } = map6.getFreeCameraOptions();
      if (!position || position.z === void 0) {
        return;
      }
      const height = map6.transform.height;
      const { longitude, latitude, pitch } = viewState;
      const cameraX = position.x * TILE_SIZE6;
      const cameraY = (1 - position.y) * TILE_SIZE6;
      const cameraZ = position.z * TILE_SIZE6;
      const center = lngLatToWorld([longitude, latitude]);
      const dx = cameraX - center[0];
      const dy = cameraY - center[1];
      const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
      const pitchRadians = pitch * DEGREES_TO_RADIANS14;
      const altitudePixels = 1.5 * height;
      const scale22 = pitchRadians < 1e-3 ? (
        // Pitch angle too small to deduce the look at point, assume elevation is 0
        altitudePixels * Math.cos(pitchRadians) / cameraZ
      ) : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
      viewState.zoom = Math.log2(scale22);
      const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale22;
      const surfaceElevation = cameraZ - cameraZFromSurface;
      viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];
    } else if (typeof map6.transform.elevation === "number") {
      viewState.position = [0, 0, map6.transform.elevation];
    }
  }
  function getViewport(deck, map6, renderParameters) {
    const viewState = getViewState(map6);
    const view = getDefaultView(map6);
    if (renderParameters) {
      view.props.nearZMultiplier = 0.2;
    }
    const nearZ = renderParameters?.nearZ ?? map6.transform._nearZ;
    const farZ = renderParameters?.farZ ?? map6.transform._farZ;
    if (Number.isFinite(nearZ)) {
      viewState.nearZ = nearZ / map6.transform.height;
      viewState.farZ = farZ / map6.transform.height;
    }
    return view.makeViewport({
      width: deck.width,
      height: deck.height,
      viewState
    });
  }
  function afterRender(deck, map6) {
    const { mapboxLayers, isExternal } = deck.userData;
    if (isExternal) {
      const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
      const deckLayers = flatten(deck.props.layers, Boolean);
      const hasNonMapboxLayers = deckLayers.some(
        (layer) => layer && !mapboxLayerIds.includes(layer.id)
      );
      let viewports = deck.getViewports();
      const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === "mapbox");
      const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
      if (hasNonMapboxLayers || hasNonMapboxViews) {
        if (mapboxViewportIdx >= 0) {
          viewports = viewports.slice();
          viewports[mapboxViewportIdx] = getViewport(deck, map6);
        }
        deck._drawLayers("mapbox-repaint", {
          viewports,
          layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== "mapbox" || !mapboxLayerIds.includes(params.layer.id)),
          clearCanvas: false
        });
      }
    }
    deck.userData.currentViewport = null;
  }
  function onMapMove(deck, map6) {
    deck.setProps({
      viewState: getViewState(map6)
    });
    deck.needsRedraw({ clearRedrawFlags: true });
  }
  function updateLayers(deck) {
    if (deck.userData.isExternal) {
      return;
    }
    const layers = [];
    deck.userData.mapboxLayers.forEach((deckLayer) => {
      const LayerType = deckLayer.props.type;
      const layer = new LayerType(deckLayer.props);
      layers.push(layer);
    });
    deck.setProps({ layers });
  }

  // ../mapbox/src/mapbox-layer.ts
  var MapboxLayer = class {
    /* eslint-disable no-this-before-super */
    constructor(props) {
      if (!props.id) {
        throw new Error("Layer must have an unique id");
      }
      this.id = props.id;
      this.type = "custom";
      this.renderingMode = props.renderingMode || "3d";
      this.slot = props.slot;
      this.map = null;
      this.deck = null;
      this.props = props;
    }
    /* Mapbox custom layer methods */
    onAdd(map6, gl) {
      this.map = map6;
      this.deck = getDeckInstance({ map: map6, gl, deck: this.props.deck });
      addLayer(this.deck, this);
    }
    onRemove() {
      if (this.deck) {
        removeLayer(this.deck, this);
      }
    }
    setProps(props) {
      Object.assign(this.props, props, { id: this.id });
      if (this.deck) {
        updateLayer(this.deck, this);
      }
    }
    render(gl, renderParameters) {
      drawLayer(this.deck, this.map, this, renderParameters);
    }
  };

  // ../mapbox/src/resolve-layers.ts
  var UNDEFINED_BEFORE_ID = "__UNDEFINED__";
  function resolveLayers(map6, deck, oldLayers, newLayers) {
    if (!map6 || !deck || !map6.style || !map6.style._loaded) {
      return;
    }
    const layers = flatten(newLayers, Boolean);
    if (oldLayers !== newLayers) {
      const prevLayers = flatten(oldLayers, Boolean);
      const prevLayerIds = new Set(prevLayers.map((l3) => l3.id));
      for (const layer of layers) {
        prevLayerIds.delete(layer.id);
      }
      for (const id of prevLayerIds) {
        if (map6.getLayer(id)) {
          map6.removeLayer(id);
        }
      }
    }
    for (const layer of layers) {
      const mapboxLayer = map6.getLayer(layer.id);
      if (mapboxLayer) {
        const layerInstance = mapboxLayer.implementation || mapboxLayer;
        layerInstance.setProps(layer.props);
      } else {
        map6.addLayer(
          new MapboxLayer({
            id: layer.id,
            deck,
            // @ts-expect-error slot is not defined in LayerProps
            slot: layer.props.slot
          }),
          // @ts-expect-error beforeId is not defined in LayerProps
          layer.props.beforeId
        );
      }
    }
    const mapLayers = map6.style._order;
    const layerGroups = {};
    for (const layer of layers) {
      let { beforeId } = layer.props;
      if (!beforeId || !mapLayers.includes(beforeId)) {
        beforeId = UNDEFINED_BEFORE_ID;
      }
      layerGroups[beforeId] = layerGroups[beforeId] || [];
      layerGroups[beforeId].push(layer.id);
    }
    for (const beforeId in layerGroups) {
      const layerGroup = layerGroups[beforeId];
      let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
      let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
      for (let i5 = layerGroup.length - 1; i5 >= 0; i5--) {
        const layerId = layerGroup[i5];
        const layerIndex = mapLayers.indexOf(layerId);
        if (layerIndex !== lastLayerIndex - 1) {
          map6.moveLayer(layerId, lastLayerId);
          if (layerIndex > lastLayerIndex) {
            lastLayerIndex++;
          }
        }
        lastLayerIndex--;
        lastLayerId = layerId;
      }
    }
  }

  // ../mapbox/src/mapbox-overlay.ts
  var MapboxOverlay = class {
    constructor(props) {
      this._handleStyleChange = () => {
        resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
      };
      this._updateContainerSize = () => {
        if (this._map && this._container) {
          const { clientWidth, clientHeight } = this._map.getContainer();
          Object.assign(this._container.style, {
            width: `${clientWidth}px`,
            height: `${clientHeight}px`
          });
        }
      };
      this._updateViewState = () => {
        const deck = this._deck;
        const map6 = this._map;
        if (deck && map6) {
          deck.setProps({
            views: this._props.views || getDefaultView(map6),
            viewState: getViewState(map6)
          });
          if (deck.isInitialized) {
            deck.redraw();
          }
        }
      };
      // eslint-disable-next-line complexity
      this._handleMouseEvent = (event) => {
        const deck = this._deck;
        if (!deck || !deck.isInitialized) {
          return;
        }
        const mockEvent = {
          type: event.type,
          offsetCenter: event.point,
          srcEvent: event
        };
        const lastDown = this._lastMouseDownPoint;
        if (!event.point && lastDown) {
          mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
          mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
          mockEvent.offsetCenter = {
            x: lastDown.x + mockEvent.deltaX,
            y: lastDown.y + mockEvent.deltaY
          };
        }
        switch (mockEvent.type) {
          case "mousedown":
            deck._onPointerDown(mockEvent);
            this._lastMouseDownPoint = {
              ...event.point,
              clientX: event.originalEvent.clientX,
              clientY: event.originalEvent.clientY
            };
            break;
          case "dragstart":
            mockEvent.type = "panstart";
            deck._onEvent(mockEvent);
            break;
          case "drag":
            mockEvent.type = "panmove";
            deck._onEvent(mockEvent);
            break;
          case "dragend":
            mockEvent.type = "panend";
            deck._onEvent(mockEvent);
            break;
          case "click":
            mockEvent.tapCount = 1;
            deck._onEvent(mockEvent);
            break;
          case "dblclick":
            mockEvent.type = "click";
            mockEvent.tapCount = 2;
            deck._onEvent(mockEvent);
            break;
          case "mousemove":
            mockEvent.type = "pointermove";
            deck._onPointerMove(mockEvent);
            break;
          case "mouseout":
            mockEvent.type = "pointerleave";
            deck._onPointerMove(mockEvent);
            break;
          default:
            return;
        }
      };
      const { interleaved = false, ...otherProps } = props;
      this._interleaved = interleaved;
      this._props = otherProps;
    }
    /** Update (partial) props of the underlying Deck instance. */
    setProps(props) {
      if (this._interleaved && props.layers) {
        resolveLayers(this._map, this._deck, this._props.layers, props.layers);
      }
      Object.assign(this._props, props);
      if (this._deck && this._map) {
        this._deck.setProps({
          ...this._props,
          parameters: {
            ...getDefaultParameters(this._map, this._interleaved),
            ...this._props.parameters
          }
        });
      }
    }
    // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.
    // Do not restrict the argument type here to avoid type conflict.
    /** Called when the control is added to a map */
    onAdd(map6) {
      this._map = map6;
      return this._interleaved ? this._onAddInterleaved(map6) : this._onAddOverlaid(map6);
    }
    _onAddOverlaid(map6) {
      const container = document.createElement("div");
      Object.assign(container.style, {
        position: "absolute",
        left: 0,
        top: 0,
        textAlign: "initial",
        pointerEvents: "none"
      });
      this._container = container;
      this._deck = new Deck({
        ...this._props,
        parent: container,
        parameters: { ...getDefaultParameters(map6, false), ...this._props.parameters },
        views: this._props.views || getDefaultView(map6),
        viewState: getViewState(map6)
      });
      map6.on("resize", this._updateContainerSize);
      map6.on("render", this._updateViewState);
      map6.on("mousedown", this._handleMouseEvent);
      map6.on("dragstart", this._handleMouseEvent);
      map6.on("drag", this._handleMouseEvent);
      map6.on("dragend", this._handleMouseEvent);
      map6.on("mousemove", this._handleMouseEvent);
      map6.on("mouseout", this._handleMouseEvent);
      map6.on("click", this._handleMouseEvent);
      map6.on("dblclick", this._handleMouseEvent);
      this._updateContainerSize();
      return container;
    }
    _onAddInterleaved(map6) {
      const gl = map6.painter.context.gl;
      if (gl instanceof WebGLRenderingContext) {
        log_default.warn(
          "Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility"
        )();
      }
      this._deck = getDeckInstance({
        map: map6,
        gl,
        deck: new Deck({
          ...this._props,
          gl
        })
      });
      map6.on("styledata", this._handleStyleChange);
      resolveLayers(map6, this._deck, [], this._props.layers);
      return document.createElement("div");
    }
    /** Called when the control is removed from a map */
    onRemove() {
      const map6 = this._map;
      if (map6) {
        if (this._interleaved) {
          this._onRemoveInterleaved(map6);
        } else {
          this._onRemoveOverlaid(map6);
        }
      }
      this._deck = void 0;
      this._map = void 0;
      this._container = void 0;
    }
    _onRemoveOverlaid(map6) {
      map6.off("resize", this._updateContainerSize);
      map6.off("render", this._updateViewState);
      map6.off("mousedown", this._handleMouseEvent);
      map6.off("dragstart", this._handleMouseEvent);
      map6.off("drag", this._handleMouseEvent);
      map6.off("dragend", this._handleMouseEvent);
      map6.off("mousemove", this._handleMouseEvent);
      map6.off("mouseout", this._handleMouseEvent);
      map6.off("click", this._handleMouseEvent);
      map6.off("dblclick", this._handleMouseEvent);
      this._deck?.finalize();
    }
    _onRemoveInterleaved(map6) {
      map6.off("styledata", this._handleStyleChange);
      resolveLayers(map6, this._deck, this._props.layers, []);
      removeDeckInstance(map6);
    }
    getDefaultPosition() {
      return "top-left";
    }
    /** Forwards the Deck.pickObject method */
    pickObject(params) {
      assert8(this._deck);
      return this._deck.pickObject(params);
    }
    /** Forwards the Deck.pickMultipleObjects method */
    pickMultipleObjects(params) {
      assert8(this._deck);
      return this._deck.pickMultipleObjects(params);
    }
    /** Forwards the Deck.pickObjects method */
    pickObjects(params) {
      assert8(this._deck);
      return this._deck.pickObjects(params);
    }
    /** Remove from map and releases all resources */
    finalize() {
      if (this._map) {
        this._map.removeControl(this);
      }
    }
    /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
    getCanvas() {
      if (!this._map) {
        return null;
      }
      return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();
    }
  };

  // ../../node_modules/preact/dist/preact.module.js
  var n2;
  var l2;
  var u;
  var t2;
  var i3;
  var o2;
  var r2;
  var f2;
  var e2;
  var c;
  var s2;
  var a2;
  var h = {};
  var p2 = [];
  var v = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  var y2 = Array.isArray;
  function d(n3, l3) {
    for (var u3 in l3)
      n3[u3] = l3[u3];
    return n3;
  }
  function w(n3) {
    var l3 = n3.parentNode;
    l3 && l3.removeChild(n3);
  }
  function _(l3, u3, t3) {
    var i5, o3, r3, f4 = {};
    for (r3 in u3)
      "key" == r3 ? i5 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f4[r3] = u3[r3];
    if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps)
      for (r3 in l3.defaultProps)
        void 0 === f4[r3] && (f4[r3] = l3.defaultProps[r3]);
    return g(l3, f4, i5, o3, null);
  }
  function g(n3, t3, i5, o3, r3) {
    var f4 = { type: n3, props: t3, key: i5, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r3 ? ++u : r3, __i: -1, __u: 0 };
    return null == r3 && null != l2.vnode && l2.vnode(f4), f4;
  }
  function k(n3) {
    return n3.children;
  }
  function b(n3, l3) {
    this.props = n3, this.context = l3;
  }
  function x2(n3, l3) {
    if (null == l3)
      return n3.__ ? x2(n3.__, n3.__i + 1) : null;
    for (var u3; l3 < n3.__k.length; l3++)
      if (null != (u3 = n3.__k[l3]) && null != u3.__e)
        return u3.__e;
    return "function" == typeof n3.type ? x2(n3) : null;
  }
  function C(n3) {
    var l3, u3;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++)
        if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
          n3.__e = n3.__c.base = u3.__e;
          break;
        }
      return C(n3);
    }
  }
  function M(n3) {
    (!n3.__d && (n3.__d = true) && i3.push(n3) && !P.__r++ || o2 !== l2.debounceRendering) && ((o2 = l2.debounceRendering) || r2)(P);
  }
  function P() {
    var n3, u3, t3, o3, r3, e3, c2, s3;
    for (i3.sort(f2); n3 = i3.shift(); )
      n3.__d && (u3 = i3.length, o3 = void 0, e3 = (r3 = (t3 = n3).__v).__e, c2 = [], s3 = [], t3.__P && ((o3 = d({}, r3)).__v = r3.__v + 1, l2.vnode && l2.vnode(o3), O(t3.__P, o3, r3, t3.__n, t3.__P.namespaceURI, 32 & r3.__u ? [e3] : null, c2, null == e3 ? x2(r3) : e3, !!(32 & r3.__u), s3), o3.__v = r3.__v, o3.__.__k[o3.__i] = o3, j(c2, o3, s3), o3.__e != e3 && C(o3)), i3.length > u3 && i3.sort(f2));
    P.__r = 0;
  }
  function S(n3, l3, u3, t3, i5, o3, r3, f4, e3, c2, s3) {
    var a3, v2, y3, d2, w2, _2 = t3 && t3.__k || p2, g2 = l3.length;
    for (u3.__d = e3, $(u3, l3, _2), e3 = u3.__d, a3 = 0; a3 < g2; a3++)
      null != (y3 = u3.__k[a3]) && "boolean" != typeof y3 && "function" != typeof y3 && (v2 = -1 === y3.__i ? h : _2[y3.__i] || h, y3.__i = a3, O(n3, y3, v2, i5, o3, r3, f4, e3, c2, s3), d2 = y3.__e, y3.ref && v2.ref != y3.ref && (v2.ref && N(v2.ref, null, y3), s3.push(y3.ref, y3.__c || d2, y3)), null == w2 && null != d2 && (w2 = d2), 65536 & y3.__u || v2.__k === y3.__k ? e3 = I(y3, e3, n3) : "function" == typeof y3.type && void 0 !== y3.__d ? e3 = y3.__d : d2 && (e3 = d2.nextSibling), y3.__d = void 0, y3.__u &= -196609);
    u3.__d = e3, u3.__e = w2;
  }
  function $(n3, l3, u3) {
    var t3, i5, o3, r3, f4, e3 = l3.length, c2 = u3.length, s3 = c2, a3 = 0;
    for (n3.__k = [], t3 = 0; t3 < e3; t3++)
      r3 = t3 + a3, null != (i5 = n3.__k[t3] = null == (i5 = l3[t3]) || "boolean" == typeof i5 || "function" == typeof i5 ? null : "string" == typeof i5 || "number" == typeof i5 || "bigint" == typeof i5 || i5.constructor == String ? g(null, i5, null, null, null) : y2(i5) ? g(k, { children: i5 }, null, null, null) : void 0 === i5.constructor && i5.__b > 0 ? g(i5.type, i5.props, i5.key, i5.ref ? i5.ref : null, i5.__v) : i5) ? (i5.__ = n3, i5.__b = n3.__b + 1, f4 = L(i5, u3, r3, s3), i5.__i = f4, o3 = null, -1 !== f4 && (s3--, (o3 = u3[f4]) && (o3.__u |= 131072)), null == o3 || null === o3.__v ? (-1 == f4 && a3--, "function" != typeof i5.type && (i5.__u |= 65536)) : f4 !== r3 && (f4 == r3 - 1 ? a3-- : f4 == r3 + 1 ? a3++ : f4 > r3 ? s3 > e3 - r3 ? a3 += f4 - r3 : a3-- : f4 < r3 && (f4 == r3 - a3 ? a3 -= f4 - r3 : a3++), f4 !== t3 + a3 && (i5.__u |= 65536))) : (o3 = u3[r3]) && null == o3.key && o3.__e && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = x2(o3)), V(o3, o3, false), u3[r3] = null, s3--);
    if (s3)
      for (t3 = 0; t3 < c2; t3++)
        null != (o3 = u3[t3]) && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = x2(o3)), V(o3, o3));
  }
  function I(n3, l3, u3) {
    var t3, i5;
    if ("function" == typeof n3.type) {
      for (t3 = n3.__k, i5 = 0; t3 && i5 < t3.length; i5++)
        t3[i5] && (t3[i5].__ = n3, l3 = I(t3[i5], l3, u3));
      return l3;
    }
    n3.__e != l3 && (l3 && n3.type && !u3.contains(l3) && (l3 = x2(n3)), u3.insertBefore(n3.__e, l3 || null), l3 = n3.__e);
    do {
      l3 = l3 && l3.nextSibling;
    } while (null != l3 && 8 === l3.nodeType);
    return l3;
  }
  function L(n3, l3, u3, t3) {
    var i5 = n3.key, o3 = n3.type, r3 = u3 - 1, f4 = u3 + 1, e3 = l3[u3];
    if (null === e3 || e3 && i5 == e3.key && o3 === e3.type && 0 == (131072 & e3.__u))
      return u3;
    if (t3 > (null != e3 && 0 == (131072 & e3.__u) ? 1 : 0))
      for (; r3 >= 0 || f4 < l3.length; ) {
        if (r3 >= 0) {
          if ((e3 = l3[r3]) && 0 == (131072 & e3.__u) && i5 == e3.key && o3 === e3.type)
            return r3;
          r3--;
        }
        if (f4 < l3.length) {
          if ((e3 = l3[f4]) && 0 == (131072 & e3.__u) && i5 == e3.key && o3 === e3.type)
            return f4;
          f4++;
        }
      }
    return -1;
  }
  function T(n3, l3, u3) {
    "-" === l3[0] ? n3.setProperty(l3, null == u3 ? "" : u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || v.test(l3) ? u3 : u3 + "px";
  }
  function A(n3, l3, u3, t3, i5) {
    var o3;
    n:
      if ("style" === l3)
        if ("string" == typeof u3)
          n3.style.cssText = u3;
        else {
          if ("string" == typeof t3 && (n3.style.cssText = t3 = ""), t3)
            for (l3 in t3)
              u3 && l3 in u3 || T(n3.style, l3, "");
          if (u3)
            for (l3 in u3)
              t3 && u3[l3] === t3[l3] || T(n3.style, l3, u3[l3]);
        }
      else if ("o" === l3[0] && "n" === l3[1])
        o3 = l3 !== (l3 = l3.replace(/(PointerCapture)$|Capture$/i, "$1")), l3 = l3.toLowerCase() in n3 || "onFocusOut" === l3 || "onFocusIn" === l3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + o3] = u3, u3 ? t3 ? u3.u = t3.u : (u3.u = e2, n3.addEventListener(l3, o3 ? s2 : c, o3)) : n3.removeEventListener(l3, o3 ? s2 : c, o3);
      else {
        if ("http://www.w3.org/2000/svg" == i5)
          l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" != l3 && "height" != l3 && "href" != l3 && "list" != l3 && "form" != l3 && "tabIndex" != l3 && "download" != l3 && "rowSpan" != l3 && "colSpan" != l3 && "role" != l3 && "popover" != l3 && l3 in n3)
          try {
            n3[l3] = null == u3 ? "" : u3;
            break n;
          } catch (n4) {
          }
        "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l3[4] ? n3.removeAttribute(l3) : n3.setAttribute(l3, "popover" == l3 && 1 == u3 ? "" : u3));
      }
  }
  function F(n3) {
    return function(u3) {
      if (this.l) {
        var t3 = this.l[u3.type + n3];
        if (null == u3.t)
          u3.t = e2++;
        else if (u3.t < t3.u)
          return;
        return t3(l2.event ? l2.event(u3) : u3);
      }
    };
  }
  function O(n3, u3, t3, i5, o3, r3, f4, e3, c2, s3) {
    var a3, h4, p3, v2, w2, _2, g2, m, x3, C2, M2, P2, $2, I2, H, L2, T2 = u3.type;
    if (void 0 !== u3.constructor)
      return null;
    128 & t3.__u && (c2 = !!(32 & t3.__u), r3 = [e3 = u3.__e = t3.__e]), (a3 = l2.__b) && a3(u3);
    n:
      if ("function" == typeof T2)
        try {
          if (m = u3.props, x3 = "prototype" in T2 && T2.prototype.render, C2 = (a3 = T2.contextType) && i5[a3.__c], M2 = a3 ? C2 ? C2.props.value : a3.__ : i5, t3.__c ? g2 = (h4 = u3.__c = t3.__c).__ = h4.__E : (x3 ? u3.__c = h4 = new T2(m, M2) : (u3.__c = h4 = new b(m, M2), h4.constructor = T2, h4.render = q), C2 && C2.sub(h4), h4.props = m, h4.state || (h4.state = {}), h4.context = M2, h4.__n = i5, p3 = h4.__d = true, h4.__h = [], h4._sb = []), x3 && null == h4.__s && (h4.__s = h4.state), x3 && null != T2.getDerivedStateFromProps && (h4.__s == h4.state && (h4.__s = d({}, h4.__s)), d(h4.__s, T2.getDerivedStateFromProps(m, h4.__s))), v2 = h4.props, w2 = h4.state, h4.__v = u3, p3)
            x3 && null == T2.getDerivedStateFromProps && null != h4.componentWillMount && h4.componentWillMount(), x3 && null != h4.componentDidMount && h4.__h.push(h4.componentDidMount);
          else {
            if (x3 && null == T2.getDerivedStateFromProps && m !== v2 && null != h4.componentWillReceiveProps && h4.componentWillReceiveProps(m, M2), !h4.__e && (null != h4.shouldComponentUpdate && false === h4.shouldComponentUpdate(m, h4.__s, M2) || u3.__v === t3.__v)) {
              for (u3.__v !== t3.__v && (h4.props = m, h4.state = h4.__s, h4.__d = false), u3.__e = t3.__e, u3.__k = t3.__k, u3.__k.forEach(function(n4) {
                n4 && (n4.__ = u3);
              }), P2 = 0; P2 < h4._sb.length; P2++)
                h4.__h.push(h4._sb[P2]);
              h4._sb = [], h4.__h.length && f4.push(h4);
              break n;
            }
            null != h4.componentWillUpdate && h4.componentWillUpdate(m, h4.__s, M2), x3 && null != h4.componentDidUpdate && h4.__h.push(function() {
              h4.componentDidUpdate(v2, w2, _2);
            });
          }
          if (h4.context = M2, h4.props = m, h4.__P = n3, h4.__e = false, $2 = l2.__r, I2 = 0, x3) {
            for (h4.state = h4.__s, h4.__d = false, $2 && $2(u3), a3 = h4.render(h4.props, h4.state, h4.context), H = 0; H < h4._sb.length; H++)
              h4.__h.push(h4._sb[H]);
            h4._sb = [];
          } else
            do {
              h4.__d = false, $2 && $2(u3), a3 = h4.render(h4.props, h4.state, h4.context), h4.state = h4.__s;
            } while (h4.__d && ++I2 < 25);
          h4.state = h4.__s, null != h4.getChildContext && (i5 = d(d({}, i5), h4.getChildContext())), x3 && !p3 && null != h4.getSnapshotBeforeUpdate && (_2 = h4.getSnapshotBeforeUpdate(v2, w2)), S(n3, y2(L2 = null != a3 && a3.type === k && null == a3.key ? a3.props.children : a3) ? L2 : [L2], u3, t3, i5, o3, r3, f4, e3, c2, s3), h4.base = u3.__e, u3.__u &= -161, h4.__h.length && f4.push(h4), g2 && (h4.__E = h4.__ = null);
        } catch (n4) {
          if (u3.__v = null, c2 || null != r3) {
            for (u3.__u |= c2 ? 160 : 32; e3 && 8 === e3.nodeType && e3.nextSibling; )
              e3 = e3.nextSibling;
            r3[r3.indexOf(e3)] = null, u3.__e = e3;
          } else
            u3.__e = t3.__e, u3.__k = t3.__k;
          l2.__e(n4, u3, t3);
        }
      else
        null == r3 && u3.__v === t3.__v ? (u3.__k = t3.__k, u3.__e = t3.__e) : u3.__e = z(t3.__e, u3, t3, i5, o3, r3, f4, c2, s3);
    (a3 = l2.diffed) && a3(u3);
  }
  function j(n3, u3, t3) {
    u3.__d = void 0;
    for (var i5 = 0; i5 < t3.length; i5++)
      N(t3[i5], t3[++i5], t3[++i5]);
    l2.__c && l2.__c(u3, n3), n3.some(function(u4) {
      try {
        n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
          n4.call(u4);
        });
      } catch (n4) {
        l2.__e(n4, u4.__v);
      }
    });
  }
  function z(l3, u3, t3, i5, o3, r3, f4, e3, c2) {
    var s3, a3, p3, v2, d2, _2, g2, m = t3.props, k2 = u3.props, b2 = u3.type;
    if ("svg" === b2 ? o3 = "http://www.w3.org/2000/svg" : "math" === b2 ? o3 = "http://www.w3.org/1998/Math/MathML" : o3 || (o3 = "http://www.w3.org/1999/xhtml"), null != r3) {
      for (s3 = 0; s3 < r3.length; s3++)
        if ((d2 = r3[s3]) && "setAttribute" in d2 == !!b2 && (b2 ? d2.localName === b2 : 3 === d2.nodeType)) {
          l3 = d2, r3[s3] = null;
          break;
        }
    }
    if (null == l3) {
      if (null === b2)
        return document.createTextNode(k2);
      l3 = document.createElementNS(o3, b2, k2.is && k2), r3 = null, e3 = false;
    }
    if (null === b2)
      m === k2 || e3 && l3.data === k2 || (l3.data = k2);
    else {
      if (r3 = r3 && n2.call(l3.childNodes), m = t3.props || h, !e3 && null != r3)
        for (m = {}, s3 = 0; s3 < l3.attributes.length; s3++)
          m[(d2 = l3.attributes[s3]).name] = d2.value;
      for (s3 in m)
        if (d2 = m[s3], "children" == s3)
          ;
        else if ("dangerouslySetInnerHTML" == s3)
          p3 = d2;
        else if ("key" !== s3 && !(s3 in k2)) {
          if ("value" == s3 && "defaultValue" in k2 || "checked" == s3 && "defaultChecked" in k2)
            continue;
          A(l3, s3, null, d2, o3);
        }
      for (s3 in k2)
        d2 = k2[s3], "children" == s3 ? v2 = d2 : "dangerouslySetInnerHTML" == s3 ? a3 = d2 : "value" == s3 ? _2 = d2 : "checked" == s3 ? g2 = d2 : "key" === s3 || e3 && "function" != typeof d2 || m[s3] === d2 || A(l3, s3, d2, m[s3], o3);
      if (a3)
        e3 || p3 && (a3.__html === p3.__html || a3.__html === l3.innerHTML) || (l3.innerHTML = a3.__html), u3.__k = [];
      else if (p3 && (l3.innerHTML = ""), S(l3, y2(v2) ? v2 : [v2], u3, t3, i5, "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : o3, r3, f4, r3 ? r3[0] : t3.__k && x2(t3, 0), e3, c2), null != r3)
        for (s3 = r3.length; s3--; )
          null != r3[s3] && w(r3[s3]);
      e3 || (s3 = "value", void 0 !== _2 && (_2 !== l3[s3] || "progress" === b2 && !_2 || "option" === b2 && _2 !== m[s3]) && A(l3, s3, _2, m[s3], o3), s3 = "checked", void 0 !== g2 && g2 !== l3[s3] && A(l3, s3, g2, m[s3], o3));
    }
    return l3;
  }
  function N(n3, u3, t3) {
    try {
      if ("function" == typeof n3) {
        var i5 = "function" == typeof n3.__u;
        i5 && n3.__u(), i5 && null == u3 || (n3.__u = n3(u3));
      } else
        n3.current = u3;
    } catch (n4) {
      l2.__e(n4, t3);
    }
  }
  function V(n3, u3, t3) {
    var i5, o3;
    if (l2.unmount && l2.unmount(n3), (i5 = n3.ref) && (i5.current && i5.current !== n3.__e || N(i5, null, u3)), null != (i5 = n3.__c)) {
      if (i5.componentWillUnmount)
        try {
          i5.componentWillUnmount();
        } catch (n4) {
          l2.__e(n4, u3);
        }
      i5.base = i5.__P = null;
    }
    if (i5 = n3.__k)
      for (o3 = 0; o3 < i5.length; o3++)
        i5[o3] && V(i5[o3], u3, t3 || "function" != typeof n3.type);
    t3 || null == n3.__e || w(n3.__e), n3.__c = n3.__ = n3.__e = n3.__d = void 0;
  }
  function q(n3, l3, u3) {
    return this.constructor(n3, u3);
  }
  function B(u3, t3, i5) {
    var o3, r3, f4, e3;
    l2.__ && l2.__(u3, t3), r3 = (o3 = "function" == typeof i5) ? null : i5 && i5.__k || t3.__k, f4 = [], e3 = [], O(t3, u3 = (!o3 && i5 || t3).__k = _(k, null, [u3]), r3 || h, h, t3.namespaceURI, !o3 && i5 ? [i5] : r3 ? null : t3.firstChild ? n2.call(t3.childNodes) : null, f4, !o3 && i5 ? i5 : r3 ? r3.__e : t3.firstChild, o3, e3), j(f4, u3, e3);
  }
  n2 = p2.slice, l2 = { __e: function(n3, l3, u3, t3) {
    for (var i5, o3, r3; l3 = l3.__; )
      if ((i5 = l3.__c) && !i5.__)
        try {
          if ((o3 = i5.constructor) && null != o3.getDerivedStateFromError && (i5.setState(o3.getDerivedStateFromError(n3)), r3 = i5.__d), null != i5.componentDidCatch && (i5.componentDidCatch(n3, t3 || {}), r3 = i5.__d), r3)
            return i5.__E = i5;
        } catch (l4) {
          n3 = l4;
        }
    throw n3;
  } }, u = 0, t2 = function(n3) {
    return null != n3 && null == n3.constructor;
  }, b.prototype.setState = function(n3, l3) {
    var u3;
    u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof n3 && (n3 = n3(d({}, u3), this.props)), n3 && d(u3, n3), null != n3 && this.__v && (l3 && this._sb.push(l3), M(this));
  }, b.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), M(this));
  }, b.prototype.render = k, i3 = [], r2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f2 = function(n3, l3) {
    return n3.__v.__b - l3.__v.__b;
  }, P.__r = 0, e2 = 0, c = F(false), s2 = F(true), a2 = 0;

  // ../widgets/src/components.tsx
  var components_exports = {};
  __export(components_exports, {
    ButtonGroup: () => ButtonGroup,
    GroupedIconButton: () => GroupedIconButton,
    IconButton: () => IconButton
  });

  // ../../node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
  var f3 = 0;
  var i4 = Array.isArray;
  function u2(e3, t3, n3, o3, i5, u3) {
    t3 || (t3 = {});
    var a3, c2, p3 = t3;
    if ("ref" in p3)
      for (c2 in p3 = {}, t3)
        "ref" == c2 ? a3 = t3[c2] : p3[c2] = t3[c2];
    var l3 = { type: e3, props: p3, key: n3, ref: a3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i5, __self: u3 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps))
      for (c2 in a3)
        void 0 === p3[c2] && (p3[c2] = a3[c2]);
    return l2.vnode && l2.vnode(l3), l3;
  }

  // ../widgets/src/components.tsx
  var IconButton = (props) => {
    const { className, label, onClick } = props;
    return /* @__PURE__ */ u2("div", { className: "deck-widget-button", children: /* @__PURE__ */ u2(
      "button",
      {
        className: `deck-widget-icon-button ${className}`,
        type: "button",
        onClick,
        title: label,
        children: /* @__PURE__ */ u2("div", { className: "deck-widget-icon" })
      }
    ) });
  };
  var ButtonGroup = (props) => {
    const { children, orientation } = props;
    return /* @__PURE__ */ u2("div", { className: `deck-widget-button-group ${orientation}`, children });
  };
  var GroupedIconButton = (props) => {
    const { className, label, onClick } = props;
    return /* @__PURE__ */ u2(
      "button",
      {
        className: `deck-widget-icon-button ${className}`,
        type: "button",
        onClick,
        title: label,
        children: /* @__PURE__ */ u2("div", { className: "deck-widget-icon" })
      }
    );
  };

  // ../widgets/src/fullscreen-widget.tsx
  var FullscreenWidget = class {
    constructor(props) {
      this.id = "fullscreen";
      this.placement = "top-left";
      this.fullscreen = false;
      this.id = props.id ?? this.id;
      this.placement = props.placement ?? this.placement;
      this.props = {
        ...props,
        enterLabel: props.enterLabel ?? "Enter Fullscreen",
        exitLabel: props.exitLabel ?? "Exit Fullscreen",
        style: props.style ?? {}
      };
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const el = document.createElement("div");
      el.classList.add("deck-widget", "deck-widget-fullscreen");
      if (className)
        el.classList.add(className);
      applyStyles(el, style);
      this.deck = deck;
      this.element = el;
      this.update();
      document.addEventListener("fullscreenchange", this.onFullscreenChange.bind(this));
      return el;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
      document.removeEventListener("fullscreenchange", this.onFullscreenChange.bind(this));
    }
    update() {
      const { enterLabel, exitLabel } = this.props;
      const element = this.element;
      if (!element) {
        return;
      }
      const ui = /* @__PURE__ */ u2(
        IconButton,
        {
          onClick: this.handleClick.bind(this),
          label: this.fullscreen ? exitLabel : enterLabel,
          className: this.fullscreen ? "deck-widget-fullscreen-exit" : "deck-widget-fullscreen-enter"
        }
      );
      B(ui, element);
    }
    setProps(props) {
      this.placement = props.placement ?? this.placement;
      const oldProps = this.props;
      const el = this.element;
      if (el) {
        if (oldProps.className !== props.className) {
          if (oldProps.className)
            el.classList.remove(oldProps.className);
          if (props.className)
            el.classList.add(props.className);
        }
        if (!deepEqual2(oldProps.style, props.style, 1)) {
          removeStyles(el, oldProps.style);
          applyStyles(el, props.style);
        }
      }
      Object.assign(this.props, props);
      this.update();
    }
    getContainer() {
      return this.props.container || this.deck?.getCanvas()?.parentElement;
    }
    onFullscreenChange() {
      const prevFullscreen = this.fullscreen;
      const fullscreen = document.fullscreenElement === this.getContainer();
      if (prevFullscreen !== fullscreen) {
        this.fullscreen = !this.fullscreen;
      }
      this.update();
    }
    async handleClick() {
      if (this.fullscreen) {
        await this.exitFullscreen();
      } else {
        await this.requestFullscreen();
      }
      this.update();
    }
    async requestFullscreen() {
      const container = this.getContainer();
      if (container?.requestFullscreen) {
        await container.requestFullscreen({ navigationUI: "hide" });
      } else {
        this.togglePseudoFullscreen();
      }
    }
    async exitFullscreen() {
      if (document.exitFullscreen) {
        await document.exitFullscreen();
      } else {
        this.togglePseudoFullscreen();
      }
    }
    togglePseudoFullscreen() {
      this.getContainer()?.classList.toggle("deck-pseudo-fullscreen");
    }
  };

  // ../widgets/src/compass-widget.tsx
  var CompassWidget = class {
    constructor(props) {
      this.id = "compass";
      this.placement = "top-left";
      this.viewId = null;
      this.viewports = {};
      this.id = props.id ?? this.id;
      this.viewId = props.viewId ?? this.viewId;
      this.placement = props.placement ?? this.placement;
      this.props = {
        ...props,
        transitionDuration: props.transitionDuration ?? 200,
        label: props.label ?? "Reset Compass",
        style: props.style ?? {}
      };
    }
    setProps(props) {
      this.placement = props.placement ?? this.placement;
      this.viewId = props.viewId ?? this.viewId;
      const oldProps = this.props;
      const el = this.element;
      if (el) {
        if (oldProps.className !== props.className) {
          if (oldProps.className)
            el.classList.remove(oldProps.className);
          if (props.className)
            el.classList.add(props.className);
        }
        if (!deepEqual2(oldProps.style, props.style, 1)) {
          removeStyles(el, oldProps.style);
          applyStyles(el, props.style);
        }
      }
      Object.assign(this.props, props);
      this.update();
    }
    onViewportChange(viewport) {
      if (!viewport.equals(this.viewports[viewport.id])) {
        this.viewports[viewport.id] = viewport;
        this.update();
      }
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const element = document.createElement("div");
      element.classList.add("deck-widget", "deck-widget-compass");
      if (className)
        element.classList.add(className);
      applyStyles(element, style);
      this.deck = deck;
      this.element = element;
      this.update();
      return element;
    }
    getRotation(viewport) {
      if (viewport instanceof WebMercatorViewport2) {
        return [-viewport.bearing, viewport.pitch];
      } else if (viewport instanceof GlobeViewport) {
        return [0, Math.max(-80, Math.min(80, viewport.latitude))];
      }
      return [0, 0];
    }
    update() {
      const viewId = this.viewId || Object.values(this.viewports)[0]?.id || "default-view";
      const viewport = this.viewports[viewId];
      const [rz, rx] = this.getRotation(viewport);
      const element = this.element;
      if (!element) {
        return;
      }
      const ui = /* @__PURE__ */ u2("div", { className: "deck-widget-button", style: { perspective: 100 }, children: /* @__PURE__ */ u2(
        "button",
        {
          type: "button",
          onClick: () => {
            for (const viewport2 of Object.values(this.viewports)) {
              this.handleCompassReset(viewport2);
            }
          },
          title: this.props.label,
          style: { transform: `rotateX(${rx}deg)` },
          children: /* @__PURE__ */ u2("svg", { fill: "none", width: "100%", height: "100%", viewBox: "0 0 26 26", children: /* @__PURE__ */ u2("g", { transform: `rotate(${rz},13,13)`, children: [
            /* @__PURE__ */ u2(
              "path",
              {
                d: "M10 13.0001L12.9999 5L15.9997 13.0001H10Z",
                fill: "var(--icon-compass-north-color, #F05C44)"
              }
            ),
            /* @__PURE__ */ u2(
              "path",
              {
                d: "M16.0002 12.9999L13.0004 21L10.0005 12.9999H16.0002Z",
                fill: "var(--icon-compass-south-color, #C2C2CC)"
              }
            )
          ] }) })
        }
      ) });
      B(ui, element);
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    handleCompassReset(viewport) {
      const viewId = this.viewId || viewport.id || "default-view";
      if (viewport instanceof WebMercatorViewport2) {
        const nextViewState = {
          ...viewport,
          bearing: 0,
          ...this.getRotation(viewport)[0] === 0 ? { pitch: 0 } : {},
          transitionDuration: this.props.transitionDuration,
          transitionInterpolator: new FlyToInterpolator()
        };
        this.deck._onViewStateChange({ viewId, viewState: nextViewState, interactionState: {} });
      }
    }
  };

  // ../widgets/src/zoom-widget.tsx
  var _ZoomWidget = class {
    constructor(props = {}) {
      this.id = "zoom";
      this.placement = "top-left";
      this.viewId = null;
      this.viewports = {};
      this.id = props.id ?? this.id;
      this.viewId = props.viewId ?? this.viewId;
      this.placement = props.placement ?? this.placement;
      this.props = {
        ..._ZoomWidget.defaultProps,
        ...props
      };
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const element = document.createElement("div");
      element.classList.add("deck-widget", "deck-widget-zoom");
      if (className)
        element.classList.add(className);
      applyStyles(element, style);
      this.deck = deck;
      this.element = element;
      this.update();
      return element;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    setProps(props) {
      this.placement = props.placement ?? this.placement;
      this.viewId = props.viewId ?? this.viewId;
      const oldProps = this.props;
      const el = this.element;
      if (el) {
        if (oldProps.className !== props.className) {
          if (oldProps.className)
            el.classList.remove(oldProps.className);
          if (props.className)
            el.classList.add(props.className);
        }
        if (!deepEqual2(oldProps.style, props.style, 1)) {
          removeStyles(el, oldProps.style);
          applyStyles(el, props.style);
        }
      }
      Object.assign(this.props, props);
      this.update();
    }
    onViewportChange(viewport) {
      this.viewports[viewport.id] = viewport;
    }
    handleZoom(viewport, nextZoom) {
      const viewId = this.viewId || viewport?.id || "default-view";
      const nextViewState = {
        ...viewport,
        zoom: nextZoom
      };
      if (this.props.transitionDuration > 0) {
        nextViewState.transitionDuration = this.props.transitionDuration;
        nextViewState.transitionInterpolator = "latitude" in nextViewState ? new FlyToInterpolator() : new LinearInterpolator();
      }
      this.setViewState(viewId, nextViewState);
    }
    handleZoomIn() {
      for (const viewport of Object.values(this.viewports)) {
        this.handleZoom(viewport, viewport.zoom + 1);
      }
    }
    handleZoomOut() {
      for (const viewport of Object.values(this.viewports)) {
        this.handleZoom(viewport, viewport.zoom - 1);
      }
    }
    /**
     * @todo - move to deck or widget manager
     */
    setViewState(viewId, viewState) {
      this.deck._onViewStateChange({ viewId, viewState, interactionState: {} });
    }
    update() {
      const element = this.element;
      if (!element) {
        return;
      }
      const ui = /* @__PURE__ */ u2(ButtonGroup, { orientation: this.props.orientation, children: [
        /* @__PURE__ */ u2(
          GroupedIconButton,
          {
            onClick: () => this.handleZoomIn(),
            label: this.props.zoomInLabel,
            className: "deck-widget-zoom-in"
          }
        ),
        /* @__PURE__ */ u2(
          GroupedIconButton,
          {
            onClick: () => this.handleZoomOut(),
            label: this.props.zoomOutLabel,
            className: "deck-widget-zoom-out"
          }
        )
      ] });
      B(ui, element);
    }
  };
  var ZoomWidget = _ZoomWidget;
  ZoomWidget.defaultProps = {
    id: "zoom-widget",
    style: {},
    placement: "top-left",
    className: void 0,
    orientation: "vertical",
    transitionDuration: 200,
    zoomInLabel: "Zoom In",
    zoomOutLabel: "Zoom Out",
    viewId: void 0
  };

  // ../widgets/src/widget-impl.ts
  var WidgetImpl = class {
    constructor(props) {
      this.id = props.id || "widget";
      this.props = props;
    }
    onAdd({ deck }) {
      this.deck = deck;
      const { style, className } = this.props;
      const el = this._createRootElement({
        widgetClassName: this.className,
        className,
        style
      });
      this.element = el;
      this.onRenderHTML();
      return this.element;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    setProps(props) {
      const oldProps = this.props;
      const el = this.element;
      if (el) {
        if (oldProps.className !== props.className) {
          if (oldProps.className)
            el.classList.remove(oldProps.className);
          if (props.className)
            el.classList.add(props.className);
        }
        if (!deepEqual2(oldProps.style, props.style, 1)) {
          removeStyles(el, oldProps.style);
          applyStyles(el, props.style);
        }
      }
      Object.assign(this.props, props);
      this.onRenderHTML();
    }
    _createRootElement(props) {
      const { widgetClassName, className, style } = props;
      const element = document.createElement("div");
      ["deck-widget", widgetClassName, className].filter((cls) => typeof cls === "string" && cls.length > 0).forEach((className2) => element.classList.add(className2));
      applyStyles(element, style);
      return element;
    }
  };
  WidgetImpl.defaultProps = {
    id: "widget",
    style: {},
    className: ""
  };

  // ../widgets/src/screenshot-widget.tsx
  var _ScreenshotWidget = class extends WidgetImpl {
    constructor(props = {}) {
      super({ ..._ScreenshotWidget.defaultProps, ...props });
      this.className = "deck-widget-screenshot";
      this.placement = "top-left";
      this.placement = props.placement ?? this.placement;
    }
    setProps(props) {
      this.placement = props.placement ?? this.placement;
      super.setProps(props);
    }
    onRenderHTML() {
      const element = this.element;
      if (!element)
        return;
      B(
        /* @__PURE__ */ u2(
          IconButton,
          {
            className: "deck-widget-camera",
            label: this.props.label,
            onClick: this.handleClick.bind(this)
          }
        ),
        element
      );
    }
    handleClick() {
      if (this.props.onCapture) {
        this.props.onCapture(this);
        return;
      }
      const dataURL = this.captureScreenToDataURL(this.props.imageFormat);
      if (dataURL) {
        this.downloadDataURL(dataURL, this.props.filename);
      }
    }
    /** @note only captures canvas contents, not HTML DOM or CSS styles */
    captureScreenToDataURL(imageFormat) {
      const canvas2 = this.deck?.getCanvas();
      return canvas2?.toDataURL(imageFormat);
    }
    /** Download a data URL */
    downloadDataURL(dataURL, filename2) {
      const link = document.createElement("a");
      link.href = dataURL;
      link.download = filename2;
      link.click();
    }
  };
  var ScreenshotWidget = _ScreenshotWidget;
  ScreenshotWidget.defaultProps = {
    ...WidgetImpl.defaultProps,
    id: "screenshot",
    placement: "top-left",
    label: "Screenshot",
    filename: "screenshot.png",
    imageFormat: "image/png",
    onCapture: void 0
  };

  // ../widgets/src/reset-view-widget.tsx
  var _ResetViewWidget = class extends WidgetImpl {
    constructor(props = {}) {
      super({ ..._ResetViewWidget.defaultProps, ...props });
      this.className = "deck-widget-reset-view";
      this.placement = "top-left";
      this.placement = props.placement ?? this.placement;
    }
    setProps(props) {
      this.placement = props.placement ?? this.placement;
      super.setProps(props);
    }
    onRenderHTML() {
      const element = this.element;
      if (!element)
        return;
      B(
        /* @__PURE__ */ u2(
          IconButton,
          {
            className: "deck-widget-reset-focus",
            label: this.props.label,
            onClick: this.handleClick.bind(this)
          }
        ),
        element
      );
    }
    handleClick() {
      const initialViewState = this.props.initialViewState || this.deck?.props.initialViewState;
      this.setViewState(initialViewState);
    }
    setViewState(viewState) {
      const viewId = this.props.viewId || viewState?.id || "default-view";
      const nextViewState = {
        ...viewState
        // only works for geospatial?
        // transitionDuration: this.props.transitionDuration,
        // transitionInterpolator: new FlyToInterpolator()
      };
      this.deck._onViewStateChange({ viewId, viewState: nextViewState, interactionState: {} });
    }
  };
  var ResetViewWidget = _ResetViewWidget;
  ResetViewWidget.defaultProps = {
    ...WidgetImpl.defaultProps,
    id: "reset-view",
    placement: "top-left",
    label: "Reset View",
    initialViewState: void 0,
    viewId: void 0
  };

  // ../widgets/src/themes.ts
  var LightTheme = {
    "--button-background": "#fff",
    "--button-stroke": "rgba(255, 255, 255, 0.3)",
    "--button-inner-stroke": "unset",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25)",
    "--button-backdrop-filter": "unset",
    "--button-icon-idle": "rgba(97, 97, 102, 1)",
    "--button-icon-hover": "rgba(24, 24, 26, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var DarkTheme = {
    "--button-background": "rgba(18, 18, 20, 1)",
    "--button-stroke": "rgba(18, 18, 20, 0.30)",
    "--button-inner-stroke": "unset",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25)",
    "--button-backdrop-filter": "unset",
    "--button-icon-idle": "rgba(158, 157, 168, 1)",
    "--button-icon-hover": "rgba(215, 214, 229, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var LightGlassTheme = {
    "--button-background": "rgba(255, 255, 255, 0.6)",
    "--button-stroke": "rgba(255, 255, 255, 0.3)",
    "--button-inner-stroke": "1px solid rgba(255, 255, 255, 0.6)",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25), 0px 0px 8px 0px rgba(0, 0, 0, 0.1) inset",
    "--button-backdrop-filter": "blur(4px)",
    "--button-icon-idle": "rgba(97, 97, 102, 1)",
    "--button-icon-hover": "rgba(24, 24, 26, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var DarkGlassTheme = {
    "--button-background": "rgba(18, 18, 20, 0.75)",
    "--button-stroke": "rgba(18, 18, 20, 0.30)",
    "--button-inner-stroke": "1px solid rgba(18, 18, 20, 0.75)",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25), 0px 0px 8px 0px rgba(0, 0, 0, 0.1) inset",
    "--button-backdrop-filter": "blur(4px)",
    "--button-icon-idle": "rgba(158, 157, 168, 1)",
    "--button-icon-hover": "rgba(215, 214, 229, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };

  // bundle.ts
  var h3 = __toESM(require_h3_js(), 1);
  H3HexagonLayer._checkH3Lib = () => {
    const installHelp = 'include the <script src="https://unpkg.com/h3-js@^4.0.0"><\/script> tag before the deck.gl script tag. https://deck.gl/docs/api-reference/geo-layers/h3-hexagon-layer';
    if (!h3) {
      throw new Error(`To use H3 functionality, ${installHelp}`);
    } else if (h3.polyfill && !h3.polygonToCells) {
      throw new Error(`Incompatible h3-js version. ${installHelp}`);
    }
  };
  return __toCommonJS(bundle_exports);
})();
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
      return __exports__;
      });
