{
  "version": 3,
  "sources": ["../src/index.ts", "../src/constants.ts", "../src/lib/bounding-volumes/axis-aligned-bounding-box.ts", "../src/lib/bounding-volumes/bounding-sphere.ts", "../src/lib/bounding-volumes/oriented-bounding-box.ts", "../src/lib/culling-volume.ts", "../src/lib/plane.ts", "../src/lib/perspective-off-center-frustum.ts", "../src/lib/perspective-frustum.ts", "../src/lib/algorithms/bounding-sphere-from-points.ts", "../src/lib/algorithms/bounding-box-from-points.ts", "../src/lib/algorithms/compute-eigen-decomposition.ts"],
  "sourcesContent": ["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {INTERSECTION} from './constants';\n\nexport {AxisAlignedBoundingBox} from './lib/bounding-volumes/axis-aligned-bounding-box';\nexport {BoundingSphere} from './lib/bounding-volumes/bounding-sphere';\nexport {OrientedBoundingBox} from './lib/bounding-volumes/oriented-bounding-box';\nexport {CullingVolume} from './lib/culling-volume';\nexport {Plane} from './lib/plane';\n\nexport {PerspectiveOffCenterFrustum as _PerspectiveOffCenterFrustum} from './lib/perspective-off-center-frustum';\nexport {PerspectiveFrustum as _PerspectiveFrustum} from './lib/perspective-frustum';\n\nexport {makeBoundingSphereFromPoints} from './lib/algorithms/bounding-sphere-from-points';\nexport {\n  makeAxisAlignedBoundingBoxFromPoints,\n  makeOrientedBoundingBoxFromPoints\n} from './lib/algorithms/bounding-box-from-points';\nexport {computeEigenDecomposition} from './lib/algorithms/compute-eigen-decomposition';\n", "// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const INTERSECTION = {\n  OUTSIDE: -1, // Represents that an object is not contained within the frustum.\n  INTERSECTING: 0, // Represents that an object intersects one of the frustum's planes.\n  INSIDE: 1 // Represents that an object is fully within the frustum.\n} as const;\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\nimport {BoundingVolume} from './bounding-volume';\nimport {Vector3} from '@math.gl/core';\nimport {Plane} from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport class AxisAlignedBoundingBox implements BoundingVolume {\n  /** The center point of the bounding box. */\n  readonly center: Vector3;\n  /** The positive half diagonal of the bounding box. */\n  readonly halfDiagonal: Vector3;\n  /** The minimum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly minimum: Vector3;\n  /** The maximum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly maximum: Vector3;\n\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(\n    minimum: readonly number[] = [0, 0, 0],\n    maximum: readonly number[] = [0, 0, 0],\n    center?: readonly number[]\n  ) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone(): AxisAlignedBoundingBox {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right: AxisAlignedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane: Plane): number {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point: readonly number[]): number {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3, mat4} from '@math.gl/core';\n\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport {Plane} from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray} from '@math.gl/types';\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport type {BoundingVolume} from './bounding-volume';\nimport {BoundingSphere} from './bounding-sphere';\nimport type {Plane} from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport class OrientedBoundingBox implements BoundingVolume {\n  center: Vector3;\n  halfAxes: Matrix3;\n\n  /**\n   * An OrientedBoundingBox of some object is a closed and convex cuboid.\n   * It can provide a tighter bounding volume than\n   * `BoundingSphere` or `AxisAlignedBoundingBox` in many cases.\n   */\n  constructor(center?: Readonly<NumericArray>, halfAxes?: Readonly<NumericArray>);\n  constructor(\n    center: Readonly<NumericArray> = [0, 0, 0],\n    halfAxes: Readonly<NumericArray> = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  /** Returns an array with three halfSizes for the bounding box */\n  get halfSize(): number[] {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  /** Returns a quaternion describing the orientation of the bounding box */\n  get quaternion(): Quaternion {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  /**\n   * Create OrientedBoundingBox from quaternion based OBB,\n   */\n  fromCenterHalfSizeQuaternion(\n    center: number[],\n    halfSize: number[],\n    quaternion: number[]\n  ): OrientedBoundingBox {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  /** Duplicates a OrientedBoundingBox instance. */\n  clone(): OrientedBoundingBox {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  /** Compares the provided OrientedBoundingBox component wise and returns */\n  equals(right: OrientedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n  getBoundingSphere(result = new BoundingSphere()): BoundingSphere {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /** Determines which side of a plane the oriented bounding box is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /**\n   * Computes the estimated distance squared from the closest point\n   * on a bounding box to a point.\n   * See Geometric Tools for Computer Graphics 10.4.2\n   */\n  distanceSquaredTo(point: readonly number[]): number {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  /**\n   * The distances calculated by the vector from the center of the bounding box\n   * to position projected onto direction.\n   *\n   * - If you imagine the infinite number of planes with normal direction,\n   *   this computes the smallest distance to the closest and farthest planes\n   *   from `position` that intersect the bounding box.\n   *\n   * @param position The position to calculate the distance from.\n   * @param direction The direction from position.\n   * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n   * @returns Interval (array of length 2) with nearest and farthest distances\n   *   on the bounding box from position in direction.\n   */\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(\n    position: readonly number[],\n    direction: Vector3,\n    result: number[] = [-0, -0]\n  ): number[] {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transformation: readonly number[]): this {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform(): Matrix4 {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport {Plane} from './plane';\nimport type {BoundingVolume} from './bounding-volumes/bounding-volume';\nimport type {BoundingSphere} from './bounding-volumes/bounding-sphere';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n// const scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n/** A culling volume defined by planes. */\nexport class CullingVolume {\n  /**\n   * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n   * represents the case where the object bounding volume is entirely outside the culling volume.\n   */\n  static MASK_OUTSIDE = 0xffffffff;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume is entirely inside the culling volume.\n   */\n  static MASK_INSIDE = 0x00000000;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n   */\n  static MASK_INDETERMINATE = 0x7fffffff;\n\n  /** Array of clipping planes. */\n  readonly planes: Plane[];\n\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes: Plane[] = []) {\n    this.planes = planes;\n  }\n\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere: BoundingSphere): CullingVolume {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      // const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      // const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume: BoundingVolume): number {\n    // const planes = this.planes;\n    let intersect: number = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume: BoundingVolume, parentPlaneMask: number): number {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, NumericArray} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport class Plane {\n  readonly normal: Vector3;\n  distance: number;\n\n  constructor(normal: Readonly<NumericArray> = [0, 0, 1], distance: number = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal: Readonly<NumericArray>, distance: number): this {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point: Readonly<NumericArray>, normal: Readonly<NumericArray>): this {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from the general equation */\n  fromCoefficients(a: number, b: number, c: number, d: number): this {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  /** Duplicates a Plane instance. */\n  clone(): Plane {\n    return new Plane(this.normal, this.distance);\n  }\n\n  /** Compares the provided Planes by normal and distance */\n  equals(right: Plane): boolean {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point: Readonly<NumericArray>): number {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4: Readonly<NumericArray>): this {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  /** Projects a point onto the plane. */\n  projectPointOntoPlane(point: Readonly<NumericArray>, result: Vector3): Vector3;\n  projectPointOntoPlane(\n    point: Readonly<NumericArray>,\n    result?: readonly number[]\n  ): readonly number[];\n\n  projectPointOntoPlane(point: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const scratchPoint = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(scratchPoint);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return scratchPoint.subtract(scaledNormal).to(result);\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\nimport {Vector3, Vector2, Matrix4, assert, NumericArray} from '@math.gl/core';\nimport {CullingVolume} from './culling-volume';\nimport {Plane} from './plane';\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n\ntype PerspectiveOffCenterFrustumOptions = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n  near?: number;\n  far?: number;\n};\n\nexport class PerspectiveOffCenterFrustum {\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  left?: number;\n  private _left?: number;\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  right?: number;\n  private _right?: number;\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  top?: number;\n  private _top?: number;\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  bottom?: number;\n  private _bottom?: number;\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  near: number;\n  private _near: number;\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  far: number;\n  private _far: number;\n\n  private _cullingVolume = new CullingVolume([\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane()\n  ]);\n  private _perspectiveMatrix = new Matrix4();\n  private _infinitePerspective = new Matrix4();\n\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options: PerspectiveOffCenterFrustumOptions = {}) {\n    const {near = 1.0, far = 500000000.0} = options;\n\n    this.left = options.left;\n    this._left = undefined;\n\n    this.right = options.right;\n    this._right = undefined;\n\n    this.top = options.top;\n    this._top = undefined;\n\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n\n    this.near = near;\n    this._near = near;\n\n    this.far = far;\n    this._far = far;\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone(): PerspectiveOffCenterFrustum {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other: PerspectiveOffCenterFrustum): boolean {\n    return (\n      other &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      this.right === other.right &&\n      this.left === other.left &&\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.near === other.near &&\n      this.far === other.far\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix(): Matrix4 {\n    this._update();\n    return this._perspectiveMatrix;\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix(): Matrix4 {\n    this._update();\n    return this._infinitePerspective;\n  }\n\n  /**\n   * Creates a culling volume for this frustum.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position: Readonly<NumericArray>,\n    /** A Vector3 defines the view direction. */\n    direction: Readonly<NumericArray>,\n    /** A Vector3 defines the up direction. */\n    up: Readonly<NumericArray>\n  ): CullingVolume {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n\n    const planes = this._cullingVolume.planes;\n\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n\n    const nearCenter = scratchPlaneNearCenter\n      .copy(direction)\n      .multiplyByScalar(this.near)\n      .add(position);\n\n    const farCenter = scratchPlaneFarCenter\n      .copy(direction)\n      .multiplyByScalar(this.far)\n      .add(position);\n\n    let normal = scratchPlaneNormal;\n\n    // Left plane computation\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n\n    planes[0].fromPointNormal(position, normal);\n\n    // Right plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.right)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up)\n      .negate();\n\n    planes[1].fromPointNormal(position, normal);\n\n    // Bottom plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.bottom)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right)\n      .negate();\n\n    planes[2].fromPointNormal(position, normal);\n\n    // Top plane computation\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n\n    planes[3].fromPointNormal(position, normal);\n\n    normal = new Vector3().copy(direction);\n\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n\n    // Far plane computation\n    normal.negate();\n\n    planes[5].fromPointNormal(farCenter, normal);\n\n    return this._cullingVolume;\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth: number,\n    /** The height of the drawing buffer. */\n    drawingBufferHeight: number,\n    /** The distance to the near plane in meters. */\n    distance: number,\n    /** The object onto which to store the result. */\n    result: Vector2\n  ): Vector2 {\n    this._update();\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  private _update() {\n    assert(\n      Number.isFinite(this.right) &&\n        Number.isFinite(this.left) &&\n        Number.isFinite(this.top) &&\n        Number.isFinite(this.bottom) &&\n        Number.isFinite(this.near) &&\n        Number.isFinite(this.far)\n    );\n    // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n\n    const {top, bottom, right, left, near, far} = this;\n\n    if (\n      top !== this._top ||\n      bottom !== this._bottom ||\n      left !== this._left ||\n      right !== this._right ||\n      near !== this._near ||\n      far !== this._far\n    ) {\n      assert(\n        this.near > 0 && this.near < this.far,\n        'near must be greater than zero and less than far.'\n      );\n\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\nimport {NumericArray} from '@math.gl/types';\nimport {assert, Matrix4, Vector2} from '@math.gl/core';\nimport {PerspectiveOffCenterFrustum} from './perspective-off-center-frustum';\nimport {CullingVolume} from './culling-volume';\n\nconst defined = (val: unknown) => val !== null && typeof val !== 'undefined';\n\ntype PerspectiveFrustumOptions = {\n  /** The angle of the field of view (FOV), in radians. */\n  fov?: number;\n  /** The aspect ratio of the frustum's width to it's height. */\n  aspectRatio?: number;\n  /** The distance of the near plane. */\n  near?: number;\n  /** The distance of the far plane. */\n  far?: number;\n  /** The offset in the x direction. */\n  xOffset?: number;\n  /** The offset in the y direction. */\n  yOffset?: number;\n};\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n *\n * @example\n * var frustum = new PerspectiveFrustum({\n *     fov : Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nexport class PerspectiveFrustum {\n  private _offCenterFrustum = new PerspectiveOffCenterFrustum();\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   */\n  fov?: number;\n  private _fov: number;\n  private _fovy: number;\n  private _sseDenominator: number;\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   */\n  aspectRatio?: number;\n  private _aspectRatio: number;\n  /**\n   * The distance of the near plane.\n   * @default 1.0\n   */\n  near: number;\n  private _near: number;\n  /**\n   * The distance of the far plane.\n   * @default 500000000.0\n   */\n  far: number;\n  private _far: number;\n  /**\n   * Offsets the frustum in the x direction.\n   * @default 0.0\n   */\n  xOffset: number;\n  private _xOffset: number;\n  /**\n   * Offsets the frustum in the y direction.\n   * @default 0.0\n   */\n  yOffset: number;\n  private _yOffset: number;\n\n  constructor(options: PerspectiveFrustumOptions = {}) {\n    const {fov, aspectRatio, near = 1.0, far = 500000000.0, xOffset = 0.0, yOffset = 0.0} = options;\n\n    this.fov = fov;\n    this.aspectRatio = aspectRatio;\n    this.near = near;\n    this.far = far;\n    this.xOffset = xOffset;\n    this.yOffset = yOffset;\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveFrustum instance.\n   */\n  clone(): PerspectiveFrustum {\n    return new PerspectiveFrustum({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other: PerspectiveFrustum): boolean {\n    if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n      return false;\n    }\n\n    this._update();\n    other._update();\n\n    return (\n      this.fov === other.fov &&\n      this.aspectRatio === other.aspectRatio &&\n      this.near === other.near &&\n      this.far === other.far &&\n      this._offCenterFrustum.equals(other._offCenterFrustum)\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view this.\n   */\n  get projectionMatrix(): Matrix4 {\n    this._update();\n    return this._offCenterFrustum.projectionMatrix;\n  }\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   */\n  get infiniteProjectionMatrix(): Matrix4 {\n    this._update();\n    return this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   */\n  get fovy(): number {\n    this._update();\n    return this._fovy;\n  }\n\n  /**\n   * @private\n   */\n  get sseDenominator(): number {\n    this._update();\n    return this._sseDenominator;\n  }\n\n  /**\n   * Creates a culling volume for this this.ion.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the this.\n   * var cullingVolume = this.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * var intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position: Readonly<NumericArray>,\n    /** A Vector3 defines the view direction. */\n    direction: Readonly<NumericArray>,\n    /** A Vector3 defines the up direction. */\n    up: Readonly<NumericArray>\n  ): CullingVolume {\n    this._update();\n    return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * var position = camera.position;\n   * var direction = camera.direction;\n   * var toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * var toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * var distance = Vector3.magnitude(toCenterProj);\n   * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth: number,\n    /** The height of the drawing buffer. */\n    drawingBufferHeight: number,\n    /** The distance to the near plane in meters. */\n    distance: number,\n    /** The object onto which to store the result. */\n    result?: Vector2\n  ): Vector2 {\n    this._update();\n    return this._offCenterFrustum.getPixelDimensions(\n      drawingBufferWidth,\n      drawingBufferHeight,\n      distance,\n      result || new Vector2()\n    );\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  private _update(): void {\n    assert(\n      Number.isFinite(this.fov) &&\n        Number.isFinite(this.aspectRatio) &&\n        Number.isFinite(this.near) &&\n        Number.isFinite(this.far)\n    );\n    // 'fov, aspectRatio, near, or far parameters are not set.'\n\n    const f = this._offCenterFrustum;\n\n    if (\n      this.fov !== this._fov ||\n      this.aspectRatio !== this._aspectRatio ||\n      this.near !== this._near ||\n      this.far !== this._far ||\n      this.xOffset !== this._xOffset ||\n      this.yOffset !== this._yOffset\n    ) {\n      assert(this.fov >= 0 && this.fov < Math.PI);\n      // throw new DeveloperError('fov must be in the range [0, PI).');\n\n      assert(this.aspectRatio > 0);\n      // throw new DeveloperError('aspectRatio must be positive.');\n\n      assert(this.near >= 0 && this.near < this.far);\n      // throw new DeveloperError('near must be greater than zero and less than far.');\n\n      this._aspectRatio = this.aspectRatio;\n      this._fov = this.fov;\n      this._fovy =\n        this.aspectRatio <= 1\n          ? this.fov\n          : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;\n      this._near = this.near;\n      this._far = this.far;\n      this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);\n      this._xOffset = this.xOffset;\n      this._yOffset = this.yOffset;\n\n      f.top = this.near * Math.tan(0.5 * this._fovy);\n      f.bottom = -f.top;\n      f.right = this.aspectRatio * f.top;\n      f.left = -f.right;\n      f.near = this.near;\n      f.far = this.far;\n\n      f.right += this.xOffset;\n      f.left += this.xOffset;\n      f.top += this.yOffset;\n      f.bottom += this.yOffset;\n    }\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport {BoundingSphere} from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\n// const volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport function makeBoundingSphereFromPoints(\n  positions: number[][],\n  result: BoundingSphere = new BoundingSphere()\n): BoundingSphere {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport {computeEigenDecomposition} from './compute-eigen-decomposition';\nimport {OrientedBoundingBox} from '../bounding-volumes/oriented-bounding-box';\nimport {AxisAlignedBoundingBox} from '../bounding-volumes/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(\n  positions: number[][],\n  result: OrientedBoundingBox = new OrientedBoundingBox()\n): OrientedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    scratchVector2.copy(position);\n\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center.copy(v1).add(v2).add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n\n  return result;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions: readonly number[][],\n  result: AxisAlignedBoundingBox = new AxisAlignedBoundingBox()\n): AxisAlignedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["import_core", "scratchVector", "scratchVector2", "import_core", "import_core", "import_core", "scratchNormal", "import_core", "scratchPlaneNormal", "import_core", "import_core", "import_core", "import_core", "scratchVector2", "scratchVector3"]
}
