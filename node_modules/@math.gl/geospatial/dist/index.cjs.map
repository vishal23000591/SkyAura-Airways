{
  "version": 3,
  "sources": ["../src/index.ts", "../src/ellipsoid/ellipsoid.ts", "../src/constants.ts", "../src/type-utils.ts", "../src/ellipsoid/helpers/ellipsoid-transform.ts", "../src/ellipsoid/helpers/scale-to-geodetic-surface.ts"],
  "sourcesContent": ["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {Ellipsoid} from './ellipsoid/ellipsoid';\nexport {isWGS84} from './type-utils';\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4, assert, equals, _MathUtils, NumericArray, vec3} from '@math.gl/core';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport type {AxisDirection} from './helpers/ellipsoid-transform';\nimport {localFrameToFixedFrame} from './helpers/ellipsoid-transform';\nimport {scaleToGeodeticSurface} from './helpers/scale-to-geodetic-surface';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result?: number[]): number[];\n\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result = new Matrix4()\n  ) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(\n    cartographic: Readonly<NumericArray>,\n    result: NumArray\n  ): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nexport const WGS84_RADIUS_X = 6378137.0;\nexport const WGS84_RADIUS_Y = 6378137.0;\nexport const WGS84_RADIUS_Z = 6356752.3142451793;\n\n// Pre-calculated ellipsoid defaults to avoid utils depending on `ellipsoid.js`\n\nexport const WGS84_CONSTANTS = {\n  radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],\n  radiiSquared: [\n    WGS84_RADIUS_X * WGS84_RADIUS_X,\n    WGS84_RADIUS_Y * WGS84_RADIUS_Y,\n    WGS84_RADIUS_Z * WGS84_RADIUS_Z\n  ],\n  oneOverRadii: [1.0 / WGS84_RADIUS_X, 1.0 / WGS84_RADIUS_Y, 1.0 / WGS84_RADIUS_Z],\n  oneOverRadiiSquared: [\n    1.0 / (WGS84_RADIUS_X * WGS84_RADIUS_X),\n    1.0 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),\n    1.0 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)\n  ],\n  maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),\n  centerToleranceSquared: 1e-1 // EPSILON1;\n};\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport type {NumericArray} from '@math.gl/core';\nimport {Vector3, toRadians, toDegrees, config} from '@math.gl/core';\nimport {WGS84_CONSTANTS} from './constants';\n\ntype LngLatHeightObject = {\n  longitude: number;\n  latitude: number;\n  height: number;\n};\n\ntype XYZObject = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Cartographic = LngLatHeightObject | XYZObject | NumericArray;\n\nfunction identity(x: number): number {\n  return x;\n}\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic: Readonly<Cartographic>): number[];\nexport function fromCartographic<NumArrayT>(\n  cartographic: Readonly<Cartographic>,\n  result: NumArrayT,\n  map?: (x: number) => number\n): NumArrayT;\nexport function fromCartographic(\n  cartographic: Readonly<Cartographic>,\n  result = [] as number[],\n  map = identity\n): number[] {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\n\nexport function fromCartographicToRadians(\n  cartographic: Readonly<Cartographic>,\n  result?: number[]\n): number[];\nexport function fromCartographicToRadians<TArray>(\n  cartographic: Readonly<Cartographic>,\n  result: TArray\n): TArray;\nexport function fromCartographicToRadians(\n  cartographic: Readonly<Cartographic>,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\n\nexport function fromCartographicToDegrees(\n  cartographic: Readonly<Cartographic>,\n  result?: number[]\n): number[];\nexport function fromCartographicToDegrees<TArray>(\n  cartographic: Readonly<Cartographic>,\n  result: TArray\n): TArray;\nexport function fromCartographicToDegrees(\n  cartographic: Readonly<Cartographic>,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\n\nexport function toCartographic<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T,\n  map: (x: number) => number = identity\n): T {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\n\nexport function toCartographicFromDegrees<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: Readonly<NumericArray>): boolean {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\nimport {NumericArray} from '@math.gl/types';\nimport {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nimport type {Ellipsoid} from '../ellipsoid';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\nexport type AxisDirection = 'up' | 'down' | 'north' | 'east' | 'south' | 'west';\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME: Record<\n  AxisDirection,\n  Partial<Record<AxisDirection, AxisDirection>>\n> = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n} as const;\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n} as const;\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport function localFrameToFixedFrame(\n  ellipsoid: Ellipsoid,\n  firstAxis: AxisDirection,\n  secondAxis: AxisDirection,\n  thirdAxis: AxisDirection,\n  cartesianOrigin: Readonly<NumericArray>,\n  result: number[]\n): number[] {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector: Vector3;\n  let secondAxisVector: Vector3;\n  let thirdAxisVector: Vector3;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n", "// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable */\nimport {Vector3, _MathUtils} from '@math.gl/core';\nimport type {Ellipsoid} from '../ellipsoid';\n\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport function scaleToGeodeticSurface(\n  cartesian: number[],\n  ellipsoid: Ellipsoid,\n  result: number[] = []\n): number[] {\n  const {oneOverRadii, oneOverRadiiSquared, centerToleranceSquared} = ellipsoid;\n\n  scratchVector.from(cartesian);\n\n  const positionX = scratchVector.x;\n  const positionY = scratchVector.y;\n  const positionZ = scratchVector.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(\n    intersection.x * oneOverRadiiSquaredX * 2.0,\n    intersection.y * oneOverRadiiSquaredY * 2.0,\n    intersection.z * oneOverRadiiSquaredZ * 2.0\n  );\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = ((1.0 - ratio) * scratchVector.len()) / (0.5 * gradient.len());\n  let correction = 0.0;\n\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "equalsEpsilon", "import_core", "scratchVector", "scratchVector"]
}
