declare const _default: "#version 300 es\n#define SHADER_NAME raster-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin float instanceElevations;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\n\nin vec3 instancePickingColors;\n\n// Result\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  // Rather than positioning using attribute, layout pixel grid using gl_InstanceID\n  vec2 tileOrigin = column.offset.xy;\n  float scale = column.widthScale; // Re-use widthScale prop to pass cell scale\n\n  int yIndex = - (gl_InstanceID / BLOCK_WIDTH);\n  int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);\n\n  // Avoid precision issues by applying 0.5 offset here, rather than when laying out vertices\n  vec2 cellCenter = scale * vec2(float(xIndex) + 0.5, float(yIndex) - 0.5);\n\n  vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\n\n  // if alpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float cellWidth = column.coverage * scale;\n\n  // Get position directly from quadbin, rather than projecting\n  // Important to set geometry.position before using project_ methods below\n  // as geometry.worldPosition is not set (we don't know our lat/long)\n  geometry.position = vec4(tileOrigin, 0.0, 1.0);\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    geometry.position.xyz -= project.commonOrigin;\n  }\n\n  // Important to apply after tileOrigin & commonOrigin as they are large values which often\n  // cancel and thus cellCenter precision is lost if applied first.\n  geometry.position.xy += cellCenter;\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar geometry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n  // calculate stroke offset\n  float strokeOffsetRatio = 1.0;\n\n  if (column.extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n  } else if (column.stroked) {\n    float halfOffset = project_pixel_size(column.widthScale) / cellWidth;\n    if (column.isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n\n  geometry.pickingColor = instancePickingColors;\n\n  // Cell coordinates centered on origin\n  vec2 base = positions.xy * scale * strokeOffsetRatio * column.coverage * shouldRender;\n  vec3 cell = vec3(base, project_size(elevation));\n  DECKGL_FILTER_SIZE(cell, geometry);\n\n  geometry.position.xyz += cell;\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n\n  geometry.normal = project_normal(normals);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Light calculations\n  if (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n  }\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
export default _default;
//# sourceMappingURL=raster-layer-vertex.glsl.d.ts.map