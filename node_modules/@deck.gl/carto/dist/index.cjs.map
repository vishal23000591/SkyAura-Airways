{
  "version": 3,
  "sources": ["../src/index.ts", "../src/layers/cluster-tile-layer.ts", "../src/layers/cluster-utils.ts", "../src/utils.ts", "../src/constants.ts", "../src/layers/quadbin-tileset-2d.ts", "../src/layers/quadbin-utils.ts", "../src/layers/schema/fast-pbf.ts", "../src/layers/schema/carto-tile.ts", "../src/layers/schema/carto-spatial-tile.ts", "../src/layers/schema/tile-loader-utils.ts", "../src/layers/schema/spatialjson-utils.ts", "../src/layers/schema/carto-spatial-tile-loader.ts", "../src/layers/utils.ts", "../src/layers/h3-tile-layer.ts", "../src/layers/h3-tileset-2d.ts", "../src/layers/spatial-index-tile-layer.ts", "../src/layers/heatmap-tile-layer.ts", "../src/layers/heatmap.ts", "../src/layers/post-process-utils.ts", "../src/layers/quadbin-tile-layer.ts", "../src/layers/quadbin-layer.ts", "../src/layers/point-label-layer.ts", "../src/layers/raster-tile-layer.ts", "../src/layers/raster-layer.ts", "../src/layers/raster-layer-vertex.glsl.ts", "../src/layers/schema/carto-raster-tile.ts", "../src/layers/schema/carto-raster-tile-loader.ts", "../src/layers/vector-tile-layer.ts", "../src/layers/schema/carto-properties-tile.ts", "../src/layers/schema/carto-properties-tile-loader.ts", "../src/layers/schema/carto-vector-tile-loader.ts", "../src/layers/label-utils.ts", "../src/basemap.ts", "../src/style/color-bins-style.ts", "../src/style/palette.ts", "../src/style/utils.ts", "../src/style/color-categories-style.ts", "../src/style/color-continuous-style.ts", "../src/api/fetch-map.ts", "../src/api/parse-map.ts", "../src/api/layer-map.ts", "../src/api/basemap.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// CARTO Layers\nimport {default as ClusterTileLayer} from './layers/cluster-tile-layer';\nimport {default as H3TileLayer} from './layers/h3-tile-layer';\nimport {default as HeatmapTileLayer} from './layers/heatmap-tile-layer';\nimport {default as PointLabelLayer} from './layers/point-label-layer';\nimport {default as QuadbinTileLayer} from './layers/quadbin-tile-layer';\nimport {default as RasterTileLayer} from './layers/raster-tile-layer';\nimport {default as VectorTileLayer} from './layers/vector-tile-layer';\n\n// Exports for playground/bindings\nconst CARTO_LAYERS = {\n  ClusterTileLayer,\n  H3TileLayer,\n  HeatmapTileLayer,\n  PointLabelLayer,\n  QuadbinTileLayer,\n  RasterTileLayer,\n  VectorTileLayer\n};\nexport {\n  CARTO_LAYERS,\n  ClusterTileLayer,\n  H3TileLayer,\n  HeatmapTileLayer,\n  PointLabelLayer,\n  QuadbinTileLayer,\n  RasterTileLayer,\n  VectorTileLayer\n};\n\n// Internal Layers\nexport {default as _QuadbinLayer} from './layers/quadbin-layer';\nexport {default as _RasterLayer} from './layers/raster-layer';\nexport {default as _SpatialIndexTileLayer} from './layers/spatial-index-tile-layer';\n\n// Types\nexport type {ClusterTileLayerProps} from './layers/cluster-tile-layer';\nexport type {H3TileLayerProps} from './layers/h3-tile-layer';\nexport type {HeatmapTileLayerProps} from './layers/heatmap-tile-layer';\nexport type {PointLabelLayerProps} from './layers/point-label-layer';\nexport type {QuadbinLayerProps} from './layers/quadbin-layer';\nexport type {QuadbinTileLayerProps} from './layers/quadbin-tile-layer';\nexport type {RasterLayerProps} from './layers/raster-layer';\nexport type {RasterTileLayerProps} from './layers/raster-tile-layer';\nexport type {SpatialIndexTileLayerProps} from './layers/spatial-index-tile-layer';\nexport type {VectorTileLayerProps} from './layers/vector-tile-layer';\n\n// Helpers\nexport {\n  default as BASEMAP,\n  GOOGLE_BASEMAPS as _GOOGLE_BASEMAPS,\n  getStyleUrl as _getStyleUrl,\n  fetchStyle as _fetchStyle,\n  applyLayerGroupFilters as _applyLayerGroupFilters,\n  STYLE_LAYER_GROUPS as _STYLE_LAYER_GROUPS\n} from './basemap';\nexport {default as colorBins} from './style/color-bins-style';\nexport {default as colorCategories} from './style/color-categories-style';\nexport {default as colorContinuous} from './style/color-continuous-style';\nexport {fetchMap} from './api/index';\nexport {fetchBasemapProps} from './api/basemap';\nexport type {\n  FetchMapOptions,\n  FetchMapResult,\n  Basemap as _Basemap,\n  MapLibreBasemap as _MapLibreBasemap,\n  GoogleBasemap as _GoogleBasemap\n} from './api/index';\n\n// TODO(v10): Consider removing re-exports from '@carto/api-client' below.\n\nimport {\n  boundaryQuerySource,\n  boundaryTableSource,\n  h3QuerySource,\n  h3TableSource,\n  h3TilesetSource,\n  rasterSource,\n  quadbinQuerySource,\n  quadbinTableSource,\n  quadbinTilesetSource,\n  vectorQuerySource,\n  vectorTableSource,\n  vectorTilesetSource\n} from '@carto/api-client';\n\nexport const CARTO_SOURCES = {\n  boundaryQuerySource,\n  boundaryTableSource,\n  h3QuerySource,\n  h3TableSource,\n  h3TilesetSource,\n  rasterSource,\n  quadbinQuerySource,\n  quadbinTableSource,\n  quadbinTilesetSource,\n  vectorQuerySource,\n  vectorTableSource,\n  vectorTilesetSource\n};\n\nexport {\n  boundaryQuerySource,\n  boundaryTableSource,\n  h3QuerySource,\n  h3TableSource,\n  h3TilesetSource,\n  rasterSource,\n  quadbinQuerySource,\n  quadbinTableSource,\n  quadbinTilesetSource,\n  vectorQuerySource,\n  vectorTableSource,\n  vectorTilesetSource,\n  query,\n  CartoAPIError,\n  SOURCE_DEFAULTS\n} from '@carto/api-client';\n\nexport type {\n  GeojsonResult,\n  JsonResult,\n  TilejsonResult,\n  SourceOptions,\n  QuerySourceOptions,\n  TableSourceOptions,\n  TilesetSourceOptions,\n  BoundaryQuerySourceOptions,\n  BoundaryTableSourceOptions,\n  H3QuerySourceOptions,\n  H3TableSourceOptions,\n  H3TilesetSourceOptions,\n  RasterSourceOptions,\n  QuadbinQuerySourceOptions,\n  QuadbinTableSourceOptions,\n  QuadbinTilesetSourceOptions,\n  VectorQuerySourceOptions,\n  VectorTableSourceOptions,\n  VectorTilesetSourceOptions,\n  QueryParameters\n} from '@carto/api-client';\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-shadow */\n\nimport {GeoJsonLayer, GeoJsonLayerProps} from '@deck.gl/layers';\nimport {\n  TileLayer,\n  _Tile2DHeader as Tile2DHeader,\n  TileLayerProps,\n  TileLayerPickingInfo\n} from '@deck.gl/geo-layers';\nimport {registerLoaders} from '@loaders.gl/core';\nimport {binaryToGeojson} from '@loaders.gl/gis';\nimport {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport type {Feature, Geometry} from 'geojson';\n\nimport {\n  Accessor,\n  DefaultProps,\n  CompositeLayer,\n  _deepEqual as deepEqual,\n  GetPickingInfoParams,\n  Layer,\n  LayersList,\n  PickingInfo\n} from '@deck.gl/core';\n\nimport {\n  aggregateTile,\n  ClusteredFeaturePropertiesT,\n  clustersToBinary,\n  computeAggregationStats,\n  extractAggregationProperties,\n  ParsedQuadbinCell,\n  ParsedQuadbinTile\n} from './cluster-utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport {getQuadbinPolygon} from './quadbin-utils';\nimport CartoSpatialTileLoader from './schema/carto-spatial-tile-loader';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport type {TilejsonResult} from '@carto/api-client';\n\nregisterLoaders([CartoSpatialTileLoader]);\n\nconst defaultProps: DefaultProps<ClusterTileLayerProps> = {\n  data: TilejsonPropType,\n  clusterLevel: {type: 'number', value: 5, min: 1},\n  getPosition: {\n    type: 'accessor',\n    value: ({id}) => getQuadbinPolygon(id, 0.5).slice(2, 4) as [number, number]\n  },\n  getWeight: {type: 'accessor', value: 1},\n  refinementStrategy: 'no-overlap',\n  tileSize: DEFAULT_TILE_SIZE\n};\n\nexport type ClusterTileLayerPickingInfo<FeaturePropertiesT = {}> = TileLayerPickingInfo<\n  ParsedQuadbinTile<FeaturePropertiesT>,\n  PickingInfo<Feature<Geometry, FeaturePropertiesT>>\n>;\n\n/** All properties supported by ClusterTileLayer. */\nexport type ClusterTileLayerProps<FeaturePropertiesT = unknown> =\n  _ClusterTileLayerProps<FeaturePropertiesT> &\n    Omit<TileLayerProps<ParsedQuadbinTile<FeaturePropertiesT>>, 'data'>;\n\n/** Properties added by ClusterTileLayer. */\ntype _ClusterTileLayerProps<FeaturePropertiesT> = Omit<\n  GeoJsonLayerProps<ClusteredFeaturePropertiesT<FeaturePropertiesT>>,\n  'data'\n> & {\n  data: null | TilejsonResult | Promise<TilejsonResult>;\n\n  /**\n   * The number of aggregation levels to cluster cells by. Larger values increase\n   * the clustering radius, with an increment of `clusterLevel` doubling the radius.\n   *\n   * @default 5\n   */\n  clusterLevel?: number;\n\n  /**\n   * The (average) position of points in a cell used for clustering.\n   * If not supplied the center of the quadbin cell is used.\n   *\n   * @default cell center\n   */\n  getPosition?: Accessor<ParsedQuadbinCell<FeaturePropertiesT>, [number, number]>;\n\n  /**\n   * The weight of each cell used for clustering.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<ParsedQuadbinCell<FeaturePropertiesT>, number>;\n};\n\nclass ClusterGeoJsonLayer<\n  FeaturePropertiesT extends {} = {},\n  ExtraProps extends {} = {}\n> extends TileLayer<\n  ParsedQuadbinTile<FeaturePropertiesT>,\n  ExtraProps & Required<_ClusterTileLayerProps<FeaturePropertiesT>>\n> {\n  static layerName = 'ClusterGeoJsonLayer';\n  static defaultProps = defaultProps;\n  state!: TileLayer<FeaturePropertiesT>['state'] & {\n    data: BinaryFeatureCollection;\n    clusterIds: bigint[];\n    hoveredFeatureId: bigint | number | null;\n    highlightColor: number[];\n    aggregationCache: WeakMap<any, Map<number, ClusteredFeaturePropertiesT<FeaturePropertiesT>[]>>;\n  };\n\n  initializeState() {\n    super.initializeState();\n    this.state.aggregationCache = new WeakMap();\n  }\n\n  // eslint-disable-next-line max-statements\n  renderLayers(): Layer | null | LayersList {\n    const visibleTiles = this.state.tileset?.tiles.filter((tile: Tile2DHeader) => {\n      return tile.isLoaded && tile.content && this.state.tileset!.isTileVisible(tile);\n    }) as Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT>>[];\n    if (!visibleTiles?.length) {\n      return null;\n    }\n    visibleTiles.sort((a, b) => b.zoom - a.zoom);\n\n    const {zoom} = this.context.viewport;\n    const {clusterLevel, getPosition, getWeight} = this.props;\n    const {aggregationCache} = this.state;\n\n    const properties = extractAggregationProperties(visibleTiles[0]);\n    const data = [] as ClusteredFeaturePropertiesT<FeaturePropertiesT>[];\n    let needsUpdate = false;\n    for (const tile of visibleTiles) {\n      // Calculate aggregation based on viewport zoom\n      const overZoom = Math.round(zoom - tile.zoom);\n      const aggregationLevels = Math.round(clusterLevel) - overZoom;\n      let tileAggregationCache = aggregationCache.get(tile.content);\n      if (!tileAggregationCache) {\n        tileAggregationCache = new Map();\n        aggregationCache.set(tile.content, tileAggregationCache);\n      }\n      const didAggregate = aggregateTile(\n        tile,\n        tileAggregationCache,\n        aggregationLevels,\n        properties,\n        getPosition,\n        getWeight\n      );\n      needsUpdate ||= didAggregate;\n      data.push(...tileAggregationCache.get(aggregationLevels)!);\n    }\n\n    data.sort((a, b) => Number(b.count - a.count));\n\n    const clusterIds = data?.map((tile: any) => tile.id);\n    needsUpdate ||= !deepEqual(clusterIds, this.state.clusterIds, 1);\n    this.setState({clusterIds});\n\n    if (needsUpdate) {\n      const stats = computeAggregationStats(data, properties);\n      const binaryData = clustersToBinary(data);\n      binaryData.points.attributes = {stats};\n      this.setState({data: binaryData});\n    }\n\n    const props = {\n      ...this.props,\n      id: 'clusters',\n      data: this.state.data,\n      dataComparator: (data?: BinaryFeatureCollection, oldData?: BinaryFeatureCollection) => {\n        const newIds = data?.points?.properties?.map((tile: any) => tile.id);\n        const oldIds = oldData?.points?.properties?.map((tile: any) => tile.id);\n        return deepEqual(newIds, oldIds, 1);\n      }\n    } as GeoJsonLayerProps<ClusteredFeaturePropertiesT<FeaturePropertiesT>>;\n\n    return new GeoJsonLayer(this.getSubLayerProps(props));\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ClusterTileLayerPickingInfo<FeaturePropertiesT> {\n    const info = params.info as TileLayerPickingInfo<ParsedQuadbinTile<FeaturePropertiesT>>;\n\n    if (info.index !== -1) {\n      const {data} = params.sourceLayer!.props;\n      info.object = binaryToGeojson(data as BinaryFeatureCollection, {\n        globalFeatureId: info.index\n      }) as Feature;\n    }\n\n    return info;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  filterSubLayer() {\n    return true;\n  }\n}\n\n// Adapter layer around ClusterLayer that converts tileJSON into TileLayer API\nexport default class ClusterTileLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_ClusterTileLayerProps<FeaturePropertiesT>>> {\n  static layerName = 'ClusterTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme: 'quadbin'}\n    });\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, maxresolution: maxZoom} = tileJSON;\n    return [\n      // @ts-ignore\n      new ClusterGeoJsonLayer(this.props, {\n        id: `cluster-geojson-layer-${this.props.id}`,\n        data,\n        // TODO: Tileset2D should be generic over TileIndex type\n        TilesetClass: QuadbinTileset2D as any,\n        maxZoom,\n        loadOptions: this.getLoadOptions()\n      })\n    ];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {cellToParent} from 'quadbin';\nimport {_Tile2DHeader as Tile2DHeader} from '@deck.gl/geo-layers';\nimport {Accessor, log} from '@deck.gl/core';\nimport {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport {createBinaryPointFeature, createEmptyBinary} from '../utils';\n\nexport type Aggregation = 'any' | 'average' | 'count' | 'min' | 'max' | 'sum';\nexport type AggregationProperties<FeaturePropertiesT> = {\n  aggregation: Aggregation;\n  name: keyof FeaturePropertiesT;\n}[];\nexport type ClusteredFeaturePropertiesT<FeaturePropertiesT> = FeaturePropertiesT & {\n  id: bigint;\n  count: number;\n  position: [number, number];\n};\nexport type ParsedQuadbinCell<FeaturePropertiesT> = {id: bigint; properties: FeaturePropertiesT};\nexport type ParsedQuadbinTile<FeaturePropertiesT> = ParsedQuadbinCell<FeaturePropertiesT>[];\n\n/**\n * Aggregates tile by specified properties, caching result in tile.userData\n *\n * @returns true if data was aggregated, false if cache used\n */\nexport function aggregateTile<FeaturePropertiesT>(\n  tile: Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT>>,\n  tileAggregationCache: Map<number, ClusteredFeaturePropertiesT<FeaturePropertiesT>[]>,\n  aggregationLevels: number,\n  properties: AggregationProperties<FeaturePropertiesT> = [],\n  getPosition: Accessor<ParsedQuadbinCell<FeaturePropertiesT>, [number, number]>,\n  getWeight: Accessor<ParsedQuadbinCell<FeaturePropertiesT>, number>\n): boolean {\n  if (!tile.content) return false;\n\n  // Aggregate on demand and cache result\n  if (!tile.userData) tile.userData = {};\n  const cell0 = tileAggregationCache.get(aggregationLevels)?.[0];\n  if (cell0) {\n    // Have already aggregated this tile\n    if (properties.every(property => property.name in cell0)) {\n      // Use cached result\n      return false;\n    }\n\n    // Aggregated properties have changed, re-aggregate\n    tileAggregationCache.clear();\n  }\n\n  const out: Record<number, any> = {};\n  for (const cell of tile.content) {\n    let id = cell.id;\n    const position = typeof getPosition === 'function' ? getPosition(cell, {} as any) : getPosition;\n\n    // Aggregate by parent rid\n    for (let i = 0; i < aggregationLevels - 1; i++) {\n      id = cellToParent(id);\n    }\n\n    // Unfortunately TS doesn't support Record<bigint, any>\n    // https://github.com/microsoft/TypeScript/issues/46395\n    const parentId = Number(id);\n    if (!(parentId in out)) {\n      out[parentId] = {id, count: 0, position: [0, 0]};\n      for (const {name, aggregation} of properties) {\n        if (aggregation === 'any') {\n          // Just pick first value for ANY\n          out[parentId][name] = cell.properties[name];\n        } else {\n          out[parentId][name] = 0;\n        }\n      }\n    }\n    // Layout props\n    const prevTotalW = out[parentId].count;\n    out[parentId].count += typeof getWeight === 'function' ? getWeight(cell, {} as any) : getWeight;\n\n    const totalW = out[parentId].count;\n    const W = totalW - prevTotalW;\n    out[parentId].position[0] = (prevTotalW * out[parentId].position[0] + W * position[0]) / totalW;\n    out[parentId].position[1] = (prevTotalW * out[parentId].position[1] + W * position[1]) / totalW;\n\n    // Re-aggregate other properties so clusters can be styled\n    for (const {name, aggregation} of properties) {\n      const prevValue = out[parentId][name];\n      const value = cell.properties[name] as number;\n      if (aggregation === 'average') {\n        out[parentId][name] = (prevTotalW * prevValue + W * value) / totalW;\n      } else if (aggregation === 'count' || aggregation === 'sum') {\n        out[parentId][name] = prevValue + value;\n      } else if (aggregation === 'max') {\n        out[parentId][name] = Math.max(prevValue, value);\n      } else if (aggregation === 'min') {\n        out[parentId][name] = Math.min(prevValue, value);\n      }\n    }\n  }\n\n  tileAggregationCache.set(aggregationLevels, Object.values(out));\n  return true;\n}\n\nexport function extractAggregationProperties<FeaturePropertiesT extends {}>(\n  tile: Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT>>\n): AggregationProperties<FeaturePropertiesT> {\n  const properties: AggregationProperties<FeaturePropertiesT> = [];\n  const validAggregations: Aggregation[] = ['any', 'average', 'count', 'min', 'max', 'sum'];\n  for (const name of Object.keys(tile.content![0].properties)) {\n    let aggregation = name.split('_').pop()!.toLowerCase() as Aggregation;\n    if (!validAggregations.includes(aggregation)) {\n      log.warn(`No valid aggregation present in ${name} property`)();\n      aggregation = 'any';\n    }\n    properties.push({name: name as keyof FeaturePropertiesT, aggregation});\n  }\n\n  return properties;\n}\n\nexport function computeAggregationStats<FeaturePropertiesT>(\n  data: ClusteredFeaturePropertiesT<FeaturePropertiesT>[],\n  properties: AggregationProperties<FeaturePropertiesT>\n) {\n  const stats = {} as Record<keyof FeaturePropertiesT, {min: number; max: number}>;\n  for (const {name, aggregation} of properties) {\n    stats[name] = {min: Infinity, max: -Infinity};\n    if (aggregation !== 'any') {\n      for (const d of data) {\n        stats[name].min = Math.min(stats[name].min, d[name] as number);\n        stats[name].max = Math.max(stats[name].max, d[name] as number);\n      }\n    }\n  }\n\n  return stats;\n}\n\ntype BinaryFeatureCollectionWithStats<FeaturePropertiesT> = Omit<\n  BinaryFeatureCollection,\n  'points'\n> & {\n  points: BinaryFeatureCollection['points'] & {\n    attributes?: {\n      stats: Record<keyof FeaturePropertiesT, {min: number; max: number}>;\n    };\n  };\n};\n\nexport function clustersToBinary<FeaturePropertiesT>(\n  data: ClusteredFeaturePropertiesT<FeaturePropertiesT>[]\n): BinaryFeatureCollectionWithStats<FeaturePropertiesT> {\n  const positions = new Float32Array(data.length * 2);\n  const featureIds = new Uint16Array(data.length);\n  for (let i = 0; i < data.length; i++) {\n    positions.set(data[i].position, 2 * i);\n    featureIds[i] = i;\n  }\n\n  return {\n    ...createEmptyBinary(),\n    points: createBinaryPointFeature(positions, featureIds, featureIds, {}, data)\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  BinaryAttribute,\n  BinaryFeature,\n  BinaryFeatureCollection,\n  BinaryPointFeature\n} from '@loaders.gl/schema';\nimport {log} from '@deck.gl/core';\nimport type {Properties, NumericProps} from './layers/schema/spatialjson-utils';\n\nexport function assert(condition: unknown, message?: string): asserts condition {\n  log.assert(condition, message);\n}\n\n// Returns a Proxy object that allows accessing binary data\n// as if it were JSON properties\nexport function createBinaryProxy(\n  data: {numericProps: NumericProps; properties: Properties[]},\n  index: number\n) {\n  const {properties, numericProps} = data;\n  return new Proxy(properties[index] || {}, {\n    get(target, property) {\n      if (property in numericProps) {\n        return numericProps[property as string].value[index];\n      }\n      return target[property as string];\n    },\n\n    has(target, property) {\n      return property in numericProps || property in target;\n    },\n\n    ownKeys(target) {\n      return [...Object.keys(numericProps), ...Reflect.ownKeys(target)];\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return {enumerable: true, configurable: true};\n    }\n  });\n}\n\nexport function getWorkerUrl(id: string, version: string) {\n  // For local testing `yarn build-workers` and then host `modules/carto/dist/`\n  // return `http://localhost:8081/dist/${id}-worker.js`;\n  return `https://unpkg.com/@deck.gl/carto@${version}/dist/${id}-worker.js`;\n}\n\nexport function scaleIdentity() {\n  let unknown;\n\n  function scale(x) {\n    return x === null ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = d => d;\n\n  scale.unknown = u => {\n    if (u) {\n      unknown = u;\n    }\n\n    return unknown;\n  };\n\n  scale.copy = () => {\n    const scaleCopy = scaleIdentity();\n    scaleCopy.unknown(unknown);\n    return scaleCopy;\n  };\n\n  return scale;\n}\n\nexport const isObject: (x: unknown) => boolean = x => x !== null && typeof x === 'object';\n\nexport const isPureObject: (x: any) => boolean = x =>\n  isObject(x) && x.constructor === {}.constructor;\n\n// Helpers for binary data\nconst EMPTY_UINT16ARRAY = new Uint16Array();\nconst EMPTY_BINARY_PROPS: Omit<BinaryPointFeature, 'type'> = {\n  positions: {value: new Float32Array(), size: 2},\n  properties: [],\n  numericProps: {},\n  featureIds: {value: EMPTY_UINT16ARRAY, size: 1},\n  globalFeatureIds: {value: EMPTY_UINT16ARRAY, size: 1}\n};\n\nexport function createEmptyBinary(): Required<BinaryFeatureCollection> {\n  return {\n    shape: 'binary-feature-collection',\n    points: {\n      type: 'Point',\n      ...EMPTY_BINARY_PROPS\n    },\n    lines: {\n      type: 'LineString',\n      pathIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      ...EMPTY_BINARY_PROPS\n    },\n    polygons: {\n      type: 'Polygon',\n      polygonIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      primitivePolygonIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      ...EMPTY_BINARY_PROPS\n    }\n  };\n}\n\nexport function createBinaryPointFeature(\n  positions: number[] | Float32Array | Float64Array,\n  featureIds: number[] | Uint16Array | Uint32Array,\n  globalFeatureIds: number[] | Uint16Array | Uint32Array,\n  numericProps: NumericProps,\n  properties: Properties,\n  size: 2 | 3 = 2\n): BinaryPointFeature {\n  return {\n    type: 'Point',\n    positions: {value: new Float32Array(positions), size},\n    featureIds: {value: new Uint16Array(featureIds), size: 1},\n    globalFeatureIds: {value: new Uint32Array(globalFeatureIds), size: 1},\n    numericProps,\n    properties\n  };\n}\n\nexport function initializeNumericProps(\n  numPoints: number,\n  sourceProps?: NumericProps\n): NumericProps {\n  const numericProps: NumericProps = {};\n  if (sourceProps) {\n    Object.keys(sourceProps).forEach(prop => {\n      numericProps[prop] = {value: new Float32Array(numPoints), size: 1};\n    });\n  }\n  return numericProps;\n}\n\nexport function copyNumericProps(\n  sourceProps: NumericProps,\n  targetProps: NumericProps,\n  sourceIndex: number,\n  targetIndex: number\n): void {\n  Object.keys(sourceProps).forEach(prop => {\n    targetProps[prop].value[targetIndex] = sourceProps[prop].value[sourceIndex];\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const DEFAULT_TILE_SIZE = 512;\n\nexport const DEFAULT_AGGREGATION_EXP_ALIAS = '__aggregationValue';\nexport const DEFAULT_AGGREGATION_EXP = `1 AS ${DEFAULT_AGGREGATION_EXP_ALIAS}`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {_Tileset2D as Tileset2D} from '@deck.gl/geo-layers';\nimport {bigIntToHex, cellToParent, cellToTile, getResolution, tileToCell} from 'quadbin';\n\n// For calculations bigint representation is used, but\n// for constructing URL also provide the hexidecimal value\ntype QuadbinTileIndex = {q: bigint; i?: string};\n\nexport default class QuadbinTileset2D extends Tileset2D {\n  // @ts-expect-error for spatial indices, TileSet2d should be parametrized by TileIndexT\n  getTileIndices(opts): QuadbinTileIndex[] {\n    return super\n      .getTileIndices(opts)\n      .map(tileToCell)\n      .map(q => ({q, i: bigIntToHex(q)}));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileId({q, i}: QuadbinTileIndex): string {\n    return i || bigIntToHex(q);\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileMetadata({q}: QuadbinTileIndex) {\n    return super.getTileMetadata(cellToTile(q));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileZoom({q}: QuadbinTileIndex): number {\n    return Number(getResolution(q));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getParentIndex({q}: QuadbinTileIndex): QuadbinTileIndex {\n    return {q: cellToParent(q)};\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {worldToLngLat} from '@math.gl/web-mercator';\nimport {cellToTile} from 'quadbin';\n\nconst TILE_SIZE = 512;\n\nexport function quadbinToOffset(quadbin: bigint): [number, number, number] {\n  const {x, y, z} = cellToTile(quadbin);\n  const scale = TILE_SIZE / (1 << z);\n  return [x * scale, TILE_SIZE - y * scale, scale];\n}\n\nexport function quadbinToWorldBounds(quadbin: bigint, coverage: number): [number[], number[]] {\n  const [xOffset, yOffset, scale] = quadbinToOffset(quadbin);\n  return [\n    [xOffset, yOffset],\n    [xOffset + coverage * scale, yOffset - coverage * scale]\n  ];\n}\n\nexport function getQuadbinPolygon(quadbin: bigint, coverage = 1): number[] {\n  const [topLeft, bottomRight] = quadbinToWorldBounds(quadbin, coverage);\n  const [w, n] = worldToLngLat(topLeft);\n  const [e, s] = worldToLngLat(bottomRight);\n  return [e, n, e, s, w, s, w, n, e, n];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {GZipCompression} from '@loaders.gl/compression';\n\ntype ReadPackedOptions = {\n  compression: null | 'gzip';\n};\n\n// Optimized (100X speed improvement) reading function for binary data\nexport function readPackedTypedArray(TypedArray, pbf, obj, options?: ReadPackedOptions) {\n  const end = pbf.type === 2 ? pbf.readVarint() + pbf.pos : pbf.pos + 1;\n  const data = pbf.buf.buffer.slice(pbf.pos, end);\n\n  if (options?.compression === 'gzip') {\n    const compression = new GZipCompression();\n    const decompressedData = compression.decompressSync(data);\n    obj.value = new TypedArray(decompressedData);\n  } else {\n    obj.value = new TypedArray(data);\n  }\n\n  pbf.pos = end;\n  return obj.value;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\nimport {TypedArray} from '@loaders.gl/loader-utils';\n\n// KeyValueObject ========================================\ninterface KeyValueObject {\n  key: string;\n  value: string;\n}\n\nclass KeyValueObjectReader {\n  static read(pbf, end?: number): KeyValueObject {\n    return pbf.readFields(KeyValueObjectReader._readField, {key: '', value: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: KeyValueObject, pbf) {\n    if (tag === 1) obj.key = pbf.readString();\n    else if (tag === 2) obj.value = pbf.readString();\n  }\n}\n\n// Properties ========================================\n\nexport class PropertiesReader {\n  static read(pbf, end?: number) {\n    return pbf.readFields(PropertiesReader._readField, {}, end);\n  }\n  static _readField(this: void, tag: number, obj: Record<string, string>, pbf) {\n    if (tag === 1) {\n      const {key, value} = KeyValueObjectReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj[key] = value;\n    }\n  }\n}\n\n// Doubles ========================================\n\ninterface Doubles {\n  value: Float64Array;\n  size: number;\n}\n\nclass DoublesReader {\n  static read(pbf, end?: number): Doubles {\n    const {value, size} = pbf.readFields(DoublesReader._readField, {value: [], size: 0}, end);\n    return {value, size};\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) readPackedTypedArray(Float64Array, pbf, obj);\n    else if (tag === 2) obj.size = pbf.readVarint(true);\n  }\n}\n\n// Ints ========================================\n\ninterface Ints {\n  value: Uint32Array;\n  size: number;\n}\n\nclass IntsReader {\n  static read(pbf, end?: number): Ints {\n    const {value, size} = pbf.readFields(IntsReader._readField, {value: [], size: 0}, end);\n    return {value: new Uint32Array(value), size};\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) pbf.readPackedVarint(obj.value);\n    else if (tag === 2) obj.size = pbf.readVarint(true);\n  }\n}\n\n// Fields ========================================\n\ninterface Fields {\n  id: number;\n}\n\nclass FieldsReader {\n  static read(pbf, end?: number): Fields {\n    return pbf.readFields(FieldsReader._readField, {id: 0}, end);\n  }\n  static _readField(this: void, tag: number, obj: Fields, pbf) {\n    if (tag === 1) obj.id = pbf.readVarint();\n  }\n}\n\n// NumericProp ========================================\n\nexport interface NumericProp {\n  value: TypedArray;\n  size: number;\n}\n\nclass NumericPropReader {\n  static read(pbf, end?: number): NumericProp {\n    return pbf.readFields(NumericPropReader._readField, {value: []}, end);\n  }\n  static _readField(this: void, tag: number, obj: NumericProp, pbf) {\n    if (tag === 1) readPackedTypedArray(Float64Array, pbf, obj);\n  }\n}\n\n// NumericPropKeyValue ========================================\ninterface NumbericPropKeyValue {\n  key: string;\n  value: NumericProp;\n}\n\nexport class NumericPropKeyValueReader {\n  static read(pbf, end?: number): NumbericPropKeyValue {\n    return pbf.readFields(NumericPropKeyValueReader._readField, {key: '', value: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: NumbericPropKeyValue, pbf) {\n    if (tag === 1) obj.key = pbf.readString();\n    else if (tag === 2) obj.value = NumericPropReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n\n// Points ========================================\n\ninterface Points {\n  positions: Doubles;\n  globalFeatureIds: Ints;\n  featureIds: Ints;\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n  fields: Fields[];\n}\n\nclass PointsReader {\n  static read(pbf, end?: number): Points {\n    return pbf.readFields(\n      PointsReader._readField,\n      {\n        positions: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Points, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 5) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 6) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n\ninterface Lines extends Points {\n  pathIndices: Ints;\n}\n// Lines ========================================\n\nclass LinesReader {\n  static read(pbf, end?: number): Lines {\n    return pbf.readFields(\n      LinesReader._readField,\n      {\n        positions: null,\n        pathIndices: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Lines, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.pathIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 5) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 6) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 7) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n// Polygons ========================================\n\ninterface Polygons extends Points {\n  polygonIndices: Ints;\n  primitivePolygonIndices: Ints;\n  triangles: Ints;\n}\n\nclass PolygonsReader {\n  static read(pbf, end?: number): Polygons {\n    return pbf.readFields(\n      PolygonsReader._readField,\n      {\n        positions: null,\n        polygonIndices: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        primitivePolygonIndices: null,\n        triangles: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Polygons, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.polygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 5)\n      obj.primitivePolygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 6) obj.triangles = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 7) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 8) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 9) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n\n// Tile ========================================\n\nexport interface Tile {\n  points: Points;\n  lines: Lines;\n  polygons: Polygons;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {points: null, lines: null, polygons: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.points = PointsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.lines = LinesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.polygons = PolygonsReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\nimport {Indices, IndexScheme} from './spatialjson-utils';\nimport {NumericProp, NumericPropKeyValueReader, PropertiesReader} from './carto-tile';\n\n// Indices =====================================\n\nexport class IndicesReader {\n  static read(pbf, end?: number): Indices {\n    return pbf.readFields(IndicesReader._readField, {value: []}, end);\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) readPackedTypedArray(BigUint64Array, pbf, obj);\n  }\n}\n\n// Cells =========================================\n\ninterface Cells {\n  indices: Indices;\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n}\n\nclass CellsReader {\n  static read(pbf, end?: number): Cells {\n    return pbf.readFields(\n      CellsReader._readField,\n      {indices: null, properties: [], numericProps: {}},\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Cells, pbf) {\n    if (tag === 1) obj.indices = IndicesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 3) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    }\n  }\n}\n\n// Tile ========================================\n\n// TODO this type is very similar to SpatialBinary, should align\nexport interface Tile {\n  scheme: IndexScheme;\n  cells: Cells;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {scheme: 0, cells: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.scheme = pbf.readVarint();\n    else if (tag === 2) obj.cells = CellsReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Protobuf from 'pbf';\n\nexport function parsePbf(buffer: ArrayBuffer, TileReader) {\n  const pbf = new Protobuf(buffer);\n  const tile = TileReader.read(pbf);\n  return tile;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {bigIntToHex} from 'quadbin';\nimport {BinaryPointFeature} from '@loaders.gl/schema';\n\nexport type IndexScheme = 'h3' | 'quadbin';\ntype TypedArray = Float32Array | Float64Array;\n\nexport type Indices = {value: BigUint64Array};\nexport type NumericProps = BinaryPointFeature['numericProps'];\nexport type Properties = BinaryPointFeature['properties'];\nexport type Cells = {\n  indices: Indices;\n  numericProps: NumericProps;\n  properties: Properties;\n};\nexport type SpatialBinary = {scheme?: IndexScheme; cells: Cells};\nexport type SpatialJson = {\n  id: string | bigint;\n  properties: Properties;\n}[];\n\nexport function binaryToSpatialjson(binary: SpatialBinary): SpatialJson {\n  const {cells, scheme} = binary;\n  const count = cells.indices.value.length;\n  const spatial: any[] = [];\n  for (let i = 0; i < count; i++) {\n    const id = scheme === 'h3' ? bigIntToHex(cells.indices.value[i]) : cells.indices.value[i];\n\n    const properties = {...cells.properties[i]};\n    for (const key of Object.keys(cells.numericProps)) {\n      properties[key] = cells.numericProps[key].value[i];\n    }\n    spatial.push({id, properties});\n  }\n\n  return spatial;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\n\nimport {Tile, TileReader} from './carto-spatial-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\nimport {IndexScheme, binaryToSpatialjson, SpatialJson} from './spatialjson-utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoSpatialTile';\n\ntype CartoSpatialTileLoaderOptions = LoaderOptions & {\n  cartoSpatialTile?: {\n    scheme: IndexScheme;\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoSpatialTileLoaderOptions = {\n  cartoSpatialTile: {\n    scheme: 'quadbin',\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoSpatialTileLoader: LoaderWithParser = {\n  name: 'CARTO Spatial Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-spatial-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoSpatialTileLoaderOptions) =>\n    parseCartoSpatialTile(arrayBuffer, options),\n  parseSync: parseCartoSpatialTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nfunction parseCartoSpatialTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoSpatialTileLoaderOptions\n): SpatialJson | null {\n  if (!arrayBuffer) return null;\n  const tile: Tile = parsePbf(arrayBuffer, TileReader);\n\n  const {cells} = tile;\n  const scheme = options?.cartoSpatialTile?.scheme;\n  const data = {cells, scheme};\n\n  return binaryToSpatialjson(data);\n}\n\nexport default CartoSpatialTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@deck.gl/core';\nimport {Tile as PropertiesTile} from './schema/carto-properties-tile';\nimport {Tile as VectorTile} from './schema/carto-tile';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {TilejsonResult} from '@carto/api-client';\n\n/**\n * Merges load options with additional options, creating a new object without mutating the input.\n * Handles nested objects through recursive deep merge with protection against circular references.\n */\nexport function mergeLoadOptions(loadOptions: any, additionalOptions: any, depth = 0): any {\n  if (!loadOptions) {\n    return additionalOptions;\n  }\n  if (!additionalOptions) {\n    return loadOptions;\n  }\n\n  // Safety check against deep recursion\n  if (depth > 10) {\n    return additionalOptions;\n  }\n\n  const result = {...loadOptions};\n\n  for (const key in additionalOptions) {\n    const value = additionalOptions[key];\n    // Skip circular references\n    if (value === loadOptions || value === additionalOptions) {\n      continue;\n    }\n    if (typeof value === 'object' && value !== null) {\n      result[key] = mergeLoadOptions(loadOptions[key], value, depth + 1);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n// eslint-disable-next-line max-statements\nexport function mergeBoundaryData(geometry: VectorTile, properties: PropertiesTile): VectorTile {\n  const mapping = {};\n  for (const {geoid, ...rest} of properties.properties) {\n    if (geoid in mapping) {\n      log.warn('Duplicate geoid key in boundary mapping, using first occurance')();\n    } else {\n      mapping[geoid] = rest;\n    }\n  }\n\n  for (const type of ['points', 'lines', 'polygons']) {\n    const geom = geometry[type];\n    if (geom.positions.value.length === 0) {\n      continue;\n    }\n\n    geom.properties = geom.properties.map(({geoid}) => mapping[geoid]);\n\n    // numericProps need to be filled to match length of positions buffer\n    const {positions, globalFeatureIds} = geom;\n    let indices: Uint16Array | Uint32Array | null = null;\n    if (type === 'lines') indices = geom.pathIndices.value;\n    if (type === 'polygons') indices = geom.polygonIndices.value;\n    const length = positions.value.length / positions.size;\n    for (const key in properties.numericProps) {\n      const sourceProp = properties.numericProps[key].value;\n      const TypedArray = sourceProp.constructor as\n        | Float32ArrayConstructor\n        | Float64ArrayConstructor;\n      const destProp = new TypedArray(length);\n      geom.numericProps[key] = {value: destProp, size: 1};\n\n      if (!indices) {\n        for (let i = 0; i < length; i++) {\n          // points\n          const featureId = globalFeatureIds.value[i];\n          destProp[i] = sourceProp[featureId];\n        }\n      } else {\n        // lines|polygons\n        for (let i = 0; i < indices.length - 1; i++) {\n          const startIndex = indices[i];\n          const endIndex = indices[i + 1];\n          const featureId = globalFeatureIds.value[startIndex];\n          destProp.fill(sourceProp[featureId], startIndex, endIndex);\n        }\n      }\n    }\n  }\n\n  return geometry;\n}\n\nexport const TilejsonPropType = {\n  type: 'object' as const,\n  value: null as null | TilejsonResult,\n  validate: (value: TilejsonResult, propType) =>\n    (propType.optional && value === null) ||\n    (typeof value === 'object' &&\n      Array.isArray(value.tiles) &&\n      value.tiles.every(url => typeof url === 'string')),\n  equal: (value1, value2) => {\n    return deepEqual(value1, value2, 2);\n  },\n  async: true\n};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CompositeLayer, CompositeLayerProps, DefaultProps} from '@deck.gl/core';\nimport {H3HexagonLayer, H3HexagonLayerProps} from '@deck.gl/geo-layers';\nimport H3Tileset2D, {getHexagonResolution} from './h3-tileset-2d';\nimport SpatialIndexTileLayer, {SpatialIndexTileLayerProps} from './spatial-index-tile-layer';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nexport const renderSubLayers = props => {\n  const {data} = props;\n  const {index} = props.tile;\n  if (!data || !data.length) return null;\n\n  return new H3HexagonLayer(props, {\n    getHexagon: d => d.id,\n    centerHexagon: index,\n    highPrecision: true\n  });\n};\n\nconst defaultProps: DefaultProps<H3TileLayerProps> = {\n  data: TilejsonPropType,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by H3TileLayer. */\nexport type H3TileLayerProps<DataT = unknown> = _H3TileLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by H3TileLayer. */\ntype _H3TileLayerProps<DataT> = Omit<H3HexagonLayerProps<DataT>, 'data'> &\n  Omit<SpatialIndexTileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nexport default class H3TileLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_H3TileLayerProps<DataT>>\n> {\n  static layerName = 'H3TileLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    H3HexagonLayer._checkH3Lib();\n  }\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme: 'h3'}\n    });\n  }\n\n  renderLayers(): SpatialIndexTileLayer | null {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data} = tileJSON;\n    let {minresolution, maxresolution} = tileJSON;\n    // Convert Mercator zooms provided in props into H3 res levels\n    // and clip into valid range provided from the tilejson\n    if (this.props.minZoom) {\n      minresolution = Math.max(\n        minresolution,\n        getHexagonResolution({zoom: this.props.minZoom, latitude: 0}, this.props.tileSize)\n      );\n    }\n    if (this.props.maxZoom) {\n      maxresolution = Math.min(\n        maxresolution,\n        getHexagonResolution({zoom: this.props.maxZoom, latitude: 0}, this.props.tileSize)\n      );\n    }\n\n    const SubLayerClass = this.getSubLayerClass('spatial-index-tile', SpatialIndexTileLayer);\n    // The naming is unfortunate, but minZoom & maxZoom in the context\n    // of a Tileset2D refer to the resolution levels, not the Mercator zooms\n    return new SubLayerClass(this.props, {\n      id: `h3-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: H3Tileset2D as any,\n      renderSubLayers,\n      // minZoom and maxZoom are H3 resolutions, however we must use this naming as that is what the Tileset2D class expects\n      minZoom: minresolution,\n      maxZoom: maxresolution,\n      loadOptions: this.getLoadOptions()\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {_Tileset2D as Tileset2D, GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {\n  polygonToCells,\n  latLngToCell,\n  getResolution,\n  cellToBoundary,\n  cellToParent,\n  gridDisk,\n  edgeLength,\n  UNITS,\n  originToDirectedEdges\n} from 'h3-js';\n\nexport type H3TileIndex = {i: string};\n\nconst MAX_LATITUDE = 85.051128;\n\n/**\n * `polygonToCells()` fills based on hexagon center, this function will\n * pad the bounds such that all cells that overlap the bounds will be included.\n *\n * @param bbox - The bounding box to pad.\n * @param resolution - The resolution of the hexagons.\n * @param scale - The scale of the buffer. 1 is to pad by the max edge length of the tile cell.\n * @returns The padded bounding box.\n */\nfunction padBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number,\n  scale: number = 1.0\n): GeoBoundingBox {\n  const corners = [\n    [north, east],\n    [south, east],\n    [south, west],\n    [north, west]\n  ];\n  const cornerCells = corners.map(c => latLngToCell(c[0], c[1], resolution));\n  const cornerEdgeLengths = cornerCells.map(\n    c => (Math.max(...originToDirectedEdges(c).map(e => edgeLength(e, UNITS.rads))) * 180) / Math.PI\n  );\n  const bufferLat = Math.max(...cornerEdgeLengths) * scale;\n  const bufferLon = Math.min(180, bufferLat / Math.cos((((north + south) / 2) * Math.PI) / 180));\n\n  return {\n    north: Math.min(north + bufferLat, MAX_LATITUDE),\n    east: east + bufferLon,\n    south: Math.max(south - bufferLat, -MAX_LATITUDE),\n    west: west - bufferLon\n  };\n}\n\nfunction getHexagonsInBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number\n): string[] {\n  const longitudeSpan = Math.abs(east - west);\n  if (longitudeSpan > 180) {\n    // This is a known issue in h3-js: polygonToCells does not work correctly\n    // when longitude span is larger than 180 degrees.\n    const nSegments = Math.ceil(longitudeSpan / 180);\n    let h3Indices: string[] = [];\n    for (let s = 0; s < nSegments; s++) {\n      const segmentWest = west + s * 180;\n      const segmentEast = Math.min(segmentWest + 179.9999999, east);\n      h3Indices = h3Indices.concat(\n        getHexagonsInBoundingBox({west: segmentWest, north, east: segmentEast, south}, resolution)\n      );\n    }\n    return [...new Set(h3Indices)];\n  }\n\n  const polygon = [\n    [north, east],\n    [south, east],\n    [south, west],\n    [north, west],\n    [north, east]\n  ];\n  return polygonToCells(polygon, resolution);\n}\n\nfunction tileToBoundingBox(index: string): GeoBoundingBox {\n  const coordinates = cellToBoundary(index);\n  const latitudes = coordinates.map(c => c[0]);\n  const longitudes = coordinates.map(c => c[1]);\n  const west = Math.min(...longitudes);\n  const south = Math.min(...latitudes);\n  const east = Math.max(...longitudes);\n  const north = Math.max(...latitudes);\n  const bbox = {west, south, east, north};\n\n  // H3 child cells extend beyond their parent's boundary forming a \"snowflake\"\n  // fractal pattern. The required buffer is approximately 10% of the\n  // edge length of the tile cell, add a bit more to be safe.\n  return padBoundingBox(bbox, getResolution(index), 0.12);\n}\n\n// Resolution conversion function. Takes a WebMercatorViewport and returns\n// a H3 resolution such that the screen space size of the hexagons is\n// similar\n// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)\nconst BIAS = 2;\nexport function getHexagonResolution(\n  viewport: {zoom: number; latitude: number},\n  tileSize: number\n): number {\n  // Difference in given tile size compared to deck's internal 512px tile size,\n  // expressed as an offset to the viewport zoom.\n  const zoomOffset = Math.log2(tileSize / 512);\n  const hexagonScaleFactor = (2 / 3) * (viewport.zoom - zoomOffset);\n  const latitudeScaleFactor = Math.log(1 / Math.cos((Math.PI * viewport.latitude) / 180));\n\n  // Clip and bias\n  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));\n}\n\nexport default class H3Tileset2D extends Tileset2D {\n  /**\n   * Returns all tile indices in the current viewport. If the current zoom level is smaller\n   * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n   * return tiles that are on maxZoom.\n   */\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileIndices({viewport, minZoom, maxZoom}): H3TileIndex[] {\n    if (viewport.latitude === undefined) return [];\n    const [west, south, east, north] = viewport.getBounds();\n    const {tileSize} = this.opts;\n\n    let z = getHexagonResolution(viewport, tileSize);\n    let indices: string[];\n    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n      // TODO support `extent` prop\n      return [];\n    }\n    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n      z = maxZoom;\n\n      // Once we are at max zoom, getHexagonsInBoundingBox doesn't work, simply\n      // get a ring centered on the hexagon in the viewport center\n      const center = latLngToCell(viewport.latitude, viewport.longitude, maxZoom);\n      indices = gridDisk(center, 1);\n    } else {\n      const paddedBounds = padBoundingBox({west, north, east, south}, z);\n      indices = getHexagonsInBoundingBox(paddedBounds, z);\n    }\n\n    return indices.map(i => ({i}));\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileId({i}: H3TileIndex): string {\n    return i;\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileMetadata({i}: H3TileIndex) {\n    return {bbox: tileToBoundingBox(i)};\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileZoom({i}: H3TileIndex): number {\n    return getResolution(i);\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getParentIndex(index: H3TileIndex): H3TileIndex {\n    const resolution = getResolution(index.i);\n    const i = cellToParent(index.i, resolution - 1);\n    return {i};\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {registerLoaders} from '@loaders.gl/core';\nimport {DefaultProps, LayerProps} from '@deck.gl/core';\nimport CartoSpatialTileLoader from './schema/carto-spatial-tile-loader';\nregisterLoaders([CartoSpatialTileLoader]);\n\nimport {PickingInfo} from '@deck.gl/core';\nimport {TileLayer, _Tile2DHeader as Tile2DHeader, TileLayerProps} from '@deck.gl/geo-layers';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nfunction isFeatureIdDefined(value: unknown): boolean {\n  return value !== undefined && value !== null && value !== '';\n}\n\nconst defaultProps: DefaultProps<SpatialIndexTileLayerProps> = {\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by SpatialIndexTileLayer. */\nexport type SpatialIndexTileLayerProps<DataT = unknown> = _SpatialIndexTileLayerProps &\n  TileLayerProps<DataT>;\n\n/** Properties added by SpatialIndexTileLayer. */\ntype _SpatialIndexTileLayerProps = {};\n\nexport default class SpatialIndexTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends TileLayer<DataT, ExtraProps & Required<_SpatialIndexTileLayerProps>> {\n  static layerName = 'SpatialIndexTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: TileLayer<DataT>['state'] & {\n    hoveredFeatureId: BigInt | number | null;\n    highlightColor: number[];\n  };\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const {hoveredFeatureId} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId: BigInt | number | null = null;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = hoveredFeature.id;\n    }\n\n    if (hoveredFeatureId !== newHoveredFeatureId) {\n      let {highlightColor} = this.props;\n      if (typeof highlightColor === 'function') {\n        highlightColor = highlightColor(info);\n      }\n\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId\n      });\n    }\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader): Partial<LayerProps> | null {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile: Tile2DHeader) {\n    const {hoveredFeatureId} = this.state;\n    const data = tile.content;\n\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId);\n    if (\n      !isFeatureIdPresent ||\n      !Array.isArray(data) ||\n      // Quick check for whether id is within tile. data.findIndex is expensive\n      !this._featureInTile(tile, hoveredFeatureId!)\n    ) {\n      return -1;\n    }\n\n    return data.findIndex(feature => feature.id === hoveredFeatureId);\n  }\n\n  _featureInTile(tile: Tile2DHeader, featureId: BigInt | number) {\n    // TODO: Tile2DHeader index should be generic for H3TileIndex or QuadbinTileIndex\n    const tileset = this.state.tileset!;\n    const tileZoom = tileset.getTileZoom(tile.index);\n    // @ts-ignore\n    const KEY = tile.index.q ? 'q' : 'i';\n    // TODO - Tileset2D methods expect tile index in the shape of {x, y, z}\n    let featureIndex: any = {[KEY]: featureId};\n    let featureZoom = tileset.getTileZoom(featureIndex);\n    while (!(featureZoom <= tileZoom)) {\n      featureIndex = tileset.getParentIndex(featureIndex);\n      featureZoom = tileset.getTileZoom(featureIndex);\n    }\n\n    return featureIndex[KEY] === tile.index[KEY];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable @typescript-eslint/no-shadow */\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {getResolution} from 'quadbin';\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  DefaultProps,\n  Layer,\n  UpdateParameters\n} from '@deck.gl/core';\nimport {SolidPolygonLayer} from '@deck.gl/layers';\n\nimport {HeatmapProps, heatmap} from './heatmap';\nimport {RTTModifier, PostProcessModifier} from './post-process-utils';\nimport QuadbinTileLayer, {QuadbinTileLayerProps} from './quadbin-tile-layer';\nimport {TilejsonPropType} from './utils';\nimport {TilejsonResult} from '@carto/api-client';\nimport {_Tile2DHeader as Tile2DHeader} from '@deck.gl/geo-layers';\nimport {Texture, TextureProps} from '@luma.gl/core';\n\nconst defaultColorRange: Color[] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  mipmaps: false,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\n/**\n * Computes the unit density (inverse of cell area)\n */\nfunction unitDensityForCell(cell: bigint) {\n  const cellResolution = Number(getResolution(cell));\n  return Math.pow(4.0, cellResolution);\n}\n\n/**\n * Converts a colorRange array to a flat array with 4 components per color\n */\nfunction colorRangeToFlatArray(colorRange: Color[]): Uint8Array {\n  const flatArray = new Uint8Array(colorRange.length * 4);\n  let index = 0;\n\n  for (let i = 0; i < colorRange.length; i++) {\n    const color = colorRange[i];\n    flatArray[index++] = color[0];\n    flatArray[index++] = color[1];\n    flatArray[index++] = color[2];\n    flatArray[index++] = Number.isFinite(color[3]) ? (color[3] as number) : 255;\n  }\n\n  return flatArray;\n}\n\nconst uniformBlock = `\\\nuniform densityUniforms {\n  float factor;\n} density;\n`;\n\ntype DensityProps = {factor: number};\nconst densityUniforms = {\n  name: 'density',\n  vs: uniformBlock,\n  uniformTypes: {\n    factor: 'f32'\n  }\n} as const satisfies ShaderModule<DensityProps>;\n\n// Modified polygon layer to draw offscreen and output value expected by heatmap\nclass RTTSolidPolygonLayer extends RTTModifier(SolidPolygonLayer) {\n  static layerName = 'RTTSolidPolygonLayer';\n\n  getShaders(type) {\n    const shaders = super.getShaders(type);\n    shaders.inject = {\n      'vs:#main-end': `\n      // Value from getWeight accessor\n  float weight = elevations;\n\n  // Keep \"power\" delivered to screen constant when tiles update\n  // by outputting normalized density\n  weight *= density.factor;\n\n  // Pack float into 3 channels to pass to heatmap shader\n  // SCALE value important, as we don't want to saturate\n  // but also want enough definition to avoid banding\n  const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);\n  const float MAX_VAL = SHIFT.z * 255.0;\n  const float SCALE = MAX_VAL / 8.0;\n  weight *= SCALE;\n  weight = clamp(weight, 0.0, MAX_VAL);\n  vColor = vec4(mod(vec3(weight, floor(weight / SHIFT.yz)), 256.0), 255.0) / 255.0;\n`\n    };\n    shaders.modules = [...shaders.modules, densityUniforms];\n    return shaders;\n  }\n\n  draw(this, opts: any) {\n    const cell = this.props!.data[0];\n    const maxDensity = this.props.elevationScale;\n    const densityProps: DensityProps = {\n      factor: unitDensityForCell(cell.id) / maxDensity\n    };\n    for (const model of this.state.models) {\n      model.shaderInputs.setProps({density: densityProps});\n    }\n\n    super.draw(opts);\n  }\n}\n\n// Modify QuadbinTileLayer to apply heatmap post process effect\nconst PostProcessQuadbinTileLayer = PostProcessModifier(QuadbinTileLayer, heatmap);\n\nconst defaultProps: DefaultProps<HeatmapTileLayerProps> = {\n  data: TilejsonPropType,\n  getWeight: {type: 'accessor', value: 1},\n  onMaxDensityChange: {type: 'function', optional: true, value: null},\n  colorDomain: {type: 'array', value: [0, 1]},\n  colorRange: defaultColorRange,\n  intensity: {type: 'number', value: 1},\n  radiusPixels: {type: 'number', min: 0, max: 100, value: 20}\n};\n\n/** All properties supported by HeatmapTileLayer. */\nexport type HeatmapTileLayerProps<DataT = unknown> = _HeatmapTileLayerProps<DataT> &\n  CompositeLayerProps & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\n/** Properties added by HeatmapTileLayer. */\ntype _HeatmapTileLayerProps<DataT> = QuadbinTileLayerProps<DataT> &\n  HeatmapProps & {\n    /**\n     * Specified as an array of colors [color1, color2, ...].\n     *\n     * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n     */\n    colorRange: Color[];\n\n    /**\n     * The weight of each object.\n     *\n     * @default 1\n     */\n    getWeight?: Accessor<DataT, number>;\n\n    /** Called when maximum density in displayed tiles changes. */\n    onMaxDensityChange?: ((maxDensity: number) => void) | null;\n  };\n\nclass HeatmapTileLayer<DataT = any, ExtraProps extends {} = {}> extends CompositeLayer<\n  ExtraProps & Required<_HeatmapTileLayerProps<DataT>>\n> {\n  static layerName = 'HeatmapTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    colorTexture?: Texture;\n    isLoaded: boolean;\n    tiles: Set<Tile2DHeader>;\n    viewportChanged?: boolean;\n  };\n  initializeState() {\n    this.state = {\n      isLoaded: false,\n      tiles: new Set(),\n      viewportChanged: false\n    };\n  }\n\n  shouldUpdateState({changeFlags}): boolean {\n    const {viewportChanged} = changeFlags;\n    this.setState({viewportChanged});\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    super.updateState(opts);\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n  }\n\n  renderLayers(): Layer {\n    const {\n      data,\n      getWeight,\n      colorDomain,\n      intensity,\n      radiusPixels,\n      _subLayerProps,\n      updateTriggers,\n      onMaxDensityChange,\n      onViewportLoad,\n      onTileLoad,\n      onTileUnload,\n      ...tileLayerProps\n    } = this.props;\n\n    // Inject modified polygon layer as sublayer into TileLayer\n    const subLayerProps = {\n      ..._subLayerProps,\n      cell: {\n        ..._subLayerProps?.cell,\n        _subLayerProps: {\n          ..._subLayerProps?.cell?._subLayerProps,\n          fill: {\n            ..._subLayerProps?.cell?._subLayerProps?.fill,\n            type: RTTSolidPolygonLayer\n          }\n        }\n      }\n    };\n\n    let tileZ = 0;\n    let maxDensity = 0;\n    const loadedTiles = [...this.state.tiles].filter(t => t.content);\n    const visibleTiles = loadedTiles.filter(t => t.isVisible);\n\n    // As deck.gl initially marks tiles as hidden, use hidden tiles as fallback for calculation.\n    // This avoids an ugly flash/glitch at startup when layer is first rendered\n    const tiles = visibleTiles.length ? visibleTiles : loadedTiles;\n\n    for (const tile of tiles) {\n      const cell = tile.content[0];\n      const unitDensity = unitDensityForCell(cell.id);\n      maxDensity = Math.max(tile.userData!.maxWeight * unitDensity, maxDensity);\n      tileZ = Math.max(tile.zoom, tileZ);\n    }\n\n    // Between zoom levels the max density will change, but it isn't possible to know by what factor. Uniform data distributions lead to a factor of 4, while very localized data gives 1. As a heurstic estimate with a value inbetween (2) to make the transitions less obvious.\n    const overzoom = this.context.viewport.zoom - tileZ;\n    const estimatedMaxDensity = maxDensity * Math.pow(2, overzoom);\n\n    maxDensity = estimatedMaxDensity;\n    if (typeof onMaxDensityChange === 'function') {\n      onMaxDensityChange(maxDensity);\n    }\n    return new PostProcessQuadbinTileLayer(\n      tileLayerProps as Omit<QuadbinTileLayerProps, 'data'>,\n      this.getSubLayerProps({\n        id: 'heatmap',\n        data,\n\n        // Re-use existing props to pass down values to sublayer\n        // TODO replace with custom layer\n        getFillColor: 0,\n        getElevation: getWeight,\n        elevationScale: maxDensity,\n\n        colorDomain,\n\n        radiusPixels,\n        intensity,\n        _subLayerProps: subLayerProps,\n        refinementStrategy: 'no-overlap',\n\n        colorTexture: this.state.colorTexture,\n\n        // Disable line rendering\n        extruded: false,\n        stroked: false,\n\n        updateTriggers: {\n          getElevation: updateTriggers.getWeight\n        },\n\n        // Tile stats\n        onViewportLoad: tiles => {\n          this.setState({isLoaded: true});\n          if (typeof onViewportLoad === 'function') {\n            onViewportLoad(tiles);\n          }\n        },\n        onTileLoad: (tile: Tile2DHeader) => {\n          let maxWeight = -Infinity;\n          if (typeof getWeight !== 'function') {\n            maxWeight = getWeight;\n          } else if (tile.content) {\n            for (const d of tile.content) {\n              maxWeight = Math.max(getWeight(d, {} as any), maxWeight);\n            }\n          }\n          tile.userData = {maxWeight};\n\n          this.state.tiles.add(tile);\n\n          if (typeof onTileLoad === 'function') {\n            onTileLoad(tile);\n          }\n        },\n        onTileUnload: (tile: Tile2DHeader) => {\n          this.state.tiles.delete(tile);\n          if (typeof onTileUnload === 'function') {\n            onTileUnload(tile);\n          }\n        },\n        transitions: {elevationScale: {type: 'spring', stiffness: 0.3, damping: 0.5}}\n      })\n    );\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange);\n\n    if (colorTexture && colorTexture?.width === colorRange.length) {\n      // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\n      (colorTexture as any).setTexture2DData({data: colors});\n    } else {\n      colorTexture?.destroy();\n      // @ts-ignore TODO v9.1\n      colorTexture = this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        data: colors,\n        width: colorRange.length,\n        height: 1\n      });\n    }\n    this.setState({colorTexture});\n  }\n}\n\nexport default HeatmapTileLayer;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {Texture} from '@luma.gl/core';\n\n/**\n * @filter       Heatmap\n * @param radiusPixels Blur radius in pixels, controls smoothness of heatmap\n * @param colorDomain Domain to apply to values prior to applying color scale\n * @param colorTexture 1D RGB lookup texture for color scale\n * @param intensity Multiplier to apply to value\n * @param opacity Output opacity\n */\n\nconst fs = /* glsl */ `\\\nuniform heatmapUniforms {\n  vec2 colorDomain;\n  vec2 delta;\n  float intensity;\n  float opacity;\n  float radiusPixels;\n} heatmap;\n\nuniform sampler2D colorTexture;\n\nvec3 colorGradient(float value) {\n  return texture(colorTexture, vec2(value, 0.5)).rgb;\n}\n\nconst vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);\nconst float MAX_VAL = SHIFT.z * 255.0;\nconst float SCALE = MAX_VAL / 8.0;\nvec4 pack(float value) {\n  return vec4(mod(vec3(value, floor(value / SHIFT.yz)), 256.0), 255.0) / 255.0;\n}\nfloat unpack(vec3 color) {\n  return 255.0 * dot(color, SHIFT);\n}\n\nvec4 heatmap_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  bool firstPass = (heatmap.delta.y < 0.5);\n  float accumulator = 0.0;\n\n  // Controls quality of heatmap, larger values increase quality at expense of performance\n  float SUPPORT = clamp(heatmap.radiusPixels / 2.0, 8.0, 32.0);\n\n  // Gaussian normalization parameters\n  float sigma = SUPPORT / 3.0;\n  float a = -0.5 / (sigma * sigma);\n  float w0 = 0.3989422804014327 / sigma; // 1D normalization\n  for (float t = -SUPPORT; t <= SUPPORT; t++) {\n    vec2 percent = (t * heatmap.delta - 0.5) / SUPPORT;\n    vec2 delta = percent * heatmap.radiusPixels / texSize;\n    vec4 offsetColor = texture(source, texCoord + delta);\n\n    // Unpack float\n    float value = unpack(offsetColor.rgb);\n\n    // Gaussian\n    float weight = w0 * exp(a * t * t);\n    \n    accumulator += value * weight;\n  }\n\n  if (firstPass) {\n    return pack(accumulator);\n  }\n\n  // Undo scaling to obtain normalized density\n  float density = 10.0 * heatmap.intensity * accumulator / SCALE;\n \n  // Domain also in normalized density units\n  vec2 domain = heatmap.colorDomain;\n\n  // Apply domain\n  float f = (density - domain[0]) / (domain[1] - domain[0]);\n\n  // sqrt/log scaling??\n  // float f = (log(density) - log(domain[0] + 1.0)) / (log(domain[1] + 1.0) - log(domain[0] + 1.0));\n  // f = sqrt(f);\n\n  // Color map\n  vec4 color = vec4(0.0);\n  color.rgb = colorGradient(f);\n\n  color.a = smoothstep(0.0, 0.1, f);\n  color.a = pow(color.a, 1.0 / 2.2);\n  color.a *= heatmap.opacity;\n\n  return color;\n}\n`;\n\nexport type HeatmapProps = {\n  /**\n   * Radius of the heatmap blur in pixels, to which the weight of a cell is distributed.\n   *\n   * @default 20\n   */\n  radiusPixels?: number;\n  /**\n   * Controls how weight values are mapped to the colors in `colorTexture`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default [0, 1]\n   */\n  colorDomain?: [number, number];\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight. A value larger than 1 biases the output color towards the higher end of the spectrum, and a value less than 1 biases the output color towards the lower end of the spectrum.\n   */\n  intensity?: number;\n  /**\n   * Color LUT for color gradient\n   */\n  colorTexture: Texture;\n  opacity: number;\n};\n\ntype PassProps = {\n  delta: [number, number];\n};\n\nexport const heatmap = {\n  name: 'heatmap',\n  uniformPropTypes: {\n    colorDomain: {value: [0, 1]},\n    delta: {value: [0, 1]},\n    intensity: {value: 1, min: 0.1, max: 10},\n    opacity: {value: 1, min: 0, max: 1},\n    radiusPixels: {value: 20, min: 0, softMax: 100}\n  },\n  uniformTypes: {\n    colorDomain: 'vec2<f32>',\n    delta: 'vec2<f32>',\n    intensity: 'f32',\n    opacity: 'f32',\n    radiusPixels: 'f32'\n  },\n  // @ts-ignore TODO v9.1\n  getUniforms: opts => {\n    if (!opts) return {};\n    const {\n      colorDomain = [0, 1],\n      colorTexture,\n      delta = [1, 0],\n      intensity = 1,\n      opacity = 1,\n      radiusPixels = 20\n    } = opts;\n    return {\n      colorDomain,\n      colorTexture,\n      delta,\n      intensity,\n      opacity,\n      radiusPixels\n    };\n  },\n  fs,\n  passes: [\n    // @ts-expect-error Seems typing in luma.gl should be Partial<>\n    {sampler: true, uniforms: {delta: [1, 0]}},\n    // @ts-expect-error Seems typing in luma.gl should be Partial<>\n    {sampler: true, uniforms: {delta: [0, 1]}}\n  ]\n} as const satisfies ShaderPass<HeatmapProps & PassProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer, TextureProps} from '@luma.gl/core';\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {\n  _ConstructorOf,\n  CompositeLayer,\n  Layer,\n  LayerContext,\n  LayerProps,\n  LayersList,\n  PostProcessEffect,\n  PostRenderOptions\n} from '@deck.gl/core';\n\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  mipmaps: false,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\n\ninterface IPostProcessLayer {\n  applyPostProcess: () => void;\n  enableRTT: Layer['draw'];\n  disableRTT: () => void;\n  props: LayerProps;\n}\n\ntype Constructor<T> = (new (...args: any[]) => T) & {layerName: string};\ntype DrawableCompositeLayer = CompositeLayer & {\n  renderLayers(): Layer<{}> | null | LayersList;\n};\n\nfunction getPostProcessLayer(layer: any): IPostProcessLayer {\n  while (layer.parent && !layer.applyPostProcess) {\n    layer = layer.parent;\n  }\n  return layer as unknown as IPostProcessLayer;\n}\n\n/**\n * Dummy Layer that draws nothing, just calls back to root Layer\n */\nclass DrawCallbackLayer extends Layer {\n  static layerName = 'DrawCallbackLayer';\n\n  initializeState(this: DrawCallbackLayer): void {\n    this.id = `draw-callback-${getPostProcessLayer(this).props.id}`;\n  }\n\n  _drawLayer(this: DrawCallbackLayer) {\n    getPostProcessLayer(this).applyPostProcess();\n  }\n}\n\n/**\n * Modifier that marks a layer for Render-to-Target rendering.\n * Resulting layer must be used as a sublayer of a layer created\n * with `PostProcessModifier`\n */\nexport function RTTModifier<T extends _ConstructorOf<Layer>>(BaseLayer: T): T {\n  // @ts-expect-error initializeState is abstract\n  return class RTTLayer extends BaseLayer {\n    // @ts-expect-error typescript doesn't see static property\n    static layerName = `RTT-${BaseLayer.layerName}`;\n\n    draw(this: RTTLayer, opts: any) {\n      const {shaderModuleProps} = opts;\n      const {picking} = shaderModuleProps;\n      const postProcessLayer = getPostProcessLayer(this);\n\n      if (!picking.isActive) {\n        postProcessLayer.enableRTT(opts);\n      }\n\n      // Draw actual layer\n      super.draw(opts);\n\n      if (!picking.isActive) {\n        postProcessLayer.disableRTT();\n      }\n    }\n  };\n}\n\n/**\n * Modifier that returns the a modified Layer, which applies a\n * postprocess effect to all subLayers created using `RTTModifier`\n */\nexport function PostProcessModifier<T extends Constructor<DrawableCompositeLayer>>(\n  BaseLayer: T,\n  effect: any\n): T {\n  return class PostProcessLayer extends BaseLayer {\n    static layerName = `PostProcess${BaseLayer.layerName}`;\n\n    internalState: any;\n\n    initializeState(this: PostProcessLayer, context: LayerContext): void {\n      super.initializeState(context);\n\n      this._createTextures();\n      this.internalState.postProcess = new PostProcessEffect(effect, this.props);\n      this.internalState.postProcess.setup(context);\n    }\n\n    updateState(this: PostProcessLayer, params: any): void {\n      super.updateState(params);\n      this.internalState.postProcess.setProps(this.props);\n    }\n\n    renderLayers(): PostProcessLayer | null | LayersList {\n      let subLayers = super.renderLayers();\n      if (!subLayers) {\n        return null;\n      }\n      subLayers = Array.isArray(subLayers) ? subLayers : [subLayers];\n      return [...subLayers, new DrawCallbackLayer()];\n    }\n\n    _createTextures(this: PostProcessLayer) {\n      const {device} = this.context;\n      this.internalState.renderBuffers = [0, 1].map(i => {\n        return device.createFramebuffer({\n          id: `layer-fbo-${i}`,\n          colorAttachments: [device.createTexture(TEXTURE_PROPS)],\n          depthStencilAttachment: 'depth16unorm'\n        });\n      });\n    }\n\n    _resizeBuffers(this: PostProcessLayer, opts: any) {\n      // TODO we could likely render to a smaller buffer for better perf\n      const {shaderModuleProps} = opts;\n      const {viewport} = this.context;\n      const {devicePixelRatio} = shaderModuleProps.project;\n      const width = devicePixelRatio * viewport.width;\n      const height = devicePixelRatio * viewport.height;\n      this.internalState.renderBuffers.forEach((fbo: Framebuffer) => fbo.resize({width, height}));\n    }\n\n    enableRTT(this: PostProcessLayer, opts: any) {\n      this._resizeBuffers(opts);\n      this.internalState.originalRenderPass = this.context.renderPass;\n\n      const [framebuffer] = this.internalState.renderBuffers;\n\n      // Create new render pass for RTT\n      this.internalState.internalRenderPass = this.context.device.beginRenderPass({\n        framebuffer,\n        parameters: {viewport: [0, 0, framebuffer.width, framebuffer.height]},\n        // Only clear on first render\n        clearColor: this.internalState.renderInProgress ? false : [0, 0, 0, 0]\n      });\n      this.internalState.renderInProgress = true;\n      this.context.renderPass = this.internalState.internalRenderPass;\n    }\n\n    disableRTT(this: PostProcessLayer) {\n      // End render pass, and reinstate original\n      this.internalState.internalRenderPass.end();\n      this.context.renderPass = this.internalState.originalRenderPass;\n    }\n\n    applyPostProcess(this: PostProcessLayer) {\n      if (!this.internalState.renderInProgress) {\n        return;\n      }\n\n      // Apply post process effect\n      const [inputBuffer, swapBuffer] = this.internalState.renderBuffers;\n      const {framebuffer: target} = this.context.renderPass.props;\n      this.internalState.postProcess.postRender({\n        inputBuffer,\n        swapBuffer,\n        target\n      } as PostRenderOptions);\n\n      this.internalState.renderInProgress = false;\n    }\n\n    _finalize(): void {\n      this.internalState.renderBuffers.forEach((fbo: Framebuffer) => {\n        fbo.destroy();\n      });\n      this.internalState.renderBuffers = null;\n      this.internalState.postProcess.cleanup();\n    }\n  };\n}\n\nconst fs = /* glsl */ `\\\nvec4 copy_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return color;\n}\n`;\n\n/**\n * Copy\n * Simple module that just copies input color to output\n */\nexport const copy = {\n  name: 'copy',\n  fs,\n  getUniforms: () => ({}),\n  passes: [{filter: true}]\n} as const satisfies ShaderPass<{}>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CompositeLayer, CompositeLayerProps, DefaultProps} from '@deck.gl/core';\nimport QuadbinLayer, {QuadbinLayerProps} from './quadbin-layer';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport SpatialIndexTileLayer, {SpatialIndexTileLayerProps} from './spatial-index-tile-layer';\nimport {hexToBigInt} from 'quadbin';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nexport const renderSubLayers = props => {\n  const {data} = props;\n  if (!data || !data.length) return null;\n  const isBigInt = typeof data[0].id === 'bigint';\n  return new QuadbinLayer(props, {\n    getQuadbin: isBigInt ? d => d.id : d => hexToBigInt(d.id)\n  });\n};\n\nconst defaultProps: DefaultProps<QuadbinTileLayerProps> = {\n  data: TilejsonPropType,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by QuadbinTileLayer. */\nexport type QuadbinTileLayerProps<DataT = unknown> = _QuadbinTileLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by QuadbinTileLayer. */\ntype _QuadbinTileLayerProps<DataT> = Omit<QuadbinLayerProps<DataT>, 'data'> &\n  Omit<SpatialIndexTileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nexport default class QuadbinTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_QuadbinTileLayerProps<DataT>>> {\n  static layerName = 'QuadbinTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme: 'quadbin'}\n    });\n  }\n\n  renderLayers(): SpatialIndexTileLayer | null {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, maxresolution: maxZoom} = tileJSON;\n    const SubLayerClass = this.getSubLayerClass('spatial-index-tile', SpatialIndexTileLayer);\n    return new SubLayerClass(this.props, {\n      id: `quadbin-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: QuadbinTileset2D as any,\n      renderSubLayers,\n      maxZoom,\n      loadOptions: this.getLoadOptions()\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, DefaultProps} from '@deck.gl/core';\nimport {\n  _GeoCellLayer as GeoCellLayer,\n  _GeoCellLayerProps as GeoCellLayerProps\n} from '@deck.gl/geo-layers';\nimport {getQuadbinPolygon} from './quadbin-utils';\n\nconst defaultProps: DefaultProps<QuadbinLayerProps> = {\n  getQuadbin: {type: 'accessor', value: (d: any) => d.quadbin}\n};\n\n/** All properties supported by QuadbinLayer. */\nexport type QuadbinLayerProps<DataT = unknown> = _QuadbinLayerProps<DataT> &\n  GeoCellLayerProps<DataT>;\n\n/** Properties added by QuadbinLayer. */\ntype _QuadbinLayerProps<DataT> = {\n  /**\n   * Called for each data object to retrieve the quadbin string identifier.\n   *\n   * By default, it reads `quadbin` property of data object.\n   */\n  getQuadbin?: AccessorFunction<DataT, bigint>;\n};\n\nexport default class QuadbinLayer<DataT = any, ExtraProps extends {} = {}> extends GeoCellLayer<\n  DataT,\n  Required<_QuadbinLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'QuadbinLayer';\n  static defaultProps = defaultProps;\n\n  indexToBounds(): Partial<GeoCellLayer['props']> | null {\n    const {data, extruded, getQuadbin} = this.props;\n    // To avoid z-fighting reduce polygon footprint when extruding\n    const coverage = extruded ? 0.99 : 1;\n\n    return {\n      data,\n      _normalize: false,\n      positionFormat: 'XY',\n\n      getPolygon: (x: DataT, objectInfo) => getQuadbinPolygon(getQuadbin(x, objectInfo), coverage),\n      updateTriggers: {getPolygon: coverage}\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  DefaultProps,\n  Layer,\n  LayersList,\n  log\n} from '@deck.gl/core';\nimport {\n  TextLayer,\n  TextLayerProps,\n  _TextBackgroundLayer as TextBackgroundLayer\n} from '@deck.gl/layers';\nimport VectorTileLayer from './vector-tile-layer';\n\nconst [LEFT, TOP, RIGHT, BOTTOM] = [0, 1, 2, 3];\n\nclass EnhancedTextBackgroundLayer extends TextBackgroundLayer {\n  static layerName = 'EnhancedTextBackgroundLayer';\n\n  getShaders() {\n    const shaders = super.getShaders();\n    let vs = shaders.vs;\n\n    // Modify shader so that the padding is offset by the pixel offset to ensure the padding\n    // always captures the anchor point. As padding is uniform we cannot pass it a per-label value\n    vs = vs.replaceAll('textBackground.padding.', '_padding.');\n    vs = vs.replace(\n      'void main(void) {',\n      'void main(void) {\\n  vec4 _padding = textBackground.padding + instancePixelOffsets.xyxy * vec4(1.0, 1.0, -1.0, -1.0);'\n    );\n\n    return {...shaders, vs};\n  }\n}\n\n// TextLayer which includes modified text-background-layer-vertex shader and only renders the\n// primary background layer in the collision pass\nclass EnhancedTextLayer extends TextLayer {\n  static layerName = 'EnhancedTextLayer';\n\n  filterSubLayer({layer, renderPass}) {\n    const background = layer.id.includes('primary-background');\n    if (renderPass === 'collision') {\n      return background; // Only draw primary background layer in collision pass\n    }\n\n    return !background; // Do not draw background layer in other passes\n  }\n}\n\nconst defaultProps: DefaultProps<PointLabelLayerProps> = {\n  ...TextLayer.defaultProps,\n  getRadius: {type: 'accessor', value: 1},\n  radiusScale: {type: 'number', min: 0, value: 1}\n};\n\n/** All properties supported by PointLabelLayer. */\nexport type PointLabelLayerProps<DataT = unknown> = _PointLabelLayerProps<DataT> &\n  TextLayerProps &\n  CompositeLayerProps;\n\n/** Properties added by PointLabelLayer. */\ntype _PointLabelLayerProps<DataT> = TextLayerProps<DataT> & {\n  /**\n   * Radius multiplier.\n   * @default 1\n   */\n  radiusScale?: number;\n  /**\n   * Radius accessor.\n   * @default 1\n   */\n  getRadius?: Accessor<DataT, number>;\n  /**\n   * Secondary label text accessor\n   */\n  getSecondaryText?: Accessor<DataT, string>;\n  /**\n   * Secondary label color accessor\n   * @default [0, 0, 0, 255]\n   */\n  getSecondaryColor?: Accessor<DataT, Color>;\n  /**\n   * Secondary label color of outline around the text, in `[r, g, b, [a]]`. Each channel is a number between 0-255 and `a` is 255 if not supplied.\n   * @default [0, 0, 0, 255]\n   */\n  secondaryOutlineColor?: Color;\n  /**\n   * Secondary label text size multiplier.\n   * @default 1\n   */\n  secondarySizeScale?: number;\n};\n\n/**\n * PointLabelLayer is a layer that renders point labels.\n * It is a composite layer that renders a primary and secondary label.\n * It behaves like a TextLayer except that getTextSize is **not supported**\n * and the text size for the primary label must be set with **sizeScale**.\n */\nexport default class PointLabelLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_PointLabelLayerProps<DataT>>> {\n  static layerName = 'PointLabelLayer';\n  static defaultProps = defaultProps;\n\n  calculatePixelOffset(secondary) {\n    const {\n      getTextAnchor: anchor,\n      getAlignmentBaseline: alignment,\n      getRadius,\n      getSecondaryText,\n      radiusScale,\n      secondarySizeScale,\n      sizeScale\n    } = this.props;\n    const xMult = anchor === 'middle' ? 0 : anchor === 'start' ? 1 : -1;\n    const yMult = alignment === 'center' ? 0 : alignment === 'bottom' ? 1 : -1;\n\n    // Padding based on font size (font size / 4)\n    const xPadding = sizeScale / 4;\n    const yPadding = sizeScale * (1 + 1 / 4);\n\n    // Place secondary label under main label (secondary label always 'top' baseline aligned)\n    const secondaryOffset = 0.6 * (1 - yMult) * sizeScale;\n    let yOffset = secondary ? secondaryOffset : 0;\n\n    // Special case, position relative to secondary label\n    if (anchor === 'middle' && alignment === 'top' && getSecondaryText) {\n      yOffset -= secondaryOffset;\n      yOffset -= secondarySizeScale;\n      yOffset += sizeScale;\n    }\n\n    // Padding based on point radius (radius/ 4)\n    const radiusPadding = 1 + 1 / 4;\n\n    return typeof getRadius === 'function'\n      ? (d, info) => {\n          const r = (info ? getRadius(d, info) : 1) * radiusScale * radiusPadding;\n          return [xMult * (r + xPadding), yMult * (r + yPadding) + yOffset];\n        }\n      : [\n          xMult * (getRadius * radiusScale * radiusPadding + xPadding),\n          yMult * (getRadius * radiusScale * radiusPadding + yPadding) + yOffset\n        ];\n  }\n\n  calculateBackgroundPadding() {\n    const {getTextAnchor: anchor, getAlignmentBaseline: alignment, sizeScale} = this.props;\n\n    // Heuristics to avoid label overlap\n    const paddingX = 12 * sizeScale;\n    const paddingY = 3 * sizeScale;\n    const backgroundPadding = [0, 0, 0, 0];\n    if (alignment === 'top') {\n      backgroundPadding[TOP] = paddingY;\n    } else if (alignment === 'bottom') {\n      backgroundPadding[BOTTOM] = paddingY;\n    } else {\n      backgroundPadding[TOP] = 0.5 * paddingY;\n      backgroundPadding[BOTTOM] = 0.5 * paddingY;\n    }\n    if (anchor === 'start') {\n      backgroundPadding[LEFT] = paddingX;\n    } else if (anchor === 'end') {\n      backgroundPadding[RIGHT] = paddingX;\n    } else {\n      backgroundPadding[LEFT] = 0.5 * paddingX;\n      backgroundPadding[RIGHT] = 0.5 * paddingX;\n    }\n\n    return backgroundPadding;\n  }\n\n  renderTextLayer(id, {updateTriggers: updateTriggersOverride = {}, ...props}): EnhancedTextLayer {\n    const {\n      data,\n\n      characterSet,\n      fontFamily,\n      fontSettings,\n      fontWeight,\n      outlineColor,\n      outlineWidth,\n      sizeScale,\n      radiusScale,\n\n      getAlignmentBaseline,\n      getColor,\n      getPosition,\n      getTextAnchor,\n\n      updateTriggers\n    } = this.props;\n\n    if (sizeScale < 2) {\n      const propName = (this.parent as VectorTileLayer)?.props?.textSizeScale\n        ? 'textSizeScale'\n        : 'sizeScale';\n      log.warn(\n        `${propName} has small value (${sizeScale}). Note getTextSize is not supported on PointLabelLayer`\n      )();\n    }\n\n    return new EnhancedTextLayer(\n      this.getSubLayerProps({\n        id,\n        data,\n\n        characterSet,\n        fontFamily,\n        fontSettings,\n        fontWeight,\n        outlineColor,\n        outlineWidth,\n        sizeScale,\n\n        getAlignmentBaseline,\n        getColor,\n        getPosition,\n        getTextAnchor,\n\n        updateTriggers: {\n          ...updateTriggers,\n          ...updateTriggersOverride,\n          getPixelOffset: [\n            updateTriggers.getRadius,\n            updateTriggers.getTextAnchor,\n            updateTriggers.getAlignmentBaseline,\n            radiusScale,\n            sizeScale\n          ]\n        }\n      }),\n      {\n        getSize: 1,\n        _subLayerProps: {background: {type: EnhancedTextBackgroundLayer}}\n      },\n      props\n    );\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const {\n      getText,\n      getSecondaryColor,\n      getSecondaryText,\n      secondaryOutlineColor,\n      secondarySizeScale,\n      updateTriggers\n    } = this.props;\n    const getPixelOffset = this.calculatePixelOffset(false);\n    const backgroundPadding = this.calculateBackgroundPadding();\n    const out = [\n      // Text doesn't update via updateTrigger for some reason\n      this.renderTextLayer(`${updateTriggers.getText}-primary`, {\n        backgroundPadding,\n        getText,\n        getPixelOffset,\n        background: true // Only use background for primary label for faster collisions\n      }),\n      Boolean(getSecondaryText) &&\n        this.renderTextLayer(`${updateTriggers.getSecondaryText}-secondary`, {\n          getText: getSecondaryText,\n          getPixelOffset: this.calculatePixelOffset(true),\n          getAlignmentBaseline: 'top',\n          // updateTriggers: {getText: updateTriggers.getSecondaryText},\n\n          // Optional overrides\n          ...(getSecondaryColor && {getColor: getSecondaryColor}),\n          ...(secondarySizeScale && {sizeScale: secondarySizeScale}),\n          ...(secondaryOutlineColor && {outlineColor: secondaryOutlineColor})\n        })\n    ];\n\n    return out;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  CompositeLayerProps,\n  DefaultProps,\n  FilterContext,\n  Layer,\n  LayersList\n} from '@deck.gl/core';\nimport RasterLayer, {RasterLayerProps} from './raster-layer';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport {TileLayer, TileLayerProps} from '@deck.gl/geo-layers';\nimport {copy, PostProcessModifier} from './post-process-utils';\nimport {registerLoaders} from '@loaders.gl/core';\nimport CartoRasterTileLoader from './schema/carto-raster-tile-loader';\n\nregisterLoaders([CartoRasterTileLoader]);\n\nexport const renderSubLayers = props => {\n  const tileIndex = props.tile?.index?.q;\n  if (!tileIndex) return null;\n  return new RasterLayer(props, {tileIndex});\n};\n\nconst defaultProps: DefaultProps<RasterTileLayerProps> = {\n  data: TilejsonPropType,\n  refinementStrategy: 'no-overlap',\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by RasterTileLayer. */\nexport type RasterTileLayerProps<DataT = unknown> = _RasterTileLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by RasterTileLayer. */\ntype _RasterTileLayerProps<DataT> = Omit<RasterLayerProps<DataT>, 'data'> &\n  Omit<TileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nclass PostProcessTileLayer extends PostProcessModifier(TileLayer, copy) {\n  filterSubLayer(context: FilterContext) {\n    // Handle DrawCallbackLayer\n    const {tile} = (context.layer as Layer<{tile: any}>).props;\n    if (!tile) return true;\n\n    return super.filterSubLayer(context);\n  }\n}\n\nexport default class RasterTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_RasterTileLayerProps<DataT>>> {\n  static layerName = 'RasterTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}}\n    });\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, minzoom: minZoom, maxzoom: maxZoom, raster_metadata: metadata} = tileJSON;\n    const SubLayerClass = this.getSubLayerClass('tile', PostProcessTileLayer);\n    const loadOptions = this.getLoadOptions();\n    return new SubLayerClass(this.props, {\n      id: `raster-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: QuadbinTileset2D as any,\n      renderSubLayers,\n      minZoom,\n      maxZoom,\n      loadOptions: {\n        ...loadOptions,\n        cartoRasterTile: {...loadOptions?.cartoRasterTile, metadata}\n      }\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayersList,\n  DefaultProps,\n  PickingInfo\n} from '@deck.gl/core';\nimport {ColumnLayer, ColumnLayerProps} from '@deck.gl/layers';\nimport {quadbinToOffset} from './quadbin-utils';\nimport {Raster} from './schema/carto-raster-tile-loader';\nimport vs from './raster-layer-vertex.glsl';\nimport {createBinaryProxy} from '../utils';\nimport {RTTModifier} from './post-process-utils';\n\nconst defaultProps: DefaultProps<RasterLayerProps> = {\n  ...ColumnLayer.defaultProps,\n  extruded: false,\n  diskResolution: 4,\n  vertices: [\n    [-0.5, -0.5],\n    [0.5, -0.5],\n    [0.5, 0.5],\n    [-0.5, 0.5]\n  ]\n};\n\n// Modified ColumnLayer with custom vertex shader\n// Use RTT to avoid inter-tile seams\nclass RasterColumnLayer extends RTTModifier(ColumnLayer) {\n  static layerName = 'RasterColumnLayer';\n\n  getShaders() {\n    const shaders = super.getShaders();\n    const data = this.props.data as unknown as {data: Raster; length: number};\n    const BLOCK_WIDTH = data.data.blockSize ?? Math.sqrt(data.length);\n    return {...shaders, defines: {...shaders.defines, BLOCK_WIDTH}, vs};\n  }\n\n  initializeState() {\n    // Only add attributes needed by shader\n    const attributeManager = this.getAttributeManager()!;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: [255, 255, 255, 255]\n      }\n    });\n  }\n}\n\n/** All properties supported by RasterLayer. */\nexport type RasterLayerProps<DataT = unknown> = _RasterLayerProps &\n  ColumnLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by RasterLayer. */\ntype _RasterLayerProps = {\n  /**\n   * Quadbin index of tile\n   */\n  tileIndex: bigint;\n};\n\ntype RasterColumnLayerData = {\n  data: Raster;\n  length: number;\n};\n\nfunction wrappedDataComparator(oldData: RasterColumnLayerData, newData: RasterColumnLayerData) {\n  return oldData.data === newData.data && oldData.length === newData.length;\n}\n\n// Adapter layer around RasterColumnLayer that converts data & accessors into correct format\nexport default class RasterLayer<DataT = any, ExtraProps = {}> extends CompositeLayer<\n  Required<RasterLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'RasterLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    highlightedObjectIndex: number;\n    highlightColor: number[];\n  };\n\n  renderLayers(): Layer | null | LayersList {\n    // Rendering props underlying layer\n    const {\n      data,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      tileIndex,\n      updateTriggers\n    } = this.props as typeof this.props & {data: Raster};\n    if (!data || !tileIndex) return null;\n\n    const blockSize = data.blockSize ?? 0;\n    const [xOffset, yOffset, scale] = quadbinToOffset(tileIndex);\n    const offset = [xOffset, yOffset];\n    const lineWidthScale = scale / blockSize;\n\n    // Filled Column Layer\n    const CellLayer = this.getSubLayerClass('column', RasterColumnLayer);\n    const {highlightedObjectIndex, highlightColor} = this.state;\n    return new CellLayer(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell',\n        updateTriggers,\n\n        getElevation: this.getSubLayerAccessor(getElevation),\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(getLineColor),\n        getLineWidth: this.getSubLayerAccessor(getLineWidth)\n      }),\n      {\n        data: {\n          data, // Pass through data for getSubLayerAccessor()\n          length: blockSize * blockSize\n        },\n        dataComparator: wrappedDataComparator,\n        offset,\n        lineWidthScale, // Re-use widthScale prop to pass cell scale,\n        highlightedObjectIndex,\n        highlightColor,\n\n        // RTT requires blending otherwise opacity < 1 blends with black\n        // render target\n        parameters: {\n          blendColorSrcFactor: 'one',\n          blendAlphaSrcFactor: 'one',\n          blendColorDstFactor: 'zero',\n          blendAlphaDstFactor: 'zero',\n          blendColorOperation: 'add',\n          blendAlphaOperation: 'add'\n        }\n      }\n    );\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    if (typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    // Proxy values back in standard feature format\n    return (object, info) => {\n      const {data, index} = info;\n      const binaryData = (data as unknown as {data: Raster}).data;\n      const proxy = createBinaryProxy(binaryData.cells, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor({properties: proxy}, info);\n    };\n  }\n\n  getPickingInfo(params: any) {\n    const info = super.getPickingInfo(params);\n\n    if (info.index !== -1) {\n      info.object = this.getSubLayerAccessor((x: any) => x)(undefined, {\n        data: this.props,\n        index: info.index\n      });\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info: PickingInfo) {\n    const {highlightedObjectIndex} = this.state;\n    let newHighlightedObjectIndex: number = -1;\n\n    if (info.index !== -1) {\n      newHighlightedObjectIndex = info.index;\n    }\n\n    if (highlightedObjectIndex !== newHighlightedObjectIndex) {\n      let {highlightColor} = this.props;\n      if (typeof highlightColor === 'function') {\n        highlightColor = highlightColor(info);\n      }\n\n      this.setState({\n        highlightColor,\n        highlightedObjectIndex: newHighlightedObjectIndex\n      });\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME raster-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin float instanceElevations;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\n\nin vec3 instancePickingColors;\n\n// Result\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  // Rather than positioning using attribute, layout pixel grid using gl_InstanceID\n  vec2 tileOrigin = column.offset.xy;\n  float scale = column.widthScale; // Re-use widthScale prop to pass cell scale\n\n  int yIndex = - (gl_InstanceID / BLOCK_WIDTH);\n  int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);\n\n  // Avoid precision issues by applying 0.5 offset here, rather than when laying out vertices\n  vec2 cellCenter = scale * vec2(float(xIndex) + 0.5, float(yIndex) - 0.5);\n\n  vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\n\n  // if alpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float cellWidth = column.coverage * scale;\n\n  // Get position directly from quadbin, rather than projecting\n  // Important to set geometry.position before using project_ methods below\n  // as geometry.worldPosition is not set (we don't know our lat/long)\n  geometry.position = vec4(tileOrigin, 0.0, 1.0);\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    geometry.position.xyz -= project.commonOrigin;\n  }\n\n  // Important to apply after tileOrigin & commonOrigin as they are large values which often\n  // cancel and thus cellCenter precision is lost if applied first.\n  geometry.position.xy += cellCenter;\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar geometry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n  // calculate stroke offset\n  float strokeOffsetRatio = 1.0;\n\n  if (column.extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n  } else if (column.stroked) {\n    float halfOffset = project_pixel_size(column.widthScale) / cellWidth;\n    if (column.isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n\n  geometry.pickingColor = instancePickingColors;\n\n  // Cell coordinates centered on origin\n  vec2 base = positions.xy * scale * strokeOffsetRatio * column.coverage * shouldRender;\n  vec3 cell = vec3(base, project_size(elevation));\n  DECKGL_FILTER_SIZE(cell, geometry);\n\n  geometry.position.xyz += cell;\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n\n  geometry.normal = project_normal(normals);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Light calculations\n  if (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n  }\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\n\nconst ARRAY_TYPES = {\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  uint64: BigUint64Array,\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  int64: BigInt64Array,\n  float32: Float32Array,\n  float64: Float64Array\n};\n\n// Band ========================================\n\nexport class BandReader {\n  static read(pbf, end?: number) {\n    return pbf.readFields(BandReader._readField, {name: '', type: '', data: null}, end);\n  }\n\n  static _readField(this: void, tag, obj, pbf) {\n    if (tag === 1) obj.name = pbf.readString();\n    else if (tag === 2) obj.type = pbf.readString();\n    else if (tag === 3) {\n      const TypedArray = ARRAY_TYPES[obj.type];\n      if (!TypedArray) {\n        throw Error(`Invalid data type: ${obj.type}`);\n      }\n      obj.data = {};\n      const {compression} = TileReader;\n      readPackedTypedArray(TypedArray, pbf, obj.data, {compression});\n    }\n  }\n}\n\nexport class TileReader {\n  public static compression: null | 'gzip';\n  static read(pbf, end) {\n    return pbf.readFields(TileReader._readField, {blockSize: 0, bands: []}, end);\n  }\n  static _readField(this: void, tag, obj, pbf) {\n    if (tag === 1) obj.blockSize = pbf.readVarint();\n    else if (tag === 2) obj.bands.push(BandReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {RasterMetadata} from '@carto/api-client';\n\nimport {TileReader} from './carto-raster-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\nimport {NumericProps, Properties} from './spatialjson-utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoRasterTile';\n\ntype CartoRasterTileLoaderOptions = LoaderOptions & {\n  cartoRasterTile?: {\n    metadata: RasterMetadata | null;\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoRasterTileLoaderOptions = {\n  cartoRasterTile: {\n    metadata: null,\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoRasterTileLoader: LoaderWithParser = {\n  name: 'CARTO Raster Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-raster-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoRasterTileLoaderOptions) =>\n    parseCartoRasterTile(arrayBuffer, options),\n  parseSync: parseCartoRasterTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nexport type Raster = {\n  /** Raster tiles are square, with 'blockSize' width and height in pixels. */\n  blockSize: number;\n  cells: {\n    numericProps: NumericProps;\n    properties: Properties[];\n  };\n};\n\nfunction parseCartoRasterTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoRasterTileLoaderOptions\n): Raster | null {\n  const metadata = options?.cartoRasterTile?.metadata;\n  if (!arrayBuffer || !metadata) return null;\n  // @ts-expect-error Upstream type needs to be updated\n  TileReader.compression = metadata.compression;\n  const out = parsePbf(arrayBuffer, TileReader);\n  const {bands, blockSize} = out;\n\n  const numericProps = {};\n  for (let i = 0; i < bands.length; i++) {\n    const {name, data} = bands[i];\n    numericProps[name] = data;\n  }\n  return {blockSize, cells: {numericProps, properties: []}};\n}\n\nexport default CartoRasterTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {registerLoaders} from '@loaders.gl/core';\nimport {BinaryFeatureCollection, BinaryPointFeature} from '@loaders.gl/schema';\nimport CartoPropertiesTileLoader from './schema/carto-properties-tile-loader';\nimport CartoVectorTileLoader from './schema/carto-vector-tile-loader';\nregisterLoaders([CartoPropertiesTileLoader, CartoVectorTileLoader]);\n\nimport {DefaultProps, Layer, LayersList} from '@deck.gl/core';\nimport {ClipExtension, CollisionFilterExtension} from '@deck.gl/extensions';\nimport {\n  MVTLayer,\n  MVTLayerProps,\n  TileLayer,\n  _getURLFromTemplate,\n  _Tile2DHeader,\n  _TileLoadProps as TileLoadProps,\n  GeoBoundingBox\n} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions, mergeBoundaryData} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport {createPointsFromLines, createPointsFromPolygons} from './label-utils';\nimport {createEmptyBinary} from '../utils';\nimport PointLabelLayer from './point-label-layer';\n\nconst defaultProps: DefaultProps<VectorTileLayerProps> = {\n  ...MVTLayer.defaultProps,\n  autoLabels: false,\n  data: TilejsonPropType,\n  dataComparator: TilejsonPropType.equal,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by VectorTileLayer. */\nexport type VectorTileLayerProps<FeaturePropertiesT = unknown> = _VectorTileLayerProps &\n  Omit<MVTLayerProps<FeaturePropertiesT>, 'data'>;\n\n/** Properties added by VectorTileLayer. */\ntype _VectorTileLayerProps = {\n  data: null | TilejsonResult | Promise<TilejsonResult>;\n\n  /**\n   * If true, create labels for lines and polygons.\n   * Specify uniqueIdProperty to only create a single label for each unique feature.\n   */\n  autoLabels?: boolean | {uniqueIdProperty: string};\n};\n\n// @ts-ignore\nexport default class VectorTileLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends MVTLayer<FeaturePropertiesT, Required<_VectorTileLayerProps> & ExtraProps> {\n  static layerName = 'VectorTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: MVTLayer['state'] & {\n    mvt: boolean;\n  };\n\n  constructor(...propObjects: VectorTileLayerProps<FeaturePropertiesT>[]) {\n    // Force externally visible props type, as it is not possible modify via extension\n    // @ts-ignore\n    super(...propObjects);\n  }\n\n  initializeState(): void {\n    super.initializeState();\n    this.setState({binary: true});\n  }\n\n  updateState(parameters) {\n    const {props} = parameters;\n    if (props.data) {\n      super.updateState(parameters);\n\n      const formatTiles = new URL(props.data.tiles[0]).searchParams.get('formatTiles');\n      const mvt = formatTiles === 'mvt';\n      this.setState({mvt});\n    }\n  }\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      gis: {format: 'binary'} // Use binary for MVT loading\n    });\n  }\n\n  /* eslint-disable camelcase */\n  async getTileData(tile: TileLoadProps) {\n    const tileJSON = this.props.data as TilejsonResult;\n    const {tiles, properties_tiles} = tileJSON;\n    const url = _getURLFromTemplate(tiles, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    const loadOptions = this.getLoadOptions();\n    const {fetch} = this.props;\n    const {signal} = tile;\n\n    // Fetch geometry and attributes separately\n    const geometryFetch = fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n\n    if (!properties_tiles) {\n      return await geometryFetch;\n    }\n\n    const propertiesUrl = _getURLFromTemplate(properties_tiles, tile);\n    if (!propertiesUrl) {\n      return Promise.reject('Invalid properties URL');\n    }\n\n    const attributesFetch = fetch(propertiesUrl, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n    const [geometry, attributes] = await Promise.all([geometryFetch, attributesFetch]);\n    if (!geometry) return null;\n\n    return attributes ? mergeBoundaryData(geometry, attributes) : geometry;\n  }\n  /* eslint-enable camelcase */\n\n  renderSubLayers(\n    props: VectorTileLayer['props'] & {\n      id: string;\n      data: any;\n      _offset: number;\n      tile: _Tile2DHeader;\n    }\n  ): GeoJsonLayer | GeoJsonLayer[] | null {\n    if (props.data === null) {\n      return null;\n    }\n\n    const tileBbox = props.tile.bbox as GeoBoundingBox;\n\n    const subLayers: GeoJsonLayer[] = [];\n\n    const defaultToPointLabelLayer = {\n      'points-text': {\n        type: PointLabelLayer,\n        ...props?._subLayerProps?.['points-text'],\n        extensions: [\n          new CollisionFilterExtension(),\n          ...(props.extensions || []),\n          ...(props?._subLayerProps?.['points-text']?.extensions || [])\n        ]\n      }\n    };\n\n    if (this.state.mvt) {\n      subLayers.push(super.renderSubLayers(props) as GeoJsonLayer);\n    } else {\n      const {west, south, east, north} = tileBbox;\n\n      const extensions = [new ClipExtension(), ...(props.extensions || [])];\n      const clipProps = {\n        clipBounds: [west, south, east, north]\n      };\n\n      const applyClipExtensionToSublayerProps = (subLayerId: string) => {\n        return {\n          [subLayerId]: {\n            ...clipProps,\n            ...props?._subLayerProps?.[subLayerId],\n            extensions: [...extensions, ...(props?._subLayerProps?.[subLayerId]?.extensions || [])]\n          }\n        };\n      };\n\n      const subLayerProps = {\n        ...props,\n        data: {...props.data, tileBbox},\n        autoHighlight: false,\n        // Do not perform clipping on points (#9059)\n        _subLayerProps: {\n          ...props._subLayerProps,\n          ...defaultToPointLabelLayer,\n          ...applyClipExtensionToSublayerProps('polygons-fill'),\n          ...applyClipExtensionToSublayerProps('polygons-stroke'),\n          ...applyClipExtensionToSublayerProps('linestrings')\n        }\n      };\n\n      subLayers.push(new GeoJsonLayer(subLayerProps));\n    }\n\n    // Add labels\n    if (subLayers[0] && props.autoLabels) {\n      const labelData = createEmptyBinary();\n      if (props.data.lines && props.data.lines.positions.value.length > 0) {\n        labelData.points = createPointsFromLines(\n          props.data.lines,\n          typeof props.autoLabels === 'object' ? props.autoLabels.uniqueIdProperty : undefined\n        ) as BinaryPointFeature;\n      }\n      if (props.data.polygons && props.data.polygons.positions.value.length > 0) {\n        labelData.points = createPointsFromPolygons(props.data.polygons, tileBbox, props);\n      }\n\n      subLayers.push(\n        subLayers[0].clone({\n          id: `${props.id}-labels`,\n          data: labelData,\n          pickable: false,\n          autoHighlight: false\n        })\n      );\n    }\n    return subLayers;\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const layers = super.renderLayers() as LayersList;\n    if (!this.props.autoLabels) {\n      return layers;\n    }\n\n    // Sort layers so that label layers are rendered after the main layer\n    const validLayers = layers.flat().filter(Boolean) as Layer[];\n    validLayers.sort((a: Layer, b: Layer) => {\n      const aHasLabel = a.id.includes('labels');\n      const bHasLabel = b.id.includes('labels');\n      if (aHasLabel && !bHasLabel) return 1;\n      if (!aHasLabel && bHasLabel) return -1;\n      return 0;\n    });\n    return validLayers.map(l =>\n      l.id.includes('labels') ? l.clone({highlightedObjectIndex: -1}) : l\n    );\n  }\n\n  protected override _isWGS84(): boolean {\n    // CARTO binary tile coordinates are [lng, lat], not tile-relative like MVT.\n    if (this.state.mvt) return super._isWGS84();\n    return true;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumericProp, NumericPropKeyValueReader, PropertiesReader} from './carto-tile';\n\n// Tile ========================================\n\nexport interface Tile {\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {properties: [], numericProps: {}}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 2) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\n\nimport {Tile, TileReader} from './carto-properties-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoPropertiesTile';\n\ntype CartoPropertiesTileLoaderOptions = LoaderOptions & {\n  cartoPropertiesTile?: {\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoPropertiesTileLoaderOptions = {\n  cartoPropertiesTile: {\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoPropertiesTileLoader: LoaderWithParser = {\n  name: 'CARTO Properties Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-properties-tile'],\n  category: 'geometry',\n  worker: true,\n  parse: async (arrayBuffer, options) => parseCartoPropertiesTile(arrayBuffer, options),\n  parseSync: parseCartoPropertiesTile,\n  options: DEFAULT_OPTIONS\n};\n\nfunction parseCartoPropertiesTile(arrayBuffer: ArrayBuffer, options?: LoaderOptions): Tile | null {\n  if (!arrayBuffer) return null;\n  return parsePbf(arrayBuffer, TileReader);\n}\n\nexport default CartoPropertiesTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport earcut from 'earcut';\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {BinaryFeatureCollection, BinaryPolygonFeature, TypedArray} from '@loaders.gl/schema';\n\nimport {TileReader} from './carto-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoVectorTile';\n\ntype CartoVectorTileLoaderOptions = LoaderOptions & {\n  cartoVectorTile?: {\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoVectorTileLoaderOptions = {\n  cartoVectorTile: {\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoVectorTileLoader: LoaderWithParser = {\n  name: 'CARTO Vector Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-vector-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoVectorTileLoaderOptions) =>\n    parseCartoVectorTile(arrayBuffer, options),\n  parseSync: parseCartoVectorTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nfunction triangulatePolygon(\n  polygons: BinaryPolygonFeature,\n  target: number[],\n  {\n    startPosition,\n    endPosition,\n    indices\n  }: {startPosition: number; endPosition: number; indices: TypedArray}\n): void {\n  const coordLength = polygons.positions.size;\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.value.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const holes = indices.slice(1).map((n: number) => n - startPosition);\n\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    target.push(startPosition + triangles[t]);\n  }\n}\n\nfunction triangulate(polygons: BinaryPolygonFeature) {\n  const {polygonIndices, primitivePolygonIndices} = polygons;\n  const triangles = [];\n\n  let rangeStart = 0;\n  for (let i = 0; i < polygonIndices.value.length - 1; i++) {\n    const startPosition = polygonIndices.value[i];\n    const endPosition = polygonIndices.value[i + 1];\n\n    // Extract hole indices between start & end position\n    const rangeEnd = primitivePolygonIndices.value.indexOf(endPosition);\n    const indices = primitivePolygonIndices.value.subarray(rangeStart, rangeEnd);\n    rangeStart = rangeEnd;\n\n    triangulatePolygon(polygons, triangles, {startPosition, endPosition, indices});\n  }\n\n  polygons.triangles = {value: new Uint32Array(triangles), size: 1};\n}\n\nfunction parseCartoVectorTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoVectorTileLoaderOptions\n): BinaryFeatureCollection | null {\n  if (!arrayBuffer) return null;\n  const tile = parsePbf(arrayBuffer, TileReader);\n\n  if (tile.polygons && !tile.polygons.triangles) {\n    triangulate(tile.polygons);\n  }\n\n  return tile;\n}\n\nexport default CartoVectorTileLoader;\n", "import {GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {TypedArray} from '@loaders.gl/loader-utils';\nimport {BinaryPointFeature, BinaryLineFeature, BinaryPolygonFeature} from '@loaders.gl/schema';\nimport {copyNumericProps, createBinaryPointFeature, initializeNumericProps} from '../utils';\n\ntype Vec2 = [number, number] | TypedArray;\ntype TileBBox = GeoBoundingBox;\ntype Properties = BinaryPointFeature['properties'];\ntype LineInfo = {index: number; length: number};\n\nexport function createPointsFromLines(\n  lines: BinaryLineFeature,\n  uniqueIdProperty?: string\n): BinaryPointFeature | null {\n  const hasNumericUniqueId = uniqueIdProperty ? uniqueIdProperty in lines.numericProps : false;\n  const idToLineInfo = new Map<string | number | undefined, LineInfo>();\n\n  // First pass: find the longest line for each unique ID\n  // If we don't have a uniqueIdProperty, treat each line as unique\n  for (let i = 0; i < lines.pathIndices.value.length - 1; i++) {\n    const pathIndex = lines.pathIndices.value[i];\n    const featureId = lines.featureIds.value[pathIndex];\n    let uniqueId: string | number | undefined;\n\n    if (uniqueIdProperty === undefined) {\n      uniqueId = featureId;\n    } else if (hasNumericUniqueId) {\n      uniqueId = lines.numericProps[uniqueIdProperty].value[pathIndex];\n    } else if (lines.properties[featureId] && uniqueIdProperty in lines.properties[featureId]) {\n      uniqueId = lines.properties[featureId][uniqueIdProperty];\n    } else {\n      uniqueId = undefined;\n    }\n    const length = getLineLength(lines, i);\n    if (!idToLineInfo.has(uniqueId) || length > idToLineInfo.get(uniqueId)!.length) {\n      idToLineInfo.set(uniqueId, {index: i, length});\n    }\n  }\n\n  const positions: number[] = [];\n  const properties: Properties = [];\n  const featureIds: number[] = [];\n  const globalFeatureIds: number[] = [];\n  const numericProps = initializeNumericProps(idToLineInfo.size, lines.numericProps);\n\n  // Second pass: create points for the longest line of each unique ID\n  let pointIndex = 0;\n  for (const [_, {index}] of idToLineInfo) {\n    const midpoint = getLineMidpoint(lines, index);\n    positions.push(...midpoint);\n\n    const pathIndex = lines.pathIndices.value[index];\n    const featureId = lines.featureIds.value[pathIndex];\n    featureIds.push(pointIndex);\n    properties.push(lines.properties[featureId]);\n    globalFeatureIds.push(lines.globalFeatureIds.value[pathIndex]);\n    copyNumericProps(lines.numericProps, numericProps, pathIndex, pointIndex);\n    pointIndex++;\n  }\n\n  return createBinaryPointFeature(\n    positions,\n    featureIds,\n    globalFeatureIds,\n    numericProps,\n    properties\n  );\n}\n\nexport function createPointsFromPolygons(\n  polygons: Required<BinaryPolygonFeature>,\n  tileBbox: TileBBox,\n  props: any\n): BinaryPointFeature {\n  const {west, south, east, north} = tileBbox;\n  const tileArea = (east - west) * (north - south);\n  const minPolygonArea = tileArea * 0.0001; // 0.1% threshold\n\n  const positions: number[] = [];\n  const properties: Properties = [];\n  const featureIds: number[] = [];\n  const globalFeatureIds: number[] = [];\n  const numericProps = initializeNumericProps(\n    polygons.polygonIndices.value.length - 1,\n    polygons.numericProps\n  );\n\n  // Process each polygon\n  let pointIndex = 0;\n  let triangleIndex = 0;\n  const {extruded} = props;\n  for (let i = 0; i < polygons.polygonIndices.value.length - 1; i++) {\n    const startIndex = polygons.polygonIndices.value[i];\n    const endIndex = polygons.polygonIndices.value[i + 1];\n\n    // Skip small polygons\n    if (getPolygonArea(polygons, i) < minPolygonArea) {\n      continue;\n    }\n\n    const centroid = getPolygonCentroid(polygons, i);\n    let maxArea = -1;\n    let largestTriangleCenter: [number, number] = [0, 0];\n    let centroidIsInside = false;\n\n    // Scan triangles until we find ones that don't belong to this polygon\n    while (triangleIndex < polygons.triangles.value.length) {\n      const i1 = polygons.triangles.value[triangleIndex];\n\n      // If we've moved past the current polygon's triangles, break\n      if (i1 >= endIndex) {\n        break;\n      }\n\n      // If we've already found a triangle containing the centroid, skip the rest\n      if (centroidIsInside) {\n        triangleIndex += 3;\n        continue;\n      }\n\n      const i2 = polygons.triangles.value[triangleIndex + 1];\n      const i3 = polygons.triangles.value[triangleIndex + 2];\n      const v1 = polygons.positions.value.subarray(\n        i1 * polygons.positions.size,\n        i1 * polygons.positions.size + polygons.positions.size\n      );\n      const v2 = polygons.positions.value.subarray(\n        i2 * polygons.positions.size,\n        i2 * polygons.positions.size + polygons.positions.size\n      );\n      const v3 = polygons.positions.value.subarray(\n        i3 * polygons.positions.size,\n        i3 * polygons.positions.size + polygons.positions.size\n      );\n\n      if (isPointInTriangle(centroid, v1, v2, v3)) {\n        centroidIsInside = true;\n      } else {\n        const area = getTriangleArea(v1, v2, v3);\n        if (area > maxArea) {\n          maxArea = area;\n          largestTriangleCenter = [(v1[0] + v2[0] + v3[0]) / 3, (v1[1] + v2[1] + v3[1]) / 3];\n        }\n      }\n\n      triangleIndex += 3;\n    }\n\n    const labelPoint = centroidIsInside ? centroid : largestTriangleCenter;\n    if (isPointInBounds(labelPoint, tileBbox)) {\n      positions.push(...labelPoint);\n      const featureId = polygons.featureIds.value[startIndex];\n      if (extruded) {\n        const elevation = props.getElevation(undefined, {\n          data: polygons,\n          index: featureId\n        });\n        positions.push(elevation * props.elevationScale);\n      }\n      properties.push(polygons.properties[featureId]);\n      featureIds.push(pointIndex);\n      globalFeatureIds.push(polygons.globalFeatureIds.value[startIndex]);\n      copyNumericProps(polygons.numericProps, numericProps, startIndex, pointIndex);\n      pointIndex++;\n    }\n  }\n\n  // Trim numeric properties arrays to actual size\n  if (polygons.numericProps) {\n    Object.keys(numericProps).forEach(prop => {\n      numericProps[prop].value = numericProps[prop].value.slice(0, pointIndex);\n    });\n  }\n\n  return createBinaryPointFeature(\n    positions,\n    featureIds,\n    globalFeatureIds,\n    numericProps,\n    properties,\n    extruded ? 3 : 2\n  );\n}\n\n// Helper functions\nfunction getPolygonArea(polygons: Required<BinaryPolygonFeature>, index: number): number {\n  const {\n    positions: {value: positions, size},\n    polygonIndices: {value: indices},\n    triangles: {value: triangles}\n  } = polygons;\n\n  const startIndex = indices[index];\n  const endIndex = indices[index + 1];\n  let area = 0;\n  let triangleIndex = 0;\n\n  // Find first triangle of this polygon\n  // Note: this assumes tirnagles and polygon indices are sorted.\n  // This is true for the current implementation of geojsonToBinary\n  while (triangleIndex < triangles.length) {\n    const i1 = triangles[triangleIndex];\n    if (i1 >= startIndex) break;\n    triangleIndex += 3;\n  }\n\n  // Process triangles until we hit the next polygon\n  while (triangleIndex < triangles.length) {\n    const i1 = triangles[triangleIndex];\n    if (i1 >= endIndex) break;\n\n    const i2 = triangles[triangleIndex + 1];\n    const i3 = triangles[triangleIndex + 2];\n    const v1 = positions.subarray(i1 * size, i1 * size + size);\n    const v2 = positions.subarray(i2 * size, i2 * size + size);\n    const v3 = positions.subarray(i3 * size, i3 * size + size);\n\n    area += getTriangleArea(v1, v2, v3);\n    triangleIndex += 3;\n  }\n\n  return area;\n}\n\nfunction isPointInBounds([x, y]: [number, number], {west, east, south, north}: TileBBox): boolean {\n  return x >= west && x < east && y >= south && y < north;\n}\n\nfunction isPointInTriangle(p: Vec2, v1: Vec2, v2: Vec2, v3: Vec2): boolean {\n  const area = Math.abs((v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1])) / 2;\n  const area1 = Math.abs((v1[0] - p[0]) * (v2[1] - p[1]) - (v2[0] - p[0]) * (v1[1] - p[1])) / 2;\n  const area2 = Math.abs((v2[0] - p[0]) * (v3[1] - p[1]) - (v3[0] - p[0]) * (v2[1] - p[1])) / 2;\n  const area3 = Math.abs((v3[0] - p[0]) * (v1[1] - p[1]) - (v1[0] - p[0]) * (v3[1] - p[1])) / 2;\n\n  // Account for floating point precision\n  return Math.abs(area - (area1 + area2 + area3)) < 1e-10;\n}\n\nfunction getTriangleArea([x1, y1]: Vec2, [x2, y2]: Vec2, [x3, y3]: Vec2): number {\n  return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);\n}\n\nfunction getPolygonCentroid(polygons: BinaryPolygonFeature, index: number): [number, number] {\n  const {\n    positions: {value: positions, size}\n  } = polygons;\n  const startIndex = size * polygons.polygonIndices.value[index];\n  const endIndex = size * polygons.polygonIndices.value[index + 1];\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    const [x, y] = positions.subarray(i, i + 2);\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [(minX + maxX) / 2, (minY + maxY) / 2];\n}\n\nfunction getSegmentLength(lines: BinaryLineFeature, index: number): number {\n  const {\n    positions: {value}\n  } = lines;\n  const [x1, y1, x2, y2] = value.subarray(index, index + 4);\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\nfunction getLineLength(lines: BinaryLineFeature, index: number): number {\n  const {\n    positions: {size}\n  } = lines;\n  const startIndex = size * lines.pathIndices.value[index];\n  const endIndex = size * lines.pathIndices.value[index + 1];\n  let length = 0;\n  for (let j = startIndex; j < endIndex; j += size) {\n    length += getSegmentLength(lines, j);\n  }\n  return length;\n}\n\nfunction getLineMidpoint(lines: BinaryLineFeature, index: number): [number, number] {\n  const {\n    positions: {value: positions},\n    pathIndices: {value: pathIndices}\n  } = lines;\n  const startIndex = pathIndices[index] * 2;\n  const endIndex = pathIndices[index + 1] * 2;\n  const numPoints = (endIndex - startIndex) / 2;\n\n  if (numPoints === 2) {\n    // For lines with only two vertices, interpolate between them\n    const [x1, y1, x2, y2] = positions.subarray(startIndex, startIndex + 4);\n    return [(x1 + x2) / 2, (y1 + y2) / 2];\n  }\n  // For lines with multiple vertices, use the middle vertex\n  const midPointIndex = startIndex + Math.floor(numPoints / 2) * 2;\n  return [positions[midPointIndex], positions[midPointIndex + 1]];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CartoAPIError, APIErrorContext} from '@carto/api-client';\nimport {GoogleBasemapProps} from './api/types';\n\nconst cartoStyleUrlTemplate = 'https://basemaps.cartocdn.com/gl/{basemap}-gl-style/style.json';\n\nexport const CARTO_MAP_STYLES = ['positron', 'dark-matter', 'voyager'];\n\nexport const GOOGLE_BASEMAPS: Record<string, GoogleBasemapProps> = {\n  roadmap: {\n    mapTypeId: 'roadmap',\n    mapId: '3754c817b510f791'\n  },\n  'google-positron': {\n    mapTypeId: 'roadmap',\n    mapId: 'ea84ae4203ef21cd'\n  },\n  'google-dark-matter': {\n    mapTypeId: 'roadmap',\n    mapId: '2fccc3b36c22a0e2'\n  },\n  'google-voyager': {\n    mapTypeId: 'roadmap',\n    mapId: '885caf1e15bb9ef2'\n  },\n  satellite: {\n    mapTypeId: 'satellite'\n  },\n  hybrid: {\n    mapTypeId: 'hybrid'\n  },\n  terrain: {\n    mapTypeId: 'terrain'\n  }\n};\n\ntype StyleLayerGroupSlug = 'label' | 'road' | 'border' | 'building' | 'water' | 'land';\ntype StyleLayerGroup = {\n  slug: StyleLayerGroupSlug;\n  filter: (layer: any) => boolean;\n  defaultVisibility: boolean;\n};\n\nexport const STYLE_LAYER_GROUPS: StyleLayerGroup[] = [\n  {\n    slug: 'label',\n    filter: ({id}: {id: string}) =>\n      Boolean(\n        id.match(/(?=(label|_label|place-|place_|poi-|poi_|watername_|roadname_|housenumber))/)\n      ),\n    defaultVisibility: true\n  },\n  {\n    slug: 'road',\n    filter: ({id}: {id: string}) =>\n      Boolean(id.match(/(?=(road|railway|tunnel|street|bridge))(?!.*label)/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'border',\n    filter: ({id}: {id: string}) => Boolean(id.match(/border|boundaries|boundary_/)),\n    defaultVisibility: false\n  },\n  {\n    slug: 'building',\n    filter: ({id}: {id: string}) => Boolean(id.match(/building/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'water',\n    filter: ({id}: {id: string}) => Boolean(id.match(/(?=(water|stream|ferry))/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'land',\n    filter: ({id}: {id: string}) =>\n      Boolean(id.match(/(?=(parks|landcover|industrial|sand|hillshade|park_))/)),\n    defaultVisibility: true\n  }\n];\n\nexport function applyLayerGroupFilters(\n  style,\n  visibleLayerGroups: Record<StyleLayerGroupSlug, boolean>\n) {\n  if (!Array.isArray(style?.layers)) {\n    return style;\n  }\n\n  const removedLayerFilters = STYLE_LAYER_GROUPS.filter(lg => !visibleLayerGroups[lg.slug]).map(\n    lg => lg.filter\n  );\n\n  const visibleLayers = style.layers.filter(layer =>\n    removedLayerFilters.every(match => !match(layer))\n  );\n\n  return {\n    ...style,\n    layers: visibleLayers\n  };\n}\n\nexport function someLayerGroupsDisabled(visibleLayerGroups?: Record<StyleLayerGroupSlug, boolean>) {\n  return visibleLayerGroups && Object.values(visibleLayerGroups).every(Boolean) === false;\n}\n\nexport function getStyleUrl(styleType: string) {\n  return cartoStyleUrlTemplate.replace('{basemap}', styleType);\n}\n\nexport async function fetchStyle({\n  styleUrl,\n  errorContext\n}: {\n  styleUrl: string;\n  errorContext?: APIErrorContext;\n}) {\n  /* global fetch */\n  let response: Response | undefined;\n  return await fetch(styleUrl, {mode: 'cors'})\n    .then(res => {\n      response = res;\n      return res.json();\n    })\n    .catch(error => {\n      throw new CartoAPIError(error, {...errorContext, requestType: 'Basemap style'}, response);\n    });\n}\n\nexport default {\n  VOYAGER: getStyleUrl('voyager'),\n  POSITRON: getStyleUrl('positron'),\n  DARK_MATTER: getStyleUrl('dark-matter'),\n  VOYAGER_NOLABELS: getStyleUrl('voyager-nolabels'),\n  POSITRON_NOLABELS: getStyleUrl('positron-nolabels'),\n  DARK_MATTER_NOLABELS: getStyleUrl('dark-matter-nolabels')\n} as const;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {scaleThreshold} from 'd3-scale';\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color bins style based on `d3` `scaleThreshold`.\n *\n * Data values of each attribute are rounded down to the nearest value in the domain and are then\n * styled with the corresponding color.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorBins<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR\n}: {\n  /** Attribute or column to symbolize by. */\n  attr: AttributeSelector<DataT, number>;\n\n  /** Category list. Must be a valid list of categories. */\n  domain: number[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors?: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204] */\n  nullColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers');\n\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length + 1) : colors;\n\n  const color = scaleThreshold<number, Color>().domain(domain).range(palette);\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return typeof value === 'number' && Number.isFinite(value) ? color(value) : nullColor;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport * as cartoColors from 'cartocolor';\nimport {assert} from '../utils';\nimport {Color} from '@deck.gl/core';\n\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR: Color = [204, 204, 204];\nexport const OTHERS_COLOR: Color = [119, 119, 119];\n\ninterface CartoColorsPalette {\n  tags?: string[];\n  [key: number]: string[];\n}\n\nexport default function getPalette(name: string, numCategories: number): Color[] {\n  const palette: CartoColorsPalette | undefined = cartoColors[name];\n  let paletteIndex = numCategories;\n\n  assert(palette, `Palette \"${name}\" not found. Expected a CARTOColors string`);\n\n  const palettesColorVariants = Object.keys(palette)\n    .filter(p => p !== 'tags')\n    .map(Number);\n\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\n\nexport function hexToRgb(hex: string): Color {\n  // Evaluate #ABC\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      255\n    ];\n  }\n\n  // Evaluate #ABCD\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16)\n    ];\n  }\n\n  // Evaluate #ABCDEF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  // Evaluate #ABCDEFAF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  assert(result, `Hexadecimal color \"${hex}\" was not parsed correctly`);\n\n  return [\n    parseInt(result[1], 16),\n    parseInt(result[2], 16),\n    parseInt(result[3], 16),\n    parseInt(result[4], 16)\n  ];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Feature} from 'geojson';\nimport {assert} from '../utils';\n\nconst ALLOWED_ATTR_TYPES = Object.freeze(['function', 'string']);\n\nexport type AttributeSelector<DataT = Feature, OutT = any> =\n  | string\n  | ((d: DataT, info: any) => OutT);\n\nexport function getAttrValue<DataT = Feature, OutT = any>(\n  attr: string | AttributeSelector<DataT, OutT>,\n  d: DataT,\n  info: any\n): OutT {\n  assert(typeof d === 'object', 'Expected \"data\" to be an object');\n  assert(ALLOWED_ATTR_TYPES.includes(typeof attr), 'Expected \"attr\" to be a function or string');\n\n  // Is function\n  if (typeof attr === 'function') {\n    return attr(d, info);\n  }\n  return (d as unknown as Feature)?.properties?.[attr] as OutT;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR, OTHERS_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color category style.\n *\n * Data values of each attribute listed in the domain are mapped one to one\n * with corresponding colors in the range.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorCategories<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR,\n  othersColor = OTHERS_COLOR\n}: {\n  /** Attribute or column to symbolize by */\n  attr: string | AttributeSelector<DataT, number | string>;\n\n  /** Category list. Must be a valid list of categories. */\n  domain: number[] | string[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204] */\n  nullColor?: Color;\n\n  /** Fallback color for a category not correctly assigned. @default: [119, 119, 119] */\n  othersColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers or strings');\n\n  const colorsByCategory = {};\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length) : colors;\n\n  for (const [i, c] of domain.entries()) {\n    colorsByCategory[c] = palette[i];\n  }\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return (typeof value === 'number' && Number.isFinite(value)) || typeof value === 'string'\n      ? colorsByCategory[value] || othersColor\n      : nullColor;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {scaleLinear} from 'd3-scale';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color continuous style.\n *\n * Data values of each field are interpolated linearly across values in the domain and\n * are then styled with a blend of the corresponding color in the range.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorContinuous<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR\n}: {\n  /** Attribute or column to symbolize by. */\n  attr: AttributeSelector<DataT, number>;\n\n  /** Attribute domain to define the data range. */\n  domain: number[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors?: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204]*/\n  nullColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers');\n\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length) : colors;\n  const color = scaleLinear<Color>().domain(domain).range(palette);\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return typeof value === 'number' && Number.isFinite(value) ? color(value) : nullColor;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable @typescript-eslint/no-shadow */\n\nimport {\n  DEFAULT_API_BASE_URL,\n  APIErrorContext,\n  CartoAPIError,\n  GeojsonResult,\n  JsonResult,\n  TilejsonResult,\n  Format,\n  MapType,\n  QueryParameters,\n  SourceOptions,\n  buildPublicMapUrl,\n  buildStatsUrl,\n  h3QuerySource,\n  h3TableSource,\n  quadbinQuerySource,\n  quadbinTableSource,\n  vectorQuerySource,\n  vectorTableSource,\n  vectorTilesetSource,\n  requestWithParameters\n} from '@carto/api-client';\nimport {ParseMapResult, parseMap} from './parse-map';\nimport {assert} from '../utils';\nimport type {Basemap} from './types';\nimport {fetchBasemapProps} from './basemap';\nimport {DEFAULT_AGGREGATION_EXP} from '../constants';\n\ntype Dataset = {\n  id: string;\n  type: MapType;\n  source: string;\n  cache?: number;\n  connectionName: string;\n  geoColumn: string;\n  data: TilejsonResult | GeojsonResult | JsonResult;\n  columns: string[];\n  format: Format;\n  aggregationExp: string;\n  aggregationResLevel: number;\n  queryParameters: QueryParameters;\n};\n\n/* global clearInterval, setInterval, URL */\n/* eslint-disable complexity, max-statements, max-params */\nasync function _fetchMapDataset(dataset: Dataset, context: _FetchMapContext) {\n  const {\n    aggregationExp,\n    aggregationResLevel,\n    connectionName,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type,\n    queryParameters\n  } = dataset;\n\n  const cache: {value?: number} = {};\n  const globalOptions = {\n    ...context,\n    cache,\n    connectionName,\n    format\n  } as SourceOptions;\n\n  if (type === 'tileset') {\n    // TODO do we want a generic tilesetSource?\n    // @ts-ignore\n    dataset.data = await vectorTilesetSource({...globalOptions, tableName: source});\n  } else {\n    const [spatialDataType, spatialDataColumn] = geoColumn ? geoColumn.split(':') : ['geom'];\n    if (spatialDataType === 'geom') {\n      const options = {...globalOptions, spatialDataColumn};\n      if (type === 'table') {\n        dataset.data = await vectorTableSource({...options, columns, tableName: source});\n      } else if (type === 'query') {\n        dataset.data = await vectorQuerySource({\n          ...options,\n          columns,\n          sqlQuery: source,\n          queryParameters\n        });\n      }\n    } else if (spatialDataType === 'h3') {\n      const options = {\n        ...globalOptions,\n        aggregationExp: aggregationExp || DEFAULT_AGGREGATION_EXP,\n        aggregationResLevel,\n        spatialDataColumn\n      };\n      if (type === 'table') {\n        dataset.data = await h3TableSource({...options, tableName: source});\n      } else if (type === 'query') {\n        dataset.data = await h3QuerySource({...options, sqlQuery: source, queryParameters});\n      }\n    } else if (spatialDataType === 'quadbin') {\n      const options = {\n        ...globalOptions,\n        aggregationExp: aggregationExp || DEFAULT_AGGREGATION_EXP,\n        aggregationResLevel,\n        spatialDataColumn\n      };\n      if (type === 'table') {\n        dataset.data = await quadbinTableSource({...options, tableName: source});\n      } else if (type === 'query') {\n        dataset.data = await quadbinQuerySource({...options, sqlQuery: source, queryParameters});\n      }\n    }\n  }\n  let cacheChanged = true;\n  if (cache.value) {\n    cacheChanged = dataset.cache !== cache.value;\n    dataset.cache = cache.value;\n  }\n\n  return cacheChanged;\n}\n\nasync function _fetchTilestats(attribute: string, dataset: Dataset, context: _FetchMapContext) {\n  const {connectionName, data, id, source, type, queryParameters} = dataset;\n  const {apiBaseUrl} = context;\n  const errorContext: APIErrorContext = {\n    requestType: 'Tile stats',\n    connection: connectionName,\n    type,\n    source\n  };\n  if (!('tilestats' in data)) {\n    throw new CartoAPIError(new Error(`Invalid dataset for tilestats: ${id}`), errorContext);\n  }\n\n  const baseUrl = buildStatsUrl({attribute, apiBaseUrl, ...dataset});\n  const client = new URLSearchParams(data.tiles[0]).get('client');\n  const headers = {Authorization: `Bearer ${context.accessToken}`};\n  const parameters: Record<string, string> = {};\n  if (client) {\n    parameters.client = client;\n  }\n  if (type === 'query') {\n    parameters.q = source;\n    if (queryParameters) {\n      parameters.queryParameters = JSON.stringify(queryParameters);\n    }\n  }\n  const stats = await requestWithParameters({\n    baseUrl,\n    headers,\n    parameters,\n    errorContext,\n    maxLengthURL: context.maxLengthURL\n  });\n\n  // Replace tilestats for attribute with value from API\n  const {attributes} = data.tilestats.layers[0];\n  const index = attributes.findIndex(d => d.attribute === attribute);\n  attributes[index] = stats;\n  return true;\n}\n\nasync function fillInMapDatasets({datasets}: {datasets: Dataset[]}, context: _FetchMapContext) {\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, context));\n  return await Promise.all(promises);\n}\n\nasync function fillInTileStats(\n  {datasets, keplerMapConfig}: {datasets: Dataset[]; keplerMapConfig: any},\n  context: _FetchMapContext\n) {\n  const attributes: {attribute: string; dataset: any}[] = [];\n  const {layers} = keplerMapConfig.config.visState;\n  for (const layer of layers) {\n    for (const channel of Object.keys(layer.visualChannels)) {\n      const attribute = layer.visualChannels[channel]?.name;\n      if (attribute) {\n        const dataset = datasets.find(d => d.id === layer.config.dataId);\n        if (dataset && dataset.type !== 'tileset' && (dataset.data as TilejsonResult).tilestats) {\n          // Only fetch stats for QUERY & TABLE map types\n          attributes.push({attribute, dataset});\n        }\n      }\n    }\n  }\n  // Remove duplicates to avoid repeated requests\n  const filteredAttributes: {attribute: string; dataset: any}[] = [];\n  for (const a of attributes) {\n    if (\n      !filteredAttributes.find(\n        ({attribute, dataset}) => attribute === a.attribute && dataset === a.dataset\n      )\n    ) {\n      filteredAttributes.push(a);\n    }\n  }\n\n  const promises = filteredAttributes.map(({attribute, dataset}) =>\n    _fetchTilestats(attribute, dataset, context)\n  );\n  return await Promise.all(promises);\n}\n\nexport type FetchMapOptions = {\n  /**\n   * CARTO platform access token. Only required for private maps.\n   */\n  accessToken?: string;\n\n  /**\n   * Base URL of the CARTO Maps API.\n   *\n   * Example for account located in EU-west region: `https://gcp-eu-west1.api.carto.com`\n   *\n   * @default https://gcp-us-east1.api.carto.com\n   */\n  apiBaseUrl?: string;\n\n  /**\n   * Identifier of map created in CARTO Builder.\n   */\n  cartoMapId: string;\n  clientId?: string;\n\n  /**\n   * Custom HTTP headers added to map instantiation and data requests.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Interval in seconds at which to autoRefresh the data. If provided, `onNewData` must also be provided.\n   */\n  autoRefresh?: number;\n\n  /**\n   * Callback function that will be invoked whenever data in layers is changed. If provided, `autoRefresh` must also be provided.\n   */\n  onNewData?: (map: any) => void;\n\n  /**\n   * Maximum URL character length. Above this limit, requests use POST.\n   * Used to avoid browser and CDN limits.\n   * @default {@link DEFAULT_MAX_LENGTH_URL}\n   */\n  maxLengthURL?: number;\n};\n\n/**\n * Context reused while fetching and updating a map with fetchMap().\n */\ntype _FetchMapContext = {apiBaseUrl: string} & Pick<\n  FetchMapOptions,\n  'accessToken' | 'clientId' | 'headers' | 'maxLengthURL'\n>;\n\nexport type FetchMapResult = ParseMapResult & {\n  /**\n   * Basemap properties.\n   */\n  basemap: Basemap | null;\n  stopAutoRefresh?: () => void;\n};\n\n/* eslint-disable max-statements */\nexport async function fetchMap({\n  accessToken,\n  apiBaseUrl = DEFAULT_API_BASE_URL,\n  cartoMapId,\n  clientId,\n  headers,\n  autoRefresh,\n  onNewData,\n  maxLengthURL\n}: FetchMapOptions): Promise<FetchMapResult> {\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  if (accessToken) {\n    headers = {Authorization: `Bearer ${accessToken}`, ...headers};\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const baseUrl = buildPublicMapUrl({apiBaseUrl, cartoMapId});\n  const errorContext: APIErrorContext = {requestType: 'Public map', mapId: cartoMapId};\n  const map = await requestWithParameters({baseUrl, headers, errorContext, maxLengthURL});\n  const context: _FetchMapContext = {\n    accessToken: map.token || accessToken,\n    apiBaseUrl,\n    clientId,\n    headers,\n    maxLengthURL\n  };\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, {\n        ...context,\n        headers: {\n          ...headers,\n          'If-Modified-Since': new Date().toUTCString()\n        }\n      });\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(\n    ({type}) => type === 'geojson' || type === 'point'\n  );\n  const geojsonDatasetIds = geojsonLayers.map(({config}) => config.dataId);\n  map.datasets.forEach(dataset => {\n    if (geojsonDatasetIds.includes(dataset.id)) {\n      const {config} = geojsonLayers.find(({config}) => config.dataId === dataset.id);\n      dataset.format = 'geojson';\n      // Support for very old maps. geoColumn was not stored in the past\n      if (!dataset.geoColumn && config.columns.geojson) {\n        dataset.geoColumn = config.columns.geojson;\n      }\n    }\n  });\n\n  const [basemap] = await Promise.all([\n    fetchBasemapProps({config: map.keplerMapConfig.config, errorContext}),\n\n    // Mutates map.datasets so that dataset.data contains data\n    fillInMapDatasets(map, context)\n  ]);\n\n  // Mutates attributes in visualChannels to contain tile stats\n  await fillInTileStats(map, context);\n\n  const out = {...parseMap(map), basemap, ...{stopAutoRefresh}};\n\n  const textLayers = out.layers.filter(layer => {\n    const pointType = layer.props.pointType || '';\n    return pointType.includes('text');\n  });\n\n  /* global FontFace, window, document */\n  if (textLayers.length && window.FontFace && !document.fonts.check('12px Inter')) {\n    // Fetch font needed for labels\n    const font = new FontFace(\n      'Inter',\n      'url(https://fonts.gstatic.com/s/inter/v12/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7W0Q5nw.woff2)'\n    );\n    await font.load().then(f => document.fonts.add(f));\n  }\n\n  return out;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-shadow */\n\nimport {ColorParameters} from '@luma.gl/core';\nimport {Layer, log} from '@deck.gl/core';\nimport {\n  AGGREGATION,\n  getLayer,\n  getColorAccessor,\n  getColorValueAccessor,\n  getSizeAccessor,\n  getTextAccessor,\n  OPACITY_MAP,\n  opacityToAlpha,\n  getIconUrlAccessor,\n  negateAccessor,\n  getMaxMarkerSize\n} from './layer-map';\nimport {assert} from '../utils';\nimport {KeplerMapConfig, MapDataset, MapLayerConfig, VisualChannels} from './types';\n\nexport type ParseMapResult = {\n  /** Map id. */\n  id: string;\n\n  /** Title of map. */\n  title: string;\n\n  /** Description of map. */\n  description?: string;\n  createdAt: string;\n  updatedAt: string;\n  initialViewState: any;\n\n  /** @deprecated Use `basemap`. */\n  mapStyle: any;\n  token: string;\n\n  layers: Layer[];\n};\n\nexport function parseMap(json) {\n  const {keplerMapConfig, datasets, token} = json;\n  assert(keplerMapConfig.version === 'v1', 'Only support Kepler v1');\n  const {mapState, mapStyle} = keplerMapConfig.config as KeplerMapConfig;\n  const {layers, layerBlending, interactionConfig} = keplerMapConfig.config.visState;\n\n  return {\n    id: json.id,\n    title: json.title,\n    description: json.description,\n    createdAt: json.createdAt,\n    updatedAt: json.updatedAt,\n    initialViewState: mapState,\n    /** @deprecated Use `basemap`. */\n    mapStyle,\n    token,\n    layers: layers.reverse().map(({id, type, config, visualChannels}) => {\n      try {\n        const {dataId} = config;\n        const dataset: MapDataset | null = datasets.find(d => d.id === dataId);\n        assert(dataset, `No dataset matching dataId: ${dataId}`);\n        const {data} = dataset;\n        assert(data, `No data loaded for dataId: ${dataId}`);\n        const {Layer, propMap, defaultProps} = getLayer(type, config, dataset);\n        const styleProps = createStyleProps(config, propMap);\n        return new Layer({\n          id,\n          data,\n          ...defaultProps,\n          ...createInteractionProps(interactionConfig),\n          ...styleProps,\n          ...createChannelProps(id, type, config, visualChannels, data), // Must come after style\n          ...createParametersProp(layerBlending, styleProps.parameters || {}), // Must come after style\n          ...createLoadOptions(token)\n        });\n      } catch (e: any) {\n        log.error(e.message)();\n        return undefined;\n      }\n    })\n  };\n}\n\nfunction createParametersProp(layerBlending: string, parameters: ColorParameters) {\n  if (layerBlending === 'additive') {\n    parameters.blendColorSrcFactor = parameters.blendAlphaSrcFactor = 'src-alpha';\n    parameters.blendColorDstFactor = parameters.blendAlphaDstFactor = 'dst-alpha';\n    parameters.blendColorOperation = parameters.blendAlphaOperation = 'add';\n  } else if (layerBlending === 'subtractive') {\n    parameters.blendColorSrcFactor = 'one';\n    parameters.blendColorDstFactor = 'one-minus-dst-color';\n    parameters.blendAlphaSrcFactor = 'src-alpha';\n    parameters.blendAlphaDstFactor = 'dst-alpha';\n    parameters.blendColorOperation = 'subtract';\n    parameters.blendAlphaOperation = 'add';\n  }\n\n  return Object.keys(parameters).length ? {parameters} : {};\n}\n\nfunction createInteractionProps(interactionConfig) {\n  const pickable = interactionConfig && interactionConfig.tooltip.enabled;\n  return {\n    autoHighlight: pickable,\n    pickable\n  };\n}\n\nfunction mapProps(source, target, mapping) {\n  for (const sourceKey in mapping) {\n    const sourceValue = source[sourceKey];\n    const targetKey = mapping[sourceKey];\n    if (sourceValue === undefined) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (typeof targetKey === 'string') {\n      target[targetKey] = sourceValue;\n    } else if (typeof targetKey === 'function') {\n      const [key, value] = Object.entries(targetKey(sourceValue))[0];\n      target[key] = value;\n    } else if (typeof targetKey === 'object') {\n      // Nested definition, recurse down one level (also handles arrays)\n      mapProps(sourceValue, target, targetKey);\n    }\n  }\n}\n\nfunction createStyleProps(config: MapLayerConfig, mapping) {\n  const result: Record<string, any> = {};\n  mapProps(config, result, mapping);\n\n  // Kepler format sometimes omits strokeColor. TODO: remove once we can rely on\n  // `strokeColor` always being set when `stroke: true`.\n  if (result.stroked && !result.getLineColor) {\n    result.getLineColor = result.getFillColor;\n  }\n\n  for (const colorAccessor in OPACITY_MAP) {\n    if (Array.isArray(result[colorAccessor])) {\n      const color = [...result[colorAccessor]];\n      const opacityKey = OPACITY_MAP[colorAccessor];\n      const opacity = config.visConfig[opacityKey];\n      color[3] = opacityToAlpha(opacity);\n      result[colorAccessor] = color;\n    }\n  }\n\n  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];\n  return result;\n}\n\n/* eslint-disable complexity, max-statements */\nfunction createChannelProps(\n  id: string,\n  type: string,\n  config: MapLayerConfig,\n  visualChannels: VisualChannels,\n  data\n) {\n  const {\n    colorField,\n    colorScale,\n    radiusField,\n    radiusScale,\n    sizeField,\n    sizeScale,\n    strokeColorField,\n    strokeColorScale,\n    weightField\n  } = visualChannels;\n  let {heightField, heightScale} = visualChannels;\n  if (type === 'hexagonId') {\n    heightField = sizeField;\n    heightScale = sizeScale;\n  }\n  const {textLabel, visConfig} = config;\n  const result: Record<string, any> = {};\n\n  if (type === 'grid' || type === 'hexagon') {\n    result.colorScaleType = colorScale;\n    if (colorField) {\n      const {colorAggregation} = config.visConfig;\n      if (!AGGREGATION[colorAggregation]) {\n        result.getColorValue = getColorValueAccessor(colorField, colorAggregation, data);\n      } else {\n        result.getColorWeight = d => d[colorField.name];\n      }\n    }\n  } else if (colorField) {\n    const {colorAggregation: aggregation, colorRange: range} = visConfig;\n    result.getFillColor = getColorAccessor(\n      colorField,\n      // @ts-ignore\n      colorScale,\n      {aggregation, range},\n      visConfig.opacity,\n      data\n    );\n  }\n\n  if (type === 'point') {\n    const altitude = config.columns?.altitude;\n    if (altitude) {\n      result.dataTransform = data => {\n        data.features.forEach(({geometry, properties}) => {\n          const {type, coordinates} = geometry;\n          if (type === 'Point') {\n            coordinates[2] = properties[altitude];\n          }\n        });\n        return data;\n      };\n    }\n  }\n\n  if (radiusField || sizeField) {\n    result.getPointRadius = getSizeAccessor(\n      // @ts-ignore\n      radiusField || sizeField,\n      // @ts-ignore\n      radiusScale || sizeScale,\n      visConfig.sizeAggregation,\n      visConfig.radiusRange || visConfig.sizeRange,\n      data\n    );\n  }\n\n  if (strokeColorField) {\n    const fallbackOpacity = type === 'point' ? visConfig.opacity : 1;\n    const opacity =\n      visConfig.strokeOpacity !== undefined ? visConfig.strokeOpacity : fallbackOpacity;\n    const {strokeColorAggregation: aggregation, strokeColorRange: range} = visConfig;\n    result.getLineColor = getColorAccessor(\n      strokeColorField,\n      // @ts-ignore\n      strokeColorScale,\n      // @ts-ignore\n      {aggregation, range},\n      opacity,\n      data\n    );\n  }\n  if (heightField && visConfig.enable3d) {\n    result.getElevation = getSizeAccessor(\n      heightField,\n      // @ts-ignore\n      heightScale,\n      visConfig.heightAggregation,\n      visConfig.heightRange || visConfig.sizeRange,\n      data\n    );\n  }\n\n  if (weightField) {\n    result.getWeight = getSizeAccessor(\n      weightField,\n      undefined,\n      visConfig.weightAggregation,\n      undefined,\n      data\n    );\n  }\n\n  if (visConfig.customMarkers) {\n    const maxIconSize = getMaxMarkerSize(visConfig, visualChannels);\n    const {getPointRadius, getFillColor} = result;\n    const {customMarkersUrl, customMarkersRange, filled: useMaskedIcons} = visConfig;\n\n    result.pointType = 'icon';\n    result.getIcon = getIconUrlAccessor(\n      visualChannels.customMarkersField,\n      customMarkersRange,\n      {fallbackUrl: customMarkersUrl, maxIconSize, useMaskedIcons},\n      data\n    );\n    result._subLayerProps = {\n      'points-icon': {\n        loadOptions: {\n          image: {\n            type: 'imagebitmap'\n          },\n          imagebitmap: {\n            resizeWidth: maxIconSize,\n            resizeHeight: maxIconSize,\n            resizeQuality: 'high'\n          }\n        }\n      }\n    };\n\n    if (getFillColor && useMaskedIcons) {\n      result.getIconColor = getFillColor;\n    }\n\n    if (getPointRadius) {\n      result.getIconSize = getPointRadius;\n    }\n\n    if (visualChannels.rotationField) {\n      result.getIconAngle = negateAccessor(\n        getSizeAccessor(visualChannels.rotationField, undefined, null, undefined, data)\n      );\n    }\n  } else if (type === 'point' || type === 'tileset') {\n    result.pointType = 'circle';\n  }\n\n  if (textLabel && textLabel.length && textLabel[0].field) {\n    const [mainLabel, secondaryLabel] = textLabel;\n    const collisionGroup = id;\n\n    ({\n      alignment: result.getTextAlignmentBaseline,\n      anchor: result.getTextAnchor,\n      color: result.getTextColor,\n      outlineColor: result.textOutlineColor,\n      size: result.textSizeScale\n    } = mainLabel);\n    const {\n      color: getSecondaryColor,\n      field: secondaryField,\n      outlineColor: secondaryOutlineColor,\n      size: secondarySizeScale\n    } = secondaryLabel || {};\n\n    result.getText = mainLabel.field && getTextAccessor(mainLabel.field, data);\n    const getSecondaryText = secondaryField && getTextAccessor(secondaryField, data);\n\n    result.pointType = `${result.pointType}+text`;\n    result.textCharacterSet = 'auto';\n    result.textFontFamily = 'Inter, sans';\n    result.textFontSettings = {sdf: true};\n    result.textFontWeight = 600;\n    result.textOutlineWidth = 3;\n\n    result._subLayerProps = {\n      ...result._subLayerProps,\n      'points-text': {\n        // The following props are injected by default by VectorTileLayer:\n        // type: PointLabelLayer,\n        // extensions: [new CollisionFilterExtension()],\n        collisionEnabled: true,\n        collisionGroup,\n\n        // getPointRadius already has radiusScale baked in, so only pass one or the other\n        ...(result.getPointRadius\n          ? {getRadius: result.getPointRadius}\n          : {radiusScale: visConfig.radius}),\n\n        ...(secondaryField && {\n          getSecondaryText,\n          getSecondaryColor,\n          secondarySizeScale,\n          secondaryOutlineColor\n        })\n      }\n    };\n  }\n\n  return result;\n}\n\nfunction createLoadOptions(accessToken: string) {\n  return {\n    loadOptions: {fetch: {headers: {Authorization: `Bearer ${accessToken}`}}}\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {deviation, extent, groupSort, median, variance} from 'd3-array';\nimport {rgb} from 'd3-color';\nimport {\n  scaleLinear,\n  scaleOrdinal,\n  scaleLog,\n  scalePoint,\n  scaleQuantile,\n  scaleQuantize,\n  scaleSqrt,\n  scaleThreshold\n} from 'd3-scale';\nimport {format as d3Format} from 'd3-format';\nimport moment from 'moment-timezone';\n\nimport {Accessor, Layer, _ConstructorOf as ConstructorOf} from '@deck.gl/core';\nimport {GridLayer, HeatmapLayer, HexagonLayer} from '@deck.gl/aggregation-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {H3HexagonLayer} from '@deck.gl/geo-layers';\n\nimport ClusterTileLayer from '../layers/cluster-tile-layer';\nimport H3TileLayer from '../layers/h3-tile-layer';\nimport QuadbinTileLayer from '../layers/quadbin-tile-layer';\nimport RasterTileLayer from '../layers/raster-tile-layer';\nimport VectorTileLayer from '../layers/vector-tile-layer';\nimport {assert, createBinaryProxy, scaleIdentity} from '../utils';\nimport {\n  CustomMarkersRange,\n  MapDataset,\n  MapTextSubLayerConfig,\n  VisConfig,\n  VisualChannelField,\n  VisualChannels\n} from './types';\nimport HeatmapTileLayer from '../layers/heatmap-tile-layer';\n\nconst SCALE_FUNCS = {\n  linear: scaleLinear,\n  ordinal: scaleOrdinal,\n  log: scaleLog,\n  point: scalePoint,\n  quantile: scaleQuantile,\n  quantize: scaleQuantize,\n  sqrt: scaleSqrt,\n  custom: scaleThreshold,\n  identity: scaleIdentity\n};\nexport type SCALE_TYPE = keyof typeof SCALE_FUNCS;\n\ntype TileLayerType =\n  | 'clusterTile'\n  | 'h3'\n  | 'heatmapTile'\n  | 'mvt'\n  | 'quadbin'\n  | 'raster'\n  | 'tileset';\ntype DocumentLayerType = 'geojson' | 'grid' | 'heatmap' | 'hexagon' | 'hexagonId' | 'point';\ntype LayerType = TileLayerType | DocumentLayerType;\n\nfunction identity<T>(v: T): T {\n  return v;\n}\n\nconst UNKNOWN_COLOR = '#868d91';\n\nexport const AGGREGATION = {\n  average: 'MEAN',\n  maximum: 'MAX',\n  minimum: 'MIN',\n  sum: 'SUM'\n};\n\nexport const OPACITY_MAP = {\n  getFillColor: 'opacity',\n  getLineColor: 'strokeOpacity',\n  getTextColor: 'opacity'\n};\n\nconst AGGREGATION_FUNC = {\n  'count unique': (values, accessor) => groupSort(values, v => v.length, accessor).length,\n  median,\n  // Unfortunately mode() is only available in d3-array@3+ which is ESM only\n  mode: (values, accessor) => groupSort(values, v => v.length, accessor).pop(),\n  stddev: deviation,\n  variance\n};\n\nconst TILE_LAYER_TYPE_TO_LAYER: Record<TileLayerType, ConstructorOf<Layer>> = {\n  clusterTile: ClusterTileLayer,\n  h3: H3TileLayer,\n  heatmapTile: HeatmapTileLayer,\n  mvt: VectorTileLayer,\n  quadbin: QuadbinTileLayer,\n  raster: RasterTileLayer,\n  tileset: VectorTileLayer\n};\n\nconst hexToRGBA = c => {\n  const {r, g, b, opacity} = rgb(c);\n  return [r, g, b, 255 * opacity];\n};\n\n// Kepler prop value -> Deck.gl prop value\n// Supports nested definitions, and function transforms:\n//   {keplerProp: 'deckProp'} is equivalent to:\n//   {keplerProp: x => ({deckProp: x})}\nconst sharedPropMap = {\n  // Apply the value of Kepler `color` prop to the deck `getFillColor` prop\n  color: 'getFillColor',\n  isVisible: 'visible',\n  label: 'cartoLabel',\n  textLabel: {\n    alignment: 'getTextAlignmentBaseline',\n    anchor: 'getTextAnchor',\n    // Apply the value of Kepler `textLabel.color` prop to the deck `getTextColor` prop\n    color: 'getTextColor',\n    size: 'getTextSize'\n  },\n  visConfig: {\n    enable3d: 'extruded',\n    elevationScale: 'elevationScale',\n    filled: 'filled',\n    strokeColor: 'getLineColor',\n    stroked: 'stroked',\n    thickness: 'getLineWidth',\n    radius: 'getPointRadius',\n    wireframe: 'wireframe'\n  }\n};\n\nconst customMarkersPropsMap = {\n  color: 'getIconColor',\n  visConfig: {\n    radius: 'getIconSize'\n  }\n};\n\nconst heatmapTilePropsMap = {\n  visConfig: {\n    colorRange: x => ({colorRange: x.colors.map(hexToRGBA)}),\n    radius: 'radiusPixels'\n  }\n};\n\nconst aggregationVisConfig = {\n  colorAggregation: x => ({colorAggregation: AGGREGATION[x] || AGGREGATION.sum}),\n  colorRange: x => ({colorRange: x.colors.map(hexToRGBA)}),\n  coverage: 'coverage',\n  elevationPercentile: ['elevationLowerPercentile', 'elevationUpperPercentile'],\n  percentile: ['lowerPercentile', 'upperPercentile']\n};\n\nconst defaultProps = {\n  lineMiterLimit: 2,\n  lineWidthUnits: 'pixels',\n  pointRadiusUnits: 'pixels',\n  rounded: true,\n  wrapLongitude: false\n};\n\nfunction mergePropMaps(a: Record<string, any> = {}, b: Record<string, any> = {}) {\n  return {...a, ...b, visConfig: {...a.visConfig, ...b.visConfig}};\n}\n\nexport function getLayer(\n  type: LayerType,\n  config: MapTextSubLayerConfig,\n  dataset: MapDataset\n): {Layer: ConstructorOf<Layer>; propMap: any; defaultProps: any} {\n  let basePropMap: any = sharedPropMap;\n\n  if (config.visConfig?.customMarkers) {\n    basePropMap = mergePropMaps(basePropMap, customMarkersPropsMap);\n  }\n  if (type === 'heatmapTile') {\n    basePropMap = mergePropMaps(basePropMap, heatmapTilePropsMap);\n  }\n  if (TILE_LAYER_TYPE_TO_LAYER[type]) {\n    return getTileLayer(dataset, basePropMap, type);\n  }\n\n  const geoColumn = dataset?.geoColumn;\n  const getPosition = d => d[geoColumn].coordinates;\n\n  const hexagonId = config.columns?.hex_id;\n\n  const layerTypeDefs: Record<\n    DocumentLayerType,\n    {Layer: ConstructorOf<Layer>; propMap?: any; defaultProps?: any}\n  > = {\n    point: {\n      Layer: GeoJsonLayer,\n      propMap: {\n        columns: {\n          altitude: x => ({parameters: {depthWriteEnabled: Boolean(x)}})\n        },\n        visConfig: {outline: 'stroked'}\n      }\n    },\n    geojson: {\n      Layer: GeoJsonLayer\n    },\n    grid: {\n      Layer: GridLayer,\n      propMap: {visConfig: {...aggregationVisConfig, worldUnitSize: x => ({cellSize: 1000 * x})}},\n      defaultProps: {getPosition}\n    },\n    heatmap: {\n      Layer: HeatmapLayer,\n      propMap: {visConfig: {...aggregationVisConfig, radius: 'radiusPixels'}},\n      defaultProps: {getPosition}\n    },\n    hexagon: {\n      Layer: HexagonLayer,\n      propMap: {visConfig: {...aggregationVisConfig, worldUnitSize: x => ({radius: 1000 * x})}},\n      defaultProps: {getPosition}\n    },\n    hexagonId: {\n      Layer: H3HexagonLayer,\n      propMap: {visConfig: {coverage: 'coverage'}},\n      defaultProps: {getHexagon: d => d[hexagonId], stroked: false}\n    }\n  };\n\n  const layer = layerTypeDefs[type];\n\n  assert(layer, `Unsupported layer type: ${type}`);\n  return {\n    ...layer,\n    propMap: mergePropMaps(basePropMap, layer.propMap),\n    defaultProps: {...defaultProps, ...layer.defaultProps}\n  };\n}\n\nfunction getTileLayer(dataset: MapDataset, basePropMap, type: LayerType) {\n  const {aggregationExp, aggregationResLevel} = dataset;\n\n  return {\n    Layer: TILE_LAYER_TYPE_TO_LAYER[type] || VectorTileLayer,\n    propMap: basePropMap,\n    defaultProps: {\n      ...defaultProps,\n      ...(aggregationExp && {aggregationExp}),\n      ...(aggregationResLevel && {aggregationResLevel}),\n      uniqueIdProperty: 'geoid'\n    }\n  };\n}\n\nfunction domainFromAttribute(attribute, scaleType: SCALE_TYPE, scaleLength: number) {\n  if (scaleType === 'ordinal' || scaleType === 'point') {\n    return attribute.categories.map(c => c.category).filter(c => c !== undefined && c !== null);\n  }\n\n  if (scaleType === 'quantile' && attribute.quantiles) {\n    return attribute.quantiles.global\n      ? attribute.quantiles.global[scaleLength]\n      : attribute.quantiles[scaleLength];\n  }\n\n  let {min} = attribute;\n  if (scaleType === 'log' && min === 0) {\n    min = 1e-5;\n  }\n  return [min, attribute.max];\n}\n\nfunction domainFromValues(values, scaleType: SCALE_TYPE) {\n  if (scaleType === 'ordinal' || scaleType === 'point') {\n    return groupSort(\n      values,\n      g => -g.length,\n      d => d\n    );\n  } else if (scaleType === 'quantile') {\n    return values.sort((a, b) => a - b);\n  } else if (scaleType === 'log') {\n    const [d0, d1] = extent(values as number[]);\n    return [d0 === 0 ? 1e-5 : d0, d1];\n  }\n  return extent(values);\n}\n\nfunction calculateDomain(data, name, scaleType, scaleLength?) {\n  if (data.tilestats) {\n    // Tileset data type\n    const {attributes} = data.tilestats.layers[0];\n    const attribute = attributes.find(a => a.attribute === name);\n    return domainFromAttribute(attribute, scaleType, scaleLength);\n  } else if (data.features) {\n    // GeoJSON data type\n    const values = data.features.map(({properties}) => properties[name]);\n    return domainFromValues(values, scaleType);\n  } else if (Array.isArray(data) && data[0][name] !== undefined) {\n    // JSON data type\n    const values = data.map(properties => properties[name]);\n    return domainFromValues(values, scaleType);\n  }\n\n  return [0, 1];\n}\n\nfunction normalizeAccessor(accessor, data) {\n  if (data.features || data.tilestats) {\n    return (object, info) => {\n      if (object) {\n        return accessor(object.properties || object.__source.object.properties);\n      }\n\n      const {data, index} = info;\n      const proxy = createBinaryProxy(data, index);\n      return accessor(proxy);\n    };\n  }\n  return accessor;\n}\n\nexport function opacityToAlpha(opacity?: number) {\n  return opacity !== undefined ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;\n}\n\nfunction getAccessorKeys(name: string, aggregation?: string | undefined): string[] {\n  let keys = [name];\n  if (aggregation) {\n    // Snowflake will capitalized the keys, need to check lower and upper case version\n    keys = keys.concat([aggregation, aggregation.toUpperCase()].map(a => `${name}_${a}`));\n  }\n  return keys;\n}\n\nfunction findAccessorKey(keys: string[], properties): string[] {\n  for (const key of keys) {\n    if (key in properties) {\n      return [key];\n    }\n  }\n\n  throw new Error(`Could not find property for any accessor key: ${keys}`);\n}\n\nexport function getColorValueAccessor({name}, colorAggregation, data: any) {\n  const aggregator = AGGREGATION_FUNC[colorAggregation];\n  const accessor = values => aggregator(values, p => p[name]);\n  return normalizeAccessor(accessor, data);\n}\n\nexport function getColorAccessor(\n  {name, colorColumn}: VisualChannelField,\n  scaleType: SCALE_TYPE,\n  {aggregation, range},\n  opacity: number | undefined,\n  data: any\n) {\n  const scale = calculateLayerScale(colorColumn || name, scaleType, range, data);\n  const alpha = opacityToAlpha(opacity);\n\n  let accessorKeys = getAccessorKeys(name, aggregation);\n  const accessor = properties => {\n    if (!(accessorKeys[0] in properties)) {\n      accessorKeys = findAccessorKey(accessorKeys, properties);\n    }\n    const propertyValue = properties[accessorKeys[0]];\n    const {r, g, b} = rgb(scale(propertyValue));\n    return [r, g, b, propertyValue === null ? 0 : alpha];\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nfunction calculateLayerScale(name, scaleType, range, data) {\n  const scale = SCALE_FUNCS[scaleType]();\n  let domain: (string | number)[] = [];\n  let scaleColor: string[] = [];\n\n  if (scaleType !== 'identity') {\n    const {colorMap, colors} = range;\n\n    if (Array.isArray(colorMap)) {\n      colorMap.forEach(([value, color]) => {\n        domain.push(value);\n        scaleColor.push(color);\n      });\n    } else {\n      domain = calculateDomain(data, name, scaleType, colors.length);\n      scaleColor = colors;\n    }\n\n    if (scaleType === 'ordinal') {\n      domain = domain.slice(0, scaleColor.length);\n    }\n  }\n\n  scale.domain(domain);\n  scale.range(scaleColor);\n  scale.unknown(UNKNOWN_COLOR);\n\n  return scale;\n}\n\nconst FALLBACK_ICON =\n  'data:image/svg+xml;charset=utf-8;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNTAiLz4NCjwvc3ZnPg==';\n\nexport function getIconUrlAccessor(\n  field: VisualChannelField | null | undefined,\n  range: CustomMarkersRange | null | undefined,\n  {fallbackUrl, maxIconSize, useMaskedIcons},\n  data: any\n) {\n  const urlToUnpackedIcon = (url: string) => ({\n    id: `${url}@@${maxIconSize}`,\n    url,\n    width: maxIconSize,\n    height: maxIconSize,\n    mask: useMaskedIcons\n  });\n  let unknownValue = fallbackUrl || FALLBACK_ICON;\n\n  if (range?.othersMarker) {\n    unknownValue = range.othersMarker;\n  }\n\n  const unknownIcon = urlToUnpackedIcon(unknownValue);\n  if (!range || !field) {\n    return () => unknownIcon;\n  }\n\n  const mapping: Record<string, any> = {};\n  for (const {value, markerUrl} of range.markerMap) {\n    if (markerUrl) {\n      mapping[value] = urlToUnpackedIcon(markerUrl);\n    }\n  }\n\n  const accessor = properties => {\n    const propertyValue = properties[field.name];\n    return mapping[propertyValue] || unknownIcon;\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nexport function getMaxMarkerSize(visConfig: VisConfig, visualChannels: VisualChannels): number {\n  const {radiusRange, radius} = visConfig;\n  const {radiusField, sizeField} = visualChannels;\n  const field = radiusField || sizeField;\n  return Math.ceil(radiusRange && field ? radiusRange[1] : radius);\n}\n\nexport function negateAccessor<T>(accessor: Accessor<T, number>): Accessor<T, number> {\n  return typeof accessor === 'function' ? (d, i) => -accessor(d, i) : -accessor;\n}\n\nexport function getSizeAccessor(\n  {name},\n  scaleType: SCALE_TYPE | undefined,\n  aggregation,\n  range: Iterable<Range> | undefined,\n  data: any\n) {\n  const scale = scaleType ? SCALE_FUNCS[scaleType as any]() : identity;\n  if (scaleType) {\n    if (aggregation !== 'count') {\n      scale.domain(calculateDomain(data, name, scaleType));\n    }\n    scale.range(range);\n  }\n\n  let accessorKeys = getAccessorKeys(name, aggregation);\n  const accessor = properties => {\n    if (!(accessorKeys[0] in properties)) {\n      accessorKeys = findAccessorKey(accessorKeys, properties);\n    }\n    const propertyValue = properties[accessorKeys[0]];\n    return scale(propertyValue);\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nconst FORMATS: Record<string, (value: any) => string> = {\n  date: s => moment.utc(s).format('MM/DD/YY HH:mm:ssa'),\n  integer: d3Format('i'),\n  float: d3Format('.5f'),\n  timestamp: s => moment.utc(s).format('X'),\n  default: String\n};\n\nexport function getTextAccessor({name, type}: VisualChannelField, data) {\n  const format = FORMATS[type] || FORMATS.default;\n  const accessor = properties => {\n    return format(properties[name]);\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nexport {domainFromValues as _domainFromValues};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MapViewState} from '@deck.gl/core';\nimport {\n  GOOGLE_BASEMAPS,\n  CARTO_MAP_STYLES,\n  applyLayerGroupFilters,\n  fetchStyle,\n  getStyleUrl,\n  someLayerGroupsDisabled\n} from '../basemap';\nimport {Basemap, KeplerMapConfig, MapLibreBasemapProps} from './types';\nimport {APIErrorContext} from '@carto/api-client';\n\nconst CUSTOM_STYLE_ID_PREFIX = 'custom:';\nconst DEFAULT_CARTO_STYLE = 'positron';\n\nfunction mapLibreViewpros(config: KeplerMapConfig): Omit<MapLibreBasemapProps, 'style'> {\n  const {longitude, latitude, ...rest} = config.mapState as MapViewState;\n  return {\n    center: [longitude, latitude],\n    ...rest\n  };\n}\n\n/**\n * Get basemap properties for Carto map.\n *\n * For maplibre-based basemaps it returns style or style URL that can be used with  `maplibregl.Map` compatible component.\n *  * style url is returned for non-filtered standard Carto basemaps or if user used style URL directly in configuration\n *  * filtered style object returned for Carto basemaps with layer groups filtered\n *\n * For Google-maps base maps, it returns options that can be used with `google.maps.Map` constructor.\n */\nexport async function fetchBasemapProps({\n  config,\n  errorContext,\n\n  applyLayerFilters = true\n}: {\n  config: KeplerMapConfig;\n\n  /** By default `fetchBasemapProps` applies layers filters to style. Set this to `false` to disable it. */\n  applyLayerFilters?: boolean;\n  errorContext?: APIErrorContext;\n}): Promise<Basemap | null> {\n  const {mapStyle} = config;\n  const styleType = mapStyle.styleType || DEFAULT_CARTO_STYLE;\n  if (styleType.startsWith(CUSTOM_STYLE_ID_PREFIX)) {\n    const currentCustomStyle = config.customBaseMaps?.customStyle;\n    if (currentCustomStyle) {\n      return {\n        type: 'maplibre',\n        props: {\n          style: currentCustomStyle.style || currentCustomStyle.url,\n          ...mapLibreViewpros(config)\n        },\n        attribution: currentCustomStyle.customAttribution\n      };\n    }\n  }\n\n  if (CARTO_MAP_STYLES.includes(styleType)) {\n    const {visibleLayerGroups} = mapStyle;\n    const styleUrl = getStyleUrl(styleType);\n    let style = styleUrl;\n    let rawStyle = styleUrl;\n    if (applyLayerFilters && visibleLayerGroups && someLayerGroupsDisabled(visibleLayerGroups)) {\n      rawStyle = await fetchStyle({styleUrl, errorContext});\n      style = applyLayerGroupFilters(rawStyle, visibleLayerGroups);\n    }\n    return {\n      type: 'maplibre',\n      props: {\n        style,\n        ...mapLibreViewpros(config)\n      },\n      visibleLayerGroups,\n      rawStyle\n    };\n  }\n  const googleBasemapDef = GOOGLE_BASEMAPS[styleType];\n  if (googleBasemapDef) {\n    const {mapState} = config;\n    return {\n      type: 'google-maps',\n      props: {\n        ...googleBasemapDef,\n        center: {lat: mapState.latitude, lng: mapState.longitude},\n        zoom: mapState.zoom + 1,\n        tilt: mapState.pitch,\n        heading: mapState.bearing\n      }\n    };\n  }\n  return {\n    type: 'maplibre',\n    props: {\n      style: getStyleUrl(DEFAULT_CARTO_STYLE),\n      ...mapLibreViewpros(config)\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["import_geo_layers", "import_core", "import_core", "id", "id", "import_quadbin", "Tileset2D", "import_quadbin", "TileReader", "TileReader", "Protobuf", "import_quadbin", "id", "TileReader", "import_core", "deepEqual", "id", "deepEqual", "data", "_a", "import_core", "import_geo_layers", "import_geo_layers", "Tileset2D", "import_core", "import_geo_layers", "defaultProps", "defaultProps", "import_quadbin", "import_core", "import_layers", "import_core", "fs", "import_core", "import_geo_layers", "defaultProps", "GeoCellLayer", "import_quadbin", "renderSubLayers", "defaultProps", "TEXTURE_PROPS", "defaultProps", "tiles", "import_core", "import_layers", "TextBackgroundLayer", "defaultProps", "id", "import_core", "import_core", "import_layers", "defaultProps", "import_geo_layers", "import_core", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "TileReader", "renderSubLayers", "defaultProps", "import_core", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "earcut", "import_geo_layers", "import_layers", "defaultProps", "fetch", "_a", "_b", "_c", "id", "import_d3_scale", "import_api_client", "import_core", "import_d3_scale", "import_layers", "import_geo_layers", "defaultProps", "data", "moment", "d3Format", "id", "Layer", "defaultProps", "data", "type", "id", "config", "import_api_client"]
}
