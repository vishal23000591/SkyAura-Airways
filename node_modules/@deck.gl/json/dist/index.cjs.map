{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/assert.ts", "../src/utils/get.ts", "../src/utils/expression-eval.ts", "../src/helpers/parse-expression-string.ts", "../src/syntactic-sugar.ts", "../src/json-configuration.ts", "../src/helpers/convert-functions.ts", "../src/helpers/instantiate-class.ts", "../src/helpers/execute-function.ts", "../src/helpers/parse-json.ts", "../src/json-converter.ts", "../src/transports/transport.ts", "../src/utils/shallow-equal-objects.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// @deck.gl/json: top-level exports\n\n// Generic JSON converter, usable by other wrapper modules\nexport {default as JSONConverter} from './json-converter';\nexport {default as JSONConfiguration} from './json-configuration';\n\n// Transports\nexport {default as Transport} from './transports/transport';\n\n// Helpers\nexport {default as _convertFunctions} from './helpers/convert-functions';\nexport {default as _parseExpressionString} from './helpers/parse-expression-string';\nexport {shallowEqualObjects as _shallowEqualObjects} from './utils/shallow-equal-objects';\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default function assert(condition, message = '') {\n  if (!condition) {\n    throw new Error(`JSON conversion error ${message}`);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Access properties of nested containers using dot-path notation\n * Returns `undefined` if any container is not valid, instead of throwing\n * @param {Object} container - container that supports get\n * @param {String|*} compositeKey - key to access, can be '.'-separated string\n * @return {*} - value in the final key of the nested container, or `undefined`\n */\nexport function get(container, compositeKey) {\n  // Split the key into subkeys\n  const keyList = getKeys(compositeKey);\n  // Recursively get the value of each key;\n  let value = container;\n  for (const key of keyList) {\n    // If any intermediate subfield is not an object, return undefined\n    value = isObject(value) ? value[key] : undefined;\n  }\n  return value;\n}\n\n/**\n * Checks if argument is an \"indexable\" object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n// Cache key to key arrays for speed\nconst keyMap = {};\n\n// Takes a string of '.' separated keys and returns an array of keys\n// - 'feature.geometry.type' => ['feature', 'geometry', 'type']\n// - 'feature' => ['feature']\nfunction getKeys(compositeKey) {\n  if (typeof compositeKey === 'string') {\n    // else assume string and split around dots\n    let keyList = keyMap[compositeKey];\n    if (!keyList) {\n      keyList = compositeKey.split('.');\n      keyMap[compositeKey] = keyList;\n    }\n    return keyList;\n  }\n  // Wrap in array if needed\n  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport jsep from 'jsep';\n\n/**\n * Sources:\n * - Copyright (c) 2013 Stephen Oney, http://jsep.from.so/, MIT License\n * - Copyright (c) 2023 Don McCurdy, https://github.com/donmccurdy/expression-eval, MIT License\n */\n\n// Default operator precedence from https://github.com/EricSmekens/jsep/blob/master/src/jsep.js#L55\nconst DEFAULT_PRECEDENCE = {\n  '||': 1,\n  '&&': 2,\n  '|': 3,\n  '^': 4,\n  '&': 5,\n  '==': 6,\n  '!=': 6,\n  '===': 6,\n  '!==': 6,\n  '<': 7,\n  '>': 7,\n  '<=': 7,\n  '>=': 7,\n  '<<': 8,\n  '>>': 8,\n  '>>>': 8,\n  '+': 9,\n  '-': 9,\n  '*': 10,\n  '/': 10,\n  '%': 10\n};\n\nconst binops = {\n  '||': (a: unknown, b: unknown) => {\n    return a || b;\n  },\n  '&&': (a: unknown, b: unknown) => {\n    return a && b;\n  },\n  '|': (a: number, b: number) => {\n    return a | b;\n  },\n  '^': (a: number, b: number) => {\n    return a ^ b;\n  },\n  '&': (a: number, b: number) => {\n    return a & b;\n  },\n  '==': (a: unknown, b: unknown) => {\n    // eslint-disable-next-line eqeqeq\n    return a == b;\n  },\n  '!=': (a: unknown, b: unknown) => {\n    // eslint-disable-next-line eqeqeq\n    return a != b;\n  },\n  '===': (a: unknown, b: unknown) => {\n    return a === b;\n  },\n  '!==': (a: unknown, b: unknown) => {\n    return a !== b;\n  },\n  '<': (a: number | string, b: number | string) => {\n    return a < b;\n  },\n  '>': (a: number | string, b: number | string) => {\n    return a > b;\n  },\n  '<=': (a: number | string, b: number | string) => {\n    return a <= b;\n  },\n  '>=': (a: number | string, b: number | string) => {\n    return a >= b;\n  },\n  '<<': (a: number, b: number) => {\n    return a << b;\n  },\n  '>>': (a: number, b: number) => {\n    return a >> b;\n  },\n  '>>>': (a: number, b: number) => {\n    return a >>> b;\n  },\n  '+': (a: unknown, b: unknown) => {\n    // @ts-expect-error\n    return a + b;\n  },\n  '-': (a: number, b: number) => {\n    return a - b;\n  },\n  '*': (a: number, b: number) => {\n    return a * b;\n  },\n  '/': (a: number, b: number) => {\n    return a / b;\n  },\n  '%': (a: number, b: number) => {\n    return a % b;\n  }\n};\n\nconst unops = {\n  '-': (a: number) => {\n    return -a;\n  },\n  '+': (a: unknown) => {\n    // @ts-expect-error\n    // eslint-disable-next-line no-implicit-coercion\n    return +a;\n  },\n  '~': (a: number) => {\n    return ~a;\n  },\n  '!': (a: unknown) => {\n    return !a;\n  }\n};\n\ndeclare type operand = number | string;\ndeclare type unaryCallback = (a: operand) => operand;\ndeclare type binaryCallback = (a: operand, b: operand) => operand;\n\ntype AnyExpression =\n  | jsep.ArrayExpression\n  | jsep.BinaryExpression\n  | jsep.MemberExpression\n  | jsep.CallExpression\n  | jsep.ConditionalExpression\n  | jsep.Identifier\n  | jsep.Literal\n  | jsep.LogicalExpression\n  | jsep.ThisExpression\n  | jsep.UnaryExpression;\n\nfunction evaluateArray(list, context) {\n  return list.map(function (v) {\n    return evaluate(v, context);\n  });\n}\n\nasync function evaluateArrayAsync(list, context) {\n  const res = await Promise.all(list.map(v => evalAsync(v, context)));\n  return res;\n}\n\nfunction evaluateMember(node: jsep.MemberExpression, context: object) {\n  const object = evaluate(node.object, context);\n  let key: string;\n  if (node.computed) {\n    key = evaluate(node.property, context);\n  } else {\n    key = (node.property as jsep.Identifier).name;\n  }\n  if (/^__proto__|prototype|constructor$/.test(key)) {\n    throw Error(`Access to member \"${key}\" disallowed.`);\n  }\n  return [object, object[key]];\n}\n\nasync function evaluateMemberAsync(node: jsep.MemberExpression, context: object) {\n  const object = await evalAsync(node.object, context);\n  let key: string;\n  if (node.computed) {\n    key = await evalAsync(node.property, context);\n  } else {\n    key = (node.property as jsep.Identifier).name;\n  }\n  if (/^__proto__|prototype|constructor$/.test(key)) {\n    throw Error(`Access to member \"${key}\" disallowed.`);\n  }\n  return [object, object[key]];\n}\n\n// eslint-disable-next-line complexity\nfunction evaluate(_node: jsep.Expression, context: object) {\n  const node = _node as AnyExpression;\n\n  switch (node.type) {\n    case 'ArrayExpression':\n      return evaluateArray(node.elements, context);\n\n    case 'BinaryExpression':\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\n\n    case 'CallExpression':\n      let caller: object;\n      let fn: Function;\n      let assign: unknown[];\n      if (node.callee.type === 'MemberExpression') {\n        assign = evaluateMember(node.callee as jsep.MemberExpression, context);\n        caller = assign[0] as object;\n        fn = assign[1] as Function;\n      } else {\n        fn = evaluate(node.callee, context);\n      }\n      if (typeof fn !== 'function') {\n        return undefined;\n      }\n      return fn.apply(caller!, evaluateArray(node.arguments, context));\n\n    case 'ConditionalExpression':\n      return evaluate(node.test, context)\n        ? evaluate(node.consequent, context)\n        : evaluate(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression':\n      if (node.operator === '||') {\n        return evaluate(node.left, context) || evaluate(node.right, context);\n      } else if (node.operator === '&&') {\n        return evaluate(node.left, context) && evaluate(node.right, context);\n      }\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\n\n    case 'MemberExpression':\n      return evaluateMember(node, context)[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](evaluate(node.argument, context));\n\n    default:\n      return undefined;\n  }\n}\n\n// eslint-disable-next-line complexity\nasync function evalAsync(_node: jsep.Expression, context: object) {\n  const node = _node as AnyExpression;\n\n  // Brackets used for some case blocks here, to avoid edge cases related to variable hoisting.\n  // See: https://stackoverflow.com/questions/57759348/const-and-let-variable-shadowing-in-a-switch-statement\n  switch (node.type) {\n    case 'ArrayExpression':\n      return await evaluateArrayAsync(node.elements, context);\n\n    case 'BinaryExpression': {\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n      return binops[node.operator](left, right);\n    }\n\n    case 'CallExpression': {\n      let caller: object;\n      let fn: Function;\n      let assign: unknown[];\n      if (node.callee.type === 'MemberExpression') {\n        assign = await evaluateMemberAsync(node.callee as jsep.MemberExpression, context);\n        caller = assign[0] as object;\n        fn = assign[1] as Function;\n      } else {\n        fn = await evalAsync(node.callee, context);\n      }\n      if (typeof fn !== 'function') {\n        return undefined;\n      }\n      return await fn.apply(caller!, await evaluateArrayAsync(node.arguments, context));\n    }\n\n    case 'ConditionalExpression':\n      return (await evalAsync(node.test, context))\n        ? await evalAsync(node.consequent, context)\n        : await evalAsync(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression': {\n      if (node.operator === '||') {\n        return (await evalAsync(node.left, context)) || (await evalAsync(node.right, context));\n      } else if (node.operator === '&&') {\n        return (await evalAsync(node.left, context)) && (await evalAsync(node.right, context));\n      }\n\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n\n      return binops[node.operator](left, right);\n    }\n\n    case 'MemberExpression':\n      return (await evaluateMemberAsync(node, context))[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](await evalAsync(node.argument, context));\n\n    default:\n      return undefined;\n  }\n}\n\nfunction compile(expression: string | jsep.Expression): (context: object) => any {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression: string | jsep.Expression): (context: object) => Promise<any> {\n  return evalAsync.bind(null, jsep(expression));\n}\n\n// Added functions to inject Custom Unary Operators (and override existing ones)\nfunction addUnaryOp(operator: string, _function: unaryCallback): void {\n  jsep.addUnaryOp(operator);\n  unops[operator] = _function;\n}\n\n// Added functions to inject Custom Binary Operators (and override existing ones)\nfunction addBinaryOp(\n  operator: string,\n  precedenceOrFn: number | binaryCallback,\n  _function: binaryCallback\n): void {\n  if (_function) {\n    jsep.addBinaryOp(operator, precedenceOrFn as number);\n    binops[operator] = _function;\n  } else {\n    jsep.addBinaryOp(operator, DEFAULT_PRECEDENCE[operator] || 1);\n    binops[operator] = precedenceOrFn;\n  }\n}\n\nexport {jsep as parse, evaluate as eval, evalAsync, compile, compileAsync, addUnaryOp, addBinaryOp};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {get} from '../utils/get';\n\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport {parse, eval as evaluate} from '../utils/expression-eval';\n\nconst cachedExpressionMap = {\n  '-': object => object\n};\n\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration) {\n  // NOTE: Can be null which represents invalid function. Return null so that prop can be omitted\n  if (propValue in cachedExpressionMap) {\n    return cachedExpressionMap[propValue];\n  }\n\n  let func;\n  // Compile with expression-eval\n  const ast = parse(propValue);\n  if (ast.type === 'Identifier') {\n    func = row => {\n      return get(row, propValue);\n    };\n  } else {\n    // NOTE: To avoid security risks, the arguments passed to the\n    // compiled expression must only give access to pure data (no globals etc)\n    // We disable function call syntax\n    traverse(ast, node => {\n      if (node.type === 'CallExpression') {\n        throw new Error('Function calls not allowed in JSON expressions');\n      }\n    });\n    // TODO Something like `expressionEval.eval(ast, {row});` would be useful for unpacking arrays\n    func = row => {\n      return evaluate(ast, row);\n    };\n  }\n\n  // Cache the compiled function\n  cachedExpressionMap[propValue] = func;\n  return func;\n}\n\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n  if (Array.isArray(node)) {\n    node.forEach(element => traverse(element, visitor));\n  } else if (node && typeof node === 'object') {\n    if (node.type) {\n      visitor(node);\n    }\n    for (const key in node) {\n      traverse(node[key], visitor);\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst FUNCTION_IDENTIFIER = '@@=';\nconst CONSTANT_IDENTIFIER = '@@#';\nconst TYPE_KEY = '@@type';\nconst FUNCTION_KEY = '@@function';\n\nexport {FUNCTION_IDENTIFIER, CONSTANT_IDENTIFIER, TYPE_KEY, FUNCTION_KEY};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO - default parsing code should not be part of the configuration.\nimport parseExpressionString from './helpers/parse-expression-string';\nimport assert from './utils/assert';\n\nimport {TYPE_KEY, FUNCTION_KEY} from './syntactic-sugar';\n\nconst isObject = value => value && typeof value === 'object';\n\nexport default class JSONConfiguration {\n  typeKey = TYPE_KEY;\n  functionKey = FUNCTION_KEY;\n  log = console; // eslint-disable-line\n  classes = {};\n  reactComponents = {};\n  enumerations = {};\n  constants = {};\n  functions = {};\n  React = null;\n  // TODO - this needs to be simpler, function conversion should be built in\n  convertFunction = parseExpressionString;\n  preProcessClassProps = (Class, props) => props;\n  postProcessConvertedJson = json => json;\n\n  constructor(...configurations) {\n    for (const configuration of configurations) {\n      this.merge(configuration);\n    }\n  }\n\n  merge(configuration) {\n    for (const key in configuration) {\n      switch (key) {\n        // DEPRECATED = For backwards compatibility, add views and layers to classes;\n        case 'layers':\n        case 'views':\n          Object.assign(this.classes, configuration[key]);\n          break;\n        default:\n          // Store configuration as root fields (this.classes, ...)\n          if (key in this) {\n            const value = configuration[key];\n            this[key] = isObject(this[key]) ? Object.assign(this[key], value) : value;\n          }\n      }\n    }\n  }\n\n  validate(configuration) {\n    assert(!this.typeKey || typeof this.typeKey === 'string');\n    assert(isObject(this.classes));\n    return true;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport parseExpressionString from './parse-expression-string';\n\nimport {FUNCTION_IDENTIFIER} from '../syntactic-sugar';\n\nfunction hasFunctionIdentifier(value) {\n  return typeof value === 'string' && value.startsWith(FUNCTION_IDENTIFIER);\n}\n\nfunction trimFunctionIdentifier(value) {\n  return value.replace(FUNCTION_IDENTIFIER, '');\n}\n\n// Try to determine if any props are function valued\n// and if so convert their string values to functions\nexport default function convertFunctions(props, configuration) {\n  // Use deck.gl prop types if available.\n  const replacedProps = {};\n  for (const propName in props) {\n    let propValue = props[propName];\n\n    // Parse string valued expressions\n    const isFunction = hasFunctionIdentifier(propValue);\n\n    if (isFunction) {\n      // Parse string as \"expression\", return equivalent JavaScript function\n      propValue = trimFunctionIdentifier(propValue);\n      propValue = parseExpressionString(propValue, configuration);\n    }\n\n    replacedProps[propName] = propValue;\n  }\n\n  return replacedProps;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport convertFunctions from './convert-functions';\n\n// This attempts to instantiate a class, either as a class or as a React component\nexport function instantiateClass(type, props, configuration) {\n  // Find the class\n  const Class = configuration.classes[type];\n  const Component = configuration.reactComponents[type];\n\n  // Check that the class is in the configuration.\n  if (!Class && !Component) {\n    const {log} = configuration; // eslint-disable-line\n    if (log) {\n      const stringProps = JSON.stringify(props, null, 0).slice(0, 40);\n      log.warn(`JSON converter: No registered class of type ${type}(${stringProps}...)  `);\n    }\n    return null;\n  }\n\n  if (Class) {\n    return instantiateJavaScriptClass(Class, props, configuration);\n  }\n\n  return instantiateReactComponent(Component, props, configuration);\n}\n\nfunction instantiateJavaScriptClass(Class, props, configuration) {\n  if (configuration.preProcessClassProps) {\n    props = configuration.preProcessClassProps(Class, props, configuration);\n  }\n  props = convertFunctions(props, configuration);\n  return new Class(props);\n}\n\nfunction instantiateReactComponent(Component, props, configuration) {\n  const {React} = configuration;\n  const {children = []} = props;\n  delete props.children;\n  if (configuration.preProcessClassProps) {\n    props = configuration.preProcessClassProps(Component, props, configuration);\n  }\n\n  props = convertFunctions(props, configuration);\n\n  return React.createElement(Component, props, children);\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// This attempts to execute a function\nexport function executeFunction(targetFunction, props, configuration) {\n  // Find the function\n  const matchedFunction = configuration.functions[targetFunction];\n\n  // Check that the function is in the configuration.\n  if (!matchedFunction) {\n    const {log} = configuration; // eslint-disable-line\n    if (log) {\n      const stringProps = JSON.stringify(props, null, 0).slice(0, 40);\n      log.warn(`JSON converter: No registered function ${targetFunction}(${stringProps}...)  `);\n    }\n    return null;\n  }\n\n  return matchedFunction(props);\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Accept JSON strings by parsing them\n// TODO - use a parser that provides meaninful error messages\nexport default function parseJSON(json) {\n  return typeof json === 'string' ? JSON.parse(json) : json;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Converts JSON to props (\"hydrating\" classes, resolving enums and functions etc).\n// Lightly processes `json` props, transform string values, and extract `views` and `layers`\n// See: https://github.com/visgl/deck.gl/blob/master/dev-docs/RFCs/v6.1/json-layers-rfc.md\n//\n// NOTES:\n// * This is intended to provide minimal necessary processing required to support\n//   existing deck.gl props via JSON. This is not an implementation of alternate JSON schemas.\n// * Optionally, error checking could be applied, but ideally should leverage\n//   non-JSON specific mechanisms like prop types.\n\nimport assert from './utils/assert';\nimport JSONConfiguration from './json-configuration';\nimport {instantiateClass} from './helpers/instantiate-class';\nimport {executeFunction} from './helpers/execute-function';\n\nimport {FUNCTION_IDENTIFIER, CONSTANT_IDENTIFIER, FUNCTION_KEY} from './syntactic-sugar';\nimport parseJSON from './helpers/parse-json';\n\nconst isObject = value => value && typeof value === 'object';\n\nexport type JSONConverterProps = {\n  configuration: JSONConfiguration | Record<string, any>;\n  onJSONChange;\n};\n\nexport default class JSONConverter {\n  log = console; // eslint-disable-line\n  configuration!: JSONConfiguration;\n  onJSONChange = () => {};\n  json = null;\n  convertedJson = null;\n\n  constructor(props) {\n    this.setProps(props);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  finalize() {}\n\n  setProps(props: JSONConverterProps) {\n    // HANDLE CONFIGURATION PROPS\n    if ('configuration' in props) {\n      // Accept object or `JSONConfiguration`\n      this.configuration =\n        props.configuration instanceof JSONConfiguration\n          ? props.configuration\n          : new JSONConfiguration(props.configuration);\n    }\n\n    if ('onJSONChange' in props) {\n      this.onJSONChange = props.onJSONChange;\n    }\n  }\n\n  mergeConfiguration(config) {\n    this.configuration.merge(config);\n  }\n\n  convert(json) {\n    // Use shallow equality to ensure we only convert same json once\n    if (!json || json === this.json) {\n      return this.convertedJson;\n    }\n    // Save json for shallow diffing\n    this.json = json;\n\n    // Accept JSON strings by parsing them\n    const parsedJSON = parseJSON(json);\n\n    // Convert the JSON\n    let convertedJson = convertJSON(parsedJSON, this.configuration);\n\n    convertedJson = this.configuration.postProcessConvertedJson(convertedJson);\n\n    this.convertedJson = convertedJson;\n    return convertedJson;\n  }\n\n  // DEPRECATED: Backwards compatibility\n  convertJson(json) {\n    return this.convert(json);\n  }\n}\n\nfunction convertJSON(json, configuration) {\n  // Fixup configuration\n  configuration = new JSONConfiguration(configuration);\n  return convertJSONRecursively(json, '', configuration);\n}\n\n// Converts JSON to props (\"hydrating\" classes, resolving enums and functions etc).\nfunction convertJSONRecursively(json, key, configuration) {\n  if (Array.isArray(json)) {\n    return json.map((element, i) => convertJSONRecursively(element, String(i), configuration));\n  }\n\n  // If object.type is in configuration, instantiate\n  if (isClassInstance(json, configuration)) {\n    return convertClassInstance(json, configuration);\n  }\n\n  if (isObject(json)) {\n    // If object.function is in configuration, convert object to function\n    if (FUNCTION_KEY in json) {\n      return convertFunctionObject(json, configuration);\n    }\n    return convertPlainObject(json, configuration);\n  }\n\n  // Single value\n  if (typeof json === 'string') {\n    return convertString(json, key, configuration);\n  }\n\n  // Return unchanged (number, boolean, ...)\n  return json;\n}\n\n// Returns true if an object has a `type` field\nfunction isClassInstance(json, configuration) {\n  const {typeKey} = configuration;\n  const isClass = isObject(json) && Boolean(json[typeKey]);\n  return isClass;\n}\n\nfunction convertClassInstance(json, configuration) {\n  // Extract the class type field\n  const {typeKey} = configuration;\n  const type = json[typeKey];\n\n  // Prepare a props object and ensure all values have been converted\n  let props = {...json};\n  delete props[typeKey];\n\n  props = convertPlainObject(props, configuration);\n\n  return instantiateClass(type, props, configuration);\n}\n\n// Plain JS object, embed functions.\nfunction convertFunctionObject(json, configuration) {\n  // Extract the target function field\n  const {functionKey} = configuration;\n  const targetFunction = json[functionKey];\n\n  // Prepare a props object and ensure all values have been converted\n  let props = {...json};\n  delete props[functionKey];\n\n  props = convertPlainObject(props, configuration);\n\n  return executeFunction(targetFunction, props, configuration);\n}\n\n// Plain JS object, convert each key and return.\nfunction convertPlainObject(json, configuration) {\n  assert(isObject(json));\n\n  const result = {};\n  for (const key in json) {\n    const value = json[key];\n    result[key] = convertJSONRecursively(value, key, configuration);\n  }\n  return result;\n}\n\n// Convert one string value in an object\n// TODO - We could also support string syntax for hydrating other types, like regexps...\n// But no current use case\nfunction convertString(string, key, configuration) {\n  // Here the JSON value is supposed to be treated as a function\n  if (string.startsWith(FUNCTION_IDENTIFIER) && configuration.convertFunction) {\n    string = string.replace(FUNCTION_IDENTIFIER, '');\n    return configuration.convertFunction(string, configuration);\n  }\n  if (string.startsWith(CONSTANT_IDENTIFIER)) {\n    string = string.replace(CONSTANT_IDENTIFIER, '');\n    if (configuration.constants[string]) {\n      return configuration.constants[string];\n    }\n    // enum\n    const [enumVarName, enumValName] = string.split('.');\n    return configuration.enumerations[enumVarName][enumValName];\n  }\n  return string;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global document */\nconst state = {\n  onInitialize: _ => _,\n  onFinalize: _ => _,\n  onMessage: _ => _\n};\n\nexport default class Transport {\n  static setCallbacks({onInitialize, onFinalize, onMessage}) {\n    if (onInitialize) {\n      state.onInitialize = onInitialize;\n    }\n    if (onFinalize) {\n      state.onFinalize = onFinalize;\n    }\n    if (onMessage) {\n      state.onMessage = onMessage;\n    }\n    // this._flushQueuedConnections();\n  }\n\n  name: string;\n  _messageQueue = [];\n  userData = {};\n  _destroyed: boolean = false;\n\n  constructor(name = 'Transport') {\n    this.name = name;\n  }\n\n  /**\n   * Return a root DOM element for this transport connection\n   * @return {HTMLElement} default implementation returns document.body\n   * Jupyter Notebook transports will return an element associated with the notebook cell\n   */\n  getRootDOMElement() {\n    return typeof document !== 'undefined' ? document.body : null;\n  }\n\n  /**\n   * Back-channel messaging\n   */\n  sendJSONMessage() {\n    // eslint-disable-next-line\n    console.error('Back-channel not implemented for this transport');\n  }\n\n  /**\n   * Back-channel messaging\n   */\n  sendBinaryMessage() {\n    // eslint-disable-next-line\n    console.error('Back-channel not implemented for this transport');\n  }\n\n  //\n  // API for transports (not intended for apps)\n  //\n\n  _initialize(options = {}) {\n    const message = {transport: this, ...options};\n    state.onInitialize(message);\n\n    // console.debug('Resolving init promise', options); // eslint-disable-line\n    // this._initResolvers.resolve(message);\n  }\n\n  _finalize(options = {}) {\n    const message = {transport: this, ...options};\n\n    // TODO - could potentially be called without Initialize being called\n    state.onFinalize(message);\n    this._destroyed = true;\n  }\n\n  _messageReceived(message = {}) {\n    message = {transport: this, ...message};\n\n    // TODO - this function could potentially be called before callback registered/ Initialize called\n    // if (!state.onMessage) {\n    //   console.error('Queueing transport message', message); // eslint-disable-line\n    //   this._messageQueue.push(message);\n    //   return;\n    // }\n\n    console.debug('Delivering transport message', message); // eslint-disable-line\n    state.onMessage(message);\n  }\n\n  /*\n  // This tries to handle the case that a transport connection initializes before the application\n  // has set the callbacks.\n  // Note: It is not clear that this can actually happen in the in initial Jupyter widget transport\n  _flushQueuedConnections() {\n    if (onInitialize) {\n      state._initPromise.then(initArgs => {\n        onInitialize(initArgs);\n\n        if (state._onMessage) {\n          // Send any queued messages\n          let message;\n          while ((message = this._messageQueue.pop())) {\n            console.debug('Delivering queued transport message', message); // eslint-disable-line\n            this._onMessage(message);\n          }\n        }\n      });\n    }\n  }\n  */\n\n  static _stringifyJSONSafe(v) {\n    const cache = new Set();\n    return JSON.stringify(v, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        if (cache.has(value)) {\n          // Circular reference found\n          try {\n            // If this value does not reference a parent it can be deduped\n            return JSON.parse(JSON.stringify(value));\n          } catch (err) {\n            // discard key if value cannot be deduped\n            return undefined;\n          }\n        }\n        // Store value in our set\n        cache.add(value);\n      }\n      return value;\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO - can we reuse the core util? Assuming we don't want to export it\n\n/* eslint-disable complexity */\n\n// Compares two objects to see if their keys are shallowly equal\nexport function shallowEqualObjects(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {\n    return false;\n  }\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!(key in b) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  for (const key in b) {\n    if (!(key in a)) {\n      return false;\n    }\n  }\n  return true;\n}\n"],
  "mappings": "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",
  "names": ["jsep", "isObject", "isObject"]
}
