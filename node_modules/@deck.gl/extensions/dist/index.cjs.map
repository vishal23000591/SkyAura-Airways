{
  "version": 3,
  "sources": ["../src/index.ts", "../src/brushing/brushing-extension.ts", "../src/brushing/shader-module.ts", "../src/data-filter/data-filter-extension.ts", "../src/data-filter/shader-module.ts", "../src/data-filter/aggregator.ts", "../src/fp64/fp64-extension.ts", "../src/fp64/project64.ts", "../src/fp64/project64.glsl.ts", "../src/path-style/path-style-extension.ts", "../src/path-style/shaders.glsl.ts", "../src/fill-style/fill-style-extension.ts", "../src/fill-style/shader-module.ts", "../src/clip/clip-extension.ts", "../src/collision-filter/collision-filter-extension.ts", "../src/collision-filter/shader-module.ts", "../src/collision-filter/collision-filter-effect.ts", "../src/collision-filter/collision-filter-pass.ts", "../src/mask/mask-extension.ts", "../src/mask/shader-module.ts", "../src/mask/mask-effect.ts", "../src/mask/mask-pass.ts", "../src/utils/projection-utils.ts", "../src/terrain/terrain-extension.ts", "../src/terrain/terrain-effect.ts", "../src/terrain/shader-module.ts", "../src/terrain/utils.ts", "../src/terrain/terrain-cover.ts", "../src/terrain/terrain-pass.ts", "../src/terrain/terrain-picking-pass.ts", "../src/terrain/height-map-builder.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {default as BrushingExtension} from './brushing/brushing-extension';\nexport {default as DataFilterExtension} from './data-filter/data-filter-extension';\nexport {default as Fp64Extension} from './fp64/fp64-extension';\nexport {default as PathStyleExtension} from './path-style/path-style-extension';\nexport {default as FillStyleExtension} from './fill-style/fill-style-extension';\nexport {default as ClipExtension} from './clip/clip-extension';\nexport {default as CollisionFilterExtension} from './collision-filter/collision-filter-extension';\nexport {default as MaskExtension} from './mask/mask-extension';\nexport {default as _TerrainExtension} from './terrain/terrain-extension';\n\n// Shader module\nexport {default as project64} from './fp64/project64';\n\n// Types\nexport type {BrushingExtensionProps} from './brushing/brushing-extension';\nexport type {\n  DataFilterExtensionProps,\n  DataFilterExtensionOptions\n} from './data-filter/data-filter-extension';\nexport type {\n  PathStyleExtensionProps,\n  PathStyleExtensionOptions\n} from './path-style/path-style-extension';\nexport type {\n  FillStyleExtensionProps,\n  FillStyleExtensionOptions\n} from './fill-style/fill-style-extension';\nexport type {ClipExtensionProps} from './clip/clip-extension';\nexport type {CollisionFilterExtensionProps} from './collision-filter/collision-filter-extension';\nexport type {MaskExtensionProps} from './mask/mask-extension';\nexport type {TerrainExtensionProps} from './terrain/terrain-extension';\nexport type {TerrainModuleProps} from './terrain/shader-module';\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension} from '@deck.gl/core';\nimport shaderModule, {BrushingModuleProps} from './shader-module';\n\nimport type {Layer, LayerContext, Accessor} from '@deck.gl/core';\n\nconst defaultProps = {\n  getBrushingTarget: {type: 'accessor', value: [0, 0]},\n\n  brushingTarget: 'source',\n  brushingEnabled: true,\n  brushingRadius: 10000\n};\n\nexport type BrushingExtensionProps<DataT = any> = {\n  /**\n   * Called to retrieve an arbitrary position for each object that it will be filtered by.\n   * Only effective if `brushingTarget` is set to `custom`.\n   */\n  getBrushingTarget?: Accessor<DataT, [number, number]>;\n  /**\n   * Enable/disable brushing. If brushing is disabled, all objects are rendered.\n   * @default true\n   */\n  brushingEnabled?: boolean;\n  /**\n   * The position used to filter each object by.\n   */\n  brushingTarget?: 'source' | 'target' | 'source_target' | 'custom';\n  /** The brushing radius centered at the pointer, in meters. If a data object is within this circle, it is rendered; otherwise it is hidden.\n   * @default 10000\n   */\n  brushingRadius?: number;\n};\n\n/** Adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position. */\nexport default class BrushingExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'BrushingExtension';\n\n  getShaders(): any {\n    return {\n      modules: [shaderModule]\n    };\n  }\n\n  initializeState(this: Layer<BrushingExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        brushingTargets: {\n          size: 2,\n          stepMode: 'dynamic',\n          accessor: 'getBrushingTarget'\n        }\n      });\n    }\n\n    // Trigger redraw when mouse moves\n    const onMouseMove = () => {\n      this.getCurrentLayer()?.setNeedsRedraw();\n    };\n    // TODO - expose this in a better way\n    this.state.onMouseMove = onMouseMove;\n    if (context.deck) {\n      // @ts-expect-error (2446) accessing protected property\n      context.deck.eventManager.on({\n        pointermove: onMouseMove,\n        pointerleave: onMouseMove\n      });\n    }\n  }\n\n  finalizeState(this: Layer<BrushingExtensionProps>, context: LayerContext, extension: this) {\n    // Remove event listeners\n    if (context.deck) {\n      const onMouseMove = this.state.onMouseMove as () => void;\n      // @ts-expect-error (2446) accessing protected property\n      context.deck.eventManager.off({\n        pointermove: onMouseMove,\n        pointerleave: onMouseMove\n      });\n    }\n  }\n\n  draw(this: Layer<BrushingExtensionProps>, params: any, extension: this) {\n    const {viewport, mousePosition} = params.context;\n    const {brushingEnabled, brushingRadius, brushingTarget} = this.props;\n    const brushingProps: BrushingModuleProps = {\n      viewport,\n      mousePosition,\n      brushingEnabled,\n      brushingRadius,\n      brushingTarget\n    };\n    this.setShaderModuleProps({brushing: brushingProps});\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project} from '@deck.gl/core';\nimport type {Viewport} from '@deck.gl/core';\n\nimport type {BrushingExtensionProps} from './brushing-extension';\n\nexport type BrushingModuleProps = {\n  // From layer context\n  viewport: Viewport;\n  mousePosition?: {x: number; y: number};\n} & BrushingExtensionProps;\n\ntype BrushingModuleUniforms = {\n  enabled?: boolean;\n  target?: number;\n  mousePos?: [number, number];\n  radius?: number;\n};\n\nconst uniformBlock = /* glsl */ `\\\nuniform brushingUniforms {\n  bool enabled;\n  highp int target;\n  vec2 mousePos;\n  float radius;\n} brushing;\n`;\n\nconst vertex = /* glsl */ `\n  in vec2 brushingTargets;\n\n  out float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing.enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing.mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);\n\n    return distance <= brushing.radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\n  in float brushing_isVisible;\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing.target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing.target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing.target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      brushingTarget = brushingTargets;\n    }\n    bool visible;\n    if (brushing.target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing.enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: (opts?: BrushingModuleProps | {}): BrushingModuleUniforms => {\n    if (!opts || !('viewport' in opts)) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n      radius: brushingRadius,\n      target: TARGET[brushingTarget] || 0,\n      mousePos: mousePosition\n        ? (viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) as [\n            number,\n            number\n          ])\n        : [0, 0]\n    };\n  },\n  uniformTypes: {\n    enabled: 'i32',\n    target: 'i32',\n    mousePos: 'vec2<f32>',\n    radius: 'f32'\n  }\n} as ShaderModule<BrushingModuleProps, BrushingModuleUniforms, {}>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Buffer, Framebuffer} from '@luma.gl/core';\nimport type {Model} from '@luma.gl/engine';\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\nimport {_deepEqual as deepEqual, LayerExtension, log} from '@deck.gl/core';\nimport {\n  CategoryBitMask,\n  DataFilterModuleProps,\n  Defines,\n  dataFilter,\n  dataFilter64\n} from './shader-module';\nimport * as aggregator from './aggregator';\nimport {NumberArray4} from '@math.gl/core';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n  getFilterCategory: {type: 'accessor', value: 0},\n  onFilteredItemsChange: {type: 'function', value: null, optional: true},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterCategories: [0],\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\ntype FilterCategory = number | string;\n\nexport type DataFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor to retrieve the value for each object that it will be filtered by.\n   * Returns either a number (if `filterSize: 1`) or an array of numbers.\n   */\n  getFilterValue?: Accessor<DataT, number | number[]>;\n  /**\n   * Accessor to retrieve the category (`number | string`) for each object that it will be filtered by.\n   * Returns either a single category (if `filterSize: 1`) or an array of categories.\n   */\n  getFilterCategory?: Accessor<DataT, FilterCategory | FilterCategory[]>;\n  /**\n   * Enable/disable the data filter. If the data filter is disabled, all objects are rendered.\n   * @default true\n   */\n  filterEnabled?: boolean;\n  /**\n   * The [min, max] bounds which defines whether an object should be rendered.\n   * If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden.\n   * @default [-1, 1]\n   */\n  filterRange?: [number, number] | [number, number][];\n  /**\n   * If specified, objects will be faded in/out instead of abruptly shown/hidden.\n   * When the filtered value is outside of the bounds defined by `filterSoftRange` but still within the bounds defined by `filterRange`, the object will be rendered as \"faded.\"\n   * @default null\n   */\n  filterSoftRange?: [number, number] | [number, number][] | null;\n  /**\n   * When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformSize?: boolean;\n  /**\n   * When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformColor?: boolean;\n  /**\n   * The categories which define whether an object should be rendered.\n   * @default []\n   */\n  filterCategories?: FilterCategory[] | FilterCategory[][];\n  /**\n   * Only called if the `countItems` option is enabled.\n   */\n  onFilteredItemsChange?: (evt: {\n    /** The id of the source layer. */\n    id: string;\n    /** The number of data objects that pass the filter. */\n    count: number;\n  }) => void;\n};\n\nexport type DataFilterExtensionOptions = {\n  /**\n   * The size of the category filter (number of columns to filter by). The category filter can show/hide data based on 1-4 properties of each object. Set to `0` to disable category filtering.\n   * @default 0\n   */\n  categorySize?: 0 | 1 | 2 | 3 | 4;\n  /**\n   * The size of the filter (number of columns to filter by). The data filter can show/hide data based on 1-4 numeric properties of each object. Set to `0` to disable numeric filtering.\n   * @default 1\n   */\n  filterSize?: 0 | 1 | 2 | 3 | 4;\n  /**\n   * Use 64-bit precision instead of 32-bit.\n   * @default false\n   */\n  fp64?: boolean;\n  /**\n   * If `true`, reports the number of filtered objects with the `onFilteredItemsChange` callback.\n   * @default `false`.\n   */\n  countItems?: boolean;\n};\n\nconst defaultOptions: Required<DataFilterExtensionOptions> = {\n  categorySize: 0,\n  filterSize: 1,\n  fp64: false,\n  countItems: false\n};\n\nconst CATEGORY_TYPE_FROM_SIZE = {\n  1: 'uint' as const,\n  2: 'uvec2' as const,\n  3: 'uvec3' as const,\n  4: 'uvec4' as const\n};\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float' as const,\n  2: 'vec2' as const,\n  3: 'vec3' as const,\n  4: 'vec4' as const\n};\n\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nexport default class DataFilterExtension extends LayerExtension<\n  Required<DataFilterExtensionOptions>\n> {\n  static defaultProps = defaultProps;\n  static extensionName = 'DataFilterExtension';\n\n  constructor(opts: DataFilterExtensionOptions = {}) {\n    super({...defaultOptions, ...opts});\n  }\n\n  getShaders(this: Layer<DataFilterExtensionProps>, extension: this): any {\n    const {categorySize, filterSize, fp64} = extension.opts;\n    const defines: Defines = {};\n    if (categorySize) {\n      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];\n      defines.DATACATEGORY_CHANNELS = categorySize;\n    }\n    if (filterSize) {\n      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];\n      defines.DATAFILTER_DOUBLE = Boolean(fp64);\n    }\n\n    const module = fp64 ? dataFilter64 : dataFilter;\n    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);\n\n    return {modules: [module], defines};\n  }\n\n  initializeState(this: Layer<DataFilterExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    const {categorySize, filterSize, fp64} = extension.opts;\n\n    if (attributeManager) {\n      if (filterSize) {\n        attributeManager.add({\n          filterValues: {\n            size: filterSize,\n            type: fp64 ? 'float64' : 'float32',\n            stepMode: 'dynamic',\n            accessor: 'getFilterValue'\n          }\n        });\n      }\n\n      if (categorySize) {\n        attributeManager.add({\n          filterCategoryValues: {\n            size: categorySize,\n            stepMode: 'dynamic',\n            accessor: 'getFilterCategory',\n            type: 'uint32',\n            transform:\n              categorySize === 1\n                ? d => extension._getCategoryKey.call(this, d, 0)\n                : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i))\n          }\n        });\n      }\n    }\n\n    const {device} = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(device);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterVertexIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: 'unorm8',\n          accessor: (object, {index}) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n\n      const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);\n      const filterModel = aggregator.getModel(\n        device,\n        attributeManager.getBufferLayouts({isInstanced: false}),\n        extension.getShaders.call(this, extension),\n        useFloatTarget\n      );\n      this.setState({filterFBO, filterModel});\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(\n    this: Layer<DataFilterExtensionProps>,\n    {props, oldProps, changeFlags}: UpdateParameters<Layer<DataFilterExtensionProps>>,\n    extension: this\n  ) {\n    const attributeManager = this.getAttributeManager();\n    const {categorySize} = extension.opts;\n    if (this.state.filterModel) {\n      const filterNeedsUpdate =\n        // attributeManager must be defined for filterModel to be set\n        attributeManager!.attributes.filterValues?.needsUpdate() ||\n        attributeManager!.attributes.filterCategoryValues?.needsUpdate() ||\n        props.filterEnabled !== oldProps.filterEnabled ||\n        props.filterRange !== oldProps.filterRange ||\n        props.filterSoftRange !== oldProps.filterSoftRange ||\n        props.filterCategories !== oldProps.filterCategories;\n      if (filterNeedsUpdate) {\n        this.setState({filterNeedsUpdate});\n      }\n    }\n    if (attributeManager?.attributes.filterCategoryValues) {\n      // Update bitmask if accessor or selected categories has changed\n      const categoryBitMaskNeedsUpdate =\n        attributeManager.attributes.filterCategoryValues.needsUpdate() ||\n        !deepEqual(props.filterCategories, oldProps.filterCategories, 2);\n      if (categoryBitMaskNeedsUpdate) {\n        this.setState({categoryBitMask: null});\n      }\n\n      // Need to recreate category map if categorySize has changed\n      const resetCategories = changeFlags.dataChanged;\n      if (resetCategories) {\n        this.setState({\n          categoryMap: Array(categorySize)\n            .fill(0)\n            .map(() => ({}))\n        });\n        attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');\n      }\n    }\n  }\n\n  // eslint-disable-next-line max-statements\n  draw(this: Layer<DataFilterExtensionProps>, params: any, extension: this) {\n    const filterFBO = this.state.filterFBO as Framebuffer;\n    const filterModel = this.state.filterModel as Model;\n    const filterNeedsUpdate = this.state.filterNeedsUpdate as boolean;\n\n    if (!this.state.categoryBitMask) {\n      extension._updateCategoryBitMask.call(this, params, extension);\n    }\n\n    const {\n      onFilteredItemsChange,\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    } = this.props;\n    const dataFilterProps: DataFilterModuleProps = {\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    };\n    if (this.state.categoryBitMask) {\n      dataFilterProps.categoryBitMask = this.state.categoryBitMask as CategoryBitMask;\n    }\n    this.setShaderModuleProps({dataFilter: dataFilterProps});\n\n    /* eslint-disable-next-line camelcase */\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const attributeManager = this.getAttributeManager()!;\n      const {\n        attributes: {filterValues, filterCategoryValues, filterVertexIndices}\n      } = attributeManager;\n      filterModel.setVertexCount(this.getNumInstances());\n\n      // @ts-expect-error filterValue and filterVertexIndices should always have buffer value\n      const attributes: Record<string, Buffer> = {\n        ...filterValues?.getValue(),\n        ...filterCategoryValues?.getValue(),\n        ...filterVertexIndices?.getValue()\n      };\n      filterModel.setAttributes(attributes);\n      filterModel.shaderInputs.setProps({\n        dataFilter: dataFilterProps\n      });\n\n      const viewport = [0, 0, filterFBO.width, filterFBO.height] as NumberArray4;\n\n      const renderPass = filterModel.device.beginRenderPass({\n        id: 'data-filter-aggregation',\n        framebuffer: filterFBO,\n        parameters: {viewport},\n        clearColor: [0, 0, 0, 0]\n      });\n      filterModel.setParameters(aggregator.parameters);\n      filterModel.draw(renderPass);\n      renderPass.end();\n\n      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({id: this.id, count});\n\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState(this: Layer<DataFilterExtensionProps>) {\n    const filterFBO = this.state.filterFBO as Framebuffer;\n    const filterModel = this.state.filterModel as Model;\n\n    // filterFBO.color.delete();\n    filterFBO?.destroy();\n    filterModel?.destroy();\n  }\n\n  /**\n   * Updates the bitmask used on the GPU to perform the filter based on the\n   * `filterCategories` prop. The mapping between categories and bit in the bitmask\n   * is performed by `_getCategoryKey()`\n   */\n  _updateCategoryBitMask(\n    this: Layer<DataFilterExtensionProps>,\n    params: any,\n    extension: this\n  ): void {\n    const {categorySize} = extension.opts;\n    if (!categorySize) return;\n    const {filterCategories} = this.props;\n    const categoryBitMask: CategoryBitMask = new Uint32Array([0, 0, 0, 0]);\n    const categoryFilters = (\n      categorySize === 1 ? [filterCategories] : filterCategories\n    ) as FilterCategory[][];\n    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;\n    for (let c = 0; c < categoryFilters.length; c++) {\n      const categoryFilter = categoryFilters[c];\n      for (const category of categoryFilter) {\n        const key = extension._getCategoryKey.call(this, category, c);\n        if (key < maxCategories) {\n          const channel = c * (maxCategories / 32) + Math.floor(key / 32);\n          categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30\n        } else {\n          log.warn(`Exceeded maximum number of categories (${maxCategories})`)();\n        }\n      }\n    }\n    this.state.categoryBitMask = categoryBitMask;\n  }\n\n  /**\n   * Returns an index of bit in the bitmask for a given category. If the category has\n   * not yet been assigned a bit, a new one is assigned.\n   */\n  _getCategoryKey(\n    this: Layer<DataFilterExtensionProps>,\n    category: FilterCategory,\n    channel: number\n  ) {\n    const categoryMap = (this.state.categoryMap as Record<FilterCategory, number>[])[channel];\n    if (!(category in categoryMap)) {\n      categoryMap[category] = Object.keys(categoryMap).length;\n    }\n    return categoryMap[category];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport type {DataFilterExtensionOptions, DataFilterExtensionProps} from './data-filter-extension';\nimport {UniformFormat} from '@luma.gl/shadertools/dist/types';\n\n/*\n * data filter shader module\n */\nexport type Defines = {\n  // Defines passed externally\n  /**\n   * Primitive type of parameter used for category filtering. If undefined, category filtering disabled.\n   */\n  DATACATEGORY_TYPE?: 'uint' | 'uvec2' | 'uvec3' | 'uvec4';\n  /**\n   * Number of category filtering channels. Must match dimension of `DATACATEGORY_TYPE`\n   */\n  DATACATEGORY_CHANNELS?: 1 | 2 | 3 | 4;\n\n  /**\n   * Primitive type of parameter used for numeric filtering. If undefined, numeric filtering disabled.\n   */\n  DATAFILTER_TYPE?: 'float' | 'vec2' | 'vec3' | 'vec4';\n\n  /**\n   * Enable 64-bit precision in numeric filter.\n   */\n  DATAFILTER_DOUBLE?: boolean;\n};\n\nconst uniformBlock = /* glsl */ `\\\nuniform dataFilterUniforms {\n  bool useSoftMargin;\n  bool enabled;\n  bool transformSize;\n  bool transformColor;\n#ifdef DATAFILTER_TYPE\n  DATAFILTER_TYPE min;\n  DATAFILTER_TYPE softMin;\n  DATAFILTER_TYPE softMax;\n  DATAFILTER_TYPE max;\n#ifdef DATAFILTER_DOUBLE\n  DATAFILTER_TYPE min64High;\n  DATAFILTER_TYPE max64High;\n#endif\n#endif\n#ifdef DATACATEGORY_TYPE\n  highp uvec4 categoryBitMask;\n#endif\n} dataFilter;\n`;\n\nconst vertex = /* glsl */ `\n#ifdef DATAFILTER_TYPE\n  in DATAFILTER_TYPE filterValues;\n#ifdef DATAFILTER_DOUBLE\n  in DATAFILTER_TYPE filterValues64Low;\n#endif\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  in DATACATEGORY_TYPE filterCategoryValues;\n#endif\n\nout float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\n\n#ifdef DATAFILTER_TYPE\n  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n    if (dataFilter.useSoftMargin) {\n      // smoothstep results are undefined if edge0 \u2265 edge1\n      // Fallback to ignore filterSoftRange if it is truncated by filterRange\n      DATAFILTER_TYPE leftInRange = mix(\n        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),\n        step(dataFilter.min, valueFromMin),\n        step(dataFilter.softMin, dataFilter.min)\n      );\n      DATAFILTER_TYPE rightInRange = mix(\n        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),\n        step(valueFromMax, dataFilter.max),\n        step(dataFilter.max, dataFilter.softMax)\n      );\n      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)\n      );\n    }\n  }\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {\n    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask\n    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];\n    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks\n    uvec2 dataFilter_masks = uvec2(\n      dataFilter.categoryBitMask[category.x / 32u],\n      dataFilter.categoryBitMask[category.y / 32u + 2u]\n    );\n    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks\n    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;\n    #else // Four 32-bit masks\n    uvec4 dataFilter_masks = dataFilter.categoryBitMask;\n    #endif\n\n    // Shift mask and extract relevant bits\n    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);\n    dataFilter_bits &= 1u;\n\n    #if DATACATEGORY_CHANNELS == 1\n    if(dataFilter_bits == 0u) dataFilter_value = 0.0;\n    #else\n    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;\n    #endif\n  }\n#endif\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\nin float dataFilter_value;\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nexport type CategoryBitMask = Uint32Array;\nexport type DataFilterModuleProps = {\n  extensions: any[]; // used to detect if layer props are present\n  categoryBitMask?: CategoryBitMask;\n} & DataFilterExtensionProps;\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts?: DataFilterModuleProps | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true,\n    categoryBitMask\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n\n  return {\n    ...(Number.isFinite(filterRange[0])\n      ? {\n          min: filterRange[0],\n          softMin: filterSoftRange[0],\n          softMax: filterSoftRange[1],\n          max: filterRange[1]\n        }\n      : {\n          min: filterRange.map(r => r[0]),\n          softMin: filterSoftRange.map(r => r[0]),\n          softMax: filterSoftRange.map(r => r[1]),\n          max: filterRange.map(r => r[1])\n        }),\n    enabled: filterEnabled,\n    useSoftMargin: Boolean(opts.filterSoftRange),\n    transformSize: filterEnabled && filterTransformSize,\n    transformColor: filterEnabled && filterTransformColor,\n    ...(categoryBitMask && {categoryBitMask})\n  };\n}\n\nfunction getUniforms64(opts?: DataFilterModuleProps | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.min)) {\n    const min64High = Math.fround(uniforms.min);\n    uniforms.min -= min64High;\n    uniforms.softMin -= min64High;\n    uniforms.min64High = min64High;\n\n    const max64High = Math.fround(uniforms.max);\n    uniforms.max -= max64High;\n    uniforms.softMax -= max64High;\n    uniforms.max64High = max64High;\n  } else {\n    const min64High = uniforms.min.map(Math.fround);\n    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);\n    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);\n    uniforms.min64High = min64High;\n\n    const max64High = uniforms.max.map(Math.fround);\n    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);\n    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);\n    uniforms.max64High = max64High;\n  }\n  return uniforms;\n}\n\nconst inject = {\n  'vs:#main-start': /* glsl */ `\n    dataFilter_value = 1.0;\n    if (dataFilter.enabled) {\n      #ifdef DATAFILTER_TYPE\n        #ifdef DATAFILTER_DOUBLE\n          dataFilter_setValue(\n            filterValues - dataFilter.min64High + filterValues64Low,\n            filterValues - dataFilter.max64High + filterValues64Low\n          );\n        #else\n          dataFilter_setValue(filterValues, filterValues);\n        #endif\n      #endif\n\n      #ifdef DATACATEGORY_TYPE\n        dataFilter_setCategoryValue(filterCategoryValues);\n      #endif\n    }\n  `,\n\n  'vs:#main-end': /* glsl */ `\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  `,\n\n  'vs:DECKGL_FILTER_SIZE': /* glsl */ `\n    if (dataFilter.transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n    if (dataFilter_value == 0.0) discard;\n    if (dataFilter.transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\n\ntype UniformTypesFunc = (opts: DataFilterExtensionOptions) => any;\nfunction uniformTypesFromOptions(opts: DataFilterExtensionOptions): any {\n  const {categorySize, filterSize, fp64} = opts;\n  const uniformTypes: Record<string, UniformFormat> = {\n    useSoftMargin: 'i32',\n    enabled: 'i32',\n    transformSize: 'i32',\n    transformColor: 'i32'\n  };\n\n  if (filterSize) {\n    const uniformFormat: UniformFormat = filterSize === 1 ? 'f32' : `vec${filterSize}<f32>`;\n    uniformTypes.min = uniformFormat;\n    uniformTypes.softMin = uniformFormat;\n    uniformTypes.softMax = uniformFormat;\n    uniformTypes.max = uniformFormat;\n    if (fp64) {\n      uniformTypes.min64High = uniformFormat;\n      uniformTypes.max64High = uniformFormat;\n    }\n  }\n\n  if (categorySize) {\n    uniformTypes.categoryBitMask = 'vec4<i32>';\n  }\n\n  return uniformTypes;\n}\n\nexport const dataFilter: ShaderModule<DataFilterModuleProps> & {\n  uniformTypesFromOptions: UniformTypesFunc;\n} = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms,\n  uniformTypesFromOptions\n};\n\nexport const dataFilter64: ShaderModule<DataFilterModuleProps> & {\n  uniformTypesFromOptions: UniformTypesFunc;\n} = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64,\n  uniformTypesFromOptions\n};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, DeviceFeature, Framebuffer, RenderPipelineParameters} from '@luma.gl/core';\nimport {Model, ModelProps} from '@luma.gl/engine';\n\nconst AGGREGATE_VS = `\\\n#version 300 es\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  in float filterIndices;\n  in float filterPrevIndices;\n#else\n  in vec2 filterIndices;\n  in vec2 filterPrevIndices;\n#endif\n\nout vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n`;\n\nconst AGGREGATE_FS = `\\\n#version 300 es\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  fragColor = vColor;\n}\n`;\n\nconst FLOAT_TARGET_FEATURES: DeviceFeature[] = [\n  'float32-renderable-webgl', // ability to render to float texture\n  'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\n\nexport function supportsFloatTarget(device: Device): boolean {\n  return FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n}\n\n// A 1x1 framebuffer object that encodes the total count of filtered items\nexport function getFramebuffer(device: Device, useFloatTarget: boolean): Framebuffer {\n  if (useFloatTarget) {\n    return device.createFramebuffer({\n      width: 1,\n      height: 1,\n      colorAttachments: [\n        device.createTexture({\n          format: 'rgba32float',\n          mipmaps: false\n        })\n      ]\n    });\n  }\n  return device.createFramebuffer({\n    width: 256,\n    height: 64,\n    colorAttachments: [device.createTexture({format: 'rgba8unorm', mipmaps: false})]\n  });\n}\n\n// Increments the counter based on dataFilter_value\nexport function getModel(\n  device: Device,\n  bufferLayout: ModelProps['bufferLayout'],\n  shaderOptions: any,\n  useFloatTarget: boolean\n): Model {\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n  if (useFloatTarget) {\n    shaderOptions.defines.FLOAT_TARGET = 1;\n  }\n\n  return new Model(device, {\n    id: 'data-filter-aggregation-model',\n    vertexCount: 1,\n    isInstanced: false,\n    topology: 'point-list',\n    disableWarnings: true,\n    vs: AGGREGATE_VS,\n    fs: AGGREGATE_FS,\n    bufferLayout,\n    ...shaderOptions\n  });\n}\n\nexport const parameters: RenderPipelineParameters = {\n  blend: true,\n  blendColorSrcFactor: 'one',\n  blendColorDstFactor: 'one',\n  blendAlphaSrcFactor: 'one',\n  blendAlphaDstFactor: 'one',\n  blendColorOperation: 'add',\n  blendAlphaOperation: 'add',\n  depthCompare: 'never'\n} as const;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport project64 from './project64';\n\nimport type {Layer} from '@deck.gl/core';\n\n/** @deprecated Adds the legacy 64-bit precision to geospatial layers. */\nexport default class Fp64Extension extends LayerExtension {\n  static extensionName = 'Fp64Extension';\n\n  getShaders(this: Layer): any {\n    const {coordinateSystem} = this.props;\n    if (\n      coordinateSystem !== COORDINATE_SYSTEM.LNGLAT &&\n      coordinateSystem !== COORDINATE_SYSTEM.DEFAULT\n    ) {\n      throw new Error('fp64: coordinateSystem must be LNGLAT');\n    }\n\n    return {\n      modules: [project64]\n    };\n  }\n\n  draw(this: Layer, params: any, extension: this): void {\n    const {viewport} = params.context;\n    this.setShaderModuleProps({project64: {viewport}});\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\nimport {fp64} from '@luma.gl/shadertools';\nimport type {ShaderModule} from '@luma.gl/shadertools';\nconst {fp64ify, fp64ifyMatrix4} = fp64;\nimport {project, _memoize as memoize} from '@deck.gl/core';\n\nimport type {Viewport} from '@deck.gl/core';\nimport project64Shader from './project64.glsl';\n\ntype Project64ModuleProps = {\n  viewport: Viewport;\n};\n\nexport default {\n  name: 'project64',\n  dependencies: [project, fp64],\n  vs: project64Shader,\n  getUniforms,\n  uniformTypes: {\n    scale: 'vec2<f32>',\n    // Cannot pass as vec2[16], so instead split into 2 mat4x4\n    viewProjectionMatrix: 'mat4x4<f32>',\n    viewProjectionMatrix64Low: 'mat4x4<f32>'\n  }\n} as ShaderModule<Project64ModuleProps>;\n\n// TODO - this module should calculate the 64 bit uniforms\n// It is currently done by project to minimize duplicated work\n\nconst getMemoizedUniforms = memoize(calculateUniforms);\n\nfunction getUniforms(opts?: Project64ModuleProps | {}): Record<string, any> {\n  if (opts && 'viewport' in opts) {\n    const {viewProjectionMatrix, scale} = opts.viewport;\n    // We only need to update fp64 uniforms if fp32 projection is being updated\n    return getMemoizedUniforms({viewProjectionMatrix, scale});\n  }\n  return {};\n}\n\nfunction calculateUniforms({\n  viewProjectionMatrix,\n  scale\n}: {\n  viewProjectionMatrix: number[];\n  scale: number;\n}) {\n  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);\n  const viewProjectionMatrix64High = new Float32Array(16);\n  const viewProjectionMatrix64Low = new Float32Array(16);\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      // Match order used in project.viewProjectionMatrix\n      const from = 4 * i + j;\n      const to = 4 * j + i;\n      viewProjectionMatrix64High[to] = glViewProjectionMatrixFP64[2 * from];\n      viewProjectionMatrix64Low[to] = glViewProjectionMatrixFP64[2 * from + 1];\n    }\n  }\n  return {\n    scale: fp64ify(scale),\n    viewProjectionMatrix: [...viewProjectionMatrix64High],\n    viewProjectionMatrix64Low: [...viewProjectionMatrix64Low]\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform project64Uniforms {\n  vec2 scale;\n  mat4 viewProjectionMatrix;\n  mat4 viewProjectionMatrix64Low;\n} project64;\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  vec2 viewProjectionMatrixFP64[16];\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      viewProjectionMatrixFP64[4 * i + j] = vec2(\n        project64.viewProjectionMatrix[j][i],\n        project64.viewProjectionMatrix64Low[j][i]\n      );\n    }   \n  }\n  mat4_vec4_mul_fp64(viewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  // This is the local offset to the instance position\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n\n  // Apply web mercator projection (depends on coordinate system imn use)\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {vec3} from '@math.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\n\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\ntype PathStyleProps = {\n  dashAlignMode: number;\n  dashGapPickable: boolean;\n};\n\nexport type PathStyleExtensionProps<DataT = any> = {\n  /**\n   * Accessor for the dash array to draw each path with: `[dashSize, gapSize]` relative to the width of the path.\n   * Requires the `dash` option to be on.\n   */\n  getDashArray?: Accessor<DataT, [number, number]>;\n  /**\n   * Accessor for the offset to draw each path with, relative to the width of the path.\n   * Negative offset is to the left hand side, and positive offset is to the right hand side.\n   * @default 0\n   */\n  getOffset?: Accessor<DataT, number>;\n  /**\n   * If `true`, adjust gaps for the dashes to align at both ends.\n   * @default false\n   */\n  dashJustified?: boolean;\n  /**\n   * If `true`, gaps between solid strokes are pickable. If `false`, only the solid strokes are pickable.\n   * @default false\n   */\n  dashGapPickable?: boolean;\n};\n\nexport type PathStyleExtensionOptions = {\n  /**\n   * Add capability to render dashed lines.\n   * @default false\n   */\n  dash: boolean;\n  /**\n   * Add capability to offset lines.\n   * @default false\n   */\n  offset: boolean;\n  /**\n   * Improve dash rendering quality in certain circumstances. Note that this option introduces additional performance overhead.\n   * @default false\n   */\n  highPrecisionDash: boolean;\n};\n\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nexport default class PathStyleExtension extends LayerExtension<PathStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'PathStyleExtension';\n\n  constructor({\n    dash = false,\n    offset = false,\n    highPrecisionDash = false\n  }: Partial<PathStyleExtensionOptions> = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer: Layer<PathStyleExtensionProps>): boolean {\n    return 'pathTesselator' in layer.state;\n  }\n\n  getShaders(this: Layer<PathStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {} as {inject: Record<string, string>};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    const {inject} = result;\n    const pathStyle: ShaderModule<PathStyleProps> = {\n      name: 'pathStyle',\n      inject,\n      uniformTypes: {\n        dashAlignMode: 'f32',\n        dashGapPickable: 'i32'\n      }\n    };\n    return {\n      modules: [pathStyle]\n    };\n  }\n\n  initializeState(this: Layer<PathStyleExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'},\n        instanceDashOffsets: extension.opts.highPrecisionDash\n          ? {\n              size: 1,\n              accessor: 'getPath',\n              transform: extension.getDashOffsets.bind(this)\n            }\n          : {\n              size: 1,\n              update: attribute => {\n                attribute.constant = true;\n                attribute.value = [0];\n              }\n            }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(\n    this: Layer<PathStyleExtensionProps>,\n    params: UpdateParameters<Layer<PathStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (extension.opts.dash) {\n      const pathStyleProps: PathStyleProps = {\n        dashAlignMode: this.props.dashJustified ? 1 : 0,\n        dashGapPickable: Boolean(this.props.dashGapPickable)\n      };\n      this.setShaderModuleProps({pathStyle: pathStyleProps});\n    }\n  }\n\n  getDashOffsets(this: Layer<PathStyleExtensionProps>, path: number[] | number[][]): number[] {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + vec3.dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    result[geometrySize - 1] = 0;\n    return result;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const dashShaders = {\n  inject: {\n    'vs:#decl': `\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n`,\n\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n\n    'fs:#decl': `\nuniform pathStyleUniforms {\n  float dashAlignMode;\n  bool dashGapPickable;\n} pathStyle;\n\nin vec2 vDashArray;\nin float vDashOffset;\n`,\n\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (pathStyle.dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (path.capType <= 0.5) {\n        if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\n          discard;\n        }\n      } else {\n        // caps are rounded, test the distance to solid ends\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n`\n  }\n};\n\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nin float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n`,\n    'vs:#main-end': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n`\n  }\n};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension} from '@deck.gl/core';\n\nimport {FillStyleModuleProps, patternShaders} from './shader-module';\n\nimport type {\n  Layer,\n  LayerContext,\n  DefaultProps,\n  Accessor,\n  AccessorFunction,\n  TextureSource,\n  UpdateParameters\n} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\n\nconst defaultProps: DefaultProps<FillStyleExtensionProps> = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {lodMaxClamp: 0}\n  },\n  fillPatternMapping: {type: 'object', value: {}, async: true},\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport type FillStyleExtensionProps<DataT = any> = {\n  /** Cheap toggle to enable/disable pattern fill. Requires the `pattern` option to be on.\n   * @default true\n   */\n  fillPatternEnabled?: boolean;\n  /** Sprite image url or texture that packs all your patterns into one layout. */\n  fillPatternAtlas?: string | TextureSource;\n  /** Pattern names mapped to pattern definitions, or a url that points to a JSON file. */\n  fillPatternMapping?:\n    | string\n    | Record<\n        string,\n        {\n          /** Left position of the pattern on the atlas */\n          x: number;\n          /** Top position of the pattern on the atlas */\n          y: number;\n          /** Width of the pattern */\n          width: number;\n          /** Height of the pattern */\n          height: number;\n        }\n      >;\n  /**\n   * Whether to treat the patterns as transparency masks.\n   * @default true\n   */\n  fillPatternMask?: boolean;\n  /** Accessor for the name of the pattern. */\n  getFillPattern?: AccessorFunction<DataT, string>;\n  /** Accessor for the scale of the pattern, relative to the original size. If the pattern is 24 x 24 pixels, scale `1` roughly yields 24 meters.\n   * @default 1\n   */\n  getFillPatternScale?: Accessor<DataT, number>;\n  /**\n   * Accessor for the offset of the pattern, relative to the original size. Offset `[0.5, 0.5]` shifts the pattern alignment by half.\n   * @default [0, 0]\n   */\n  getFillPatternOffset?: Accessor<DataT, [number, number]>;\n};\n\nexport type FillStyleExtensionOptions = {\n  /** If `true`, adds the ability to tile the filled area with a pattern.\n   * @default false\n   */\n  pattern: boolean;\n};\n\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nexport default class FillStyleExtension extends LayerExtension<FillStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'FillStyleExtension';\n\n  constructor({pattern = false}: Partial<FillStyleExtensionOptions> = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer: Layer<FillStyleExtensionProps>): boolean {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n\n  getShaders(this: Layer<FillStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(this: Layer<FillStyleExtensionProps>, context: LayerContext, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager!.add({\n        fillPatternFrames: {\n          size: 4,\n          stepMode: 'dynamic',\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this)\n        },\n        fillPatternScales: {\n          size: 1,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternScale',\n          defaultValue: 1\n        },\n        fillPatternOffsets: {\n          size: 2,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternOffset'\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(\n    this: Layer<FillStyleExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<FillStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager()!.invalidate('getFillPattern');\n    }\n  }\n\n  draw(this: Layer<FillStyleExtensionProps>, params: any, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {fillPatternAtlas, fillPatternEnabled, fillPatternMask} = this.props;\n    const fillProps: FillStyleModuleProps = {\n      project: params.shaderModuleProps.project,\n      fillPatternEnabled,\n      fillPatternMask,\n      fillPatternTexture: (fillPatternAtlas || this.state.emptyTexture) as Texture\n    };\n    this.setShaderModuleProps({fill: fillProps});\n  }\n\n  finalizeState(this: Layer<FillStyleExtensionProps>) {\n    const emptyTexture = this.state.emptyTexture as Texture;\n    emptyTexture?.delete();\n  }\n\n  getPatternFrame(this: Layer<FillStyleExtensionProps>, name: string) {\n    const {fillPatternMapping} = this.getCurrentLayer()!.props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project, fp64LowPart} from '@deck.gl/core';\nimport type {ProjectProps, ProjectUniforms} from '@deck.gl/core';\n\nimport type {Texture} from '@luma.gl/core';\n\nconst uniformBlock = /* glsl */ `\\\nuniform fillUniforms {\n  vec2 patternTextureSize;\n  bool patternEnabled;\n  bool patternMask;\n  vec2 uvCoordinateOrigin;\n  vec2 uvCoordinateOrigin64Low;\n} fill;\n`;\n\n/*\n * fill pattern shader module\n */\nconst patternVs = /* glsl */ `\nin vec4 fillPatternFrames;\nin float fillPatternScales;\nin vec2 fillPatternOffsets;\n\nout vec2 fill_uv;\nout vec4 fill_patternBounds;\nout vec4 fill_patternPlacement;\n`;\n\nconst vs = `\n${uniformBlock}\n${patternVs}\n`;\n\nconst patternFs = /* glsl */ `\nuniform sampler2D fill_patternTexture;\n\nin vec4 fill_patternBounds;\nin vec4 fill_patternPlacement;\nin vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n`;\n\nconst fs = `\n${uniformBlock}\n${patternFs}\n`;\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n    fill_uv = geometry.position.xy;\n  `,\n\n  'vs:DECKGL_FILTER_COLOR': /* glsl */ `\n    if (fill.patternEnabled) {\n      fill_patternBounds = fillPatternFrames / vec4(fill.patternTextureSize, fill.patternTextureSize);\n      fill_patternPlacement.xy = fillPatternOffsets;\n      fill_patternPlacement.zw = fillPatternScales * fillPatternFrames.zw;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n    if (fill.patternEnabled) {\n      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\n      vec2 patternUV = mod(mod(fill.uvCoordinateOrigin, scale) + fill.uvCoordinateOrigin64Low + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n\n      vec4 patternColor = texture(fill_patternTexture, texCoords);\n      color.a *= patternColor.a;\n      if (!fill.patternMask) {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  `\n};\n\nexport type FillStyleModuleProps = {\n  project: ProjectProps;\n  fillPatternEnabled?: boolean;\n  fillPatternMask?: boolean;\n  fillPatternTexture: Texture;\n};\n\ntype FillStyleModuleUniforms = {\n  patternTextureSize?: [number, number];\n  patternEnabled?: boolean;\n  patternMask?: boolean;\n  uvCoordinateOrigin?: [number, number];\n  uvCoordinateOrigin64Low?: [number, number];\n};\n\ntype FillStyleModuleBindings = {\n  fill_patternTexture?: Texture;\n};\n\n/* eslint-disable camelcase */\nfunction getPatternUniforms(\n  opts?: FillStyleModuleProps | {}\n): FillStyleModuleBindings & FillStyleModuleUniforms {\n  if (!opts) {\n    return {};\n  }\n  const uniforms: FillStyleModuleBindings & FillStyleModuleUniforms = {};\n  if ('fillPatternTexture' in opts) {\n    const {fillPatternTexture} = opts;\n    uniforms.fill_patternTexture = fillPatternTexture;\n    uniforms.patternTextureSize = [fillPatternTexture.width, fillPatternTexture.height];\n  }\n  if ('project' in opts) {\n    const {fillPatternMask = true, fillPatternEnabled = true} = opts;\n    const projectUniforms = project.getUniforms(opts.project) as ProjectUniforms;\n    const {commonOrigin: coordinateOriginCommon} = projectUniforms;\n\n    const coordinateOriginCommon64Low: [number, number] = [\n      fp64LowPart(coordinateOriginCommon[0]),\n      fp64LowPart(coordinateOriginCommon[1])\n    ];\n\n    uniforms.uvCoordinateOrigin = coordinateOriginCommon.slice(0, 2) as [number, number];\n    uniforms.uvCoordinateOrigin64Low = coordinateOriginCommon64Low;\n    uniforms.patternMask = fillPatternMask;\n    uniforms.patternEnabled = fillPatternEnabled;\n  }\n  return uniforms;\n}\n\nexport const patternShaders = {\n  name: 'fill',\n  vs,\n  fs,\n  inject,\n  dependencies: [project],\n  getUniforms: getPatternUniforms,\n  uniformTypes: {\n    patternTextureSize: 'vec2<f32>',\n    patternEnabled: 'i32',\n    patternMask: 'i32',\n    uvCoordinateOrigin: 'vec2<f32>',\n    uvCoordinateOrigin64Low: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<\n  FillStyleModuleProps,\n  FillStyleModuleUniforms,\n  FillStyleModuleBindings\n>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {LayerExtension} from '@deck.gl/core';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1],\n  clipByInstance: undefined\n};\n\nexport type ClipExtensionProps = {\n  /** Rectangular bounds to be used for clipping the rendered region, in `[left, bottom, right, top]`.\n   * @default [0, 0, 1, 1]\n   */\n  clipBounds?: [number, number, number, number];\n  /**\n   * Controls whether an object is clipped by its anchor (e.g. icon, point) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  clipByInstance?: boolean;\n};\n\nconst shaderFunction = /* glsl */ `\nuniform clipUniforms {\n  vec4 bounds;\n} clip;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];\n}\n`;\n\nexport type ClipModuleProps = {\n  bounds: [number, number, number, number];\n};\n\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs: ShaderModule<ClipModuleProps> = {\n  name: 'clip',\n  vs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\n\nconst injectionVs = {\n  'vs:#decl': /* glsl */ `\nout float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n  'fs:#decl': /* glsl */ `\nin float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (clip_isVisible < 0.5) discard;\n`\n};\n\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs: ShaderModule<ClipModuleProps> = {\n  name: 'clip',\n  fs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\n\nconst injectionFs = {\n  'vs:#decl': /* glsl */ `\nout vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': /* glsl */ `\nin vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n\n/** Adds support for clipping rendered layers by rectangular bounds. */\nexport default class ClipExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'ClipExtension';\n\n  getShaders(this: Layer<ClipExtensionProps>) {\n    // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n    // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n\n    // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n    let clipByInstance = 'instancePositions' in this.getAttributeManager()!.attributes;\n    // Users can override by setting the `clipByInstance` prop\n    if (this.props.clipByInstance !== undefined) {\n      clipByInstance = Boolean(this.props.clipByInstance);\n    }\n    this.state.clipByInstance = clipByInstance;\n\n    return clipByInstance\n      ? {\n          modules: [shaderModuleVs],\n          inject: injectionVs\n        }\n      : {\n          modules: [shaderModuleFs],\n          inject: injectionFs\n        };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<ClipExtensionProps>>): void {\n    const {clipBounds} = this.props;\n    const clipProps = {} as ClipModuleProps;\n    if (this.state.clipByInstance) {\n      clipProps.bounds = clipBounds;\n    } else {\n      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n\n      clipProps.bounds = [\n        Math.min(corner0[0], corner1[0]),\n        Math.min(corner0[1], corner1[1]),\n        Math.max(corner0[0], corner1[0]),\n        Math.max(corner0[1], corner1[1])\n      ];\n    }\n\n    this.setShaderModuleProps({clip: clipProps});\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Accessor, Layer, LayerContext, LayerExtension} from '@deck.gl/core';\nimport collision from './shader-module';\nimport CollisionFilterEffect from './collision-filter-effect';\n\nconst defaultProps = {\n  getCollisionPriority: {type: 'accessor', value: 0},\n  collisionEnabled: true,\n  collisionGroup: {type: 'string', value: 'default'},\n  collisionTestProps: {}\n};\n\nexport type CollisionFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor for collision priority. Must return a number in the range -1000 -> 1000. Features with higher values are shown preferentially.\n   */\n  getCollisionPriority?: Accessor<DataT, number>;\n\n  /**\n   * Enable/disable collisions. If collisions are disabled, all objects are rendered.\n   * @default true\n   */\n  collisionEnabled: boolean;\n\n  /**\n   * Collision group this layer belongs to. If it is not set, the 'default' collision group is used\n   */\n  collisionGroup?: string;\n\n  /**\n   * Props to override when rendering collision map\n   */\n  collisionTestProps?: {};\n};\n\n/** Allows layers to hide overlapping objects. */\nexport default class CollisionFilterExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'CollisionFilterExtension';\n\n  getShaders(this: Layer<CollisionFilterExtensionProps>): any {\n    return {modules: [collision]};\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<CollisionFilterExtensionProps>, {shaderModuleProps}: any) {\n    if (shaderModuleProps.collision?.drawToCollisionMap) {\n      // Override any props with those defined in collisionTestProps\n      // @ts-ignore\n      this.props = this.clone(this.props.collisionTestProps).props;\n    }\n  }\n\n  initializeState(\n    this: Layer<CollisionFilterExtensionProps>,\n    context: LayerContext,\n    extension: this\n  ) {\n    if (this.getAttributeManager() === null) {\n      return;\n    }\n    this.context.deck?._addDefaultEffect(new CollisionFilterEffect());\n    const attributeManager = this.getAttributeManager();\n    attributeManager!.add({\n      collisionPriorities: {\n        size: 1,\n        stepMode: 'dynamic',\n        accessor: 'getCollisionPriority'\n      }\n    });\n  }\n\n  getNeedsPickingBuffer(this: Layer<CollisionFilterExtensionProps>): boolean {\n    return this.props.collisionEnabled;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer, Texture, TextureView} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project} from '@deck.gl/core';\n\nconst vs = /* glsl */ `\nin float collisionPriorities;\n\nuniform sampler2D collision_texture;\n\nuniform collisionUniforms {\n  bool sort;\n  bool enabled;\n} collision;\n\nvec2 collision_getCoords(vec4 position) {\n  vec4 collision_clipspace = project_common_position_to_clipspace(position);\n  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\n\nfloat collision_match(vec2 tex, vec3 pickingColor) {\n  vec4 collision_pickingColor = texture(collision_texture, tex);\n  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\n  float e = 0.001;\n  return step(delta, e);\n}\n\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\n  if (!collision.enabled) {\n    return 1.0;\n  }\n\n  // Visibility test, sample area of 5x5 pixels in order to fade in/out.\n  // Due to the locality, the lookups will be cached\n  // This reduces the flicker present when objects are shown/hidden\n  const int N = 2;\n  float accumulator = 0.0;\n  vec2 step = vec2(1.0 / project.viewportSize);\n\n  const float floatN = float(N);\n  vec2 delta = -floatN * step;\n  for(int i = -N; i <= N; i++) {\n    delta.x = -step.x * floatN;\n    for(int j = -N; j <= N; j++) {\n      accumulator += collision_match(texCoords + delta, pickingColor);\n      delta.x += step.x;\n    }\n    delta.y += step.y;\n  }\n\n  float W = 2.0 * floatN + 1.0;\n  return pow(accumulator / (W * W), 2.2);\n}\n`;\n\nconst inject = {\n  'vs:#decl': /* glsl */ `\n  float collision_fade = 1.0;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  if (collision.sort) {\n    float collisionPriority = collisionPriorities;\n    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000\n  }\n\n  if (collision.enabled) {\n    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n    vec2 collision_texCoords = collision_getCoords(collision_common_position);\n    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\n    if (collision_fade < 0.0001) {\n      // Position outside clip space bounds to discard\n      position = vec4(0.0, 0.0, 2.0, 1.0);\n    }\n  }\n  `,\n  'vs:DECKGL_FILTER_COLOR': /* glsl */ `\n  color.a *= collision_fade;\n  `\n};\n\nexport type CollisionModuleProps = {\n  enabled: boolean;\n  collisionFBO?: Framebuffer;\n  drawToCollisionMap?: boolean;\n  dummyCollisionMap?: Texture;\n};\n\n/* eslint-disable camelcase */\ntype CollisionUniforms = {\n  enabled?: boolean;\n  sort?: boolean;\n};\n\ntype CollisionBindings = {\n  collision_texture?: TextureView | Texture;\n};\n\nconst getCollisionUniforms = (\n  opts: CollisionModuleProps | {}\n): CollisionBindings & CollisionUniforms => {\n  if (!opts || !('dummyCollisionMap' in opts)) {\n    return {};\n  }\n  const {enabled, collisionFBO, drawToCollisionMap, dummyCollisionMap} = opts;\n  return {\n    enabled: enabled && !drawToCollisionMap,\n    sort: Boolean(drawToCollisionMap),\n    collision_texture:\n      !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap\n  };\n};\n\n// @ts-ignore\nexport default {\n  name: 'collision',\n  dependencies: [project],\n  vs,\n  inject,\n  getUniforms: getCollisionUniforms,\n  uniformTypes: {\n    sort: 'i32',\n    enabled: 'i32'\n  }\n} as ShaderModule<CollisionModuleProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer, Texture} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {Effect, EffectContext, Layer, PreRenderOptions, Viewport} from '@deck.gl/core';\nimport CollisionFilterPass from './collision-filter-pass';\nimport {MaskPreRenderStats} from '../mask/mask-effect';\n// import {debugFBO} from '../utils/debug';\n\nimport type {CollisionFilterExtensionProps} from './collision-filter-extension';\nimport type {CollisionModuleProps} from './shader-module';\n\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\n\ntype RenderInfo = {\n  collisionGroup: string;\n  layers: Layer<CollisionFilterExtensionProps>[];\n  layerBounds: ([number[], number[]] | null)[];\n  allLayersLoaded: boolean;\n};\n\nexport default class CollisionFilterEffect implements Effect {\n  id = 'collision-filter-effect';\n  props = null;\n  useInPicking = true;\n  order = 1;\n\n  private context?: EffectContext;\n  private channels: Record<string, RenderInfo> = {};\n  private collisionFilterPass?: CollisionFilterPass;\n  private collisionFBOs: Record<string, Framebuffer> = {};\n  private dummyCollisionMap?: Texture;\n  private lastViewport?: Viewport;\n\n  setup(context: EffectContext) {\n    this.context = context;\n    const {device} = context;\n    this.dummyCollisionMap = device.createTexture({width: 1, height: 1});\n    this.collisionFilterPass = new CollisionFilterPass(device, {id: 'default-collision-filter'});\n  }\n\n  preRender({\n    effects: allEffects,\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking,\n    preRenderStats = {}\n  }: PreRenderOptions): void {\n    // This can only be called in preRender() after setup() where context is populated\n    const {device} = this.context!;\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n\n    const collisionLayers = layers.filter(\n      // @ts-ignore\n      ({props: {visible, collisionEnabled}}) => visible && collisionEnabled\n    ) as Layer<CollisionFilterExtensionProps>[];\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.useInPicking && preRenderStats[e.id]);\n    const maskEffectRendered = (preRenderStats['mask-effect'] as MaskPreRenderStats)?.didRender;\n\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(device, collisionLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged =\n      !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      // @ts-expect-error TODO - assuming WebGL context\n      const [width, height] = device.canvasContext.getPixelSize();\n      collisionFBO.resize({\n        width: width / DOWNSCALE,\n        height: height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n\n  private _render(\n    renderInfo: RenderInfo,\n    {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      effects: PreRenderOptions['effects'];\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const {collisionGroup} = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n\n    const needsRender =\n      viewportChanged ||\n      // If render info is new\n      renderInfo === oldRenderInfo ||\n      // If sublayers have changed\n      !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n      // If a sublayer's bounds have been updated\n      renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n      // If a sublayer's isLoaded state has been updated\n      renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n      // Some prop is in transition\n      renderInfo.layers.some(layer => layer.props.transitions);\n\n    this.channels[collisionGroup] = renderInfo;\n\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n\n      // Rerender collision FBO\n      this.collisionFilterPass!.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          collision: {\n            enabled: true,\n            // To avoid feedback loop forming between Framebuffer and active Texture.\n            dummyCollisionMap: this.dummyCollisionMap\n          },\n          project: {\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  private _groupByCollisionGroup(\n    device: Device,\n    collisionLayers: Layer<CollisionFilterExtensionProps>[]\n  ): Record<string, RenderInfo> {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const collisionGroup = layer.props.collisionGroup!;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true};\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(device, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n\n    return channelMap;\n  }\n\n  getShaderModuleProps(layer: Layer): {\n    collision: CollisionModuleProps;\n  } {\n    const {collisionGroup, collisionEnabled} = (layer as Layer<CollisionFilterExtensionProps>)\n      .props;\n    const {collisionFBOs, dummyCollisionMap} = this;\n    const collisionFBO = collisionFBOs[collisionGroup!];\n    const enabled = collisionEnabled && Boolean(collisionFBO);\n    return {\n      collision: {\n        enabled,\n        collisionFBO,\n        dummyCollisionMap: dummyCollisionMap!\n      }\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n\n  createFBO(device: Device, collisionGroup: string) {\n    // @ts-expect-error\n    const {width, height} = device.gl.canvas;\n    const collisionMap = device.createTexture({\n      format: 'rgba8unorm',\n      width,\n      height,\n      sampler: {\n        minFilter: 'nearest',\n        magFilter: 'nearest',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      }\n    });\n\n    // @ts-ignore\n    const depthStencilAttachment = device.createTexture({\n      format: 'depth16unorm',\n      width,\n      height,\n      mipmaps: false\n    });\n    this.collisionFBOs[collisionGroup] = device.createFramebuffer({\n      id: `collision-${collisionGroup}`,\n      width,\n      height,\n      colorAttachments: [collisionMap],\n      depthStencilAttachment\n    });\n  }\n\n  destroyFBO(collisionGroup: string) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    fbo.colorAttachments[0]?.destroy();\n    fbo.depthStencilAttachment?.destroy();\n    fbo.destroy();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer, Parameters} from '@luma.gl/core';\nimport {Layer, _LayersPass as LayersPass, LayersPassRenderOptions, Viewport} from '@deck.gl/core';\n\ntype CollisionFilterPassRenderOptions = LayersPassRenderOptions & {};\n\nexport default class CollisionFilterPass extends LayersPass {\n  renderCollisionMap(target: Framebuffer, options: CollisionFilterPassRenderOptions) {\n    const padding = 1;\n    const clearColor = [0, 0, 0, 0];\n    const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];\n\n    this.render({...options, clearColor, scissorRect, target, pass: 'collision'});\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): Parameters {\n    return {\n      ...layer.props.parameters,\n      blend: false,\n      depthWriteEnabled: true,\n      depthCompare: 'less-equal'\n    };\n  }\n\n  getShaderModuleProps() {\n    // Draw picking colors into collision FBO\n    return {\n      collision: {\n        drawToCollisionMap: true\n      },\n      picking: {\n        isActive: 1,\n        isAttribute: false\n      },\n      lighting: {enabled: false}\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, Layer, LayerExtension, log} from '@deck.gl/core';\nimport mask, {MaskProps} from './shader-module';\nimport MaskEffect from './mask-effect';\n\nconst defaultProps = {\n  maskId: '',\n  maskByInstance: undefined,\n  maskInverted: false\n};\n\nexport type MaskExtensionProps = {\n  /**\n   * Id of the layer that defines the mask. The mask layer must use the prop `operation: 'mask'`.\n   * Masking is disabled if `maskId` is empty or no valid mask layer with the specified id is found.\n   */\n  maskId?: string;\n  /**\n   * controls whether an object is clipped by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  maskByInstance?: boolean;\n  /**\n   * Inverts the masking operation\n   */\n  maskInverted?: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class MaskExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'MaskExtension';\n\n  initializeState(this: Layer<MaskExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new MaskEffect());\n  }\n\n  getShaders(this: Layer<MaskExtensionProps>): any {\n    // Infer by geometry if 'maskByInstance' prop isn't explictly set\n    let maskByInstance = 'instancePositions' in this.getAttributeManager()!.attributes;\n    // Users can override by setting the `maskByInstance` prop\n    if (this.props.maskByInstance !== undefined) {\n      maskByInstance = Boolean(this.props.maskByInstance);\n    }\n    this.state.maskByInstance = maskByInstance;\n\n    return {\n      modules: [mask]\n    };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<MaskExtensionProps>>, {context, shaderModuleProps}: any) {\n    const maskProps = {} as MaskProps;\n    maskProps.maskByInstance = Boolean(this.state.maskByInstance);\n    const {maskId, maskInverted} = this.props;\n    const {maskChannels} = shaderModuleProps.mask || {};\n    const {viewport} = context;\n    if (maskChannels && maskChannels[maskId]) {\n      const {index, bounds, coordinateOrigin: fromCoordinateOrigin} = maskChannels[maskId];\n      let {coordinateSystem: fromCoordinateSystem} = maskChannels[maskId];\n      maskProps.enabled = true;\n      maskProps.channel = index;\n      maskProps.inverted = maskInverted;\n\n      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        fromCoordinateSystem = viewport.isGeospatial\n          ? COORDINATE_SYSTEM.LNGLAT\n          : COORDINATE_SYSTEM.CARTESIAN;\n      }\n      const opts = {modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem};\n      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);\n      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);\n      maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];\n    } else {\n      if (maskId) {\n        log.warn(`Could not find a mask layer with id: ${maskId}`)();\n      }\n      maskProps.enabled = false;\n    }\n\n    this.setShaderModuleProps({mask: maskProps});\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\n\nconst uniformBlock = /* glsl */ `\\\nuniform maskUniforms {\n  vec4 bounds;\n  highp int channel;\n  bool enabled;\n  bool inverted;\n  bool maskByInstance;\n} mask;\n`;\n\nconst vertex = /* glsl */ `\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);\n}\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\nuniform sampler2D mask_texture;\n\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask.enabled) {\n    return true;\n  }\n  vec4 maskColor = texture(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask.channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask.channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask.channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask.channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask.inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nconst inject = {\n  'vs:#decl': /* glsl */ `\nout vec2 mask_texCoords;\n`,\n  'vs:#main-end': /* glsl */ `\n   vec4 mask_common_position;\n   if (mask.maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n`,\n  'fs:#decl': /* glsl */ `\nin vec2 mask_texCoords;\n`,\n  'fs:#main-start': /* glsl */ `\n  if (mask.enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // fragColor = vec4(mask_texCoords, 0.0, 1.0);\n    // fragColor = texture(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n`\n};\n\ntype MaskBindingProps = {\n  maskMap?: Texture;\n};\n\ntype MaskUniformProps = {\n  bounds: [number, number, number, number];\n  channel: number;\n  enabled: boolean;\n  inverted: boolean;\n  maskByInstance: boolean;\n};\n\nexport type MaskProps = MaskBindingProps & MaskUniformProps;\n\n/* eslint-disable camelcase */\nconst getMaskUniforms = (opts?: MaskProps | {}): Record<string, any> => {\n  if (opts && 'maskMap' in opts) {\n    return {\n      mask_texture: opts.maskMap\n    };\n  }\n  return opts || {};\n};\n\nexport default {\n  name: 'mask',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: getMaskUniforms,\n  uniformTypes: {\n    bounds: 'vec4<f32>',\n    channel: 'i32',\n    enabled: 'i32',\n    inverted: 'i32',\n    maskByInstance: 'i32'\n  }\n} as const satisfies ShaderModule<MaskProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  Viewport,\n  Effect,\n  EffectContext,\n  PreRenderOptions,\n  CoordinateSystem,\n  log\n} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: 0 | 1 | 2 | 3;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: 0 | 1 | 2 | 3;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture;\n  private lastViewport?: Viewport;\n\n  setup({device}: EffectContext) {\n    this.dummyMaskMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n\n    this.maskPass = new MaskPass(device, {id: 'default-mask'});\n    this.maskMap = this.maskPass.maskMap;\n  }\n\n  preRender({\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking\n  }: PreRenderOptions): MaskPreRenderStats {\n    let didRender = false;\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  /* eslint-disable-next-line complexity */\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap!.width,\n            height: maskMap!.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          shaderModuleProps: {\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getShaderModuleProps(): {\n    mask: {\n      maskMap: Texture;\n      maskChannels: Record<string, Mask> | null;\n    };\n  } {\n    return {\n      mask: {\n        maskMap: this.masks ? this.maskMap! : this.dummyMaskMap!,\n        maskChannels: this.masks\n      }\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  Device,\n  Framebuffer,\n  Parameters,\n  RenderPipelineParameters,\n  Texture\n} from '@luma.gl/core';\nimport {Layer, _LayersPass as LayersPass, LayersPassRenderOptions, Viewport} from '@deck.gl/core';\n\ntype MaskPassRenderOptions = LayersPassRenderOptions & {\n  /** The channel to render into, 0:red, 1:green, 2:blue, 3:alpha */\n  channel: 0 | 1 | 2 | 3;\n};\n\nconst MASK_BLENDING: RenderPipelineParameters = {\n  blendColorOperation: 'subtract',\n  blendColorSrcFactor: 'zero',\n  blendColorDstFactor: 'one',\n  blendAlphaOperation: 'subtract',\n  blendAlphaSrcFactor: 'zero',\n  blendAlphaDstFactor: 'one'\n};\n\nexport default class MaskPass extends LayersPass {\n  maskMap: Texture;\n  fbo: Framebuffer;\n\n  constructor(device: Device, props: {id: string; mapSize?: number}) {\n    super(device, props);\n\n    const {mapSize = 2048} = props;\n\n    this.maskMap = device.createTexture({\n      format: 'rgba8unorm',\n      width: mapSize,\n      height: mapSize,\n      sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      }\n    });\n\n    this.fbo = device.createFramebuffer({\n      id: 'maskmap',\n      width: mapSize,\n      height: mapSize,\n      colorAttachments: [this.maskMap]\n    });\n  }\n\n  render(options: MaskPassRenderOptions) {\n    const colorMask = 2 ** options.channel;\n    const clearColor = [255, 255, 255, 255];\n    super.render({...options, clearColor, colorMask, target: this.fbo, pass: 'mask'});\n  }\n\n  protected getLayerParameters(\n    layer: Layer<{}>,\n    layerIndex: number,\n    viewport: Viewport\n  ): Parameters {\n    return {\n      ...layer.props.parameters,\n      blend: true,\n      depthCompare: 'always',\n      ...MASK_BLENDING\n    };\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.operation.includes('mask');\n  }\n\n  delete() {\n    this.fbo.delete();\n    this.maskMap.delete();\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {WebMercatorViewport, OrthographicViewport} from '@deck.gl/core';\nimport type {Layer, Viewport} from '@deck.gl/core';\n\n/** Bounds in CARTESIAN coordinates */\nexport type Bounds = [minX: number, minY: number, maxX: number, maxY: number];\n\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(\n  /** The layers to combine */\n  layers: Layer[],\n  /** A Viewport instance that is used to determine the type of the view */\n  viewport: Viewport\n): Bounds | null {\n  // Join the bounds of layer data\n  const bounds: Bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {viewport, autoOffset: false});\n      const topRightCommon = layer.projectPosition(layerBounds[1], {viewport, autoOffset: false});\n\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\n\nconst MAX_VIEWPORT_SIZE = 2048;\n\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts: {\n  /** The cartesian bounds of layers that will render into this texture */\n  bounds: Bounds;\n  /** Target width. If not specified, will be deduced from zoom */\n  width?: number;\n  /** Target height. If not specified, will be deduced from zoom */\n  height?: number;\n  /** Target zoom. If not specified, will be deduced from width and height */\n  zoom?: number;\n  /** Border around the viewport in pixels */\n  border?: number;\n  /** A viewport used to determine the output type */\n  viewport: Viewport;\n}): Viewport | null {\n  const {bounds, viewport, border = 0} = opts;\n  const {isGeospatial} = viewport;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const centerWorld = viewport.unprojectPosition([\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n    0\n  ]);\n\n  let {width, height, zoom} = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width! - border * 2;\n    height = height! - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial\n    ? new WebMercatorViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        longitude: centerWorld[0],\n        latitude: centerWorld[1],\n        zoom,\n        orthographic: true\n      })\n    : new OrthographicViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        target: centerWorld,\n        zoom,\n        flipY: false\n      });\n}\n\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport: Viewport, zRange?: [number, number]): Bounds {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld: Bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    viewportBoundsWorld = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [\n    viewportBottomLeftCommon[0],\n    viewportBottomLeftCommon[1],\n    viewportTopRightCommon[0],\n    viewportTopRightCommon[1]\n  ];\n}\n\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(\n  layerBounds: Bounds,\n  viewport: Viewport,\n  zRange?: [number, number]\n): Bounds {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (\n    layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] &&\n    layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]\n  ) {\n    return layerBounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [\n    Math.max(layerBounds[0], paddedBounds[0]),\n    Math.max(layerBounds[1], paddedBounds[1]),\n    Math.min(layerBounds[2], paddedBounds[2]),\n    Math.min(layerBounds[3], paddedBounds[3])\n  ];\n}\n\nfunction doubleBounds(bounds: Bounds): Bounds {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension, UpdateParameters} from '@deck.gl/core';\nimport {TerrainEffect} from './terrain-effect';\nimport {terrainModule} from './shader-module';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\n\nexport type TerrainExtensionProps = {\n  /**\n   * controls whether an object is drawn over the terrain surface by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  terrainDrawMode?: 'offset' | 'drape';\n};\n\ntype TerrainExtensionState = {\n  /** Resolved fitting mode */\n  terrainDrawMode: 'offset' | 'drape';\n  /** Set when a layer is flagged as needs redraw */\n  terrainCoverNeedsRedraw: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class TerrainExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'TerrainExtension';\n\n  getShaders(this: Layer<TerrainExtensionProps>): any {\n    return {\n      modules: [terrainModule]\n    };\n  }\n\n  initializeState(this: Layer<TerrainExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new TerrainEffect());\n  }\n\n  updateState(\n    this: Layer<TerrainExtensionProps>,\n    params: UpdateParameters<Layer<TerrainExtensionProps>>\n  ) {\n    const {props, oldProps} = params;\n\n    if (\n      this.state.terrainDrawMode &&\n      props.terrainDrawMode === oldProps.terrainDrawMode &&\n      // @ts-ignore `extruded` may not exist in props\n      props.extruded === oldProps.extruded\n    ) {\n      return;\n    }\n\n    let {terrainDrawMode} = props;\n    if (!terrainDrawMode) {\n      // props.extruded is used as an indication that the layer is 2.5D\n      // @ts-ignore `extruded` may not exist in props\n      const is3d = this.props.extruded as boolean;\n      const attributes = this.getAttributeManager()?.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n    this.setState({terrainDrawMode});\n  }\n\n  onNeedsRedraw(this: Layer<{}>): void {\n    const state = this.state as TerrainExtensionState;\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\n\nimport {terrainModule, TerrainModuleProps} from './shader-module';\nimport {TerrainCover} from './terrain-cover';\nimport {TerrainPass} from './terrain-pass';\nimport {TerrainPickingPass, TerrainPickingPassRenderOptions} from './terrain-picking-pass';\nimport {HeightMapBuilder} from './height-map-builder';\n\nimport type {Effect, EffectContext, PreRenderOptions, Layer, Viewport} from '@deck.gl/core';\n\n/** Class to manage terrain effect */\nexport class TerrainEffect implements Effect {\n  id = 'terrain-effect';\n  props = null;\n  useInPicking = true;\n\n  /** true if picking in the current pass */\n  private isPicking: boolean = false;\n  /** true if should use in the current pass */\n  private isDrapingEnabled: boolean = false;\n  /** An empty texture as placeholder */\n  private dummyHeightMap?: Texture;\n  /** A texture encoding the ground elevation, updated once per redraw. Used by layers with offset mode */\n  private heightMap?: HeightMapBuilder;\n  private terrainPass!: TerrainPass;\n  private terrainPickingPass!: TerrainPickingPass;\n  /** One texture for each primitive terrain layer, into which the draped layers render */\n  private terrainCovers: Map<string, TerrainCover> = new Map();\n\n  setup({device, deck}: EffectContext) {\n    this.dummyHeightMap = device.createTexture({\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(device, {id: 'terrain'});\n    this.terrainPickingPass = new TerrainPickingPass(device, {id: 'terrain-picking'});\n\n    if (HeightMapBuilder.isSupported(device)) {\n      this.heightMap = new HeightMapBuilder(device);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n\n    deck._addDefaultShaderModule(terrainModule);\n  }\n\n  preRender(opts: PreRenderOptions): void {\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n\n    const {viewports} = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(\n      viewport,\n      opts as TerrainPickingPassRenderOptions\n    );\n\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n\n  getShaderModuleProps(\n    layer: Layer,\n    otherShaderModuleProps: Record<string, any>\n  ): {terrain: TerrainModuleProps} {\n    const {terrainDrawMode} = layer.state;\n\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project,\n        isPicking: this.isPicking,\n        heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,\n        heightMapBounds: this.heightMap?.bounds,\n        dummyHeightMap: this.dummyHeightMap!,\n        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n        useTerrainHeightMap: terrainDrawMode === 'offset',\n        terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n      }\n    };\n  }\n\n  cleanup({deck}: EffectContext): void {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n\n    deck._removeDefaultShaderModule(terrainModule);\n  }\n\n  private _updateHeightMap(terrainLayers: Layer[], viewport: Viewport, opts: PreRenderOptions) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n\n    const shouldUpdate = this.heightMap.shouldUpdate({layers: terrainLayers, viewport});\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      shaderModuleProps: {\n        terrain: {\n          heightMapBounds: this.heightMap.bounds,\n          dummyHeightMap: this.dummyHeightMap,\n          drawToTerrainHeightMap: true\n        },\n        project: {\n          devicePixelRatio: 1\n        }\n      }\n    });\n  }\n\n  private _updateTerrainCovers(\n    terrainLayers: Layer[],\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw: Record<string, boolean> = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({layerNeedsRedraw});\n    }\n\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n\n  private _updateTerrainCover(\n    terrainLayer: Layer,\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          shaderModuleProps: {\n            terrain: {\n              dummyHeightMap: this.dummyHeightMap,\n              terrainSkipRender: false\n            },\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n\n        if (!this.isPicking) {\n          // IsDirty refers to the normal fbo, not the picking fbo.\n          // Only mark it as not dirty if the normal fbo was updated.\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err as Error, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n\n  private _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove: string[] = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project, ProjectProps, ProjectUniforms} from '@deck.gl/core';\n\nimport type {Texture} from '@luma.gl/core';\nimport type {Bounds} from '../utils/projection-utils';\nimport type {TerrainCover} from './terrain-cover';\n\n/** Module parameters expected by the terrain shader module */\nexport type TerrainModuleProps = {\n  project: ProjectProps;\n  isPicking: boolean;\n  heightMap: Texture | null;\n  heightMapBounds?: Bounds | null;\n  dummyHeightMap: Texture;\n  terrainCover?: TerrainCover | null;\n  drawToTerrainHeightMap?: boolean;\n  useTerrainHeightMap?: boolean;\n  terrainSkipRender?: boolean;\n};\n\ntype TerrainModuleUniforms = {\n  mode: number;\n  bounds: [number, number, number, number];\n};\n\ntype TerrainModuleBindings = {\n  terrain_map: Texture;\n};\n\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\n\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n  .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n  .join('\\n');\n\nconst uniformBlock =\n  // eslint-disable-next-line prefer-template\n  TERRAIN_MODE_CONSTANTS +\n  /* glsl */ `\nuniform terrainUniforms {\n  float mode;\n  vec4 bounds;\n} terrain;\n\nuniform sampler2D terrain_map;\n`;\n\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  // eslint-disable-next-line prefer-template\n  vs: uniformBlock + /* glsl */ 'out vec3 commonPos;',\n  // eslint-disable-next-line prefer-template\n  fs: uniformBlock + /* glsl */ 'in vec3 commonPos;',\n  inject: {\n    'vs:#main-start': /* glsl */ `\nif (terrain.mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\ncommonPos = geometry.position.xyz;\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project.commonOrigin.z;\n}\nif (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#main-start': /* glsl */ `\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */ `\nif ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  vec4 pixel = texture(terrain_map, texCoords);\n  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts: Partial<TerrainModuleProps> = {}) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const projectUniforms = project.getUniforms(opts.project) as ProjectUniforms;\n      const {commonOrigin} = projectUniforms;\n\n      let mode: number = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler: Texture | undefined = dummyHeightMap as Texture;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds: number[] | null = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds!;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds!;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const fbo = opts.isPicking\n          ? terrainCover.getPickingFramebuffer()\n          : terrainCover.getRenderFramebuffer();\n        sampler = fbo?.colorAttachments[0].texture;\n        if (opts.isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap!;\n        }\n      }\n\n      /* eslint-disable camelcase */\n      return {\n        mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        bounds: bounds\n          ? [\n              bounds[0] - commonOrigin[0],\n              bounds[1] - commonOrigin[1],\n              bounds[2] - bounds[0],\n              bounds[3] - bounds[1]\n            ]\n          : [0, 0, 0, 0]\n      };\n    }\n    return {};\n  },\n  uniformTypes: {\n    mode: 'f32',\n    bounds: 'vec4<f32>'\n  }\n} as const satisfies ShaderModule<TerrainModuleProps, TerrainModuleUniforms, TerrainModuleBindings>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nexport function createRenderTarget(\n  device: Device,\n  opts: {\n    id: string;\n    float?: boolean;\n    interpolate?: boolean;\n  }\n) {\n  return device.createFramebuffer({\n    id: opts.id,\n    colorAttachments: [\n      device.createTexture({\n        id: opts.id,\n        ...(opts.float && {\n          format: 'rgba32float',\n          type: GL.FLOAT\n        }),\n        mipmaps: false,\n        sampler:\n          opts.interpolate === false\n            ? {\n                minFilter: 'nearest',\n                magFilter: 'nearest'\n              }\n            : {\n                minFilter: 'linear',\n                magFilter: 'linear'\n              }\n      })\n    ]\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer} from '@luma.gl/core';\n\nimport type {Layer, Viewport} from '@deck.gl/core';\n\nimport {createRenderTarget} from './utils';\nimport {joinLayerBounds, makeViewport, getRenderBounds, Bounds} from '../utils/projection-utils';\n\ntype TileHeader = {\n  boundingBox: [min: number[], max: number[]];\n};\n\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  isDirty: boolean = true;\n  /** The terrain layer that this instance belongs to */\n  targetLayer: Layer;\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the terrain cover texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  private fbo?: Framebuffer;\n  private pickingFbo?: Framebuffer;\n  private layers: string[] = [];\n  private tile: TileHeader | null;\n  /** Cached version of targetLayer.getBounds() */\n  private targetBounds: [number[], number[]] | null = null;\n  /** targetBounds in cartesian space */\n  private targetBoundsCommon: Bounds | null = null;\n\n  constructor(targetLayer: Layer) {\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n\n  get id() {\n    return this.targetLayer.id;\n  }\n\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive(): boolean {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }: {\n    targetLayer?: Layer;\n    viewport?: Viewport;\n    layers?: Layer[];\n    layerNeedsRedraw?: Record<string, boolean>;\n  }): boolean {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n\n    return layersChanged || sizeChanged;\n  }\n\n  /** Compare layers with the last version. Only rerender if necessary. */\n  private _updateLayers(layers: Layer[]): boolean {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  // eslint-disable-next-line max-statements\n  private _updateViewport(viewport: Viewport): boolean {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [\n          bottomLeftCommon[0],\n          bottomLeftCommon[1],\n          topRightCommon[0],\n          topRightCommon[1]\n        ];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n\n    return shouldRedraw;\n  }\n\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.device, {id: this.id});\n    }\n    return this.fbo;\n  }\n\n  getPickingFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {\n        id: `${this.id}-picking`,\n        interpolate: false\n      });\n    }\n    return this.pickingFbo;\n  }\n\n  filterLayers(layers: Layer[]) {\n    return layers.filter(({id}) => this.layers.includes(id));\n  }\n\n  delete() {\n    const {fbo, pickingFbo} = this;\n    if (fbo) {\n      fbo.colorAttachments[0].destroy();\n      fbo.destroy();\n    }\n    if (pickingFbo) {\n      pickingFbo.colorAttachments[0].destroy();\n      pickingFbo.destroy();\n    }\n  }\n}\n\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile: TileHeader, layers: Layer[]): Layer[] {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer: Layer): TileHeader | null {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {tile} = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent as Layer;\n  }\n  return null;\n}\n\nfunction intersect(b1?: [number[], number[]], b2?: [number[], number[]]): boolean {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Parameters, RenderPipelineParameters} from '@luma.gl/core';\nimport {Layer, Viewport, _LayersPass as LayersPass, LayersPassRenderOptions} from '@deck.gl/core';\nimport type {HeightMapBuilder} from './height-map-builder';\nimport type {TerrainCover} from './terrain-cover';\n\nexport type TerrainPassRenderOptions = LayersPassRenderOptions;\n\nconst TERRAIN_BLENDING: RenderPipelineParameters = {\n  blendColorOperation: 'max',\n  blendColorSrcFactor: 'one',\n  blendColorDstFactor: 'one',\n  blendAlphaOperation: 'max',\n  blendAlphaSrcFactor: 'one',\n  blendAlphaDstFactor: 'one'\n};\n\n/** Renders textures used by the TerrainEffect render pass */\nexport class TerrainPass extends LayersPass {\n  getRenderableLayers(viewport: Viewport, opts: TerrainPassRenderOptions): Layer[] {\n    const {layers} = opts;\n    const result: Layer[] = [];\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n      }\n    }\n\n    return result;\n  }\n\n  renderHeightMap(heightMap: HeightMapBuilder, opts: Partial<TerrainPassRenderOptions>) {\n    // console.log('Updating height map')\n    const target = heightMap.getRenderFramebuffer();\n    const viewport = heightMap.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    target.resize(viewport);\n\n    this.render({\n      ...opts,\n      target,\n      pass: 'terrain-height-map',\n      layers: opts.layers!,\n      viewports: [viewport],\n      effects: [],\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n\n  renderTerrainCover(terrainCover: TerrainCover, opts: Partial<TerrainPassRenderOptions>) {\n    // console.log('Updating terrain cover ' + terrainCover.id)\n    const target = terrainCover.getRenderFramebuffer();\n    const viewport = terrainCover.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    const layers = terrainCover.filterLayers(opts.layers!);\n    target.resize(viewport);\n\n    this.render({\n      ...opts,\n      target,\n      pass: `terrain-cover-${terrainCover.id}`,\n      layers,\n      effects: [],\n      viewports: [viewport],\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n\n  protected getLayerParameters(\n    layer: Layer<{}>,\n    layerIndex: number,\n    viewport: Viewport\n  ): Parameters {\n    return {\n      ...layer.props.parameters,\n      blend: true,\n      depthCompare: 'always',\n      ...(layer.props.operation.includes('terrain') && TERRAIN_BLENDING)\n    };\n  }\n\n  getShaderModuleProps(layer: Layer, effects: any, otherShaderModuleProps: Record<string, any>) {\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project\n      }\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  Viewport,\n  LayersPassRenderOptions,\n  _PickLayersPass as PickLayersPass\n} from '@deck.gl/core';\nimport type {TerrainCover} from './terrain-cover';\nimport {Parameters} from '@luma.gl/core';\n\nexport type TerrainPickingPassRenderOptions = LayersPassRenderOptions & {\n  pickZ: boolean;\n};\n\n/** Renders textures used by the TerrainEffect picking pass */\nexport class TerrainPickingPass extends PickLayersPass {\n  /** Save layer index for use when drawing to terrain cover.\n   * When a terrain cover's picking buffer is rendered,\n   * we need to make sure each layer receives a consistent index (encoded in the alpha channel)\n   * so that a picked color can be decoded back to the correct layer.\n   * Updated in getRenderableLayers which is called in TerrainEffect.preRender\n   */\n  drawParameters: Record<string, any> = {};\n\n  getRenderableLayers(viewport: Viewport, opts: TerrainPickingPassRenderOptions): Layer[] {\n    const {layers} = opts;\n    const result: Layer[] = [];\n    this.drawParameters = {};\n    this._resetColorEncoder(opts.pickZ);\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;\n      }\n    }\n\n    return result;\n  }\n\n  renderTerrainCover(terrainCover: TerrainCover, opts: Partial<TerrainPickingPassRenderOptions>) {\n    // console.log('Updating terrain cover for picking ' + terrainCover.id)\n    const target = terrainCover.getPickingFramebuffer();\n    const viewport = terrainCover.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    const layers = terrainCover.filterLayers(opts.layers!);\n    const terrainLayer = terrainCover.targetLayer;\n    if (terrainLayer.props.pickable) {\n      layers.unshift(terrainLayer);\n    }\n    target.resize(viewport);\n\n    this.render({\n      ...opts,\n      pickingFBO: target,\n      pass: `terrain-cover-picking-${terrainCover.id}`,\n      layers,\n      effects: [],\n      viewports: [viewport],\n      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,\n      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`\n      cullRect: undefined,\n      deviceRect: viewport,\n      pickZ: false\n    });\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): Parameters {\n    let parameters: any;\n    if (this.drawParameters[layer.id]) {\n      parameters = this.drawParameters[layer.id];\n    } else {\n      parameters = super.getLayerParameters(layer, layerIndex, viewport);\n      parameters.blend = true;\n    }\n    return {...parameters, depthCompare: 'always'};\n  }\n\n  getShaderModuleProps(layer: Layer, effects: any, otherShaderModuleProps: Record<string, any>) {\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project\n      }\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\nimport {createRenderTarget} from './utils';\n\nimport type {Viewport, Layer} from '@deck.gl/core';\n\nconst MAP_MAX_SIZE = 2048;\n\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the height map texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  protected fbo?: Framebuffer;\n  protected device: Device;\n  /** Last rendered layers */\n  private layers: Layer[] = [];\n  /** Last layer.getBounds() */\n  private layersBounds: ([number[], number[]] | null)[] = [];\n  /** The union of layersBounds in cartesian space */\n  private layersBoundsCommon: Bounds | null = null;\n  private lastViewport: Viewport | null = null;\n\n  static isSupported(device: Device): boolean {\n    return device.isTextureFormatRenderable('rgba32float');\n  }\n\n  constructor(device: Device) {\n    this.device = device;\n  }\n\n  /** Returns the height map framebuffer for read/write access.\n   * Returns null when the texture is invalid.\n   */\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.device, {id: 'height-map', float: true});\n    }\n    return this.fbo;\n  }\n\n  /** Called every render cycle to check if the framebuffer needs update */\n  shouldUpdate({layers, viewport}: {layers: Layer[]; viewport: Viewport}): boolean {\n    const layersChanged =\n      layers.length !== this.layers.length ||\n      layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a terrain source,\n          // for example getElevation+updateTriggers, elevationScale, modelMatrix\n          layer !== this.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions ||\n          // Layer's geometry bounds have changed\n          layer.getBounds() !== this.layersBounds[i]\n      );\n\n    if (layersChanged) {\n      // Recalculate cached bounds\n      this.layers = layers;\n      this.layersBounds = layers.map(layer => layer.getBounds());\n      this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n    }\n\n    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n\n    if (!this.layersBoundsCommon) {\n      this.renderViewport = null;\n    } else if (layersChanged || viewportChanged) {\n      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        this.renderViewport = null;\n        return false;\n      }\n\n      this.bounds = bounds;\n      this.lastViewport = viewport;\n\n      const scale = viewport.scale;\n      const pixelWidth = (bounds[2] - bounds[0]) * scale;\n      const pixelHeight = (bounds[3] - bounds[1]) * scale;\n\n      this.renderViewport =\n        pixelWidth > 0 || pixelHeight > 0\n          ? makeViewport({\n              // It's not important whether the geometry is visible in this viewport, because\n              // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n              // However the viewport must have the same center and zoom as the screen viewport\n              // So that projection uniforms used for calculating z are the same\n              bounds: [\n                viewport.center[0] - 1,\n                viewport.center[1] - 1,\n                viewport.center[0] + 1,\n                viewport.center[1] + 1\n              ],\n              zoom: viewport.zoom,\n              width: Math.min(pixelWidth, MAP_MAX_SIZE),\n              height: Math.min(pixelHeight, MAP_MAX_SIZE),\n              viewport\n            })\n          : null;\n      return true;\n    }\n    return false;\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.colorAttachments[0].delete();\n      this.fbo.delete();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "uniformBlock", "vertex", "vs", "fragment", "fs", "inject", "fp64", "defaultProps", "fp64", "module", "deepEqual", "import_core", "import_core", "getUniforms", "memoize", "import_core", "defaultProps", "mergeShaders", "inject", "import_core", "import_core", "uniformBlock", "vs", "fs", "inject", "defaultProps", "import_core", "defaultProps", "import_core", "import_core", "vs", "inject", "shader_module_default", "import_core", "import_core", "LayersPass", "deepEqual", "defaultProps", "shader_module_default", "import_core", "import_core", "uniformBlock", "vertex", "vs", "fragment", "fs", "inject", "shader_module_default", "import_core", "import_core", "LayersPass", "import_core", "defaultProps", "shader_module_default", "import_core", "import_core", "import_core", "uniformBlock", "import_core", "LayersPass", "import_core", "PickLayersPass", "parameters", "defaultProps"]
}
