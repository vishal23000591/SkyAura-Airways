(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var Lo=Object.create;var Et=Object.defineProperty;var Po=Object.getOwnPropertyDescriptor;var wo=Object.getOwnPropertyNames;var No=Object.getPrototypeOf,Oo=Object.prototype.hasOwnProperty;var Jt=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),Ro=(n,t)=>{for(var e in t)Et(n,e,{get:t[e],enumerable:!0})},bt=(n,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of wo(t))!Oo.call(n,r)&&r!==e&&Et(n,r,{get:()=>t[r],enumerable:!(o=Po(t,r))||o.enumerable});return n},j=(n,t,e)=>(bt(n,t,"default"),e&&bt(e,t,"default")),L=(n,t,e)=>(e=n!=null?Lo(No(n)):{},bt(t||!n||!n.__esModule?Et(e,"default",{value:n,enumerable:!0}):e,n)),_o=n=>bt(Et({},"__esModule",{value:!0}),n);var Z=Jt((zr,ue)=>{ue.exports=globalThis.deck});var I=Jt((Fr,xe)=>{xe.exports=globalThis.deck});var X=Jt((jr,be)=>{be.exports=globalThis.luma});var Ct={};Ro(Ct,{CPUAggregator:()=>O,ContourLayer:()=>Jn,GridLayer:()=>so,HeatmapLayer:()=>To,HexagonLayer:()=>Xe,ScreenGridLayer:()=>We,WebGLAggregator:()=>P,_AggregationLayer:()=>U});var B={},me=L(Z(),1);j(B,L(Z(),1));if(!me.GeoJsonLayer)throw new Error("@deck.gl/layers is not found");j(Ct,B);var Fe=L(I(),1);var Ce=L(I(),1);function ve({pointCount:n,getBinId:t}){let e=new Map;for(let o=0;o<n;o++){let r=t(o);if(r===null)continue;let i=e.get(String(r));i?i.points.push(o):(i={id:r,index:e.size,points:[o]},e.set(String(r),i))}return Array.from(e.values())}function Me({bins:n,dimensions:t,target:e}){let o=n.length*t;(!e||e.length<o)&&(e=new Float32Array(o));for(let r=0;r<n.length;r++){let{id:i}=n[r];Array.isArray(i)?e.set(i,r*t):e[r]=i}return e}var zo=n=>n.length,ye=(n,t)=>{let e=0;for(let o of n)e+=t(o);return e},Io=(n,t)=>n.length===0?NaN:ye(n,t)/n.length,Fo=(n,t)=>{let e=1/0;for(let o of n){let r=t(o);r<e&&(e=r)}return e},Wo=(n,t)=>{let e=-1/0;for(let o of n){let r=t(o);r>e&&(e=r)}return e},Se={COUNT:zo,SUM:ye,MEAN:Io,MIN:Fo,MAX:Wo};function Ae({bins:n,getValue:t,operation:e,target:o}){(!o||o.length<n.length)&&(o=new Float32Array(n.length));let r=1/0,i=-1/0;for(let s=0;s<n.length;s++){let{points:a}=n[s];o[s]=e(a,t),o[s]<r&&(r=o[s]),o[s]>i&&(i=o[s])}return{value:o,domain:[r,i]}}function te(n,t,e){let o={};for(let i of n.sources||[]){let s=t[i];if(s)o[i]=Do(s);else throw new Error(`Cannot find attribute ${i}`)}let r={};return i=>{for(let s in o)r[s]=o[s](i);return n.getValue(r,i,e)}}function Do(n){let t=n.value,{offset:e=0,stride:o,size:r}=n.getAccessor(),i=t.BYTES_PER_ELEMENT,s=e/i,a=o?o/i:r;if(r===1)return n.isConstant?()=>t[0]:g=>{let h=s+a*g;return t[h]};let c;return n.isConstant?(c=Array.from(t),()=>c):(c=new Array(r),g=>{let h=s+a*g;for(let f=0;f<r;f++)c[f]=t[h+f];return c})}var O=class{constructor(t){this.bins=[],this.binIds=null,this.results=[],this.dimensions=t.dimensions,this.channelCount=t.getValue.length,this.props={...t,binOptions:{},pointCount:0,operations:[],customOperations:[],attributes:{}},this.needsUpdate=!0,this.setProps(t)}destroy(){}get binCount(){return this.bins.length}setProps(t){let e=this.props;if(t.binOptions&&((0,Ce._deepEqual)(t.binOptions,e.binOptions,2)||this.setNeedsUpdate()),t.operations)for(let o=0;o<this.channelCount;o++)t.operations[o]!==e.operations[o]&&this.setNeedsUpdate(o);if(t.customOperations)for(let o=0;o<this.channelCount;o++)Boolean(t.customOperations[o])!==Boolean(e.customOperations[o])&&this.setNeedsUpdate(o);t.pointCount!==void 0&&t.pointCount!==e.pointCount&&this.setNeedsUpdate(),t.attributes&&(t.attributes={...e.attributes,...t.attributes}),Object.assign(this.props,t)}setNeedsUpdate(t){t===void 0?this.needsUpdate=!0:this.needsUpdate!==!0&&(this.needsUpdate=this.needsUpdate||[],this.needsUpdate[t]=!0)}update(){if(this.needsUpdate===!0){this.bins=ve({pointCount:this.props.pointCount,getBinId:te(this.props.getBin,this.props.attributes,this.props.binOptions)});let t=Me({bins:this.bins,dimensions:this.dimensions,target:this.binIds?.value});this.binIds={value:t,type:"float32",size:this.dimensions}}for(let t=0;t<this.channelCount;t++)if(this.needsUpdate===!0||this.needsUpdate[t]){let e=this.props.customOperations[t]||Se[this.props.operations[t]],{value:o,domain:r}=Ae({bins:this.bins,getValue:te(this.props.getValue[t],this.props.attributes,void 0),operation:e,target:this.results[t]?.value});this.results[t]={value:o,domain:r,type:"float32",size:1},this.props.onUpdate?.({channel:t})}this.needsUpdate=!1}preDraw(){}getBins(){return this.binIds}getResult(t){return this.results[t]}getResultDomain(t){return this.results[t]?.domain??[1/0,-1/0]}getBin(t){let e=this.bins[t];if(!e)return null;let o=new Array(this.channelCount);for(let r=0;r<o.length;r++){let i=this.results[r];o[r]=i?.value[t]}return{id:e.id,value:o,count:e.points.length,pointIndices:e.points}}};var Le=L(X(),1);function Tt(n,t,e){return n.createFramebuffer({width:t,height:e,colorAttachments:[n.createTexture({width:t,height:e,format:"rgba32float",mipmaps:!1,sampler:{minFilter:"nearest",magFilter:"nearest"}})]})}var Vo=`uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`,Ee={name:"binSorter",vs:Vo,uniformTypes:{binIdRange:"vec4<i32>",targetSize:"vec2<i32>"}};var Pe=[1,2,4,8],Te=3e38,Bo={SUM:0,MEAN:0,MIN:0,MAX:0,COUNT:0},dt=1024,Lt=class{constructor(t,e){this.binsFBO=null,this.device=t,this.model=Ho(t,e)}get texture(){return this.binsFBO?this.binsFBO.colorAttachments[0].texture:null}destroy(){this.model.destroy(),this.binsFBO?.colorAttachments[0].texture.destroy(),this.binsFBO?.destroy()}getBinValues(t){if(!this.binsFBO)return null;let e=t%dt,o=Math.floor(t/dt),r=this.device.readPixelsToArrayWebGL(this.binsFBO,{sourceX:e,sourceY:o,sourceWidth:1,sourceHeight:1}).buffer;return new Float32Array(r)}setDimensions(t,e){let o=dt,r=Math.ceil(t/o);this.binsFBO?this.binsFBO.height<r&&this.binsFBO.resize({width:o,height:r}):this.binsFBO=Tt(this.device,o,r);let i={binIdRange:[e[0][0],e[0][1],e[1]?.[0]||0,e[1]?.[1]||0],targetSize:[this.binsFBO.width,this.binsFBO.height]};this.model.shaderInputs.setProps({binSorter:i})}setModelProps(t){let e=this.model;t.attributes&&e.setAttributes(t.attributes),t.constantAttributes&&e.setConstantAttributes(t.constantAttributes),t.vertexCount!==void 0&&e.setVertexCount(t.vertexCount),t.shaderModuleProps&&e.shaderInputs.setProps(t.shaderModuleProps)}update(t){if(!this.binsFBO)return;let e=Uo(t);this._updateBins("SUM",e.SUM+e.MEAN),this._updateBins("MIN",e.MIN),this._updateBins("MAX",e.MAX)}_updateBins(t,e){if(e===0)return;e|=Pe[3];let o=this.model,r=this.binsFBO,i=t==="MAX"?-Te:t==="MIN"?Te:0,s=this.device.beginRenderPass({id:`gpu-aggregation-${t}`,framebuffer:r,parameters:{viewport:[0,0,r.width,r.height],colorMask:e},clearColor:[i,i,i,0],clearDepth:!1,clearStencil:!1});o.setParameters({blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendColorOperation:t==="MAX"?"max":t==="MIN"?"min":"add",blendAlphaOperation:"add"}),o.draw(s),s.end()}};function Uo(n){let t={...Bo};for(let e=0;e<n.length;e++){let o=n[e];o&&(t[o]+=Pe[e])}return t}function Ho(n,t){let e=t.vs;t.dimensions===2&&(e+=`
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`);let o=`#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${e}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`,r=`#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`;return new Le.Model(n,{bufferLayout:t.bufferLayout,modules:[...t.modules||[],Ee],defines:{...t.defines,NON_INSTANCED_MODEL:1,NUM_CHANNELS:t.channelCount},isInstanced:!1,vs:o,fs:r,topology:"point-list",disableWarnings:!0})}var Ne=L(X(),1);var ko=`uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`,we={name:"aggregatorTransform",vs:ko,uniformTypes:{binIdRange:"vec4<i32>",isCount:"vec3<f32>",isMean:"vec3<f32>"}};var ee=3e38,Pt=class{constructor(t,e){this.binBuffer=null,this.valueBuffer=null,this._domains=null,this.device=t,this.channelCount=e.channelCount,this.transform=jo(t,e),this.domainFBO=Tt(t,2,1)}destroy(){this.transform.destroy(),this.binBuffer?.destroy(),this.valueBuffer?.destroy(),this.domainFBO.colorAttachments[0].texture.destroy(),this.domainFBO.destroy()}get domains(){if(!this._domains){let t=this.device.readPixelsToArrayWebGL(this.domainFBO).buffer,e=new Float32Array(t);this._domains=[[-e[4],e[0]],[-e[5],e[1]],[-e[6],e[2]]].slice(0,this.channelCount)}return this._domains}setDimensions(t,e){let{model:o,transformFeedback:r}=this.transform;o.setVertexCount(t);let i={binIdRange:[e[0][0],e[0][1],e[1]?.[0]||0,e[1]?.[1]||0]};o.shaderInputs.setProps({aggregatorTransform:i});let s=t*e.length*4;(!this.binBuffer||this.binBuffer.byteLength<s)&&(this.binBuffer?.destroy(),this.binBuffer=this.device.createBuffer({byteLength:s}),r.setBuffer("binIds",this.binBuffer));let a=t*this.channelCount*4;(!this.valueBuffer||this.valueBuffer.byteLength<a)&&(this.valueBuffer?.destroy(),this.valueBuffer=this.device.createBuffer({byteLength:a}),r.setBuffer("values",this.valueBuffer))}update(t,e){if(!t)return;let o=this.transform,r=this.domainFBO,i=[0,1,2].map(c=>e[c]==="COUNT"?1:0),s=[0,1,2].map(c=>e[c]==="MEAN"?1:0),a={isCount:i,isMean:s,bins:t};o.model.shaderInputs.setProps({aggregatorTransform:a}),o.run({id:"gpu-aggregation-domain",framebuffer:r,parameters:{viewport:[0,0,2,1]},clearColor:[-ee,-ee,-ee,0],clearDepth:!1,clearStencil:!1}),this._domains=null}};function jo(n,t){let e=`#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`,o=`#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`;return new Ne.BufferTransform(n,{vs:e,fs:o,topology:"point-list",modules:[we],parameters:{blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendColorOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendAlphaOperation:"max"},defines:{NUM_DIMS:t.dimensions,NUM_CHANNELS:t.channelCount,SAMPLER_WIDTH:dt},varyings:["binIds","values"],disableWarnings:!0})}var ut=L(I(),1),P=class{static isSupported(t){return t.features.has("float32-renderable-webgl")&&t.features.has("texture-blend-float-webgl")}constructor(t,e){this.binCount=0,this.binIds=null,this.results=[],this.device=t,this.dimensions=e.dimensions,this.channelCount=e.channelCount,this.props={...e,pointCount:0,binIdRange:[[0,0]],operations:[],attributes:{},binOptions:{}},this.needsUpdate=new Array(this.channelCount).fill(!0),this.binSorter=new Lt(t,e),this.aggregationTransform=new Pt(t,e),this.setProps(e)}getBins(){let t=this.aggregationTransform.binBuffer;return t?(this.binIds?.buffer!==t&&(this.binIds={buffer:t,type:"float32",size:this.dimensions}),this.binIds):null}getResult(t){let e=this.aggregationTransform.valueBuffer;return!e||t>=this.channelCount?null:(this.results[t]?.buffer!==e&&(this.results[t]={buffer:e,type:"float32",size:1,stride:this.channelCount*4,offset:t*4}),this.results[t])}getResultDomain(t){return this.aggregationTransform.domains[t]}getBin(t){if(t<0||t>=this.binCount)return null;let{binIdRange:e}=this.props,o;if(this.dimensions===1)o=[t+e[0][0]];else{let[[a,c],[g]]=e,h=c-a;o=[t%h+a,Math.floor(t/h)+g]}let r=this.binSorter.getBinValues(t);if(!r)return null;let i=r[3],s=[];for(let a=0;a<this.channelCount;a++){let c=this.props.operations[a];c==="COUNT"?s[a]=i:i===0?s[a]=NaN:s[a]=c==="MEAN"?r[a]/i:r[a]}return{id:o,value:s,count:i}}destroy(){this.binSorter.destroy(),this.aggregationTransform.destroy()}setProps(t){let e=this.props;if("binIdRange"in t&&!(0,ut._deepEqual)(t.binIdRange,e.binIdRange,2)){let o=t.binIdRange;if(ut.log.assert(o.length===this.dimensions),this.dimensions===1){let[[r,i]]=o;this.binCount=i-r}else{let[[r,i],[s,a]]=o;this.binCount=(i-r)*(a-s)}this.binSorter.setDimensions(this.binCount,o),this.aggregationTransform.setDimensions(this.binCount,o),this.setNeedsUpdate()}if(t.operations)for(let o=0;o<this.channelCount;o++)t.operations[o]!==e.operations[o]&&this.setNeedsUpdate(o);if(t.pointCount!==void 0&&t.pointCount!==e.pointCount&&(this.binSorter.setModelProps({vertexCount:t.pointCount}),this.setNeedsUpdate()),t.binOptions&&((0,ut._deepEqual)(t.binOptions,e.binOptions,2)||this.setNeedsUpdate(),this.binSorter.model.shaderInputs.setProps({binOptions:t.binOptions})),t.attributes){let o={},r={};for(let i of Object.values(t.attributes))for(let[s,a]of Object.entries(i.getValue()))ArrayBuffer.isView(a)?r[s]=a:a&&(o[s]=a);this.binSorter.setModelProps({attributes:o,constantAttributes:r})}t.shaderModuleProps&&this.binSorter.setModelProps({shaderModuleProps:t.shaderModuleProps}),Object.assign(this.props,t)}setNeedsUpdate(t){t===void 0?this.needsUpdate.fill(!0):this.needsUpdate[t]=!0}update(){}preDraw(){if(!this.needsUpdate.some(Boolean))return;let{operations:t}=this.props,e=this.needsUpdate.map((o,r)=>o?t[r]:null);this.binSorter.update(e),this.aggregationTransform.update(this.binSorter.texture,t);for(let o=0;o<this.channelCount;o++)this.needsUpdate[o]&&(this.needsUpdate[o]=!1,this.props.onUpdate?.({channel:o}))}};var Nt=L(I(),1),wt=class extends Nt.CompositeLayer{get isDrawable(){return!0}initializeState(){this.getAttributeManager().remove(["instancePickingColors"])}updateState(t){super.updateState(t);let e=this.getAggregatorType();if(t.changeFlags.extensionsChanged||this.state.aggregatorType!==e){this.state.aggregator?.destroy();let o=this.createAggregator(e);return o.setProps({attributes:this.getAttributeManager()?.attributes}),this.setState({aggregator:o,aggregatorType:e}),!0}return!1}finalizeState(t){super.finalizeState(t),this.state.aggregator.destroy()}updateAttributes(t){let{aggregator:e}=this.state;e.setProps({attributes:t});for(let o in t)this.onAttributeChange(o);e.update()}draw({shaderModuleProps:t}){let{aggregator:e}=this.state;e.setProps({shaderModuleProps:t}),e.preDraw()}_getAttributeManager(){return new Nt.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}};wt.layerName="AggregationLayer";var U=wt;var _t=L(X(),1),zt=L(I(),1);var G=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function ne(n,t=!1,e=Float32Array){let o;if(Number.isFinite(n[0]))o=new e(n);else{o=new e(n.length*4);let r=0;for(let i=0;i<n.length;i++){let s=n[i];o[r++]=s[0],o[r++]=s[1],o[r++]=s[2],o[r++]=Number.isFinite(s[3])?s[3]:255}}if(t)for(let r=0;r<o.length;r++)o[r]/=255;return o}var Ot={linear:"linear",quantile:"nearest",quantize:"nearest",ordinal:"nearest"};function Q(n,t){n.setSampler({minFilter:Ot[t],magFilter:Ot[t]})}function J(n,t,e="linear"){let o=ne(t,!1,Uint8Array);return n.createTexture({format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:Ot[e],magFilter:Ot[e],addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},data:o,width:o.length/4,height:1})}var Oe=`#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec2 positions;
in vec2 instancePositions;
in float instanceWeights;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
if (isnan(instanceWeights)) {
gl_Position = vec4(0.);
return;
}
vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;
pos.x = pos.x - 1.0;
pos.y = 1.0 - pos.y;
gl_Position = vec4(pos, 0., 1.);
vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);
vColor.a *= layer.opacity;
picking_setPickingColor(instancePickingColors);
}
`;var Re=`#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Go=`uniform screenGridUniforms {
  vec2 cellSizeClipspace;
  vec2 gridSizeClipspace;
  vec2 colorDomain;
} screenGrid;
`,_e={name:"screenGrid",vs:Go,uniformTypes:{cellSizeClipspace:"vec2<f32>",gridSizeClipspace:"vec2<f32>",colorDomain:"vec2<f32>"}};var Rt=class extends zt.Layer{getShaders(){return super.getShaders({vs:Oe,fs:Re,modules:[zt.picking,_e]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceWeights:{size:1,type:"float32",accessor:"getWeight"}}),this.state.model=this._getModel()}updateState(t){super.updateState(t);let{props:e,oldProps:o,changeFlags:r}=t,i=this.state.model;if(o.colorRange!==e.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=J(this.context.device,e.colorRange,e.colorScaleType);let s={colorRange:this.state.colorTexture};i.shaderInputs.setProps({screenGrid:s})}else o.colorScaleType!==e.colorScaleType&&Q(this.state.colorTexture,e.colorScaleType);if(o.cellMarginPixels!==e.cellMarginPixels||o.cellSizePixels!==e.cellSizePixels||r.viewportChanged){let{width:s,height:a}=this.context.viewport,{cellSizePixels:c,cellMarginPixels:g}=this.props,h=Math.max(c-g,0),f={gridSizeClipspace:[c/s*2,c/a*2],cellSizeClipspace:[h/s*2,h/a*2]};i.shaderInputs.setProps({screenGrid:f})}}finalizeState(t){super.finalizeState(t),this.state.colorTexture?.destroy()}draw({uniforms:t}){let e=this.props.colorDomain(),o=this.state.model,r={colorDomain:e};o.shaderInputs.setProps({screenGrid:r}),o.draw(this.context.renderPass)}_getModel(){return new _t.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new _t.Geometry({topology:"triangle-strip",attributes:{positions:{value:new Float32Array([0,0,1,0,0,1,1,1]),size:2}}}),isInstanced:!0})}};Rt.layerName="ScreenGridCellLayer";var ze=Rt;var qo=`uniform binOptionsUniforms {
  float cellSizePixels;
} binOptions;
`,Ie={name:"binOptions",vs:qo,uniformTypes:{cellSizePixels:"f32"}};var Yo={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0},colorRange:G,colorScaleType:"linear",getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},mt=class extends U{getAggregatorType(){return this.props.gpuAggregation&&P.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(t){return t==="cpu"||!P.isSupported(this.context.device)?new O({dimensions:2,getBin:{sources:["positions"],getValue:({positions:e},o,r)=>{let i=this.context.viewport,s=i.project(e),a=r.cellSizePixels;return s[0]<0||s[0]>=i.width||s[1]<0||s[1]>=i.height?null:[Math.floor(s[0]/a),Math.floor(s[1]/a)]}},getValue:[{sources:["counts"],getValue:({counts:e})=>e}]}):new P(this.context.device,{dimensions:2,channelCount:1,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[Fe.project32,Ie],vs:`
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;
  
  void getBin(out ivec2 binId) {
    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));
    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;
    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);
    binId = ivec2(gridCoords);
  }
  void getValue(out float weight) {
    weight = counts;
  }
  `})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},counts:{size:1,accessor:"getWeight"}})}shouldUpdateState({changeFlags:t}){return t.somethingChanged}updateState(t){let e=super.updateState(t),{props:o,oldProps:r,changeFlags:i}=t,{cellSizePixels:s,aggregation:a}=o;if(e||i.dataChanged||i.updateTriggersChanged||i.viewportChanged||a!==r.aggregation||s!==r.cellSizePixels){let{width:c,height:g}=this.context.viewport,{aggregator:h}=this.state;h instanceof P&&h.setProps({binIdRange:[[0,Math.ceil(c/s)],[0,Math.ceil(g/s)]]}),h.setProps({pointCount:this.getNumInstances(),operations:[a],binOptions:{cellSizePixels:s}})}return i.viewportChanged&&this.state.aggregator.setNeedsUpdate(),e}onAttributeChange(t){let{aggregator:e}=this.state;switch(t){case"positions":e.setNeedsUpdate();break;case"counts":e.setNeedsUpdate(0);break;default:}}renderLayers(){let{aggregator:t}=this.state,e=this.getSubLayerClass("cells",ze),o=t.getBins(),r=t.getResult(0);return new e(this.props,this.getSubLayerProps({id:"cell-layer"}),{data:{length:t.binCount,attributes:{getBin:o,getWeight:r}},dataComparator:(i,s)=>i.length===s.length,updateTriggers:{getBin:[o],getWeight:[r]},parameters:{depthWriteEnabled:!1,...this.props.parameters},colorDomain:()=>this.props.colorDomain||t.getResultDomain(0),extensions:[]})}getPickingInfo(t){let e=t.info,{index:o}=e;if(o>=0){let r=this.state.aggregator.getBin(o),i;r&&(i={col:r.id[0],row:r.id[1],value:r.value[0],count:r.count},r.pointIndices&&(i.pointIndices=r.pointIndices,i.points=Array.isArray(this.props.data)?r.pointIndices.map(s=>this.props.data[s]):[])),e.object=i}return e}};mt.layerName="ScreenGridLayer";mt.defaultProps=Yo;var We=mt;var Y=L(I(),1);var q=class{constructor(t,e){this.props={scaleType:"linear",lowerPercentile:0,upperPercentile:100},this.domain=null,this.cutoff=null,this.input=t,this.inputLength=e,this.attribute=t}getScalePercentile(){if(!this._percentile){let t=De(this.input,this.inputLength);this._percentile=Xo(t)}return this._percentile}getScaleOrdinal(){if(!this._ordinal){let t=De(this.input,this.inputLength);this._ordinal=$o(t)}return this._ordinal}getCutoff({scaleType:t,lowerPercentile:e,upperPercentile:o}){if(t==="quantile")return[e,o-1];if(e>0||o<100){let{domain:r}=this.getScalePercentile(),i=r[Math.floor(e)-1]??-1/0,s=r[Math.floor(o)-1]??1/0;if(t==="ordinal"){let{domain:a}=this.getScaleOrdinal();i=a.findIndex(c=>c>=i),s=a.findIndex(c=>c>s)-1,s===-2&&(s=a.length-1)}return[i,s]}return null}update(t){let e=this.props;if(t.scaleType!==e.scaleType)switch(t.scaleType){case"quantile":{let{attribute:o}=this.getScalePercentile();this.attribute=o,this.domain=[0,99];break}case"ordinal":{let{attribute:o,domain:r}=this.getScaleOrdinal();this.attribute=o,this.domain=[0,r.length-1];break}default:this.attribute=this.input,this.domain=null}return(t.scaleType!==e.scaleType||t.lowerPercentile!==e.lowerPercentile||t.upperPercentile!==e.upperPercentile)&&(this.cutoff=this.getCutoff(t)),this.props=t,this}};function $o(n){let t=new Set;for(let r of n)Number.isFinite(r)&&t.add(r);let e=Array.from(t).sort(),o=new Map;for(let r=0;r<e.length;r++)o.set(e[r],r);return{attribute:{value:n.map(r=>Number.isFinite(r)?o.get(r):NaN),type:"float32",size:1},domain:e}}function Xo(n,t=100){let e=Array.from(n).filter(Number.isFinite).sort(Ko),o=0,r=Math.max(1,t),i=new Array(r-1);for(;++o<r;)i[o-1]=Zo(e,o/r);return{attribute:{value:n.map(s=>Number.isFinite(s)?Qo(i,s):NaN),type:"float32",size:1},domain:i}}function De(n,t){let e=(n.stride??4)/4,o=(n.offset??0)/4,r=n.value;if(!r){let s=n.buffer?.readSyncWebGL(0,e*4*t);s&&(r=new Float32Array(s.buffer),n.value=r)}if(e===1)return r.subarray(0,t);let i=new Float32Array(t);for(let s=0;s<t;s++)i[s]=r[s*e+o];return i}function Ko(n,t){return n-t}function Zo(n,t){let e=n.length;if(t<=0||e<2)return n[0];if(t>=1)return n[e-1];let o=(e-1)*t,r=Math.floor(o),i=n[r],s=n[r+1];return i+(s-i)*(o-r)}function Qo(n,t){let e=0,o=n.length;for(;e<o;){let r=e+o>>>1;n[r]>t?o=r:e=r+1}return e}function tt({dataBounds:n,getBinId:t,padding:e=0}){let o=[n[0],n[1],[n[0][0],n[1][1]],[n[1][0],n[0][1]]].map(c=>t(c)),r=Math.min(...o.map(c=>c[0]))-e,i=Math.min(...o.map(c=>c[1]))-e,s=Math.max(...o.map(c=>c[0]))+e+1,a=Math.max(...o.map(c=>c[1]))+e+1;return[[r,s],[i,a]]}var Ge=L(Z(),1);var Ve=Math.PI/3,It=2*Math.sin(Ve),Ft=1.5,Be=Array.from({length:6},(n,t)=>{let e=t*Ve;return[Math.sin(e),-Math.cos(e)]});function Wt([n,t],e){let o=Math.round(t=t/e/Ft),r=Math.round(n=n/e/It-(o&1)/2),i=t-o;if(Math.abs(i)*3>1){let s=n-r,a=r+(n<r?-1:1)/2,c=o+(t<o?-1:1),g=n-a,h=t-c;s*s+i*i>g*g+h*h&&(r=a+(o&1?1:-1)/2,o=c)}return[r,o]}var Ue=`
const vec2 DIST = vec2(${It}, ${Ft});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`;function oe([n,t],e){return[(n+(t&1)/2)*e*It,t*e*Ft]}var He=`
const vec2 DIST = vec2(${It}, ${Ft});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`;var ke=`#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
${He}
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < hexagon.colorDomain.z ||
instanceColorValues > hexagon.colorDomain.w ||
instanceElevationValues < hexagon.elevationDomain.z ||
instanceElevationValues > hexagon.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
commonPosition += positions.xy * column.radius * column.coverage;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Jo=`uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`,je={name:"hexagon",vs:Jo,uniformTypes:{colorDomain:"vec4<f32>",elevationDomain:"vec4<f32>",elevationRange:"vec2<f32>",originCommon:"vec2<f32>"}};var Dt=class extends Ge.ColumnLayer{getShaders(){let t=super.getShaders();return t.modules.push(je),{...t,vs:ke}}initializeState(){super.initializeState();let t=this.getAttributeManager();t.remove(["instanceElevations","instanceFillColors","instanceLineColors","instanceStrokeWidths"]),t.addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceColorValues:{size:1,type:"float32",accessor:"getColorValue"},instanceElevationValues:{size:1,type:"float32",accessor:"getElevationValue"}})}updateState(t){super.updateState(t);let{props:e,oldProps:o}=t,r=this.state.fillModel;if(o.colorRange!==e.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=J(this.context.device,e.colorRange,e.colorScaleType);let i={colorRange:this.state.colorTexture};r.shaderInputs.setProps({hexagon:i})}else o.colorScaleType!==e.colorScaleType&&Q(this.state.colorTexture,e.colorScaleType)}finalizeState(t){super.finalizeState(t),this.state.colorTexture?.destroy()}draw({uniforms:t}){let{radius:e,hexOriginCommon:o,elevationRange:r,elevationScale:i,extruded:s,coverage:a,colorDomain:c,elevationDomain:g}=this.props,h=this.props.colorCutoff||[-1/0,1/0],f=this.props.elevationCutoff||[-1/0,1/0],p=this.state.fillModel;p.vertexArray.indexBuffer&&p.setIndexBuffer(null),p.setVertexCount(this.state.fillVertexCount);let d={colorDomain:[Math.max(c[0],h[0]),Math.min(c[1],h[1]),Math.max(c[0]-1,h[0]),Math.min(c[1]+1,h[1])],elevationDomain:[Math.max(g[0],f[0]),Math.min(g[1],f[1]),Math.max(g[0]-1,f[0]),Math.min(g[1]+1,f[1])],elevationRange:[r[0]*i,r[1]*i],originCommon:o};p.shaderInputs.setProps({column:{extruded:s,coverage:a,radius:e},hexagon:d}),p.draw(this.context.renderPass)}};Dt.layerName="HexagonCellLayer";var qe=Dt;var tr=`uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`,Ye={name:"binOptions",vs:tr,uniformTypes:{hexOriginCommon:"vec2<f32>",radiusCommon:"f32"}};function $e(){}var er={gpuAggregation:!0,colorDomain:null,colorRange:G,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:$e,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScaleType:"linear",onSetElevationDomain:$e,radius:{type:"number",min:1,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},hexagonAggregator:{type:"function",optional:!0,value:null},extruded:!1,material:!0},xt=class extends U{getAggregatorType(){let{gpuAggregation:t,hexagonAggregator:e,getColorValue:o,getElevationValue:r}=this.props;return t&&(e||o||r)?(Y.log.warn("Features not supported by GPU aggregation, falling back to CPU")(),"cpu"):t&&P.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(t){if(t==="cpu"){let{hexagonAggregator:e,radius:o}=this.props;return new O({dimensions:2,getBin:{sources:["positions"],getValue:({positions:r},i,s)=>{if(e)return e(r,o);let c=this.state.aggregatorViewport.projectPosition(r),{radiusCommon:g,hexOriginCommon:h}=s;return Wt([c[0]-h[0],c[1]-h[1]],g)}},getValue:[{sources:["colorWeights"],getValue:({colorWeights:r})=>r},{sources:["elevationWeights"],getValue:({elevationWeights:r})=>r}]})}return new P(this.context.device,{dimensions:2,channelCount:2,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[Y.project32,Ye],vs:`
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${Ue}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},colorWeights:{size:1,accessor:"getColorWeight"},elevationWeights:{size:1,accessor:"getElevationWeight"}})}updateState(t){let e=super.updateState(t),{props:o,oldProps:r,changeFlags:i}=t,{aggregator:s}=this.state;if((i.dataChanged||!this.state.dataAsArray)&&(o.getColorValue||o.getElevationValue)&&(this.state.dataAsArray=Array.from((0,Y.createIterable)(o.data).iterable)),e||i.dataChanged||o.radius!==r.radius||o.getColorValue!==r.getColorValue||o.getElevationValue!==r.getElevationValue||o.colorAggregation!==r.colorAggregation||o.elevationAggregation!==r.elevationAggregation){this._updateBinOptions();let{radiusCommon:a,hexOriginCommon:c,binIdRange:g,dataAsArray:h}=this.state;if(s.setProps({binIdRange:g,pointCount:this.getNumInstances(),operations:[o.colorAggregation,o.elevationAggregation],binOptions:{radiusCommon:a,hexOriginCommon:c},onUpdate:this._onAggregationUpdate.bind(this)}),h){let{getColorValue:f,getElevationValue:p}=this.props;s.setProps({customOperations:[f&&(d=>f(d.map(x=>h[x]),{indices:d,data:o.data})),p&&(d=>p(d.map(x=>h[x]),{indices:d,data:o.data}))]})}}return i.updateTriggersChanged&&i.updateTriggersChanged.getColorValue&&s.setNeedsUpdate(0),i.updateTriggersChanged&&i.updateTriggersChanged.getElevationValue&&s.setNeedsUpdate(1),e}_updateBinOptions(){let t=this.getBounds(),e=1,o=[0,0],r=[[0,1],[0,1]],i=this.context.viewport;if(t&&Number.isFinite(t[0][0])){let s=[(t[0][0]+t[1][0])/2,(t[0][1]+t[1][1])/2],{radius:a}=this.props,{unitsPerMeter:c}=i.getDistanceScales(s);e=c[0]*a;let g=Wt(i.projectFlat(s),e);s=i.unprojectFlat(oe(g,e));let h=i.constructor;i=i.isGeospatial?new h({longitude:s[0],latitude:s[1],zoom:12}):new Y.Viewport({position:[s[0],s[1],0],zoom:12}),o=[Math.fround(i.center[0]),Math.fround(i.center[1])],r=tt({dataBounds:t,getBinId:f=>{let p=i.projectFlat(f);return p[0]-=o[0],p[1]-=o[1],Wt(p,e)},padding:1})}this.setState({radiusCommon:e,hexOriginCommon:o,binIdRange:r,aggregatorViewport:i})}draw(t){t.shaderModuleProps.project&&(t.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(t)}_onAggregationUpdate({channel:t}){let e=this.getCurrentLayer().props,{aggregator:o}=this.state;if(t===0){let r=o.getResult(0);this.setState({colors:new q(r,o.binCount)}),e.onSetColorDomain(o.getResultDomain(0))}else if(t===1){let r=o.getResult(1);this.setState({elevations:new q(r,o.binCount)}),e.onSetElevationDomain(o.getResultDomain(1))}}onAttributeChange(t){let{aggregator:e}=this.state;switch(t){case"positions":e.setNeedsUpdate(),this._updateBinOptions();let{radiusCommon:o,hexOriginCommon:r,binIdRange:i}=this.state;e.setProps({binIdRange:i,binOptions:{radiusCommon:o,hexOriginCommon:r}});break;case"colorWeights":e.setNeedsUpdate(0);break;case"elevationWeights":e.setNeedsUpdate(1);break;default:}}renderLayers(){let{aggregator:t,radiusCommon:e,hexOriginCommon:o}=this.state,{elevationScale:r,colorRange:i,elevationRange:s,extruded:a,coverage:c,material:g,transitions:h,colorScaleType:f,lowerPercentile:p,upperPercentile:d,colorDomain:x,elevationScaleType:v,elevationLowerPercentile:S,elevationUpperPercentile:C,elevationDomain:E}=this.props,M=this.getSubLayerClass("cells",qe),b=t.getBins(),y=this.state.colors?.update({scaleType:f,lowerPercentile:p,upperPercentile:d}),A=this.state.elevations?.update({scaleType:v,lowerPercentile:S,upperPercentile:C});return!y||!A?null:new M(this.getSubLayerProps({id:"cells"}),{data:{length:t.binCount,attributes:{getBin:b,getColorValue:y.attribute,getElevationValue:A.attribute}},dataComparator:(w,N)=>w.length===N.length,updateTriggers:{getBin:[b],getColorValue:[y.attribute],getElevationValue:[A.attribute]},diskResolution:6,vertices:Be,radius:e,hexOriginCommon:o,elevationScale:r,colorRange:i,colorScaleType:f,elevationRange:s,extruded:a,coverage:c,material:g,colorDomain:y.domain||x||t.getResultDomain(0),elevationDomain:A.domain||E||t.getResultDomain(1),colorCutoff:y.cutoff,elevationCutoff:A.cutoff,transitions:h&&{getFillColor:h.getColorValue||h.getColorWeight,getElevation:h.getElevationValue||h.getElevationWeight},extensions:[]})}getPickingInfo(t){let e=t.info,{index:o}=e;if(o>=0){let r=this.state.aggregator.getBin(o),i;if(r){let s=oe(r.id,this.state.radiusCommon),a=this.context.viewport.unprojectFlat(s);i={col:r.id[0],row:r.id[1],position:a,colorValue:r.value[0],elevationValue:r.value[1],count:r.count},r.pointIndices&&(i.pointIndices=r.pointIndices,i.points=Array.isArray(this.props.data)?r.pointIndices.map(c=>this.props.data[c]):[])}e.object=i}return e}};xt.layerName="HexagonLayer";xt.defaultProps=er;var Xe=xt;var H=L(I(),1),Xt=L(Z(),1);var m=.16666666666666666,l={N:[0,.5],E:[.5,0],S:[0,-.5],W:[-.5,0],NE:[.5,.5],NW:[-.5,.5],SE:[.5,-.5],SW:[-.5,-.5]},et=[l.W,l.SW,l.S],nt=[l.S,l.SE,l.E],ot=[l.E,l.NE,l.N],rt=[l.NW,l.W,l.N],it=[[-.5,m],[-.5,-m],[-m,-.5],[m,-.5]],st=[[-m,-.5],[m,-.5],[.5,-m],[.5,m]],at=[[.5,-m],[.5,m],[m,.5],[-m,.5]],ct=[[-.5,m],[-.5,-m],[m,.5],[-m,.5]],Ke=[l.W,l.SW,l.SE,l.E],Ze=[l.S,l.SE,l.NE,l.N],Qe=[l.NW,l.W,l.E,l.NE],Je=[l.NW,l.SW,l.S,l.N],tn=[[-.5,m],[-.5,-m],[.5,-m],[.5,m]],en=[[-m,-.5],[m,-.5],[m,.5],[-m,.5]],nr=[l.NW,l.SW,l.SE,l.NE],nn=[l.NW,l.SW,l.SE,l.E,l.N],on=[l.W,l.SW,l.SE,l.NE,l.N],rn=[l.NW,l.W,l.S,l.SE,l.NE],sn=[l.NW,l.SW,l.S,l.E,l.NE],an=[l.NW,l.W,[.5,-m],[.5,m],l.N],cn=[[-m,-.5],[m,-.5],l.E,l.NE,l.N],ln=[[-.5,m],[-.5,-m],l.S,l.SE,l.E],gn=[l.W,l.SW,l.S,[m,.5],[-m,.5]],hn=[l.NW,l.W,[-m,-.5],[m,-.5],l.N],pn=[[-.5,m],[-.5,-m],l.E,l.NE,l.N],fn=[l.S,l.SE,l.E,[m,.5],[-m,.5]],dn=[l.W,l.SW,l.S,[.5,-m],[.5,m]],un=[l.W,l.SW,l.SE,l.E,[m,.5],[-m,.5]],mn=[[-.5,m],[-.5,-m],l.S,l.SE,l.NE,l.N],xn=[l.NW,l.W,[-m,-.5],[m,-.5],l.E,l.NE],vn=[l.NW,l.SW,l.S,[.5,-m],[.5,m],l.N],lt=[l.W,l.SW,l.S,l.E,l.NE,l.N],gt=[l.NW,l.W,l.S,l.SE,l.E,l.N],Vt=[[-.5,m],[-.5,-m],[-m,-.5],[m,-.5],l.E,l.NE,l.N],Bt=[l.W,l.SW,l.S,[.5,-m],[.5,m],[m,.5],[-m,.5]],Ut=[l.NW,l.W,[-m,-.5],[m,-.5],[.5,-m],[.5,m],l.N],Ht=[[-.5,m],[-.5,-m],l.S,l.SE,l.E,[m,.5],[-m,.5]],Mn=[[-.5,m],[-.5,-m],[-m,-.5],[m,-.5],[.5,-m],[.5,m],[m,.5],[-m,.5]],yn={0:[],1:[[l.W,l.S]],2:[[l.S,l.E]],3:[[l.W,l.E]],4:[[l.N,l.E]],5:{0:[[l.W,l.S],[l.N,l.E]],1:[[l.W,l.N],[l.S,l.E]]},6:[[l.N,l.S]],7:[[l.W,l.N]],8:[[l.W,l.N]],9:[[l.N,l.S]],10:{0:[[l.W,l.N],[l.S,l.E]],1:[[l.W,l.S],[l.N,l.E]]},11:[[l.N,l.E]],12:[[l.W,l.E]],13:[[l.S,l.E]],14:[[l.W,l.S]],15:[]};function u(n){return parseInt(n,4)}var Sn={[u("0000")]:[],[u("2222")]:[],[u("2221")]:[et],[u("2212")]:[nt],[u("2122")]:[ot],[u("1222")]:[rt],[u("0001")]:[et],[u("0010")]:[nt],[u("0100")]:[ot],[u("1000")]:[rt],[u("2220")]:[it],[u("2202")]:[st],[u("2022")]:[at],[u("0222")]:[ct],[u("0002")]:[it],[u("0020")]:[st],[u("0200")]:[at],[u("2000")]:[ct],[u("0011")]:[Ke],[u("0110")]:[Ze],[u("1100")]:[Qe],[u("1001")]:[Je],[u("2211")]:[Ke],[u("2112")]:[Ze],[u("1122")]:[Qe],[u("1221")]:[Je],[u("2200")]:[tn],[u("2002")]:[en],[u("0022")]:[tn],[u("0220")]:[en],[u("1111")]:[nr],[u("1211")]:[nn],[u("2111")]:[on],[u("1112")]:[rn],[u("1121")]:[sn],[u("1011")]:[nn],[u("0111")]:[on],[u("1110")]:[rn],[u("1101")]:[sn],[u("1200")]:[an],[u("0120")]:[cn],[u("0012")]:[ln],[u("2001")]:[gn],[u("1022")]:[an],[u("2102")]:[cn],[u("2210")]:[ln],[u("0221")]:[gn],[u("1002")]:[hn],[u("2100")]:[pn],[u("0210")]:[fn],[u("0021")]:[dn],[u("1220")]:[hn],[u("0122")]:[pn],[u("2012")]:[fn],[u("2201")]:[dn],[u("0211")]:[un],[u("2110")]:[mn],[u("1102")]:[xn],[u("1021")]:[vn],[u("2011")]:[un],[u("0112")]:[mn],[u("1120")]:[xn],[u("1201")]:[vn],[u("2101")]:[lt],[u("0121")]:[lt],[u("1012")]:[gt],[u("1210")]:[gt],[u("0101")]:{0:[et,ot],1:[lt],2:[lt]},[u("1010")]:{0:[rt,nt],1:[gt],2:[gt]},[u("2121")]:{0:[lt],1:[lt],2:[et,ot]},[u("1212")]:{0:[gt],1:[gt],2:[rt,nt]},[u("2120")]:{0:[Vt],1:[Vt],2:[it,ot]},[u("2021")]:{0:[Bt],1:[Bt],2:[et,at]},[u("1202")]:{0:[Ut],1:[Ut],2:[rt,st]},[u("0212")]:{0:[Ht],1:[Ht],2:[nt,ct]},[u("0102")]:{0:[it,ot],1:[Vt],2:[Vt]},[u("0201")]:{0:[et,at],1:[Bt],2:[Bt]},[u("1020")]:{0:[rt,st],1:[Ut],2:[Ut]},[u("2010")]:{0:[nt,ct],1:[Ht],2:[Ht]},[u("2020")]:{0:[ct,st],1:[Mn],2:[it,at]},[u("0202")]:{0:[at,it],1:[Mn],2:[ct,st]}};function vt(n,t){return Number.isNaN(n)?0:Array.isArray(t)?n<t[0]?0:n<t[1]?1:2:n>=t?1:0}function An(n){let{x:t,y:e,xRange:o,yRange:r,getValue:i,threshold:s}=n,a=t<o[0],c=t>=o[1]-1,g=e<r[0],h=e>=r[1]-1,f=a||c||g||h,p=0,d,x,v,S;if(a||h)v=0;else{let M=i(t,e+1);v=vt(M,s),p+=M}if(c||h)S=0;else{let M=i(t+1,e+1);S=vt(M,s),p+=M}if(c||g)x=0;else{let M=i(t+1,e);x=vt(M,s),p+=M}if(a||g)d=0;else{let M=i(t,e);d=vt(M,s),p+=M}let C=-1;Number.isFinite(s)&&(C=v<<3|S<<2|x<<1|d),Array.isArray(s)&&(C=v<<6|S<<4|x<<2|d);let E=0;return f||(E=vt(p/4,s)),{code:C,meanCode:E}}function Cn(n){let{x:t,y:e,z:o,code:r,meanCode:i}=n,s=Sn[r];Array.isArray(s)||(s=s[i]);let a=t+1,c=e+1,g=[];return s.forEach(h=>{let f=[];h.forEach(p=>{let d=a+p[0],x=c+p[1];f.push([d,x,o])}),g.push(f)}),g}function bn(n){let{x:t,y:e,z:o,code:r,meanCode:i}=n,s=yn[r];Array.isArray(s)||(s=s[i]);let a=t+1,c=e+1,g=[];return s.forEach(h=>{h.forEach(f=>{let p=a+f[0],d=c+f[1];g.push([p,d,o])})}),g}function En({contours:n,getValue:t,xRange:e,yRange:o}){let r=[],i=[],s=0,a=0;for(let c=0;c<n.length;c++){let g=n[c],h=g.zIndex??c,{threshold:f}=g;for(let p=e[0]-1;p<e[1];p++)for(let d=o[0]-1;d<o[1];d++){let{code:x,meanCode:v}=An({getValue:t,threshold:f,x:p,y:d,xRange:e,yRange:o}),S={x:p,y:d,z:h,code:x,meanCode:v};if(Array.isArray(f)){let C=Cn(S);for(let E of C)i[a++]={vertices:E,contour:g}}else{let C=bn(S);C.length>0&&(r[s++]={vertices:C,contour:g})}}}return{lines:r,polygons:i}}function Tn(n){let{aggregator:t,binIdRange:e,channel:o}=n;if(t instanceof P){let r=t.getResult(o)?.buffer;if(r){let i=new Float32Array(r.readSyncWebGL().buffer);return or(i,e)}}if(t instanceof O){let r=t.getResult(o)?.value,i=t.getBins()?.value;if(i&&r)return rr(r,i,t.binCount)}return null}function or(n,t){let[[e,o],[r,i]]=t,s=o-e,a=i-r;return(c,g)=>(c-=e,g-=r,c<0||c>=s||g<0||g>=a?NaN:n[g*s+c])}function rr(n,t,e){let o={};for(let r=0;r<e;r++){let i=t[r*2],s=t[r*2+1];o[i]=o[i]||{},o[i][s]=n[r]}return(r,i)=>o[r]?.[i]??NaN}var Zi=1/Math.PI*180,Qi=1/180*Math.PI,ir={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...ir}};var R=globalThis.mathgl.config;function Ln(n,{precision:t=R.precision}={}){return n=sr(n),`${parseFloat(n.toPrecision(t))}`}function kt(n){return Array.isArray(n)||ArrayBuffer.isView(n)&&!(n instanceof DataView)}function re(n,t,e){let o=R.EPSILON;e&&(R.EPSILON=e);try{if(n===t)return!0;if(kt(n)&&kt(t)){if(n.length!==t.length)return!1;for(let r=0;r<n.length;++r)if(!re(n[r],t[r]))return!1;return!0}return n&&n.equals?n.equals(t):t&&t.equals?t.equals(n):typeof n=="number"&&typeof t=="number"?Math.abs(n-t)<=R.EPSILON*Math.max(1,Math.abs(n),Math.abs(t)):!1}finally{R.EPSILON=o}}function sr(n){return Math.round(n/R.EPSILON)*R.EPSILON}var jt=class extends Array{clone(){return new this.constructor().copy(this)}fromArray(t,e=0){for(let o=0;o<this.ELEMENTS;++o)this[o]=t[o+e];return this.check()}toArray(t=[],e=0){for(let o=0;o<this.ELEMENTS;++o)t[e+o]=this[o];return t}toObject(t){return t}from(t){return Array.isArray(t)?this.copy(t):this.fromObject(t)}to(t){return t===this?this:kt(t)?this.toArray(t):this.toObject(t)}toTarget(t){return t?this.to(t):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(R)}formatString(t){let e="";for(let o=0;o<this.ELEMENTS;++o)e+=(o>0?", ":"")+Ln(this[o],t);return`${t.printTypes?this.constructor.name:""}[${e}]`}equals(t){if(!t||this.length!==t.length)return!1;for(let e=0;e<this.ELEMENTS;++e)if(!re(this[e],t[e]))return!1;return!0}exactEquals(t){if(!t||this.length!==t.length)return!1;for(let e=0;e<this.ELEMENTS;++e)if(this[e]!==t[e])return!1;return!0}negate(){for(let t=0;t<this.ELEMENTS;++t)this[t]=-this[t];return this.check()}lerp(t,e,o){if(o===void 0)return this.lerp(this,t,e);for(let r=0;r<this.ELEMENTS;++r){let i=t[r],s=typeof e=="number"?e:e[r];this[r]=i+o*(s-i)}return this.check()}min(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=Math.min(t[e],this[e]);return this.check()}max(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=Math.max(t[e],this[e]);return this.check()}clamp(t,e){for(let o=0;o<this.ELEMENTS;++o)this[o]=Math.min(Math.max(this[o],t[o]),e[o]);return this.check()}add(...t){for(let e of t)for(let o=0;o<this.ELEMENTS;++o)this[o]+=e[o];return this.check()}subtract(...t){for(let e of t)for(let o=0;o<this.ELEMENTS;++o)this[o]-=e[o];return this.check()}scale(t){if(typeof t=="number")for(let e=0;e<this.ELEMENTS;++e)this[e]*=t;else for(let e=0;e<this.ELEMENTS&&e<t.length;++e)this[e]*=t[e];return this.check()}multiplyByScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]*=t;return this.check()}check(){if(R.debug&&!this.validate())throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);return this}validate(){let t=this.length===this.ELEMENTS;for(let e=0;e<this.ELEMENTS;++e)t=t&&Number.isFinite(this[e]);return t}sub(t){return this.subtract(t)}setScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]=t;return this.check()}addScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]+=t;return this.check()}subScalar(t){return this.addScalar(-t)}multiplyScalar(t){for(let e=0;e<this.ELEMENTS;++e)this[e]*=t;return this.check()}divideScalar(t){return this.multiplyByScalar(1/t)}clampScalar(t,e){for(let o=0;o<this.ELEMENTS;++o)this[o]=Math.min(Math.max(this[o],t),e);return this.check()}get elements(){return this}};function ar(n,t){if(n.length!==t)return!1;for(let e=0;e<n.length;++e)if(!Number.isFinite(n[e]))return!1;return!0}function Pn(n){if(!Number.isFinite(n))throw new Error(`Invalid number ${JSON.stringify(n)}`);return n}function Gt(n,t,e=""){if(R.debug&&!ar(n,t))throw new Error(`math.gl: ${e} some fields set to invalid numbers'`);return n}var k=typeof Float32Array<"u"?Float32Array:Array;var rs=Math.PI/180;function cr(){let n=new k(2);return k!=Float32Array&&(n[0]=0,n[1]=0),n}function On(n,t,e){let o=t[0],r=t[1];return n[0]=e[0]*o+e[4]*r+e[12],n[1]=e[1]*o+e[5]*r+e[13],n}var is=function(){let n=cr();return function(t,e,o,r,i,s){let a,c;for(e||(e=2),o||(o=0),r?c=Math.min(r*e+o,t.length):c=t.length,a=o;a<c;a+=e)n[0]=t[a],n[1]=t[a+1],i(n,n,s),t[a]=n[0],t[a+1]=n[1];return t}}();function Rn(n,t,e){let o=t[0],r=t[1],i=e[3]*o+e[7]*r||1;return n[0]=(e[0]*o+e[4]*r)/i,n[1]=(e[1]*o+e[5]*r)/i,n}function _n(n,t,e){let o=t[0],r=t[1],i=t[2],s=e[3]*o+e[7]*r+e[11]*i||1;return n[0]=(e[0]*o+e[4]*r+e[8]*i)/s,n[1]=(e[1]*o+e[5]*r+e[9]*i)/s,n[2]=(e[2]*o+e[6]*r+e[10]*i)/s,n}function lr(){let n=new k(3);return k!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n}function zn(n,t,e){let o=t[0],r=t[1],i=t[2],s=e[3]*o+e[7]*r+e[11]*i+e[15];return s=s||1,n[0]=(e[0]*o+e[4]*r+e[8]*i+e[12])/s,n[1]=(e[1]*o+e[5]*r+e[9]*i+e[13])/s,n[2]=(e[2]*o+e[6]*r+e[10]*i+e[14])/s,n}var cs=function(){let n=lr();return function(t,e,o,r,i,s){let a,c;for(e||(e=3),o||(o=0),r?c=Math.min(r*e+o,t.length):c=t.length,a=o;a<c;a+=e)n[0]=t[a],n[1]=t[a+1],n[2]=t[a+2],i(n,n,s),t[a]=n[0],t[a+1]=n[1],t[a+2]=n[2];return t}}();var qt=class extends jt{toString(){let t="[";if(R.printRowMajor){t+="row-major:";for(let e=0;e<this.RANK;++e)for(let o=0;o<this.RANK;++o)t+=` ${this[o*this.RANK+e]}`}else{t+="column-major:";for(let e=0;e<this.ELEMENTS;++e)t+=` ${this[e]}`}return t+="]",t}getElementIndex(t,e){return e*this.RANK+t}getElement(t,e){return this[e*this.RANK+t]}setElement(t,e,o){return this[e*this.RANK+t]=Pn(o),this}getColumn(t,e=new Array(this.RANK).fill(-0)){let o=t*this.RANK;for(let r=0;r<this.RANK;++r)e[r]=this[o+r];return e}setColumn(t,e){let o=t*this.RANK;for(let r=0;r<this.RANK;++r)this[o+r]=e[r];return this}};function gr(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function In(n,t){if(n===t){let e=t[1],o=t[2],r=t[3],i=t[6],s=t[7],a=t[11];n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=e,n[6]=t[9],n[7]=t[13],n[8]=o,n[9]=i,n[11]=t[14],n[12]=r,n[13]=s,n[14]=a}else n[0]=t[0],n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=t[1],n[5]=t[5],n[6]=t[9],n[7]=t[13],n[8]=t[2],n[9]=t[6],n[10]=t[10],n[11]=t[14],n[12]=t[3],n[13]=t[7],n[14]=t[11],n[15]=t[15];return n}function Fn(n,t){let e=t[0],o=t[1],r=t[2],i=t[3],s=t[4],a=t[5],c=t[6],g=t[7],h=t[8],f=t[9],p=t[10],d=t[11],x=t[12],v=t[13],S=t[14],C=t[15],E=e*a-o*s,M=e*c-r*s,b=e*g-i*s,y=o*c-r*a,A=o*g-i*a,w=r*g-i*c,N=h*v-f*x,_=h*S-p*x,z=h*C-d*x,F=f*S-p*v,W=f*C-d*v,D=p*C-d*S,T=E*D-M*W+b*F+y*z-A*_+w*N;return T?(T=1/T,n[0]=(a*D-c*W+g*F)*T,n[1]=(r*W-o*D-i*F)*T,n[2]=(v*w-S*A+C*y)*T,n[3]=(p*A-f*w-d*y)*T,n[4]=(c*z-s*D-g*_)*T,n[5]=(e*D-r*z+i*_)*T,n[6]=(S*b-x*w-C*M)*T,n[7]=(h*w-p*b+d*M)*T,n[8]=(s*W-a*z+g*N)*T,n[9]=(o*z-e*W-i*N)*T,n[10]=(x*A-v*b+C*E)*T,n[11]=(f*b-h*A-d*E)*T,n[12]=(a*_-s*F-c*N)*T,n[13]=(e*F-o*_+r*N)*T,n[14]=(v*M-x*y-S*E)*T,n[15]=(h*y-f*M+p*E)*T,n):null}function Wn(n){let t=n[0],e=n[1],o=n[2],r=n[3],i=n[4],s=n[5],a=n[6],c=n[7],g=n[8],h=n[9],f=n[10],p=n[11],d=n[12],x=n[13],v=n[14],S=n[15],C=t*s-e*i,E=t*a-o*i,M=e*a-o*s,b=g*x-h*d,y=g*v-f*d,A=h*v-f*x,w=t*A-e*y+o*b,N=i*A-s*y+a*b,_=g*M-h*E+f*C,z=d*M-x*E+v*C;return c*w-r*N+S*_-p*z}function se(n,t,e){let o=t[0],r=t[1],i=t[2],s=t[3],a=t[4],c=t[5],g=t[6],h=t[7],f=t[8],p=t[9],d=t[10],x=t[11],v=t[12],S=t[13],C=t[14],E=t[15],M=e[0],b=e[1],y=e[2],A=e[3];return n[0]=M*o+b*a+y*f+A*v,n[1]=M*r+b*c+y*p+A*S,n[2]=M*i+b*g+y*d+A*C,n[3]=M*s+b*h+y*x+A*E,M=e[4],b=e[5],y=e[6],A=e[7],n[4]=M*o+b*a+y*f+A*v,n[5]=M*r+b*c+y*p+A*S,n[6]=M*i+b*g+y*d+A*C,n[7]=M*s+b*h+y*x+A*E,M=e[8],b=e[9],y=e[10],A=e[11],n[8]=M*o+b*a+y*f+A*v,n[9]=M*r+b*c+y*p+A*S,n[10]=M*i+b*g+y*d+A*C,n[11]=M*s+b*h+y*x+A*E,M=e[12],b=e[13],y=e[14],A=e[15],n[12]=M*o+b*a+y*f+A*v,n[13]=M*r+b*c+y*p+A*S,n[14]=M*i+b*g+y*d+A*C,n[15]=M*s+b*h+y*x+A*E,n}function Dn(n,t,e){let o=e[0],r=e[1],i=e[2],s,a,c,g,h,f,p,d,x,v,S,C;return t===n?(n[12]=t[0]*o+t[4]*r+t[8]*i+t[12],n[13]=t[1]*o+t[5]*r+t[9]*i+t[13],n[14]=t[2]*o+t[6]*r+t[10]*i+t[14],n[15]=t[3]*o+t[7]*r+t[11]*i+t[15]):(s=t[0],a=t[1],c=t[2],g=t[3],h=t[4],f=t[5],p=t[6],d=t[7],x=t[8],v=t[9],S=t[10],C=t[11],n[0]=s,n[1]=a,n[2]=c,n[3]=g,n[4]=h,n[5]=f,n[6]=p,n[7]=d,n[8]=x,n[9]=v,n[10]=S,n[11]=C,n[12]=s*o+h*r+x*i+t[12],n[13]=a*o+f*r+v*i+t[13],n[14]=c*o+p*r+S*i+t[14],n[15]=g*o+d*r+C*i+t[15]),n}function Vn(n,t,e){let o=e[0],r=e[1],i=e[2];return n[0]=t[0]*o,n[1]=t[1]*o,n[2]=t[2]*o,n[3]=t[3]*o,n[4]=t[4]*r,n[5]=t[5]*r,n[6]=t[6]*r,n[7]=t[7]*r,n[8]=t[8]*i,n[9]=t[9]*i,n[10]=t[10]*i,n[11]=t[11]*i,n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n}function Bn(n,t,e,o){let r=o[0],i=o[1],s=o[2],a=Math.sqrt(r*r+i*i+s*s),c,g,h,f,p,d,x,v,S,C,E,M,b,y,A,w,N,_,z,F,W,D,T,ft;return a<1e-6?null:(a=1/a,r*=a,i*=a,s*=a,g=Math.sin(e),c=Math.cos(e),h=1-c,f=t[0],p=t[1],d=t[2],x=t[3],v=t[4],S=t[5],C=t[6],E=t[7],M=t[8],b=t[9],y=t[10],A=t[11],w=r*r*h+c,N=i*r*h+s*g,_=s*r*h-i*g,z=r*i*h-s*g,F=i*i*h+c,W=s*i*h+r*g,D=r*s*h+i*g,T=i*s*h-r*g,ft=s*s*h+c,n[0]=f*w+v*N+M*_,n[1]=p*w+S*N+b*_,n[2]=d*w+C*N+y*_,n[3]=x*w+E*N+A*_,n[4]=f*z+v*F+M*W,n[5]=p*z+S*F+b*W,n[6]=d*z+C*F+y*W,n[7]=x*z+E*F+A*W,n[8]=f*D+v*T+M*ft,n[9]=p*D+S*T+b*ft,n[10]=d*D+C*T+y*ft,n[11]=x*D+E*T+A*ft,t!==n&&(n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n)}function Un(n,t,e){let o=Math.sin(e),r=Math.cos(e),i=t[4],s=t[5],a=t[6],c=t[7],g=t[8],h=t[9],f=t[10],p=t[11];return t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[4]=i*r+g*o,n[5]=s*r+h*o,n[6]=a*r+f*o,n[7]=c*r+p*o,n[8]=g*r-i*o,n[9]=h*r-s*o,n[10]=f*r-a*o,n[11]=p*r-c*o,n}function Hn(n,t,e){let o=Math.sin(e),r=Math.cos(e),i=t[0],s=t[1],a=t[2],c=t[3],g=t[8],h=t[9],f=t[10],p=t[11];return t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=i*r-g*o,n[1]=s*r-h*o,n[2]=a*r-f*o,n[3]=c*r-p*o,n[8]=i*o+g*r,n[9]=s*o+h*r,n[10]=a*o+f*r,n[11]=c*o+p*r,n}function kn(n,t,e){let o=Math.sin(e),r=Math.cos(e),i=t[0],s=t[1],a=t[2],c=t[3],g=t[4],h=t[5],f=t[6],p=t[7];return t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=i*r+g*o,n[1]=s*r+h*o,n[2]=a*r+f*o,n[3]=c*r+p*o,n[4]=g*r-i*o,n[5]=h*r-s*o,n[6]=f*r-a*o,n[7]=p*r-c*o,n}function jn(n,t){let e=t[0],o=t[1],r=t[2],i=t[3],s=e+e,a=o+o,c=r+r,g=e*s,h=o*s,f=o*a,p=r*s,d=r*a,x=r*c,v=i*s,S=i*a,C=i*c;return n[0]=1-f-x,n[1]=h+C,n[2]=p-S,n[3]=0,n[4]=h-C,n[5]=1-g-x,n[6]=d+v,n[7]=0,n[8]=p+S,n[9]=d-v,n[10]=1-g-f,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function Gn(n,t,e,o,r,i,s){let a=1/(e-t),c=1/(r-o),g=1/(i-s);return n[0]=i*2*a,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=i*2*c,n[6]=0,n[7]=0,n[8]=(e+t)*a,n[9]=(r+o)*c,n[10]=(s+i)*g,n[11]=-1,n[12]=0,n[13]=0,n[14]=s*i*2*g,n[15]=0,n}function hr(n,t,e,o,r){let i=1/Math.tan(t/2);if(n[0]=i/e,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=i,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,r!=null&&r!==1/0){let s=1/(o-r);n[10]=(r+o)*s,n[14]=2*r*o*s}else n[10]=-1,n[14]=-2*o;return n}var qn=hr;function pr(n,t,e,o,r,i,s){let a=1/(t-e),c=1/(o-r),g=1/(i-s);return n[0]=-2*a,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*c,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=2*g,n[11]=0,n[12]=(t+e)*a,n[13]=(r+o)*c,n[14]=(s+i)*g,n[15]=1,n}var Yn=pr;function $n(n,t,e,o){let r,i,s,a,c,g,h,f,p,d,x=t[0],v=t[1],S=t[2],C=o[0],E=o[1],M=o[2],b=e[0],y=e[1],A=e[2];return Math.abs(x-b)<1e-6&&Math.abs(v-y)<1e-6&&Math.abs(S-A)<1e-6?gr(n):(f=x-b,p=v-y,d=S-A,r=1/Math.sqrt(f*f+p*p+d*d),f*=r,p*=r,d*=r,i=E*d-M*p,s=M*f-C*d,a=C*p-E*f,r=Math.sqrt(i*i+s*s+a*a),r?(r=1/r,i*=r,s*=r,a*=r):(i=0,s=0,a=0),c=p*a-d*s,g=d*i-f*a,h=f*s-p*i,r=Math.sqrt(c*c+g*g+h*h),r?(r=1/r,c*=r,g*=r,h*=r):(c=0,g=0,h=0),n[0]=i,n[1]=c,n[2]=f,n[3]=0,n[4]=s,n[5]=g,n[6]=p,n[7]=0,n[8]=a,n[9]=h,n[10]=d,n[11]=0,n[12]=-(i*x+s*v+a*S),n[13]=-(c*x+g*v+h*S),n[14]=-(f*x+p*v+d*S),n[15]=1,n)}function fr(){let n=new k(4);return k!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0,n[3]=0),n}function Xn(n,t,e){let o=t[0],r=t[1],i=t[2],s=t[3];return n[0]=e[0]*o+e[4]*r+e[8]*i+e[12]*s,n[1]=e[1]*o+e[5]*r+e[9]*i+e[13]*s,n[2]=e[2]*o+e[6]*r+e[10]*i+e[14]*s,n[3]=e[3]*o+e[7]*r+e[11]*i+e[15]*s,n}var us=function(){let n=fr();return function(t,e,o,r,i,s){let a,c;for(e||(e=4),o||(o=0),r?c=Math.min(r*e+o,t.length):c=t.length,a=o;a<c;a+=e)n[0]=t[a],n[1]=t[a+1],n[2]=t[a+2],n[3]=t[a+3],i(n,n,s),t[a]=n[0],t[a+1]=n[1],t[a+2]=n[2],t[a+3]=n[3];return t}}();var le;(function(n){n[n.COL0ROW0=0]="COL0ROW0",n[n.COL0ROW1=1]="COL0ROW1",n[n.COL0ROW2=2]="COL0ROW2",n[n.COL0ROW3=3]="COL0ROW3",n[n.COL1ROW0=4]="COL1ROW0",n[n.COL1ROW1=5]="COL1ROW1",n[n.COL1ROW2=6]="COL1ROW2",n[n.COL1ROW3=7]="COL1ROW3",n[n.COL2ROW0=8]="COL2ROW0",n[n.COL2ROW1=9]="COL2ROW1",n[n.COL2ROW2=10]="COL2ROW2",n[n.COL2ROW3=11]="COL2ROW3",n[n.COL3ROW0=12]="COL3ROW0",n[n.COL3ROW1=13]="COL3ROW1",n[n.COL3ROW2=14]="COL3ROW2",n[n.COL3ROW3=15]="COL3ROW3"})(le||(le={}));var dr=45*Math.PI/180,ur=1,ae=.1,ce=500,mr=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),K=class extends qt{static get IDENTITY(){return vr()}static get ZERO(){return xr()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return le}constructor(t){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(t)?this.copy(t):this.identity()}copy(t){return this[0]=t[0],this[1]=t[1],this[2]=t[2],this[3]=t[3],this[4]=t[4],this[5]=t[5],this[6]=t[6],this[7]=t[7],this[8]=t[8],this[9]=t[9],this[10]=t[10],this[11]=t[11],this[12]=t[12],this[13]=t[13],this[14]=t[14],this[15]=t[15],this.check()}set(t,e,o,r,i,s,a,c,g,h,f,p,d,x,v,S){return this[0]=t,this[1]=e,this[2]=o,this[3]=r,this[4]=i,this[5]=s,this[6]=a,this[7]=c,this[8]=g,this[9]=h,this[10]=f,this[11]=p,this[12]=d,this[13]=x,this[14]=v,this[15]=S,this.check()}setRowMajor(t,e,o,r,i,s,a,c,g,h,f,p,d,x,v,S){return this[0]=t,this[1]=i,this[2]=g,this[3]=d,this[4]=e,this[5]=s,this[6]=h,this[7]=x,this[8]=o,this[9]=a,this[10]=f,this[11]=v,this[12]=r,this[13]=c,this[14]=p,this[15]=S,this.check()}toRowMajor(t){return t[0]=this[0],t[1]=this[4],t[2]=this[8],t[3]=this[12],t[4]=this[1],t[5]=this[5],t[6]=this[9],t[7]=this[13],t[8]=this[2],t[9]=this[6],t[10]=this[10],t[11]=this[14],t[12]=this[3],t[13]=this[7],t[14]=this[11],t[15]=this[15],t}identity(){return this.copy(mr)}fromObject(t){return this.check()}fromQuaternion(t){return jn(this,t),this.check()}frustum(t){let{left:e,right:o,bottom:r,top:i,near:s=ae,far:a=ce}=t;return a===1/0?Mr(this,e,o,r,i,s):Gn(this,e,o,r,i,s,a),this.check()}lookAt(t){let{eye:e,center:o=[0,0,0],up:r=[0,1,0]}=t;return $n(this,e,o,r),this.check()}ortho(t){let{left:e,right:o,bottom:r,top:i,near:s=ae,far:a=ce}=t;return Yn(this,e,o,r,i,s,a),this.check()}orthographic(t){let{fovy:e=dr,aspect:o=ur,focalDistance:r=1,near:i=ae,far:s=ce}=t;Kn(e);let a=e/2,c=r*Math.tan(a),g=c*o;return this.ortho({left:-g,right:g,bottom:-c,top:c,near:i,far:s})}perspective(t){let{fovy:e=45*Math.PI/180,aspect:o=1,near:r=.1,far:i=500}=t;return Kn(e),qn(this,e,o,r,i),this.check()}determinant(){return Wn(this)}getScale(t=[-0,-0,-0]){return t[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),t[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),t[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),t}getTranslation(t=[-0,-0,-0]){return t[0]=this[12],t[1]=this[13],t[2]=this[14],t}getRotation(t,e){t=t||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],e=e||[-0,-0,-0];let o=this.getScale(e),r=1/o[0],i=1/o[1],s=1/o[2];return t[0]=this[0]*r,t[1]=this[1]*i,t[2]=this[2]*s,t[3]=0,t[4]=this[4]*r,t[5]=this[5]*i,t[6]=this[6]*s,t[7]=0,t[8]=this[8]*r,t[9]=this[9]*i,t[10]=this[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}getRotationMatrix3(t,e){t=t||[-0,-0,-0,-0,-0,-0,-0,-0,-0],e=e||[-0,-0,-0];let o=this.getScale(e),r=1/o[0],i=1/o[1],s=1/o[2];return t[0]=this[0]*r,t[1]=this[1]*i,t[2]=this[2]*s,t[3]=this[4]*r,t[4]=this[5]*i,t[5]=this[6]*s,t[6]=this[8]*r,t[7]=this[9]*i,t[8]=this[10]*s,t}transpose(){return In(this,this),this.check()}invert(){return Fn(this,this),this.check()}multiplyLeft(t){return se(this,t,this),this.check()}multiplyRight(t){return se(this,this,t),this.check()}rotateX(t){return Un(this,this,t),this.check()}rotateY(t){return Hn(this,this,t),this.check()}rotateZ(t){return kn(this,this,t),this.check()}rotateXYZ(t){return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2])}rotateAxis(t,e){return Bn(this,this,t,e),this.check()}scale(t){return Vn(this,this,Array.isArray(t)?t:[t,t,t]),this.check()}translate(t){return Dn(this,this,t),this.check()}transform(t,e){return t.length===4?(e=Xn(e||[-0,-0,-0,-0],t,this),Gt(e,4),e):this.transformAsPoint(t,e)}transformAsPoint(t,e){let{length:o}=t,r;switch(o){case 2:r=On(e||[-0,-0],t,this);break;case 3:r=zn(e||[-0,-0,-0],t,this);break;default:throw new Error("Illegal vector")}return Gt(r,t.length),r}transformAsVector(t,e){let o;switch(t.length){case 2:o=Rn(e||[-0,-0],t,this);break;case 3:o=_n(e||[-0,-0,-0],t,this);break;default:throw new Error("Illegal vector")}return Gt(o,t.length),o}transformPoint(t,e){return this.transformAsPoint(t,e)}transformVector(t,e){return this.transformAsPoint(t,e)}transformDirection(t,e){return this.transformAsVector(t,e)}makeRotationX(t){return this.identity().rotateX(t)}makeTranslation(t,e,o){return this.identity().translate([t,e,o])}},Yt,$t;function xr(){return Yt||(Yt=new K([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(Yt)),Yt}function vr(){return $t||($t=new K,Object.freeze($t)),$t}function Kn(n){if(n>Math.PI*2)throw Error("expected radians")}function Mr(n,t,e,o,r,i){let s=2*i/(e-t),a=2*i/(r-o),c=(e+t)/(e-t),g=(r+o)/(r-o),h=-1,f=-1,p=-2*i;return n[0]=s,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=a,n[6]=0,n[7]=0,n[8]=c,n[9]=g,n[10]=h,n[11]=f,n[12]=0,n[13]=0,n[14]=p,n[15]=0,n}var yr=`uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`,Zn={name:"binOptions",vs:yr,uniformTypes:{cellOriginCommon:"vec2<f32>",cellSizeCommon:"vec2<f32>"}};var Qn=[255,255,255,255],Sr=1,Ar={cellSize:{type:"number",min:1,value:1e3},gridOrigin:{type:"array",compare:!0,value:[0,0]},getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM",contours:{type:"object",value:[{threshold:1}],optional:!0,compare:3},zOffset:.005},Mt=class extends U{getAggregatorType(){return this.props.gpuAggregation&&P.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(t){return t==="cpu"?new O({dimensions:2,getBin:{sources:["positions"],getValue:({positions:e},o,r)=>{let s=this.state.aggregatorViewport.projectPosition(e),{cellSizeCommon:a,cellOriginCommon:c}=r;return[Math.floor((s[0]-c[0])/a[0]),Math.floor((s[1]-c[1])/a[1])]}},getValue:[{sources:["counts"],getValue:({counts:e})=>e}],onUpdate:this._onAggregationUpdate.bind(this)}):new P(this.context.device,{dimensions:2,channelCount:1,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[H.project32,Zn],vs:`
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out float value) {
    value = counts;
  }
  `}),onUpdate:this._onAggregationUpdate.bind(this)})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},counts:{size:1,accessor:"getWeight"}})}updateState(t){let e=super.updateState(t),{props:o,oldProps:r,changeFlags:i}=t,{aggregator:s}=this.state;if(e||i.dataChanged||o.cellSize!==r.cellSize||!(0,H._deepEqual)(o.gridOrigin,r.gridOrigin,1)||o.aggregation!==r.aggregation){this._updateBinOptions();let{cellSizeCommon:a,cellOriginCommon:c,binIdRange:g}=this.state;s.setProps({binIdRange:g,pointCount:this.getNumInstances(),operations:[o.aggregation],binOptions:{cellSizeCommon:a,cellOriginCommon:c}})}return(0,H._deepEqual)(r.contours,o.contours,2)||this.setState({contourData:null}),e}_updateBinOptions(){let t=this.getBounds(),e=[1,1],o=[0,0],r=[[0,1],[0,1]],i=this.context.viewport;if(t&&Number.isFinite(t[0][0])){let s=[(t[0][0]+t[1][0])/2,(t[0][1]+t[1][1])/2],{cellSize:a,gridOrigin:c}=this.props,{unitsPerMeter:g}=i.getDistanceScales(s);e[0]=g[0]*a,e[1]=g[1]*a;let h=i.projectFlat(s);o=[Math.floor((h[0]-c[0])/e[0])*e[0]+c[0],Math.floor((h[1]-c[1])/e[1])*e[1]+c[1]],s=i.unprojectFlat(o);let f=i.constructor;i=i.isGeospatial?new f({longitude:s[0],latitude:s[1],zoom:12}):new H.Viewport({position:[s[0],s[1],0],zoom:12}),o=[Math.fround(i.center[0]),Math.fround(i.center[1])],r=tt({dataBounds:t,getBinId:p=>{let d=i.projectFlat(p);return[Math.floor((d[0]-o[0])/e[0]),Math.floor((d[1]-o[1])/e[1])]}})}this.setState({cellSizeCommon:e,cellOriginCommon:o,binIdRange:r,aggregatorViewport:i})}draw(t){t.shaderModuleProps.project&&(t.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(t)}_onAggregationUpdate(){let{aggregator:t,binIdRange:e}=this.state;this.setState({aggregatedValueReader:Tn({aggregator:t,binIdRange:e,channel:0}),contourData:null})}_getContours(){let{aggregatedValueReader:t}=this.state;if(!t)return null;if(!this.state.contourData){let{binIdRange:e}=this.state,{contours:o}=this.props,r=En({contours:o,getValue:t,xRange:e[0],yRange:e[1]});this.state.contourData=r}return this.state.contourData}onAttributeChange(t){let{aggregator:e}=this.state;switch(t){case"positions":e.setNeedsUpdate(),this._updateBinOptions();let{cellSizeCommon:o,cellOriginCommon:r,binIdRange:i}=this.state;e.setProps({binIdRange:i,binOptions:{cellSizeCommon:o,cellOriginCommon:r}});break;case"counts":e.setNeedsUpdate(0);break;default:}}renderLayers(){let t=this._getContours();if(!t)return null;let{lines:e,polygons:o}=t,{zOffset:r}=this.props,{cellOriginCommon:i,cellSizeCommon:s}=this.state,a=this.getSubLayerClass("lines",Xt.PathLayer),c=this.getSubLayerClass("bands",Xt.SolidPolygonLayer),g=new K().translate([i[0],i[1],0]).scale([s[0],s[1],r]),h=e&&e.length>0&&new a(this.getSubLayerProps({id:"lines"}),{data:e,coordinateSystem:H.COORDINATE_SYSTEM.CARTESIAN,modelMatrix:g,getPath:p=>p.vertices,getColor:p=>p.contour.color??Qn,getWidth:p=>p.contour.strokeWidth??Sr,widthUnits:"pixels"}),f=o&&o.length>0&&new c(this.getSubLayerProps({id:"bands"}),{data:o,coordinateSystem:H.COORDINATE_SYSTEM.CARTESIAN,modelMatrix:g,getPolygon:p=>p.vertices,getFillColor:p=>p.contour.color??Qn});return[h,f]}getPickingInfo(t){let e=t.info,{object:o}=e;return o&&(e.object={contour:o.contour}),e}};Mt.layerName="ContourLayer";Mt.defaultProps=Ar;var Jn=Mt;var $=L(I(),1);var no=L(Z(),1),oo=L(X(),1);var to=`#version 300 es
#define SHADER_NAME grid-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < grid.colorDomain.z ||
instanceColorValues > grid.colorDomain.w ||
instanceElevationValues < grid.elevationDomain.z ||
instanceElevationValues > grid.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Cr=`uniform gridUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
  vec2 sizeCommon;
} grid;
`,eo={name:"grid",vs:Cr,uniformTypes:{colorDomain:"vec4<f32>",elevationDomain:"vec4<f32>",elevationRange:"vec2<f32>",originCommon:"vec2<f32>",sizeCommon:"vec2<f32>"}};var yt=class extends no.ColumnLayer{getShaders(){let t=super.getShaders();return t.modules.push(eo),{...t,vs:to}}initializeState(){super.initializeState();let t=this.getAttributeManager();t.remove(["instanceElevations","instanceFillColors","instanceLineColors","instanceStrokeWidths"]),t.addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceColorValues:{size:1,type:"float32",accessor:"getColorValue"},instanceElevationValues:{size:1,type:"float32",accessor:"getElevationValue"}})}updateState(t){super.updateState(t);let{props:e,oldProps:o}=t,r=this.state.fillModel;if(o.colorRange!==e.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=J(this.context.device,e.colorRange,e.colorScaleType);let i={colorRange:this.state.colorTexture};r.shaderInputs.setProps({grid:i})}else o.colorScaleType!==e.colorScaleType&&Q(this.state.colorTexture,e.colorScaleType)}finalizeState(t){super.finalizeState(t),this.state.colorTexture?.destroy()}_updateGeometry(){let t=new oo.CubeGeometry;this.state.fillModel.setGeometry(t)}draw({uniforms:t}){let{cellOriginCommon:e,cellSizeCommon:o,elevationRange:r,elevationScale:i,extruded:s,coverage:a,colorDomain:c,elevationDomain:g}=this.props,h=this.props.colorCutoff||[-1/0,1/0],f=this.props.elevationCutoff||[-1/0,1/0],p=this.state.fillModel,d={colorDomain:[Math.max(c[0],h[0]),Math.min(c[1],h[1]),Math.max(c[0]-1,h[0]),Math.min(c[1]+1,h[1])],elevationDomain:[Math.max(g[0],f[0]),Math.min(g[1],f[1]),Math.max(g[0]-1,f[0]),Math.min(g[1]+1,f[1])],elevationRange:[r[0]*i,r[1]*i],originCommon:e,sizeCommon:o};p.shaderInputs.setProps({column:{extruded:s,coverage:a},grid:d}),p.draw(this.context.renderPass)}};yt.layerName="GridCellLayer";var br=`uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`,ro={name:"binOptions",vs:br,uniformTypes:{cellOriginCommon:"vec2<f32>",cellSizeCommon:"vec2<f32>"}};function io(){}var Er={gpuAggregation:!0,colorDomain:null,colorRange:G,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:io,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScaleType:"linear",onSetElevationDomain:io,cellSize:{type:"number",min:0,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},gridAggregator:{type:"function",optional:!0,value:null},extruded:!1,material:!0},St=class extends U{getAggregatorType(){let{gpuAggregation:t,gridAggregator:e,getColorValue:o,getElevationValue:r}=this.props;return t&&(e||o||r)?($.log.warn("Features not supported by GPU aggregation, falling back to CPU")(),"cpu"):t&&P.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(t){if(t==="cpu"){let{gridAggregator:e,cellSize:o}=this.props;return new O({dimensions:2,getBin:{sources:["positions"],getValue:({positions:r},i,s)=>{if(e)return e(r,o);let c=this.state.aggregatorViewport.projectPosition(r),{cellSizeCommon:g,cellOriginCommon:h}=s;return[Math.floor((c[0]-h[0])/g[0]),Math.floor((c[1]-h[1])/g[1])]}},getValue:[{sources:["colorWeights"],getValue:({colorWeights:r})=>r},{sources:["elevationWeights"],getValue:({elevationWeights:r})=>r}]})}return new P(this.context.device,{dimensions:2,channelCount:2,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[$.project32,ro],vs:`
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},colorWeights:{size:1,accessor:"getColorWeight"},elevationWeights:{size:1,accessor:"getElevationWeight"}})}updateState(t){let e=super.updateState(t),{props:o,oldProps:r,changeFlags:i}=t,{aggregator:s}=this.state;if((i.dataChanged||!this.state.dataAsArray)&&(o.getColorValue||o.getElevationValue)&&(this.state.dataAsArray=Array.from((0,$.createIterable)(o.data).iterable)),e||i.dataChanged||o.cellSize!==r.cellSize||o.getColorValue!==r.getColorValue||o.getElevationValue!==r.getElevationValue||o.colorAggregation!==r.colorAggregation||o.elevationAggregation!==r.elevationAggregation){this._updateBinOptions();let{cellSizeCommon:a,cellOriginCommon:c,binIdRange:g,dataAsArray:h}=this.state;if(s.setProps({binIdRange:g,pointCount:this.getNumInstances(),operations:[o.colorAggregation,o.elevationAggregation],binOptions:{cellSizeCommon:a,cellOriginCommon:c},onUpdate:this._onAggregationUpdate.bind(this)}),h){let{getColorValue:f,getElevationValue:p}=this.props;s.setProps({customOperations:[f&&(d=>f(d.map(x=>h[x]),{indices:d,data:o.data})),p&&(d=>p(d.map(x=>h[x]),{indices:d,data:o.data}))]})}}return i.updateTriggersChanged&&i.updateTriggersChanged.getColorValue&&s.setNeedsUpdate(0),i.updateTriggersChanged&&i.updateTriggersChanged.getElevationValue&&s.setNeedsUpdate(1),e}_updateBinOptions(){let t=this.getBounds(),e=[1,1],o=[0,0],r=[[0,1],[0,1]],i=this.context.viewport;if(t&&Number.isFinite(t[0][0])){let s=[(t[0][0]+t[1][0])/2,(t[0][1]+t[1][1])/2],{cellSize:a}=this.props,{unitsPerMeter:c}=i.getDistanceScales(s);e[0]=c[0]*a,e[1]=c[1]*a;let g=i.projectFlat(s);o=[Math.floor(g[0]/e[0])*e[0],Math.floor(g[1]/e[1])*e[1]],s=i.unprojectFlat(o);let h=i.constructor;i=i.isGeospatial?new h({longitude:s[0],latitude:s[1],zoom:12}):new $.Viewport({position:[s[0],s[1],0],zoom:12}),o=[Math.fround(i.center[0]),Math.fround(i.center[1])],r=tt({dataBounds:t,getBinId:f=>{let p=i.projectFlat(f);return[Math.floor((p[0]-o[0])/e[0]),Math.floor((p[1]-o[1])/e[1])]}})}this.setState({cellSizeCommon:e,cellOriginCommon:o,binIdRange:r,aggregatorViewport:i})}draw(t){t.shaderModuleProps.project&&(t.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(t)}_onAggregationUpdate({channel:t}){let e=this.getCurrentLayer().props,{aggregator:o}=this.state;if(t===0){let r=o.getResult(0);this.setState({colors:new q(r,o.binCount)}),e.onSetColorDomain(o.getResultDomain(0))}else if(t===1){let r=o.getResult(1);this.setState({elevations:new q(r,o.binCount)}),e.onSetElevationDomain(o.getResultDomain(1))}}onAttributeChange(t){let{aggregator:e}=this.state;switch(t){case"positions":e.setNeedsUpdate(),this._updateBinOptions();let{cellSizeCommon:o,cellOriginCommon:r,binIdRange:i}=this.state;e.setProps({binIdRange:i,binOptions:{cellSizeCommon:o,cellOriginCommon:r}});break;case"colorWeights":e.setNeedsUpdate(0);break;case"elevationWeights":e.setNeedsUpdate(1);break;default:}}renderLayers(){let{aggregator:t,cellOriginCommon:e,cellSizeCommon:o}=this.state,{elevationScale:r,colorRange:i,elevationRange:s,extruded:a,coverage:c,material:g,transitions:h,colorScaleType:f,lowerPercentile:p,upperPercentile:d,colorDomain:x,elevationScaleType:v,elevationLowerPercentile:S,elevationUpperPercentile:C,elevationDomain:E}=this.props,M=this.getSubLayerClass("cells",yt),b=t.getBins(),y=this.state.colors?.update({scaleType:f,lowerPercentile:p,upperPercentile:d}),A=this.state.elevations?.update({scaleType:v,lowerPercentile:S,upperPercentile:C});return!y||!A?null:new M(this.getSubLayerProps({id:"cells"}),{data:{length:t.binCount,attributes:{getBin:b,getColorValue:y.attribute,getElevationValue:A.attribute}},dataComparator:(w,N)=>w.length===N.length,updateTriggers:{getBin:[b],getColorValue:[y.attribute],getElevationValue:[A.attribute]},cellOriginCommon:e,cellSizeCommon:o,elevationScale:r,colorRange:i,colorScaleType:f,elevationRange:s,extruded:a,coverage:c,material:g,colorDomain:y.domain||x||t.getResultDomain(0),elevationDomain:A.domain||E||t.getResultDomain(1),colorCutoff:y.cutoff,elevationCutoff:A.cutoff,transitions:h&&{getFillColor:h.getColorValue||h.getColorWeight,getElevation:h.getElevationValue||h.getElevationWeight},extensions:[]})}getPickingInfo(t){let e=t.info,{index:o}=e;if(o>=0){let r=this.state.aggregator.getBin(o),i;r&&(i={col:r.id[0],row:r.id[1],colorValue:r.value[0],elevationValue:r.value[1],count:r.count},r.pointIndices&&(i.pointIndices=r.pointIndices,i.points=Array.isArray(this.props.data)?r.pointIndices.map(s=>this.props.data[s]):[])),e.object=i}return e}};St.layerName="GridLayer";St.defaultProps=Er;var so=St;function co(n){let t=n.map(a=>a[0]),e=n.map(a=>a[1]),o=Math.min.apply(null,t),r=Math.max.apply(null,t),i=Math.min.apply(null,e),s=Math.max.apply(null,e);return[o,i,r,s]}function lo(n,t){return t[0]>=n[0]&&t[2]<=n[2]&&t[1]>=n[1]&&t[3]<=n[3]}var ao=new Float32Array(12);function ge(n,t=2){let e=0;for(let o of n)for(let r=0;r<t;r++)ao[e++]=o[r]||0;return ao}function go(n,t,e){let[o,r,i,s]=n,a=i-o,c=s-r,g=a,h=c;a/c<t/e?g=t/e*c:h=e/t*a,g<t&&(g=t,h=e);let f=(i+o)/2,p=(s+r)/2;return[f-g/2,p-h/2,f+g/2,p+h/2]}function ho(n,t){let[e,o,r,i]=t;return[(n[0]-e)/(r-e),(n[1]-o)/(i-o)]}var de=L(X(),1),V=L(I(),1);var xo=L(X(),1),Zt=L(I(),1);var po=`#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * triangle.threshold;
if (triangle.colorDomain[1] > 0.) {
maxValue = triangle.colorDomain[1];
minValue = triangle.colorDomain[0];
}
vIntensityMax = triangle.intensity / maxValue;
vIntensityMin = triangle.intensity / minValue;
}
`;var fo=`#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (triangle.aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= layer.opacity;
fragColor = linearColor;
}
`;var uo=`uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`,mo={name:"triangle",vs:uo,fs:uo,uniformTypes:{aggregationMode:"f32",colorDomain:"vec2<f32>",intensity:"f32",threshold:"f32"}};var Kt=class extends Zt.Layer{getShaders(){return super.getShaders({vs:po,fs:fo,modules:[Zt.project32,mo]})}initializeState({device:t}){this.setState({model:this._getModel(t)})}_getModel(t){let{vertexCount:e,data:o}=this.props;return new xo.Model(t,{...this.getShaders(),id:this.props.id,attributes:o.attributes,bufferLayout:[{name:"positions",format:"float32x3"},{name:"texCoords",format:"float32x2"}],topology:"triangle-strip",vertexCount:e})}draw(){let{model:t}=this.state,{aggregationMode:e,colorDomain:o,intensity:r,threshold:i,colorTexture:s,maxTexture:a,weightsTexture:c}=this.props,g={aggregationMode:e,colorDomain:o,intensity:r,threshold:i,colorTexture:s,maxTexture:a,weightsTexture:c};t.shaderInputs.setProps({triangle:g}),t.draw(this.context.renderPass)}};Kt.layerName="TriangleLayer";var vo=Kt;var pt=L(I(),1);function Mo(n,t){let e={};for(let o in n)t.includes(o)||(e[o]=n[o]);return e}var Qt=class extends pt.CompositeLayer{initializeAggregationLayer(t){super.initializeState(this.context),this.setState({ignoreProps:Mo(this.constructor._propTypes,t.data.props),dimensions:t})}updateState(t){super.updateState(t);let{changeFlags:e}=t;if(e.extensionsChanged){let o=this.getShaders({});o&&o.defines&&(o.defines.NON_INSTANCED_MODEL=1),this.updateShaders(o)}this._updateAttributes()}updateAttributes(t){this.setState({changedAttributes:t})}getAttributes(){return this.getAttributeManager().getAttributes()}getModuleSettings(){let{viewport:t,mousePosition:e,device:o}=this.context;return Object.assign(Object.create(this.props),{viewport:t,mousePosition:e,picking:{isActive:0},devicePixelRatio:o.canvasContext.cssToDeviceRatio()})}updateShaders(t){}isAggregationDirty(t,e={}){let{props:o,oldProps:r,changeFlags:i}=t,{compareAll:s=!1,dimension:a}=e,{ignoreProps:c}=this.state,{props:g,accessors:h=[]}=a,{updateTriggersChanged:f}=i;if(i.dataChanged)return!0;if(f){if(f.all)return!0;for(let p of h)if(f[p])return!0}if(s)return i.extensionsChanged?!0:(0,pt._compareProps)({oldProps:r,newProps:o,ignoreProps:c,propTypes:this.constructor._propTypes});for(let p of g)if(o[p]!==r[p])return!0;return!1}isAttributeChanged(t){let{changedAttributes:e}=this.state;return t?e&&e[t]!==void 0:!Tr(e)}_getAttributeManager(){return new pt.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}};Qt.layerName="AggregationLayer";var yo=Qt;function Tr(n){let t=!0;for(let e in n){t=!1;break}return t}var he=`#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
void main()
{
weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`;var pe=`#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var So=`#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(maxWeight.textureSize);
int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;var Ao=`#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;var Lr=`uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`,Co={name:"weight",vs:Lr,uniformTypes:{commonBounds:"vec4<f32>",radiusPixels:"f32",textureWidth:"f32",weightsScale:"f32"}},bo={name:"maxWeight",vs:`uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,uniformTypes:{textureSize:"f32"}};var Pr=2,fe={format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}},Eo=[0,0],wr={SUM:0,MEAN:1},Nr={getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},intensity:{type:"number",min:0,value:1},radiusPixels:{type:"number",min:1,max:100,value:50},colorRange:G,threshold:{type:"number",min:0,max:1,value:.05},colorDomain:{type:"array",value:null,optional:!0},aggregation:"SUM",weightsTextureSize:{type:"number",min:128,max:2048,value:2048},debounceTimeout:{type:"number",min:0,max:1e3,value:500}},Or=["float32-renderable-webgl","texture-blend-float-webgl"],Rr={data:{props:["radiusPixels"]}},At=class extends yo{getShaders(t){let e=[V.project32];return t.modules&&(e=[...e,...t.modules]),super.getShaders({...t,modules:e})}initializeState(){super.initializeAggregationLayer(Rr),this.setState({colorDomain:Eo}),this._setupTextureParams(),this._setupAttributes(),this._setupResources()}shouldUpdateState({changeFlags:t}){return t.somethingChanged}updateState(t){super.updateState(t),this._updateHeatmapState(t)}_updateHeatmapState(t){let{props:e,oldProps:o}=t,r=this._getChangeFlags(t);(r.dataChanged||r.viewportChanged)&&(r.boundsChanged=this._updateBounds(r.dataChanged),this._updateTextureRenderingBounds()),r.dataChanged||r.boundsChanged?(clearTimeout(this.state.updateTimer),this.setState({isWeightMapDirty:!0})):r.viewportZoomChanged&&this._debouncedUpdateWeightmap(),e.colorRange!==o.colorRange&&this._updateColorTexture(t),this.state.isWeightMapDirty&&this._updateWeightmap(),this.setState({zoom:t.context.viewport.zoom})}renderLayers(){let{weightsTexture:t,triPositionBuffer:e,triTexCoordBuffer:o,maxWeightsTexture:r,colorTexture:i,colorDomain:s}=this.state,{updateTriggers:a,intensity:c,threshold:g,aggregation:h}=this.props,f=this.getSubLayerClass("triangle",vo);return new f(this.getSubLayerProps({id:"triangle-layer",updateTriggers:a}),{coordinateSystem:V.COORDINATE_SYSTEM.DEFAULT,data:{attributes:{positions:e,texCoords:o}},vertexCount:4,maxTexture:r,colorTexture:i,aggregationMode:wr[h]||0,weightsTexture:t,intensity:c,threshold:g,colorDomain:s})}finalizeState(t){super.finalizeState(t);let{weightsTransform:e,weightsTexture:o,maxWeightTransform:r,maxWeightsTexture:i,triPositionBuffer:s,triTexCoordBuffer:a,colorTexture:c,updateTimer:g}=this.state;e?.destroy(),o?.destroy(),r?.destroy(),i?.destroy(),s?.destroy(),a?.destroy(),c?.destroy(),g&&clearTimeout(g)}_getAttributeManager(){return new V.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}_getChangeFlags(t){let e={},{dimensions:o}=this.state;e.dataChanged=this.isAttributeChanged()&&"attribute changed"||this.isAggregationDirty(t,{compareAll:!0,dimension:o.data})&&"aggregation is dirty",e.viewportChanged=t.changeFlags.viewportChanged;let{zoom:r}=this.state;return(!t.context.viewport||t.context.viewport.zoom!==r)&&(e.viewportZoomChanged=!0),e}_createTextures(){let{textureSize:t,format:e}=this.state;this.setState({weightsTexture:this.context.device.createTexture({...fe,width:t,height:t,format:e}),maxWeightsTexture:this.context.device.createTexture({...fe,width:1,height:1,format:e})})}_setupAttributes(){this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"},weights:{size:1,accessor:"getWeight"}}),this.setState({positionAttributeName:"positions"})}_setupTextureParams(){let{device:t}=this.context,{weightsTextureSize:e}=this.props,o=Math.min(e,t.limits.maxTextureDimension2D),r=Or.every(a=>t.features.has(a)),i=r?"rgba32float":"rgba8unorm",s=r?1:1/255;this.setState({textureSize:o,format:i,weightsScale:s}),r||V.log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)()}_createWeightsTransform(t){let{weightsTransform:e}=this.state,{weightsTexture:o}=this.state,r=this.getAttributeManager();e?.destroy(),e=new de.TextureTransform(this.context.device,{id:`${this.id}-weights-transform`,bufferLayout:r.getBufferLayouts(),vertexCount:1,targetTexture:o,parameters:{depthWriteEnabled:!1,blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},topology:"point-list",...t,modules:[...t.modules,Co]}),this.setState({weightsTransform:e})}_setupResources(){this._createTextures();let{device:t}=this.context,{textureSize:e,weightsTexture:o,maxWeightsTexture:r}=this.state,i=this.getShaders({vs:he,fs:pe});this._createWeightsTransform(i);let s=this.getShaders({vs:So,fs:Ao,modules:[bo]}),a=new de.TextureTransform(t,{id:`${this.id}-max-weights-transform`,targetTexture:r,...s,vertexCount:e*e,topology:"point-list",parameters:{depthWriteEnabled:!1,blendColorOperation:"max",blendAlphaOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"}}),c={inTexture:o,textureSize:e};a.model.shaderInputs.setProps({maxWeight:c}),this.setState({weightsTexture:o,maxWeightsTexture:r,maxWeightTransform:a,zoom:null,triPositionBuffer:t.createBuffer({byteLength:48}),triTexCoordBuffer:t.createBuffer({byteLength:48})})}updateShaders(t){this._createWeightsTransform({vs:he,fs:pe,...t})}_updateMaxWeightValue(){let{maxWeightTransform:t}=this.state;t.run({parameters:{viewport:[0,0,1,1]},clearColor:[0,0,0,0]})}_updateBounds(t=!1){let{viewport:e}=this.context,o=[e.unproject([0,0]),e.unproject([e.width,0]),e.unproject([0,e.height]),e.unproject([e.width,e.height])].map(a=>a.map(Math.fround)),r=co(o),i={visibleWorldBounds:r,viewportCorners:o},s=!1;if(t||!this.state.worldBounds||!lo(this.state.worldBounds,r)){let a=this._worldToCommonBounds(r),c=this._commonToWorldBounds(a);this.props.coordinateSystem===V.COORDINATE_SYSTEM.LNGLAT&&(c[1]=Math.max(c[1],-85.051129),c[3]=Math.min(c[3],85.051129),c[0]=Math.max(c[0],-360),c[2]=Math.min(c[2],360));let g=this._worldToCommonBounds(c);i.worldBounds=c,i.normalizedCommonBounds=g,s=!0}return this.setState(i),s}_updateTextureRenderingBounds(){let{triPositionBuffer:t,triTexCoordBuffer:e,normalizedCommonBounds:o,viewportCorners:r}=this.state,{viewport:i}=this.context;t.write(ge(r,3));let s=r.map(a=>ho(i.projectPosition(a),o));e.write(ge(s,2))}_updateColorTexture(t){let{colorRange:e}=t.props,{colorTexture:o}=this.state,r=ne(e,!1,Uint8Array);o&&o?.width===e.length?o.setTexture2DData({data:r}):(o?.destroy(),o=this.context.device.createTexture({...fe,data:r,width:e.length,height:1})),this.setState({colorTexture:o})}_updateWeightmap(){let{radiusPixels:t,colorDomain:e,aggregation:o}=this.props,{worldBounds:r,textureSize:i,weightsScale:s,weightsTexture:a}=this.state,c=this.state.weightsTransform;this.state.isWeightMapDirty=!1;let g=this._worldToCommonBounds(r,{useLayerCoordinateSystem:!0});if(e&&o==="SUM"){let{viewport:M}=this.context,b=M.distanceScales.metersPerUnit[2]*(g[2]-g[0])/i;this.state.colorDomain=e.map(y=>y*b*s)}else this.state.colorDomain=e||Eo;let f=this.getAttributeManager().getAttributes(),p=this.getModuleSettings();this._setModelAttributes(c.model,f),c.model.setVertexCount(this.getNumInstances());let d={radiusPixels:t,commonBounds:g,textureWidth:i,weightsScale:s,weightsTexture:a},{viewport:x,devicePixelRatio:v,coordinateSystem:S,coordinateOrigin:C}=p,{modelMatrix:E}=this.props;c.model.shaderInputs.setProps({project:{viewport:x,devicePixelRatio:v,modelMatrix:E,coordinateSystem:S,coordinateOrigin:C},weight:d}),c.run({parameters:{viewport:[0,0,i,i]},clearColor:[0,0,0,0]}),this._updateMaxWeightValue()}_debouncedUpdateWeightmap(t=!1){let{updateTimer:e}=this.state,{debounceTimeout:o}=this.props;t?(e=null,this._updateBounds(!0),this._updateTextureRenderingBounds(),this.setState({isWeightMapDirty:!0})):(this.setState({isWeightMapDirty:!1}),clearTimeout(e),e=setTimeout(this._debouncedUpdateWeightmap.bind(this,!0),o)),this.setState({updateTimer:e})}_worldToCommonBounds(t,e={}){let{useLayerCoordinateSystem:o=!1}=e,[r,i,s,a]=t,{viewport:c}=this.context,{textureSize:g}=this.state,{coordinateSystem:h}=this.props,f=o&&(h===V.COORDINATE_SYSTEM.LNGLAT_OFFSETS||h===V.COORDINATE_SYSTEM.METER_OFFSETS),p=f?c.projectPosition(this.props.coordinateOrigin):[0,0],d=g*Pr/c.scale,x,v;return o&&!f?(x=this.projectPosition([r,i,0]),v=this.projectPosition([s,a,0])):(x=c.projectPosition([r,i,0]),v=c.projectPosition([s,a,0])),go([x[0]-p[0],x[1]-p[1],v[0]-p[0],v[1]-p[1]],d,d)}_commonToWorldBounds(t){let[e,o,r,i]=t,{viewport:s}=this.context,a=s.unprojectPosition([e,o]),c=s.unprojectPosition([r,i]);return a.slice(0,2).concat(c.slice(0,2))}};At.layerName="HeatmapLayer";At.defaultProps=Nr;var To=At;return _o(Ct);})();
      return __exports__;
      });
