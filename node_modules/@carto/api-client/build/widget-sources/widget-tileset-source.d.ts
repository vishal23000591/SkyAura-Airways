import { TilesetSourceOptions } from '../sources/index.js';
import type { ModelSource } from '../models/index.js';
import { CategoryRequestOptions, CategoryResponse, FeaturesResponse, FormulaRequestOptions, FormulaResponse, HistogramRequestOptions, HistogramResponse, RangeRequestOptions, RangeResponse, ScatterRequestOptions, ScatterResponse, TableRequestOptions, TableResponse, TimeSeriesRequestOptions, TimeSeriesResponse } from './types.js';
import { TileFormat } from '../constants.js';
import { Filters, SpatialFilter } from '../types.js';
import { TileFeatureExtractOptions } from '../filters/index.js';
import { FeatureCollection } from 'geojson';
import { SpatialDataType } from '../sources/types.js';
import { WidgetSource, WidgetSourceProps } from './widget-source.js';
export type WidgetTilesetSourceProps = WidgetSourceProps & Omit<TilesetSourceOptions, 'filters'> & {
    tileFormat: TileFormat;
    spatialDataType: SpatialDataType;
};
export type WidgetTilesetSourceResult = {
    widgetSource: WidgetTilesetSource;
};
/**
 * Source for Widget API requests on a data source defined by a tileset.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTilesetSource}, {@link h3TilesetSource}, or {@link quadbinTilesetSource},
 * which can be shared with map layers. Sources contain a `widgetSource`
 * property, for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTilesetSource } from '@carto/api-client';
 *
 * const data = vectorTilesetSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_rasters.my_tileset_source'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
export declare class WidgetTilesetSource extends WidgetSource<WidgetTilesetSourceProps> {
    private _tiles;
    private _features;
    private _tileFeatureExtractOptions;
    private _tileFeatureExtractPreviousInputs;
    protected getModelSource(filters: Filters | undefined, filterOwner: string): ModelSource;
    /**
     * Loads features as a list of tiles (typically provided by deck.gl).
     * After tiles are loaded, {@link extractTileFeatures} must be called
     * before computing statistics on the tiles.
     */
    loadTiles(tiles: unknown[]): void;
    /** Configures options used to extract features from tiles. */
    setTileFeatureExtractOptions(options: TileFeatureExtractOptions): void;
    protected _extractTileFeatures(spatialFilter: SpatialFilter): void;
    /**
     * Loads features as GeoJSON (used for testing).
     * @experimental
     * @internal Not for public use. Spatial filters in other method calls will be ignored.
     */
    loadGeoJSON({ geojson, spatialFilter, }: {
        geojson: FeatureCollection;
        spatialFilter: SpatialFilter;
    }): void;
    getFeatures(): Promise<FeaturesResponse>;
    getFormula({ column, operation, joinOperation, filters, filterOwner, spatialFilter, }: FormulaRequestOptions): Promise<FormulaResponse>;
    getHistogram({ operation, ticks, column, joinOperation, filters, filterOwner, spatialFilter, }: HistogramRequestOptions): Promise<HistogramResponse>;
    getCategories({ column, operation, operationColumn, joinOperation, filters, filterOwner, spatialFilter, }: CategoryRequestOptions): Promise<CategoryResponse>;
    getScatter({ xAxisColumn, yAxisColumn, xAxisJoinOperation, yAxisJoinOperation, filters, filterOwner, spatialFilter, }: ScatterRequestOptions): Promise<ScatterResponse>;
    getTable({ columns, searchFilterColumn, searchFilterText, sortBy, sortDirection, sortByColumnType, offset, limit, filters, filterOwner, spatialFilter, }: TableRequestOptions): Promise<TableResponse>;
    getTimeSeries({ column, stepSize, operation, operationColumn, joinOperation, filters, filterOwner, spatialFilter, }: TimeSeriesRequestOptions): Promise<TimeSeriesResponse>;
    getRange({ column, filters, filterOwner, spatialFilter, }: RangeRequestOptions): Promise<RangeResponse>;
    /****************************************************************************
     * INTERNAL
     */
    private _getFilteredFeatures;
}
