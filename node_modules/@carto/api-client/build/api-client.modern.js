import intersects from '@turf/boolean-intersects';
import bboxPolygon from '@turf/bbox-polygon';
import booleanWithin from '@turf/boolean-within';
import intersect from '@turf/intersect';
import { featureCollection, feature, polygon, multiPolygon } from '@turf/helpers';
import bboxClip from '@turf/bbox-clip';
import { getResolution as getResolution$2, polygonToCells } from 'h3-js';
import union from '@turf/union';
import { getType } from '@turf/invariant';
import { booleanEqual } from '@turf/boolean-equal';

/**
 * @internal
 * @privateRemarks Source: @carto/react-core, @carto/constants, @deck.gl/carto
 */
let client = 'deck-gl-carto';
/**
 * Returns current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
function getClient() {
  return client;
}
/**
 * Sets current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
function setClient(c) {
  client = c;
}

/**
 * Defines a comparator used when matching a column's values against given filter values.
 *
 * Example:
 *
 * ```javascript
 * import { FilterType } from '@carto/api-client';
 * const filters = {
 *   column_name: { [FilterType.IN]: { values: ['a', 'b', 'c'] } }
 * };
 * ```
 *
 * @privateRemarks Source: @carto/react-api, @deck.gl/carto
 */
var FilterType;
(function (FilterType) {
  FilterType["IN"] = "in";
  /** [a, b] both are included. */
  FilterType["BETWEEN"] = "between";
  /** [a, b) a is included, b is not. */
  FilterType["CLOSED_OPEN"] = "closed_open";
  FilterType["TIME"] = "time";
  FilterType["STRING_SEARCH"] = "stringSearch";
})(FilterType || (FilterType = {}));
/** @privateRemarks Source: @carto/constants */
var ApiVersion;
(function (ApiVersion) {
  ApiVersion["V1"] = "v1";
  ApiVersion["V2"] = "v2";
  ApiVersion["V3"] = "v3";
})(ApiVersion || (ApiVersion = {}));
/** @privateRemarks Source: @carto/constants, @deck.gl/carto */
const DEFAULT_API_BASE_URL = 'https://gcp-us-east1.api.carto.com';
/** @privateRemarks Source: @carto/react-core */
var TileFormat;
(function (TileFormat) {
  TileFormat["MVT"] = "mvt";
  TileFormat["JSON"] = "json";
  TileFormat["GEOJSON"] = "geojson";
  TileFormat["BINARY"] = "binary";
})(TileFormat || (TileFormat = {}));
/** @privateRemarks Source: @carto/react-core */
var SpatialIndex;
(function (SpatialIndex) {
  SpatialIndex["H3"] = "h3";
  SpatialIndex["S2"] = "s2";
  SpatialIndex["QUADBIN"] = "quadbin";
})(SpatialIndex || (SpatialIndex = {}));
/** @privateRemarks Source: @carto/react-core */
var Provider;
(function (Provider) {
  Provider["BIGQUERY"] = "bigquery";
  Provider["REDSHIFT"] = "redshift";
  Provider["POSTGRES"] = "postgres";
  Provider["SNOWFLAKE"] = "snowflake";
  Provider["DATABRICKS"] = "databricks";
  Provider["DATABRICKS_REST"] = "databricksRest";
})(Provider || (Provider = {}));

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}

function makeIntervalComplete(intervals) {
  return intervals.map(val => {
    if (val[0] === undefined || val[0] === null) {
      return [Number.MIN_SAFE_INTEGER, val[1]];
    }
    if (val[1] === undefined || val[1] === null) {
      return [val[0], Number.MAX_SAFE_INTEGER];
    }
    return val;
  });
}

const filterFunctions = {
  [FilterType.IN]: filterIn,
  [FilterType.BETWEEN]: filterBetween,
  [FilterType.TIME]: filterTime,
  [FilterType.CLOSED_OPEN]: filterClosedOpen,
  [FilterType.STRING_SEARCH]: filterStringSearch
};
function filterIn(filterValues, featureValue) {
  return filterValues.includes(featureValue);
}
// FilterTypes.BETWEEN
function filterBetween(filterValues, featureValue) {
  const checkRange = range => {
    const [lowerBound, upperBound] = range;
    return featureValue >= lowerBound && featureValue <= upperBound;
  };
  return makeIntervalComplete(filterValues).some(checkRange);
}
function filterTime(filterValues, featureValue) {
  const featureValueAsTimestamp = new Date(featureValue).getTime();
  if (isFinite(featureValueAsTimestamp)) {
    return filterBetween(filterValues, featureValueAsTimestamp);
  } else {
    throw new Error(`Column used to filter by time isn't well formatted.`);
  }
}
// FilterTypes.CLOSED_OPEN
function filterClosedOpen(filterValues, featureValue) {
  const checkRange = range => {
    const [lowerBound, upperBound] = range;
    return featureValue >= lowerBound && featureValue < upperBound;
  };
  return makeIntervalComplete(filterValues).some(checkRange);
}
// FilterTypes.STRING_SEARCH
function filterStringSearch(filterValues, featureValue, params = {}) {
  const normalizedFeatureValue = normalize(featureValue, params);
  const stringRegExp = params.useRegExp ? filterValues : filterValues.map(filterValue => {
    let stringRegExp = escapeRegExp(normalize(filterValue, params));
    if (params.mustStart) stringRegExp = `^${stringRegExp}`;
    if (params.mustEnd) stringRegExp = `${stringRegExp}$`;
    return stringRegExp;
  });
  const regex = new RegExp(stringRegExp.join('|'), params.caseSensitive ? 'g' : 'gi');
  return !!normalizedFeatureValue.match(regex);
}
// Aux
const specialCharRegExp = /[.*+?^${}()|[\]\\]/g;
const normalizeRegExp = /(?:[\^`\xA8\xAF\xB4\xB7\xB8\u02B0-\u034E\u0350-\u0357\u035D-\u0362\u0374\u0375\u037A\u0384\u0385\u0483-\u0487\u0559\u0591-\u05A1\u05A3-\u05BD\u05BF\u05C1\u05C2\u05C4\u064B-\u0652\u0657\u0658\u06DF\u06E0\u06E5\u06E6\u06EA-\u06EC\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F5\u0818\u0819\u0898-\u089F\u08C9-\u08D2\u08E3-\u08FE\u093C\u094D\u0951-\u0954\u0971\u09BC\u09CD\u0A3C\u0A4D\u0ABC\u0ACD\u0AFD-\u0AFF\u0B3C\u0B4D\u0B55\u0BCD\u0C3C\u0C4D\u0CBC\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0E47-\u0E4C\u0E4E\u0EBA\u0EC8-\u0ECC\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F82-\u0F84\u0F86\u0F87\u0FC6\u1037\u1039\u103A\u1063\u1064\u1069-\u106D\u1087-\u108D\u108F\u109A\u109B\u135D-\u135F\u1714\u1715\u1734\u17C9-\u17D3\u17DD\u1939-\u193B\u1A60\u1A75-\u1A7C\u1A7F\u1AB0-\u1ABE\u1AC1-\u1ACB\u1B34\u1B44\u1B6B-\u1B73\u1BAA\u1BAB\u1BE6\u1BF2\u1BF3\u1C36\u1C37\u1C78-\u1C7D\u1CD0-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1D2C-\u1D6A\u1DC4-\u1DCF\u1DF5-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2CEF-\u2CF1\u2E2F\u302A-\u302F\u3099-\u309C\u30FC\uA66F\uA67C\uA67D\uA67F\uA69C\uA69D\uA6F0\uA6F1\uA700-\uA721\uA788-\uA78A\uA7F8\uA7F9\uA806\uA82C\uA8C4\uA8E0-\uA8F1\uA92B-\uA92E\uA953\uA9B3\uA9C0\uA9E5\uAA7B-\uAA7D\uAABF-\uAAC2\uAAF6\uAB5B-\uAB5F\uAB69-\uAB6B\uABEC\uABED\uFB1E\uFE20-\uFE2F\uFF3E\uFF40\uFF70\uFF9E\uFF9F\uFFE3]|\uD800\uDEE0|\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD22-\uDD27\uDD4E\uDD69-\uDD6D\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC46\uDC70\uDCB9\uDCBA\uDD33\uDD34\uDD73\uDDC0\uDDCA-\uDDCC\uDE35\uDE36\uDEE9\uDEEA\uDF3B\uDF3C\uDF4D\uDF66-\uDF6C\uDF70-\uDF74\uDFCE-\uDFD0\uDFD2\uDFD3\uDFE1\uDFE2]|\uD805[\uDC42\uDC46\uDCC2\uDCC3\uDDBF\uDDC0\uDE3F\uDEB6\uDEB7\uDF2B]|\uD806[\uDC39\uDC3A\uDD3D\uDD3E\uDD43\uDDE0\uDE34\uDE47\uDE99]|\uD807[\uDC3F\uDD42\uDD44\uDD45\uDD97\uDF41\uDF42\uDF5A]|\uD80D[\uDC47-\uDC55]|\uD818\uDD2F|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDD6B\uDD6C\uDF8F-\uDF9F\uDFF0\uDFF1]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uD838[\uDC30-\uDC6D\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDDEE\uDDEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD46\uDD48-\uDD4A])/g;
function escapeRegExp(value) {
  return value.replace(specialCharRegExp, '\\$&');
}
function normalize(data, params) {
  let normalizedData = String(data);
  if (!params.keepSpecialCharacters) normalizedData = normalizedData.normalize('NFD').replace(normalizeRegExp, '');
  return normalizedData;
}

const LOGICAL_OPERATOR_METHODS = {
  and: 'every',
  or: 'some'
};
function passesFilter(columns, filters, feature, filtersLogicalOperator) {
  const method = LOGICAL_OPERATOR_METHODS[filtersLogicalOperator];
  return columns[method](column => {
    const columnFilters = filters[column];
    const columnFilterTypes = Object.keys(columnFilters);
    if (!feature || feature[column] === null || feature[column] === undefined) {
      return false;
    }
    return columnFilterTypes.every(filter => {
      const filterFunction = filterFunctions[filter];
      if (!filterFunction) {
        throw new Error(`"${filter}" filter is not implemented.`);
      }
      return filterFunction(columnFilters[filter].values, feature[column], columnFilters[filter].params);
    });
  });
}
/**
 * @internal
 * @privateRemarks Exported for use in @deck.gl/carto's getDataFilterExtensionProps.
 */
function _buildFeatureFilter({
  filters = {},
  type = 'boolean',
  filtersLogicalOperator = 'and'
}) {
  const columns = Object.keys(filters);
  if (!columns.length) {
    return () => type === 'number' ? 1 : true;
  }
  return feature => {
    const f = feature.properties || feature;
    const featurePassesFilter = passesFilter(columns, filters, f, filtersLogicalOperator);
    return type === 'number' ? Number(featurePassesFilter) : featurePassesFilter;
  };
}
/**
 * Apply certain filters to a collection of features.
 * @internal
 */
function applyFilters(features, filters, filtersLogicalOperator) {
  return Object.keys(filters).length ? features.filter(_buildFeatureFilter({
    filters,
    filtersLogicalOperator
  })) : features;
}
/**
 * Binary.
 * @internal
 */
function buildBinaryFeatureFilter({
  filters = {}
}) {
  const columns = Object.keys(filters);
  if (!columns.length) {
    return () => 1;
  }
  return (featureIdIdx, binaryData) => passesFilterUsingBinary(columns, filters, featureIdIdx, binaryData);
}
function getValueFromNumericProps(featureIdIdx, binaryData, {
  column
}) {
  var _binaryData$numericPr;
  return (_binaryData$numericPr = binaryData.numericProps) == null || (_binaryData$numericPr = _binaryData$numericPr[column]) == null ? void 0 : _binaryData$numericPr.value[featureIdIdx];
}
function getValueFromProperties(featureIdIdx, binaryData, {
  column
}) {
  var _binaryData$propertie;
  const propertyIdx = binaryData.featureIds.value[featureIdIdx];
  return (_binaryData$propertie = binaryData.properties[propertyIdx]) == null ? void 0 : _binaryData$propertie[column];
}
const GET_VALUE_BY_BINARY_PROP = {
  properties: getValueFromProperties,
  numericProps: getValueFromNumericProps
};
function getBinaryPropertyByFilterValues(filterValues) {
  return typeof filterValues.flat()[0] === 'string' ? 'properties' : 'numericProps';
}
function getFeatureValue(featureIdIdx, binaryData, filter) {
  const {
    column,
    values
  } = filter;
  const binaryProp = getBinaryPropertyByFilterValues(values);
  const getFeatureValueFn = GET_VALUE_BY_BINARY_PROP[binaryProp];
  return getFeatureValueFn(featureIdIdx, binaryData, {
    column
  });
}
function passesFilterUsingBinary(columns, filters, featureIdIdx, binaryData) {
  return columns.every(column => {
    const columnFilters = filters[column];
    return Object.entries(columnFilters).every(([type, {
      values
    }]) => {
      const filterFn = filterFunctions[type];
      if (!filterFn) {
        throw new Error(`"${type}" filter is not implemented.`);
      }
      if (!values) return 0;
      const featureValue = getFeatureValue(featureIdIdx, binaryData, {
        type: type,
        column,
        values
      });
      if (featureValue === undefined || featureValue === null) return 0;
      return filterFn(values, featureValue);
    });
  });
}

function geojsonFeatures({
  geojson,
  spatialFilter,
  uniqueIdProperty
}) {
  let uniqueIdx = 0;
  const map = new Map();
  if (!spatialFilter) {
    return [];
  }
  for (const feature of geojson.features) {
    const uniqueId = uniqueIdProperty ? feature.properties[uniqueIdProperty] : ++uniqueIdx;
    if (!map.has(uniqueId) && intersects(spatialFilter, feature)) {
      map.set(uniqueId, feature.properties);
    }
  }
  return Array.from(map.values());
}

// math.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const DEFAULT_CONFIG = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
// Configuration is truly global as of v3.6 to ensure single config even if multiple copies of math.gl
// Multiple copies of config can be quite tricky to debug...
globalThis.mathgl = globalThis.mathgl || {
  config: {
    ...DEFAULT_CONFIG
  }
};
/**
 * Check if value is an "array"
 * Returns `true` if value is either an array or a typed array
 * Note: returns `false` for `ArrayBuffer` and `DataView` instances
 * @note isTypedArray and isNumericArray are often more useful in TypeScript
 */
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }
  return t * b + (1 - t) * a;
}

// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert$1(condition, message) {
  if (!condition) {
    throw new Error(message || '@math.gl/web-mercator: assertion failed.');
  }
}

// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE
// CONSTANTS
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return [x,y] coordinates.
 */
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert$1(Number.isFinite(lng));
  assert$1(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  const lambda2 = lng * DEGREES_TO_RADIANS;
  const phi2 = lat * DEGREES_TO_RADIANS;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param xy - array with [x,y] members
 *  representing point on projected map plane
 * @return - array with [x,y] of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

const TRANSFORM_FN$1 = {
  Point: transformPoint$1,
  MultiPoint: transformMultiPoint$1,
  LineString: transformLineString$1,
  MultiLineString: transformMultiLineString$1,
  Polygon: transformPolygon$1,
  MultiPolygon: transformMultiPolygon$1
};
/**
 * Transform WGS84 coordinates to tile coords.
 * It's the inverse of deck.gl coordinate-transform (https://github.com/visgl/deck.gl/blob/master/modules/geo-layers/src/mvt-layer/coordinate-transform.js)
 *
 * @param geometry - any valid geojson geometry
 * @param bbox - geojson bbox
 */
function transformToTileCoords(geometry, bbox) {
  const [west, south, east, north] = bbox;
  const nw = projectFlat([west, north]);
  const se = projectFlat([east, south]);
  const projectedBbox = [nw, se];
  if (geometry.type === 'GeometryCollection') {
    throw new Error('Unsupported geometry type GeometryCollection');
  }
  const transformFn = TRANSFORM_FN$1[geometry.type];
  const coordinates = transformFn(geometry.coordinates, projectedBbox);
  return _extends({}, geometry, {
    coordinates
  });
}
function transformPoint$1([pointX, pointY], [nw, se]) {
  const x = inverseLerp(nw[0], se[0], pointX);
  const y = inverseLerp(nw[1], se[1], pointY);
  return [x, y];
}
function getPoints$1(geometry, bbox) {
  return geometry.map(g => transformPoint$1(projectFlat(g), bbox));
}
function transformMultiPoint$1(multiPoint, bbox) {
  return getPoints$1(multiPoint, bbox);
}
function transformLineString$1(line, bbox) {
  return getPoints$1(line, bbox);
}
function transformMultiLineString$1(multiLineString, bbox) {
  return multiLineString.map(lineString => transformLineString$1(lineString, bbox));
}
function transformPolygon$1(polygon, bbox) {
  return polygon.map(polygonRing => getPoints$1(polygonRing, bbox));
}
function transformMultiPolygon$1(multiPolygon, bbox) {
  return multiPolygon.map(polygon => transformPolygon$1(polygon, bbox));
}
function projectFlat(xyz) {
  return lngLatToWorld(xyz);
}
function inverseLerp(a, b, x) {
  return (x - a) / (b - a);
}

const TRANSFORM_FN = {
  Point: transformPoint,
  MultiPoint: transformMultiPoint,
  LineString: transformLineString,
  MultiLineString: transformMultiLineString,
  Polygon: transformPolygon,
  MultiPolygon: transformMultiPolygon
};
/**
 * Transform tile coords to WGS84 coordinates.
 *
 * @param geometry - any valid geojson geometry
 * @param bbox - geojson bbox
 */
function transformTileCoordsToWGS84(geometry, bbox) {
  const [west, south, east, north] = bbox;
  const nw = lngLatToWorld([west, north]);
  const se = lngLatToWorld([east, south]);
  const projectedBbox = [nw, se];
  if (geometry.type === 'GeometryCollection') {
    throw new Error('Unsupported geometry type GeometryCollection');
  }
  const transformFn = TRANSFORM_FN[geometry.type];
  const coordinates = transformFn(geometry.coordinates, projectedBbox);
  return _extends({}, geometry, {
    coordinates
  });
}
function transformPoint([pointX, pointY], [nw, se]) {
  const x = lerp(nw[0], se[0], pointX);
  const y = lerp(nw[1], se[1], pointY);
  return worldToLngLat([x, y]);
}
function getPoints(geometry, bbox) {
  return geometry.map(g => transformPoint(g, bbox));
}
function transformMultiPoint(multiPoint, bbox) {
  return getPoints(multiPoint, bbox);
}
function transformLineString(line, bbox) {
  return getPoints(line, bbox);
}
function transformMultiLineString(multiLineString, bbox) {
  return multiLineString.map(lineString => transformLineString(lineString, bbox));
}
function transformPolygon(polygon, bbox) {
  return polygon.map(polygonRing => getPoints(polygonRing, bbox));
}
function transformMultiPolygon(multiPolygon, bbox) {
  return multiPolygon.map(polygon => transformPolygon(polygon, bbox));
}

const FEATURE_GEOM_PROPERTY = '__geomValue';
function tileFeaturesGeometries({
  tiles,
  tileFormat,
  spatialFilter,
  uniqueIdProperty,
  options
}) {
  const map = new Map();
  for (const tile of tiles) {
    // Discard if it's not a visible tile (only check false value, not undefined)
    // or tile has not data
    if (tile.isVisible === false || !tile.data) {
      continue;
    }
    const bbox = [tile.bbox.west, tile.bbox.south, tile.bbox.east, tile.bbox.north];
    const bboxToGeom = bboxPolygon(bbox);
    const tileIsFullyVisible = booleanWithin(bboxToGeom, spatialFilter);
    // Clip the geometry to intersect with the tile
    const spatialFilterFeature = {
      type: 'Feature',
      geometry: spatialFilter,
      properties: {}
    };
    const clippedGeometryToIntersect = intersect(featureCollection([bboxToGeom, spatialFilterFeature]));
    if (!clippedGeometryToIntersect) {
      continue;
    }
    // We assume that MVT tileFormat uses local coordinates so we transform the geometry to intersect to tile coordinates [0..1],
    // while in the case of 'geojson' or binary, the geometries are already in WGS84
    const transformedGeometryToIntersect = tileFormat === TileFormat.MVT ? transformToTileCoords(clippedGeometryToIntersect.geometry, bbox) : clippedGeometryToIntersect.geometry;
    createIndicesForPoints(tile.data.points);
    calculateFeatures({
      map,
      tileIsFullyVisible,
      geometryIntersection: transformedGeometryToIntersect,
      data: tile.data.points,
      type: 'Point',
      bbox,
      tileFormat,
      uniqueIdProperty,
      options
    });
    calculateFeatures({
      map,
      tileIsFullyVisible,
      geometryIntersection: transformedGeometryToIntersect,
      data: tile.data.lines,
      type: 'LineString',
      bbox,
      tileFormat,
      uniqueIdProperty,
      options
    });
    calculateFeatures({
      map,
      tileIsFullyVisible,
      geometryIntersection: transformedGeometryToIntersect,
      data: tile.data.polygons,
      type: 'Polygon',
      bbox,
      tileFormat,
      uniqueIdProperty,
      options
    });
  }
  return Array.from(map.values());
}
function processTileFeatureProperties({
  map,
  data,
  startIndex,
  endIndex,
  type,
  bbox,
  tileFormat,
  uniqueIdProperty,
  storeGeometry,
  geometryIntersection
}) {
  const tileProps = getPropertiesFromTile(data, startIndex);
  const uniquePropertyValue = getUniquePropertyValue(tileProps, uniqueIdProperty, map);
  if (!uniquePropertyValue || map.has(uniquePropertyValue)) {
    return;
  }
  let geometry = null;
  // Only calculate geometry if necessary
  if (storeGeometry || geometryIntersection) {
    const {
      positions
    } = data;
    const ringCoordinates = getRingCoordinatesFor(startIndex, endIndex, positions);
    geometry = getFeatureByType(ringCoordinates, type);
  }
  // If intersection is required, check before proceeding
  if (geometry && geometryIntersection && !intersects(geometry, geometryIntersection)) {
    return;
  }
  const properties = parseProperties(tileProps);
  // Only save geometry if necessary
  if (storeGeometry && geometry) {
    properties[FEATURE_GEOM_PROPERTY] = tileFormat === TileFormat.MVT ? transformTileCoordsToWGS84(geometry, bbox) : geometry;
  }
  map.set(uniquePropertyValue, properties);
}
function addIntersectedFeaturesInTile({
  map,
  data,
  geometryIntersection,
  type,
  bbox,
  tileFormat,
  uniqueIdProperty,
  options
}) {
  const indices = getIndices(data);
  const storeGeometry = (options == null ? void 0 : options.storeGeometry) || false;
  for (let i = 0; i < indices.length - 1; i++) {
    const startIndex = indices[i];
    const endIndex = indices[i + 1];
    processTileFeatureProperties({
      map,
      data,
      startIndex,
      endIndex,
      type,
      bbox,
      tileFormat,
      uniqueIdProperty,
      storeGeometry,
      geometryIntersection
    });
  }
}
function getIndices(data) {
  let indices;
  switch (data.type) {
    case 'Point':
      // @ts-expect-error Missing or changed types?
      indices = data.pointIndices;
      break;
    case 'LineString':
      indices = data.pathIndices;
      break;
    case 'Polygon':
      indices = data.primitivePolygonIndices;
      break;
    default:
      throw new Error(`Unexpected type, "${data.type}"`);
  }
  return indices.value;
}
function getFeatureId(data, startIndex) {
  return data.featureIds.value[startIndex];
}
function getPropertiesFromTile(data, startIndex) {
  var _fields$featureId;
  const featureId = getFeatureId(data, startIndex);
  const {
    properties,
    numericProps,
    fields
  } = data;
  const result = {
    uniqueId: fields == null || (_fields$featureId = fields[featureId]) == null ? void 0 : _fields$featureId.id,
    properties: properties[featureId],
    numericProps: {}
  };
  for (const key in numericProps) {
    result.numericProps[key] = numericProps[key].value[startIndex];
  }
  return result;
}
function parseProperties(tileProps) {
  const {
    properties,
    numericProps
  } = tileProps;
  return Object.assign({}, properties, numericProps);
}
function getUniquePropertyValue(tileProps, uniqueIdProperty, map) {
  if (uniqueIdProperty) {
    return getValueFromTileProps(tileProps, uniqueIdProperty);
  }
  if (tileProps.uniqueId) {
    return tileProps.uniqueId;
  }
  const artificialId = map.size + 1; // a counter, assumed as a valid new id
  return getValueFromTileProps(tileProps, 'cartodb_id') || getValueFromTileProps(tileProps, 'geoid') || artificialId;
}
function getValueFromTileProps(tileProps, propertyName) {
  const {
    properties,
    numericProps
  } = tileProps;
  return numericProps[propertyName] || properties[propertyName];
}
function getFeatureByType(coordinates, type) {
  switch (type) {
    case 'Polygon':
      return {
        type: 'Polygon',
        coordinates: [coordinates]
      };
    case 'LineString':
      return {
        type: 'LineString',
        coordinates
      };
    case 'Point':
      return {
        type: 'Point',
        coordinates: coordinates[0]
      };
    default:
      throw new Error('Invalid geometry type');
  }
}
function getRingCoordinatesFor(startIndex, endIndex, positions) {
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    ringCoordinates.push(Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size)));
  }
  return ringCoordinates;
}
function calculateFeatures({
  map,
  tileIsFullyVisible,
  geometryIntersection,
  data,
  type,
  bbox,
  tileFormat,
  uniqueIdProperty,
  options
}) {
  if (!(data != null && data.properties.length)) {
    return;
  }
  if (tileIsFullyVisible) {
    addAllFeaturesInTile({
      map,
      data,
      type,
      bbox,
      tileFormat,
      uniqueIdProperty,
      options
    });
  } else {
    addIntersectedFeaturesInTile({
      map,
      data,
      geometryIntersection,
      type,
      bbox,
      tileFormat,
      uniqueIdProperty,
      options
    });
  }
}
function addAllFeaturesInTile({
  map,
  data,
  type,
  bbox,
  tileFormat,
  uniqueIdProperty,
  options
}) {
  const indices = getIndices(data);
  const storeGeometry = (options == null ? void 0 : options.storeGeometry) || false;
  for (let i = 0; i < indices.length - 1; i++) {
    const startIndex = indices[i];
    const endIndex = indices[i + 1];
    processTileFeatureProperties({
      map,
      data,
      startIndex,
      endIndex,
      type,
      bbox,
      tileFormat,
      uniqueIdProperty,
      storeGeometry
    });
  }
}
function createIndicesForPoints(data) {
  const featureIds = data.featureIds.value;
  const lastFeatureId = featureIds[featureIds.length - 1];
  const PointIndicesArray = featureIds.constructor;
  const pointIndices = {
    value: new PointIndicesArray(featureIds.length + 1),
    size: 1
  };
  pointIndices.value.set(featureIds);
  pointIndices.value.set([lastFeatureId + 1], featureIds.length);
  // @ts-expect-error Missing or changed types?
  data.pointIndices = pointIndices;
}

// a tile is an array [x,y,z]
var d2r = Math.PI / 180,
  r2d = 180 / Math.PI;
function tileToBBOX(tile) {
  var e = tile2lon(tile[0] + 1, tile[2]);
  var w = tile2lon(tile[0], tile[2]);
  var s = tile2lat(tile[1] + 1, tile[2]);
  var n = tile2lat(tile[1], tile[2]);
  return [w, s, e, n];
}
function tileToGeoJSON(tile) {
  var bbox = tileToBBOX(tile);
  var poly = {
    type: 'Polygon',
    coordinates: [[[bbox[0], bbox[1]], [bbox[0], bbox[3]], [bbox[2], bbox[3]], [bbox[2], bbox[1]], [bbox[0], bbox[1]]]]
  };
  return poly;
}
function tile2lon(x, z) {
  return x / Math.pow(2, z) * 360 - 180;
}
function tile2lat(y, z) {
  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
  return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
}
function pointToTile(lon, lat, z) {
  var tile = pointToTileFraction(lon, lat, z);
  tile[0] = Math.floor(tile[0]);
  tile[1] = Math.floor(tile[1]);
  return tile;
}
function getChildren(tile) {
  return [[tile[0] * 2, tile[1] * 2, tile[2] + 1], [tile[0] * 2 + 1, tile[1] * 2, tile[2] + 1], [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1], [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]];
}
function getParent(tile) {
  // top left
  if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
    return [tile[0] / 2, tile[1] / 2, tile[2] - 1];
  }
  // bottom left
  else if (tile[0] % 2 === 0 && !tile[1] % 2 === 0) {
    return [tile[0] / 2, (tile[1] - 1) / 2, tile[2] - 1];
  }
  // top right
  else if (!tile[0] % 2 === 0 && tile[1] % 2 === 0) {
    return [(tile[0] - 1) / 2, tile[1] / 2, tile[2] - 1];
  }
  // bottom right
  else {
    return [(tile[0] - 1) / 2, (tile[1] - 1) / 2, tile[2] - 1];
  }
}
function getSiblings(tile) {
  return getChildren(getParent(tile));
}
function hasSiblings(tile, tiles) {
  var siblings = getSiblings(tile);
  for (var i = 0; i < siblings.length; i++) {
    if (!hasTile(tiles, siblings[i])) return false;
  }
  return true;
}
function hasTile(tiles, tile) {
  for (var i = 0; i < tiles.length; i++) {
    if (tilesEqual(tiles[i], tile)) return true;
  }
  return false;
}
function tilesEqual(tile1, tile2) {
  return tile1[0] === tile2[0] && tile1[1] === tile2[1] && tile1[2] === tile2[2];
}
function tileToQuadkey(tile) {
  var index = '';
  for (var z = tile[2]; z > 0; z--) {
    var b = 0;
    var mask = 1 << z - 1;
    if ((tile[0] & mask) !== 0) b++;
    if ((tile[1] & mask) !== 0) b += 2;
    index += b.toString();
  }
  return index;
}
function quadkeyToTile(quadkey) {
  var x = 0;
  var y = 0;
  var z = quadkey.length;
  for (var i = z; i > 0; i--) {
    var mask = 1 << i - 1;
    switch (quadkey[z - i]) {
      case '0':
        break;
      case '1':
        x |= mask;
        break;
      case '2':
        y |= mask;
        break;
      case '3':
        x |= mask;
        y |= mask;
        break;
    }
  }
  return [x, y, z];
}
function bboxToTile(bboxCoords) {
  var min = pointToTile(bboxCoords[0], bboxCoords[1], 32);
  var max = pointToTile(bboxCoords[2], bboxCoords[3], 32);
  var bbox = [min[0], min[1], max[0], max[1]];
  var z = getBboxZoom(bbox);
  if (z === 0) return [0, 0, 0];
  var x = bbox[0] >>> 32 - z;
  var y = bbox[1] >>> 32 - z;
  return [x, y, z];
}
function getBboxZoom(bbox) {
  var MAX_ZOOM = 28;
  for (var z = 0; z < MAX_ZOOM; z++) {
    var mask = 1 << 32 - (z + 1);
    if ((bbox[0] & mask) != (bbox[2] & mask) || (bbox[1] & mask) != (bbox[3] & mask)) {
      return z;
    }
  }
  return MAX_ZOOM;
}
function pointToTileFraction(lon, lat, z) {
  var sin = Math.sin(lat * d2r),
    z2 = Math.pow(2, z),
    x = z2 * (lon / 360 + 0.5),
    y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
  return [x, y, z];
}
var tilebelt = {
  tileToGeoJSON: tileToGeoJSON,
  tileToBBOX: tileToBBOX,
  getChildren: getChildren,
  getParent: getParent,
  getSiblings: getSiblings,
  hasTile: hasTile,
  hasSiblings: hasSiblings,
  tilesEqual: tilesEqual,
  tileToQuadkey: tileToQuadkey,
  quadkeyToTile: quadkeyToTile,
  pointToTile: pointToTile,
  bboxToTile: bboxToTile,
  pointToTileFraction: pointToTileFraction
};

/**
 * Given a geometry, create cells and return them in their raw form,
 * as an array of cell identifiers.
 *
 * @alias tiles
 * @param {Object} geom GeoJSON geometry
 * @param {Object} limits an object with min_zoom and max_zoom properties
 * specifying the minimum and maximum level to be tiled.
 * @returns {Array<Array<number>>} An array of tiles given as [x, y, z] arrays
 */
var tiles = getTiles;
function getTiles(geom, limits) {
  var i,
    tile,
    coords = geom.coordinates,
    maxZoom = limits.max_zoom,
    tileHash = {},
    tiles = [];
  if (geom.type === 'Point') {
    return [tilebelt.pointToTile(coords[0], coords[1], maxZoom)];
  } else if (geom.type === 'MultiPoint') {
    for (i = 0; i < coords.length; i++) {
      tile = tilebelt.pointToTile(coords[i][0], coords[i][1], maxZoom);
      tileHash[toID(tile[0], tile[1], tile[2])] = true;
    }
  } else if (geom.type === 'LineString') {
    lineCover(tileHash, coords, maxZoom);
  } else if (geom.type === 'MultiLineString') {
    for (i = 0; i < coords.length; i++) {
      lineCover(tileHash, coords[i], maxZoom);
    }
  } else if (geom.type === 'Polygon') {
    polygonCover(tileHash, tiles, coords, maxZoom);
  } else if (geom.type === 'MultiPolygon') {
    for (i = 0; i < coords.length; i++) {
      polygonCover(tileHash, tiles, coords[i], maxZoom);
    }
  } else {
    throw new Error('Geometry type not implemented');
  }
  if (limits.min_zoom !== maxZoom) {
    // sync tile hash and tile array so that both contain the same tiles
    var len = tiles.length;
    appendHashTiles(tileHash, tiles);
    for (i = 0; i < len; i++) {
      var t = tiles[i];
      tileHash[toID(t[0], t[1], t[2])] = true;
    }
    return mergeTiles(tileHash, tiles, limits);
  }
  appendHashTiles(tileHash, tiles);
  return tiles;
}
function mergeTiles(tileHash, tiles, limits) {
  var mergedTiles = [];
  for (var z = limits.max_zoom; z > limits.min_zoom; z--) {
    var parentTileHash = {};
    var parentTiles = [];
    for (var i = 0; i < tiles.length; i++) {
      var t = tiles[i];
      if (t[0] % 2 === 0 && t[1] % 2 === 0) {
        var id2 = toID(t[0] + 1, t[1], z),
          id3 = toID(t[0], t[1] + 1, z),
          id4 = toID(t[0] + 1, t[1] + 1, z);
        if (tileHash[id2] && tileHash[id3] && tileHash[id4]) {
          tileHash[toID(t[0], t[1], t[2])] = false;
          tileHash[id2] = false;
          tileHash[id3] = false;
          tileHash[id4] = false;
          var parentTile = [t[0] / 2, t[1] / 2, z - 1];
          if (z - 1 === limits.min_zoom) mergedTiles.push(parentTile);else {
            parentTileHash[toID(t[0] / 2, t[1] / 2, z - 1)] = true;
            parentTiles.push(parentTile);
          }
        }
      }
    }
    for (i = 0; i < tiles.length; i++) {
      t = tiles[i];
      if (tileHash[toID(t[0], t[1], t[2])]) mergedTiles.push(t);
    }
    tileHash = parentTileHash;
    tiles = parentTiles;
  }
  return mergedTiles;
}
function polygonCover(tileHash, tileArray, geom, zoom) {
  var intersections = [];
  for (var i = 0; i < geom.length; i++) {
    var ring = [];
    lineCover(tileHash, geom[i], zoom, ring);
    for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
      var m = (j + 1) % len;
      var y = ring[j][1];

      // add interesction if it's not local extremum or duplicate
      if ((y > ring[k][1] || y > ring[m][1]) && (
      // not local minimum
      y < ring[k][1] || y < ring[m][1]) &&
      // not local maximum
      y !== ring[m][1]) intersections.push(ring[j]);
    }
  }
  intersections.sort(compareTiles); // sort by y, then x

  for (i = 0; i < intersections.length; i += 2) {
    // fill tiles between pairs of intersections
    y = intersections[i][1];
    for (var x = intersections[i][0] + 1; x < intersections[i + 1][0]; x++) {
      var id = toID(x, y, zoom);
      if (!tileHash[id]) {
        tileArray.push([x, y, zoom]);
      }
    }
  }
}
function compareTiles(a, b) {
  return a[1] - b[1] || a[0] - b[0];
}
function lineCover(tileHash, coords, maxZoom, ring) {
  var prevX, prevY;
  for (var i = 0; i < coords.length - 1; i++) {
    var start = tilebelt.pointToTileFraction(coords[i][0], coords[i][1], maxZoom),
      stop = tilebelt.pointToTileFraction(coords[i + 1][0], coords[i + 1][1], maxZoom),
      x0 = start[0],
      y0 = start[1],
      x1 = stop[0],
      y1 = stop[1],
      dx = x1 - x0,
      dy = y1 - y0;
    if (dy === 0 && dx === 0) continue;
    var sx = dx > 0 ? 1 : -1,
      sy = dy > 0 ? 1 : -1,
      x = Math.floor(x0),
      y = Math.floor(y0),
      tMaxX = dx === 0 ? Infinity : Math.abs(((dx > 0 ? 1 : 0) + x - x0) / dx),
      tMaxY = dy === 0 ? Infinity : Math.abs(((dy > 0 ? 1 : 0) + y - y0) / dy),
      tdx = Math.abs(sx / dx),
      tdy = Math.abs(sy / dy);
    if (x !== prevX || y !== prevY) {
      tileHash[toID(x, y, maxZoom)] = true;
      if (ring && y !== prevY) ring.push([x, y]);
      prevX = x;
      prevY = y;
    }
    while (tMaxX < 1 || tMaxY < 1) {
      if (tMaxX < tMaxY) {
        tMaxX += tdx;
        x += sx;
      } else {
        tMaxY += tdy;
        y += sy;
      }
      tileHash[toID(x, y, maxZoom)] = true;
      if (ring && y !== prevY) ring.push([x, y]);
      prevX = x;
      prevY = y;
    }
  }
  if (ring && y === ring[0][1]) ring.pop();
}
function appendHashTiles(hash, tiles) {
  var keys = Object.keys(hash);
  for (var i = 0; i < keys.length; i++) {
    tiles.push(fromID(+keys[i]));
  }
}
function toID(x, y, z) {
  var dim = 2 * (1 << z);
  return (dim * y + x) * 32 + z;
}
function fromID(id) {
  var z = id % 32,
    dim = 2 * (1 << z),
    xy = (id - z) / 32,
    x = xy % dim,
    y = (xy - x) / dim % dim;
  return [x, y, z];
}

const B = [0x5555555555555555n, 0x3333333333333333n, 0x0f0f0f0f0f0f0f0fn, 0x00ff00ff00ff00ffn, 0x0000ffff0000ffffn, 0x00000000ffffffffn];
const S = [0n, 1n, 2n, 4n, 8n, 16n];
function tileToCell(tile) {
  if (tile.z < 0 || tile.z > 26) {
    throw new Error('Wrong zoom');
  }
  const z = BigInt(tile.z);
  let x = BigInt(tile.x) << 32n - z;
  let y = BigInt(tile.y) << 32n - z;
  for (let i = 0; i < 5; i++) {
    const s = S[5 - i];
    const b = B[4 - i];
    x = (x | x << s) & b;
    y = (y | y << s) & b;
  }
  const quadbin = 0x4000000000000000n | 1n << 59n |
  // | (mode << 59) | (mode_dep << 57)
  z << 52n | (x | y << 1n) >> 12n | 0xfffffffffffffn >> z * 2n;
  return quadbin;
}
function getResolution$1(quadbin) {
  return quadbin >> 52n & 0x1fn;
}
function geometryToCells(geometry, resolution) {
  const zoom = Number(resolution);
  return tiles(geometry, {
    min_zoom: zoom,
    max_zoom: zoom
  }).map(([x, y, z]) => tileToCell({
    x,
    y,
    z
  }));
}

function tileFeaturesSpatialIndex({
  tiles,
  spatialFilter,
  spatialDataColumn,
  spatialDataType
}) {
  const map = new Map();
  const spatialIndex = getSpatialIndex(spatialDataType);
  const resolution = getResolution(tiles, spatialIndex);
  const spatialIndexIDName = spatialDataColumn ? spatialDataColumn : spatialIndex;
  if (!resolution) {
    return [];
  }
  const cells = getCellsCoverGeometry(spatialFilter, spatialIndex, resolution);
  if (!(cells != null && cells.length)) {
    return [];
  }
  // We transform cells to Set to improve the performace
  const cellsSet = new Set(cells);
  for (const tile of tiles) {
    if (tile.isVisible === false || !tile.data) {
      continue;
    }
    tile.data.forEach(d => {
      if (cellsSet.has(d.id)) {
        map.set(d.id, _extends({}, d.properties, {
          [spatialIndexIDName]: d.id
        }));
      }
    });
  }
  return Array.from(map.values());
}
function getResolution(tiles, spatialIndex) {
  var _tiles$find;
  const data = (_tiles$find = tiles.find(tile => {
    var _tile$data;
    return (_tile$data = tile.data) == null ? void 0 : _tile$data.length;
  })) == null ? void 0 : _tiles$find.data;
  if (!data) {
    return;
  }
  if (spatialIndex === SpatialIndex.QUADBIN) {
    return Number(getResolution$1(data[0].id));
  }
  if (spatialIndex === SpatialIndex.H3) {
    return getResolution$2(data[0].id);
  }
}
const bboxWest = [-180, -90, 0, 90];
const bboxEast = [0, -90, 180, 90];
function getCellsCoverGeometry(geometry, spatialIndex, resolution) {
  if (spatialIndex === SpatialIndex.QUADBIN) {
    // @ts-expect-error TODO: Probably ought to be stricter about number vs. bigint types in this file.
    return geometryToCells(geometry, resolution);
  }
  if (spatialIndex === SpatialIndex.H3) {
    // The current H3 polyfill algorithm can't deal with polygon segments of greater than 180 degrees longitude
    // so we clip the geometry to be sure that none of them is greater than 180 degrees
    // https://github.com/uber/h3-js/issues/24#issuecomment-431893796
    return polygonToCells(bboxClip(geometry, bboxWest).geometry.coordinates, resolution, true).concat(polygonToCells(bboxClip(geometry, bboxEast).geometry.coordinates, resolution, true));
  }
}
function getSpatialIndex(spatialDataType) {
  switch (spatialDataType) {
    case 'h3':
      return SpatialIndex.H3;
    case 'quadbin':
      return SpatialIndex.QUADBIN;
    default:
      throw new Error('Unexpected spatial data type');
  }
}

/**
 * Current version of @carto/api-client.
 * @internal
 */
/** @internal */
const V3_MINOR_VERSION = '3.4';
/** @privateRemarks Source: @carto/constants, @deck.gl/carto */
const DEFAULT_GEO_COLUMN = 'geom';
/**
 * Fastly default limit is 8192; leave some padding.
 * @privateRemarks Source: @deck.gl/carto
 */
const DEFAULT_MAX_LENGTH_URL = 7000;
/** @privateRemarks Source: @deck.gl/carto */
const DEFAULT_TILE_RESOLUTION = 0.5;
/**
 * @privateRemarks Source: @deck.gl/carto
 * @internal
 */
const DEFAULT_AGGREGATION_RES_LEVEL_H3 = 4;
/**
 * @privateRemarks Source: @deck.gl/carto
 * @internal
 */
const DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN = 6;

/** @privateRemarks Source: @carto/react-core */
function tileFeatures({
  tiles,
  spatialFilter,
  uniqueIdProperty,
  tileFormat,
  spatialDataColumn = DEFAULT_GEO_COLUMN,
  spatialDataType,
  options = {}
}) {
  if (spatialDataType !== 'geo') {
    return tileFeaturesSpatialIndex({
      tiles: tiles,
      spatialFilter,
      spatialDataColumn,
      spatialDataType
    });
  }
  return tileFeaturesGeometries({
    tiles,
    tileFormat,
    spatialFilter,
    uniqueIdProperty,
    options
  });
}

/**
 * deck.gl's DataFilterExtension supports GPU filtering with 1–4 values. We
 * allocate filters[0] to generic filters and filters[1] to time filters.
 *
 * getFilterValue() _must_ return an array of the same size as the filterSize
 * used to initialize the DataFilterExtension. We document that users must use
 * filterSize=4 for compatibility with @link {getDataFilterExtensionProps}.
 */
const DEFAULT_FILTER_SIZE = 4;
/**
 * Creates props for DataFilterExtension, from `@deck.gl/extensions`, given
 * a set of filters. Requires that DataFilterExtension is initialized with
 * filterSize=4, where the CARTO filters will occupy the first two slots.
 *
 * @example To create a deck.gl layer with GPU data filtering:
 * ```typescript
 * import {DataFilterExtension} from '@deck.gl/extensions';
 * import {VectorTileLayer} from '@deck.gl/layers';
 * import {getDataFilterExtensionProps} from '@carto/api-client';
 *
 * const layer = new VectorTileLayer({
 *  data: data,
 *  extensions: [new DataFilterExtension({filterSize: 4})],
 *  ...getDataFilterExtensionProps(filters),
 * });
 * ```
 */
function getDataFilterExtensionProps(filters, filtersLogicalOperator) {
  const {
    filtersWithoutTimeType,
    timeColumn,
    timeFilter
  } = getFiltersByType(filters);
  return {
    filterRange: getFilterRange(timeFilter, DEFAULT_FILTER_SIZE),
    updateTriggers: getUpdateTriggers(filtersWithoutTimeType, timeColumn, timeFilter),
    getFilterValue: getFilterValue(filtersWithoutTimeType, timeColumn, timeFilter, DEFAULT_FILTER_SIZE, filtersLogicalOperator)
  };
}
/** @internal */
function getFiltersByType(filters) {
  const filtersWithoutTimeType = {};
  let timeColumn = null;
  let timeFilter = null;
  for (const [column, columnData] of Object.entries(filters)) {
    for (const [type, typeData] of Object.entries(columnData)) {
      if (type === FilterType.TIME) {
        timeColumn = column;
        timeFilter = typeData;
      } else {
        filtersWithoutTimeType[column] = {
          [type]: typeData
        };
      }
    }
  }
  return {
    filtersWithoutTimeType,
    timeColumn,
    timeFilter
  };
}
/** @internal */
function getFilterRange(timeFilter, filterSize) {
  const result = Array(filterSize).fill([0, 0]);
  // According to getFilterValue all filters are resolved as 0 or 1 in the first position of the array
  // except the time filter value that is resolved with the real value of the feature in the second position of the array
  result[0] = [1, 1];
  if (timeFilter) {
    var _timeFilter$params;
    const offsetBy = ((_timeFilter$params = timeFilter.params) == null ? void 0 : _timeFilter$params.offsetBy) || 0;
    result[1] = timeFilter.values[0].map(v => v - offsetBy);
  }
  return result;
}
/** @internal */
function getUpdateTriggers(filtersWithoutTimeType, timeColumn, timeFilter) {
  const result = _extends({}, filtersWithoutTimeType);
  // We don't want to change the layer UpdateTriggers every time that the time filter changes
  // because this filter is changed by the time series widget during its animation
  // so we remove the time filter value from the `updateTriggers`
  if (timeColumn && timeFilter) {
    var _timeFilter$params2;
    result[timeColumn] = _extends({}, result[timeColumn], {
      offsetBy: (_timeFilter$params2 = timeFilter.params) == null ? void 0 : _timeFilter$params2.offsetBy,
      [FilterType.TIME]: {} // Allows working with other filters, without an impact on performance.
    });
  }
  return {
    getFilterValue: JSON.stringify(result)
  };
}
/** @internal */
function getFilterValue(filtersWithoutTimeType, timeColumn, timeFilter, filterSize, filtersLogicalOperator) {
  const result = Array(filterSize).fill(0);
  const featureFilter = _buildFeatureFilter({
    filters: filtersWithoutTimeType,
    type: 'number',
    filtersLogicalOperator
  });
  // We evaluate all filters except the time filter using _buildFeatureFilter function.
  // For the time filter, we return the value of the feature and we will change the getFilterRange result
  // every time this filter changes
  return feature => {
    result[0] = featureFilter(feature);
    if (timeColumn && timeFilter) {
      var _timeFilter$params3;
      const offsetBy = ((_timeFilter$params3 = timeFilter.params) == null ? void 0 : _timeFilter$params3.offsetBy) || 0;
      const f = feature.properties || feature;
      result[1] = f[timeColumn] - offsetBy;
    }
    return result;
  };
}

const FILTER_TYPES = new Set(Object.values(FilterType));
const isFilterType = type => FILTER_TYPES.has(type);
/**
 * @privateRemarks Source: @carto/react-widgets
 * @internal
 */
function getApplicableFilters(owner, filters) {
  if (!filters) return {};
  const applicableFilters = {};
  for (const column in filters) {
    for (const type in filters[column]) {
      if (!isFilterType(type)) continue;
      const filter = filters[column][type];
      const isApplicable = !owner || !(filter != null && filter.owner) || (filter == null ? void 0 : filter.owner) !== owner;
      if (filter && isApplicable) {
        applicableFilters[column] || (applicableFilters[column] = {});
        applicableFilters[column][type] = filter;
      }
    }
  }
  return applicableFilters;
}
/**
 * Due to each data warehouse having its own behavior with columns,
 * we need to normalize them and transform every key to lowercase.
 *
 * @privateRemarks Source: @carto/react-widgets
 * @internal
 */
function normalizeObjectKeys(el) {
  if (Array.isArray(el)) {
    return el.map(value => normalizeObjectKeys(value));
  } else if (typeof el !== 'object') {
    return el;
  }
  return Object.entries(el).reduce((acc, [key, value]) => {
    acc[key.toLowerCase()] = typeof value === 'object' && value ? normalizeObjectKeys(value) : value;
    return acc;
  }, {});
}
/** @privateRemarks Source: @carto/react-core */
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
/**
 * @privateRemarks Source: @carto/react-core
 * @internal
 */
class InvalidColumnError extends Error {
  constructor(message) {
    super(`${InvalidColumnError.NAME}: ${message}`);
    this.name = InvalidColumnError.NAME;
  }
  static is(error) {
    var _error$message;
    return error instanceof InvalidColumnError || ((_error$message = error.message) == null ? void 0 : _error$message.includes(InvalidColumnError.NAME));
  }
}
InvalidColumnError.NAME = 'InvalidColumnError';
function isEmptyObject(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
/** @internal */
const isObject = x => x !== null && typeof x === 'object';
/** @internal */
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;

/**
 * Adds a {@link Filter} to the filter set. Any previous filters with the same
 * `column` and `type` will be replaced.
 */
function addFilter(filters, {
  column,
  type,
  values,
  owner
}) {
  if (!filters[column]) {
    filters[column] = {};
  }
  const filter = {
    values,
    owner
  };
  filters[column][type] = filter;
  return filters;
}
/**
 * Removes one or more {@link Filter filters} from the filter set. If only
 * `column` is specified, then all filters on that column are removed. If both
 * `column` and `owner` are specified, then only filters for that column
 * associated with the owner are removed.
 */
function removeFilter(filters, {
  column,
  owner
}) {
  const filter = filters[column];
  if (!filter) {
    return filters;
  }
  if (owner) {
    for (const type of Object.values(FilterType)) {
      var _filter$type;
      if (owner === ((_filter$type = filter[type]) == null ? void 0 : _filter$type.owner)) {
        delete filter[type];
      }
    }
  }
  if (!owner || isEmptyObject(filter)) {
    delete filters[column];
  }
  return filters;
}
/**
 * Clears all {@link Filter filters} from the filter set.
 */
function clearFilters(filters) {
  for (const column of Object.keys(filters)) {
    delete filters[column];
  }
  return filters;
}
function hasFilter(filters, {
  column,
  owner
}) {
  const filter = filters[column];
  if (!filter) {
    return false;
  }
  if (!owner) {
    return true;
  }
  for (const type of Object.values(FilterType)) {
    var _filter$type2;
    if (owner === ((_filter$type2 = filter[type]) == null ? void 0 : _filter$type2.owner)) {
      return true;
    }
  }
  return false;
}
function getFilter(filters, {
  column,
  type,
  owner
}) {
  var _filter$type3;
  const filter = filters[column];
  if (!filter) {
    return null;
  }
  if (!owner || owner === ((_filter$type3 = filter[type]) == null ? void 0 : _filter$type3.owner)) {
    return filter[type] || null;
  }
  return null;
}

/**
 * Returns a {@link SpatialFilter} for a given viewport, typically obtained
 * from deck.gl's `viewport.getBounds()` method ([west, south, east, north]).
 * If the viewport covers the entire world (to some margin of error in Web
 * Mercator space), `undefined` is returned instead.
 *
 * If the viewport extends beyond longitude range [-180, +180], the polygon
 * may be reformatted for compatibility with CARTO APIs.
 */
function createViewportSpatialFilter(viewport) {
  if (_isGlobalViewport(viewport)) {
    return;
  }
  return createPolygonSpatialFilter(bboxPolygon(viewport).geometry);
}
/**
 * Returns a {@link SpatialFilter} for a given {@link Polygon} or
 * {@link MultiPolygon}. If the polygon(s) extend outside longitude
 * range [-180, +180], the result may be reformatted for compatibility
 * with CARTO APIs.
 */
function createPolygonSpatialFilter(spatialFilter) {
  return spatialFilter && _normalizeGeometry(spatialFilter) || undefined;
}
/**
 * Check if a viewport is large enough to represent a global coverage.
 * In this case the spatial filter parameter for widget calculation is removed.
 *
 * @privateRemarks Source: @carto/react-core
 */
function _isGlobalViewport(viewport) {
  const [minx, miny, maxx, maxy] = viewport;
  return maxx - minx > 179.5 * 2 && maxy - miny > 85.05 * 2;
}
/**
 * Normalized a geometry, coming from a mask or a viewport. The parts
 * spanning outside longitude range [-180, +180] are clipped and "folded"
 * back to the valid range and unioned to the polygons inide that range.
 *
 * It results in a Polygon or MultiPolygon strictly inside the validity range.
 *
 * @privateRemarks Source: @carto/react-core
 */
function _normalizeGeometry(geometry) {
  const WORLD = [-180, -90, +180, +90];
  const worldClip = _clean(bboxClip(geometry, WORLD).geometry);
  const geometryTxWest = _tx(geometry, 360);
  const geometryTxEast = _tx(geometry, -360);
  let result = worldClip;
  if (result && geometryTxWest) {
    const worldWestClip = _clean(bboxClip(geometryTxWest, WORLD).geometry);
    if (worldWestClip) {
      const collection = featureCollection([feature(result), feature(worldWestClip)]);
      const merged = union(collection);
      result = merged ? _clean(merged.geometry) : result;
    }
  }
  if (result && geometryTxEast) {
    const worldEastClip = _clean(bboxClip(geometryTxEast, WORLD).geometry);
    if (worldEastClip) {
      const collection = featureCollection([feature(result), feature(worldEastClip)]);
      const merged = union(collection);
      result = merged ? _clean(merged.geometry) : result;
    }
  }
  return result;
}
/** @privateRemarks Source: @carto/react-core */
function _cleanPolygonCoords(cc) {
  const coords = cc.filter(c => c.length > 0);
  return coords.length > 0 ? coords : null;
}
/** @privateRemarks Source: @carto/react-core */
function _cleanMultiPolygonCoords(ccc) {
  const coords = ccc.map(_cleanPolygonCoords).filter(cc => cc);
  return coords.length > 0 ? coords : null;
}
/** @privateRemarks Source: @carto/react-core */
function _clean(geometry) {
  if (!geometry) {
    return null;
  }
  if (_isPolygon(geometry)) {
    const coords = _cleanPolygonCoords(geometry.coordinates);
    return coords ? polygon(coords).geometry : null;
  }
  if (_isMultiPolygon(geometry)) {
    const coords = _cleanMultiPolygonCoords(geometry.coordinates);
    return coords ? multiPolygon(coords).geometry : null;
  }
  return null;
}
/** @privateRemarks Source: @carto/react-core */
function _txContourCoords(cc, distance) {
  return cc.map(c => [c[0] + distance, c[1]]);
}
/** @privateRemarks Source: @carto/react-core */
function _txPolygonCoords(ccc, distance) {
  return ccc.map(cc => _txContourCoords(cc, distance));
}
/** @privateRemarks Source: @carto/react-core */
function _txMultiPolygonCoords(cccc, distance) {
  return cccc.map(ccc => _txPolygonCoords(ccc, distance));
}
/** @privateRemarks Source: @carto/react-core */
function _tx(geometry, distance) {
  if (geometry && getType(geometry) === 'Polygon') {
    const coords = _txPolygonCoords(geometry.coordinates, distance);
    return polygon(coords).geometry;
  } else if (geometry && getType(geometry) === 'MultiPolygon') {
    const coords = _txMultiPolygonCoords(geometry.coordinates, distance);
    return multiPolygon(coords).geometry;
  } else {
    return null;
  }
}
function _isPolygon(geometry) {
  return getType(geometry) === 'Polygon';
}
function _isMultiPolygon(geometry) {
  return getType(geometry) === 'MultiPolygon';
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
function joinPath(...args) {
  return args.map(part => part.endsWith('/') ? part.slice(0, -1) : part).join('/');
}
function buildV3Path(apiBaseUrl, version, endpoint, ...rest) {
  return joinPath(apiBaseUrl, version, endpoint, ...rest);
}
/** @internal Required by fetchMap(). */
function buildPublicMapUrl({
  apiBaseUrl,
  cartoMapId
}) {
  return buildV3Path(apiBaseUrl, 'v3', 'maps', 'public', cartoMapId);
}
/** @internal Required by fetchMap(). */
function buildStatsUrl({
  attribute,
  apiBaseUrl,
  connectionName,
  source,
  type
}) {
  if (type === 'query') {
    return buildV3Path(apiBaseUrl, 'v3', 'stats', connectionName, attribute);
  }
  // type === 'table'
  return buildV3Path(apiBaseUrl, 'v3', 'stats', connectionName, source, attribute);
}
function buildSourceUrl({
  apiBaseUrl,
  connectionName,
  endpoint
}) {
  return buildV3Path(apiBaseUrl, 'v3', 'maps', connectionName, endpoint);
}
function buildQueryUrl({
  apiBaseUrl,
  connectionName
}) {
  return buildV3Path(apiBaseUrl, 'v3', 'sql', connectionName, 'query');
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 *
 * Custom error for reported errors in CARTO Maps API.
 * Provides useful debugging information in console and context for applications.
 *
 */
class CartoAPIError extends Error {
  constructor(error, errorContext, response, responseJson) {
    let responseString = 'Failed to connect';
    if (response) {
      responseString = 'Server returned: ';
      if (response.status === 400) {
        responseString += 'Bad request';
      } else if (response.status === 401 || response.status === 403) {
        responseString += 'Unauthorized access';
      } else if (response.status === 404) {
        responseString += 'Not found';
      } else {
        responseString += 'Error';
      }
      responseString += ` (${response.status}):`;
    }
    responseString += ` ${error.message || error}`;
    let message = `${errorContext.requestType} API request failed`;
    message += `\n${responseString}`;
    for (const key of Object.keys(errorContext)) {
      if (key === 'requestType') continue;
      message += `\n${formatErrorKey(key)}: ${errorContext[key]}`;
    }
    message += '\n';
    super(message);
    /** Source error from server */
    this.error = void 0;
    /** Context (API call & parameters) in which error occured */
    this.errorContext = void 0;
    /** Response from server */
    this.response = void 0;
    /** JSON Response from server */
    this.responseJson = void 0;
    this.name = 'CartoAPIError';
    this.response = response;
    this.responseJson = responseJson;
    this.error = error;
    this.errorContext = errorContext;
  }
}
/**
 * Converts camelCase to Camel Case
 */
function formatErrorKey(key) {
  return key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
}

const DEFAULT_HEADERS = {
  Accept: 'application/json',
  'Content-Type': 'application/json'
};
const DEFAULT_REQUEST_CACHE = new Map();
async function requestWithParameters({
  baseUrl,
  parameters = {},
  headers: customHeaders = {},
  errorContext,
  maxLengthURL = DEFAULT_MAX_LENGTH_URL,
  localCache
}) {
  // Parameters added to all requests issued with `requestWithParameters()`.
  // These parameters override parameters already in the base URL, but not
  // user-provided parameters.
  parameters = _extends({
    v: V3_MINOR_VERSION,
    client: getClient()
  }, typeof deck !== 'undefined' && deck.VERSION && {
    deckglVersion: deck.VERSION
  }, parameters);
  baseUrl = excludeURLParameters(baseUrl, Object.keys(parameters));
  const key = createCacheKey(baseUrl, parameters, customHeaders);
  const {
    cache: REQUEST_CACHE,
    canReadCache,
    canStoreInCache
  } = getCacheSettings(localCache);
  if (canReadCache && REQUEST_CACHE.has(key)) {
    return REQUEST_CACHE.get(key);
  }
  const url = createURLWithParameters(baseUrl, parameters);
  const headers = _extends({}, DEFAULT_HEADERS, customHeaders);
  /* global fetch */
  const fetchPromise = url.length > maxLengthURL ? fetch(baseUrl, {
    method: 'POST',
    body: JSON.stringify(parameters),
    headers
  }) : fetch(url, {
    headers
  });
  let response;
  let responseJson;
  const jsonPromise = fetchPromise.then(_response => {
    response = _response;
    return response.json();
  }).then(json => {
    responseJson = json;
    if (!response || !response.ok) {
      throw new Error(json.error);
    }
    return json;
  }).catch(error => {
    if (canStoreInCache) {
      REQUEST_CACHE.delete(key);
    }
    throw new CartoAPIError(error, errorContext, response, responseJson);
  });
  if (canStoreInCache) {
    REQUEST_CACHE.set(key, jsonPromise);
  }
  return jsonPromise;
}
function getCacheSettings(localCache) {
  var _localCache$cacheCont, _localCache$cacheCont2;
  const canReadCache = localCache != null && (_localCache$cacheCont = localCache.cacheControl) != null && _localCache$cacheCont.includes('no-cache') ? false : true;
  const canStoreInCache = localCache != null && (_localCache$cacheCont2 = localCache.cacheControl) != null && _localCache$cacheCont2.includes('no-store') ? false : true;
  const cache = (localCache == null ? void 0 : localCache.cache) || DEFAULT_REQUEST_CACHE;
  return {
    cache,
    canReadCache,
    canStoreInCache
  };
}
function createCacheKey(baseUrl, parameters, headers) {
  const parameterEntries = Object.entries(parameters).sort(([a], [b]) => a > b ? 1 : -1);
  const headerEntries = Object.entries(headers).sort(([a], [b]) => a > b ? 1 : -1);
  return JSON.stringify({
    baseUrl,
    parameters: parameterEntries,
    headers: headerEntries
  });
}
/**
 * Appends query string parameters to a URL. Existing URL parameters are kept,
 * unless there is a conflict, in which case the new parameters override
 * those already in the URL.
 */
function createURLWithParameters(baseUrlString, parameters) {
  const baseUrl = new URL(baseUrlString);
  for (const [key, value] of Object.entries(parameters)) {
    if (isPureObject(value) || Array.isArray(value)) {
      baseUrl.searchParams.set(key, JSON.stringify(value));
    } else {
      baseUrl.searchParams.set(key, value.toString());
    }
  }
  return baseUrl.toString();
}
/**
 * Deletes query string parameters from a URL.
 */
function excludeURLParameters(baseUrlString, parameters) {
  const baseUrl = new URL(baseUrlString);
  for (const param of parameters) {
    if (baseUrl.searchParams.has(param)) {
      baseUrl.searchParams.delete(param);
    }
  }
  return baseUrl.toString();
}

const _excluded$1 = ["accessToken", "connectionName", "cache"];
const SOURCE_DEFAULTS = {
  apiBaseUrl: DEFAULT_API_BASE_URL,
  format: 'tilejson',
  headers: {},
  maxLengthURL: DEFAULT_MAX_LENGTH_URL
};
async function baseSource(endpoint, options, urlParameters) {
  const {
      accessToken,
      connectionName,
      cache
    } = options,
    optionalOptions = _objectWithoutPropertiesLoose(options, _excluded$1);
  const mergedOptions = _extends({}, SOURCE_DEFAULTS, {
    clientId: getClient(),
    accessToken,
    connectionName,
    endpoint
  });
  for (const key in optionalOptions) {
    if (optionalOptions[key]) {
      mergedOptions[key] = optionalOptions[key];
    }
  }
  const baseUrl = buildSourceUrl(mergedOptions);
  const {
    clientId,
    maxLengthURL,
    format,
    localCache
  } = mergedOptions;
  const headers = _extends({
    Authorization: `Bearer ${options.accessToken}`
  }, options.headers);
  const parameters = _extends({
    client: clientId
  }, urlParameters);
  const errorContext = {
    requestType: 'Map instantiation',
    connection: options.connectionName,
    type: endpoint,
    source: JSON.stringify(parameters, undefined, 2)
  };
  const mapInstantiation = await requestWithParameters({
    baseUrl,
    parameters,
    headers,
    errorContext,
    maxLengthURL,
    localCache
  });
  const dataUrl = mapInstantiation[format].url[0];
  if (cache) {
    cache.value = parseInt(new URL(dataUrl).searchParams.get('cache') || '', 10);
  }
  errorContext.requestType = 'Map data';
  if (format === 'tilejson') {
    const json = await requestWithParameters({
      baseUrl: dataUrl,
      parameters: {
        client: clientId
      },
      headers,
      errorContext,
      maxLengthURL,
      localCache
    });
    if (accessToken) {
      json.accessToken = accessToken;
    }
    return json;
  }
  return await requestWithParameters({
    baseUrl: dataUrl,
    parameters: {
      client: clientId
    },
    headers,
    errorContext,
    maxLengthURL,
    localCache
  });
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const boundaryQuerySource = async function boundaryQuerySource(options) {
  const {
    columns,
    filters,
    tilesetTableName,
    propertiesSqlQuery,
    queryParameters
  } = options;
  const urlParameters = {
    tilesetTableName,
    propertiesSqlQuery
  };
  if (columns) {
    urlParameters.columns = columns.join(',');
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  if (queryParameters) {
    urlParameters.queryParameters = queryParameters;
  }
  return baseSource('boundary', options, urlParameters);
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const boundaryTableSource = async function boundaryTableSource(options) {
  const {
    filters,
    tilesetTableName,
    columns,
    propertiesTableName
  } = options;
  const urlParameters = {
    tilesetTableName,
    propertiesTableName
  };
  if (columns) {
    urlParameters.columns = columns.join(',');
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('boundary', options, urlParameters);
};

/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Abstract class. Use {@link WidgetQuerySource} or {@link WidgetTableSource}.
 */
class WidgetSource {
  constructor(props) {
    this.props = void 0;
    this.props = _extends({}, WidgetSource.defaultProps, {
      clientId: getClient()
    }, props);
  }
  _getModelSource(filters, filterOwner) {
    const props = this.props;
    return {
      apiVersion: props.apiVersion,
      apiBaseUrl: props.apiBaseUrl,
      clientId: props.clientId,
      accessToken: props.accessToken,
      connectionName: props.connectionName,
      filters: getApplicableFilters(filterOwner, filters || props.filters),
      filtersLogicalOperator: props.filtersLogicalOperator,
      spatialDataType: props.spatialDataType,
      spatialDataColumn: props.spatialDataColumn,
      dataResolution: props.dataResolution
    };
  }
}
/**
 * @todo TODO(v0.5): Remove WidgetBaseSource alias.
 * @deprecated Use WidgetSourceP.
 */
WidgetSource.defaultProps = {
  apiVersion: ApiVersion.V3,
  apiBaseUrl: DEFAULT_API_BASE_URL,
  clientId: getClient(),
  filters: {},
  filtersLogicalOperator: 'and'
};
const WidgetBaseSource = WidgetSource;

/**
 * Return more descriptive error from API
 * @privateRemarks Source: @carto/react-api
 */
function dealWithApiError({
  response,
  data
}) {
  var _data$error, _data$error2;
  if (data.error === 'Column not found') {
    throw new InvalidColumnError(`${data.error} ${data.column_name}`);
  }
  if (typeof data.error === 'string' && (_data$error = data.error) != null && _data$error.includes('Missing columns')) {
    throw new InvalidColumnError(data.error);
  }
  switch (response.status) {
    case 401:
      throw new Error('Unauthorized access. Invalid credentials');
    case 403:
      throw new Error('Forbidden access to the requested data');
    default:
      throw new Error(data && data.error && typeof data.error === 'string' ? data.error : JSON.stringify((data == null ? void 0 : data.hint) || ((_data$error2 = data.error) == null ? void 0 : _data$error2[0])));
  }
}
/** @privateRemarks Source: @carto/react-api */
async function makeCall({
  url,
  accessToken,
  opts
}) {
  let response;
  let data;
  const isPost = (opts == null ? void 0 : opts.method) === 'POST';
  try {
    response = await fetch(url.toString(), _extends({
      headers: _extends({
        Authorization: `Bearer ${accessToken}`
      }, isPost && {
        'Content-Type': 'application/json'
      }, opts.headers)
    }, isPost && {
      method: opts == null ? void 0 : opts.method,
      body: opts == null ? void 0 : opts.body
    }, {
      signal: opts == null ? void 0 : opts.signal
    }, opts == null ? void 0 : opts.otherOptions));
    data = await response.json();
  } catch (error) {
    if (error.name === 'AbortError') throw error;
    throw new Error(`Failed request: ${error}`);
  }
  if (!response.ok) {
    dealWithApiError({
      response,
      data
    });
  }
  return data;
}

/** @privateRemarks Source: @carto/react-api */
const AVAILABLE_MODELS = ['category', 'histogram', 'formula', 'pick', 'timeseries', 'range', 'scatterplot', 'table'];
const {
  V3
} = ApiVersion;
const REQUEST_GET_MAX_URL_LENGTH = 2048;
/**
 * Execute a SQL model request.
 * @privateRemarks Source: @carto/react-api
 */
function executeModel(props) {
  assert(props.source, 'executeModel: missing source');
  assert(props.model, 'executeModel: missing model');
  assert(props.params, 'executeModel: missing params');
  assert(AVAILABLE_MODELS.includes(props.model), `executeModel: model provided isn't valid. Available models: ${AVAILABLE_MODELS.join(', ')}`);
  const {
    model,
    source,
    params,
    opts
  } = props;
  const {
    type,
    apiVersion,
    apiBaseUrl,
    accessToken,
    connectionName,
    clientId
  } = source;
  assert(apiBaseUrl, 'executeModel: missing apiBaseUrl');
  assert(accessToken, 'executeModel: missing accessToken');
  assert(apiVersion === V3, 'executeModel: SQL Model API requires CARTO 3+');
  assert(type !== 'tileset', 'executeModel: Tilesets not supported');
  let url = `${apiBaseUrl}/v3/sql/${connectionName}/model/${model}`;
  const {
    data,
    filters,
    filtersLogicalOperator = 'and',
    spatialDataType = 'geo',
    spatialFiltersMode = 'intersects'
  } = source;
  const queryParams = {
    type,
    client: clientId,
    source: data,
    params,
    queryParameters: source.queryParameters || '',
    filters,
    filtersLogicalOperator
  };
  const spatialDataColumn = source.spatialDataColumn || DEFAULT_GEO_COLUMN;
  // Picking Model API requires 'spatialDataColumn'.
  if (model === 'pick') {
    queryParams.spatialDataColumn = spatialDataColumn;
  }
  // API supports multiple filters, we apply it only to spatialDataColumn
  const spatialFilters = source.spatialFilter ? {
    [spatialDataColumn]: source.spatialFilter
  } : undefined;
  if (spatialFilters) {
    queryParams.spatialFilters = spatialFilters;
    queryParams.spatialDataColumn = spatialDataColumn;
    queryParams.spatialDataType = spatialDataType;
  }
  if (spatialDataType !== 'geo') {
    queryParams.spatialFiltersMode = spatialFiltersMode;
  }
  const urlWithSearchParams = url + '?' + objectToURLSearchParams(queryParams).toString();
  const isGet = urlWithSearchParams.length <= REQUEST_GET_MAX_URL_LENGTH;
  if (isGet) {
    url = urlWithSearchParams;
  }
  return makeCall({
    url,
    accessToken: source.accessToken,
    opts: _extends({}, opts, {
      method: isGet ? 'GET' : 'POST'
    }, !isGet && {
      body: JSON.stringify(queryParams)
    })
  });
}
function objectToURLSearchParams(object) {
  const params = new URLSearchParams();
  for (const key in object) {
    if (isPureObject(object[key])) {
      params.append(key, JSON.stringify(object[key]));
    } else if (Array.isArray(object[key])) {
      params.append(key, JSON.stringify(object[key]));
    } else if (object[key] === null) {
      params.append(key, 'null');
    } else if (object[key] !== undefined) {
      params.append(key, String(object[key]));
    }
  }
  return params;
}

const _excluded = ["signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded2 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded3 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode", "operationExp"],
  _excluded4 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded5 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded6 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded7 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"],
  _excluded8 = ["abortController", "signal", "filters", "filterOwner", "spatialFilter", "spatialFiltersMode"];
/**
 * Source for Widget API requests.
 *
 * Abstract class. Use {@link WidgetQuerySource} or {@link WidgetTableSource}.
 */
class WidgetRemoteSource extends WidgetSource {
  async getCategories(options) {
    const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded);
    const {
      column,
      operation,
      operationColumn
    } = params;
    return executeModel({
      model: 'category',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column,
        operation,
        operationColumn: operationColumn || column
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => normalizeObjectKeys(res.rows));
  }
  async getFeatures(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded2);
    const {
      columns,
      dataType,
      featureIds,
      z,
      limit,
      tileResolution
    } = params;
    return executeModel({
      model: 'pick',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        columns,
        dataType,
        featureIds,
        z,
        limit: limit || 1000,
        tileResolution: tileResolution || DEFAULT_TILE_RESOLUTION
      },
      opts: {
        signal,
        headers: this.props.headers
      }
      // Avoid `normalizeObjectKeys()`, which changes column names.
    }).then(({
      rows
    }) => ({
      rows
    }));
  }
  async getFormula(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        operationExp
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded3);
    const {
      column,
      operation
    } = params;
    return executeModel({
      model: 'formula',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column: column != null ? column : '*',
        operation: operation != null ? operation : 'count',
        operationExp
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => normalizeObjectKeys(res.rows[0]));
  }
  async getHistogram(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded4);
    const {
      column,
      operation,
      ticks
    } = params;
    const data = await executeModel({
      model: 'histogram',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column,
        operation,
        ticks
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => normalizeObjectKeys(res.rows));
    if (data.length) {
      // Given N ticks the API returns up to N+1 bins, omitting any empty bins. Bins
      // include 1 bin below the lowest tick, N-1 between ticks, and 1 bin above the highest tick.
      const result = Array(ticks.length + 1).fill(0);
      data.forEach(({
        tick,
        value
      }) => result[tick] = value);
      return result;
    }
    return [];
  }
  async getRange(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded5);
    const {
      column
    } = params;
    return executeModel({
      model: 'range',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => normalizeObjectKeys(res.rows[0]));
  }
  async getScatter(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded6);
    const {
      xAxisColumn,
      xAxisJoinOperation,
      yAxisColumn,
      yAxisJoinOperation
    } = params;
    // Make sure this is sync with the same constant in cloud-native/maps-api
    const HARD_LIMIT = 500;
    return executeModel({
      model: 'scatterplot',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        xAxisColumn,
        xAxisJoinOperation,
        yAxisColumn,
        yAxisJoinOperation,
        limit: HARD_LIMIT
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => normalizeObjectKeys(res.rows)).then(res => res.map(({
      x,
      y
    }) => [x, y]));
  }
  async getTable(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded7);
    const {
      columns,
      sortBy,
      sortDirection,
      offset = 0,
      limit = 10
    } = params;
    return executeModel({
      model: 'table',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column: columns,
        sortBy,
        sortDirection,
        limit,
        offset
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => {
      var _res$rows, _res$metadata$total, _res$metadata, _res$METADATA;
      return {
        // Avoid `normalizeObjectKeys()`, which changes column names.
        rows: (_res$rows = res.rows) != null ? _res$rows : res.ROWS,
        totalCount: (_res$metadata$total = (_res$metadata = res.metadata) == null ? void 0 : _res$metadata.total) != null ? _res$metadata$total : (_res$METADATA = res.METADATA) == null ? void 0 : _res$METADATA.TOTAL
      };
    });
  }
  async getTimeSeries(options) {
    const {
        abortController,
        signal = abortController == null ? void 0 : abortController.signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode
      } = options,
      params = _objectWithoutPropertiesLoose(options, _excluded8);
    const {
      column,
      operationColumn,
      joinOperation,
      operation,
      stepSize,
      stepMultiplier,
      splitByCategory,
      splitByCategoryLimit,
      splitByCategoryValues
    } = params;
    return executeModel({
      model: 'timeseries',
      source: _extends({}, this.getModelSource(filters, filterOwner), {
        spatialFiltersMode,
        spatialFilter
      }),
      params: {
        column,
        stepSize,
        stepMultiplier,
        operationColumn: operationColumn || column,
        joinOperation,
        operation,
        splitByCategory,
        splitByCategoryLimit,
        splitByCategoryValues
      },
      opts: {
        signal,
        headers: this.props.headers
      }
    }).then(res => {
      var _res$metadata2;
      return {
        rows: normalizeObjectKeys(res.rows),
        categories: (_res$metadata2 = res.metadata) == null ? void 0 : _res$metadata2.categories
      };
    });
  }
}

/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorQuerySource}, {@link h3QuerySource}, or {@link quadbinQuerySource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorQuerySource } from '@carto/api-client';
 *
 * const data = vectorQuerySource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   sqlQuery: 'SELECT * FROM carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
class WidgetQuerySource extends WidgetRemoteSource {
  getModelSource(filters, filterOwner) {
    return _extends({}, super._getModelSource(filters, filterOwner), {
      type: 'query',
      data: this.props.sqlQuery,
      queryParameters: this.props.queryParameters
    });
  }
}

/**
 * Source for Widget API requests on a data source defined as a table.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTableSource}, {@link h3TableSource}, or {@link quadbinTableSource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTableSource } from '@carto/api-client';
 *
 * const data = vectorTableSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
class WidgetTableSource extends WidgetRemoteSource {
  getModelSource(filters, filterOwner) {
    return _extends({}, super._getModelSource(filters, filterOwner), {
      type: 'table',
      data: this.props.tableName
    });
  }
}

/** @privateRemarks Source: @carto/react-core */
const aggregationFunctions = {
  count: values => values.length,
  min: (...args) => applyAggregationFunction(min, ...args),
  max: (...args) => applyAggregationFunction(max, ...args),
  sum: (...args) => applyAggregationFunction(sum, ...args),
  avg: (...args) => applyAggregationFunction(avg, ...args)
};
/** @privateRemarks Source: @carto/react-core */
function aggregate(feature, keys, operation) {
  if (!(keys != null && keys.length)) {
    throw new Error('Cannot aggregate a feature without having keys');
  } else if (keys.length === 1) {
    const value = feature[keys[0]];
    return isPotentiallyValidNumber(value) ? Number(value) : value;
  }
  const aggregationFn = aggregationFunctions[operation];
  if (!aggregationFn) {
    throw new Error(`${operation} isn't a valid aggregation function`);
  }
  return aggregationFn(keys.map(column => {
    const value = feature[column];
    return isPotentiallyValidNumber(value) ? Number(value) : value;
  }));
}
/*
 * Forced casting to Number (just of non empty strings) allows to work-around
 * some specific situations, where a big numeric field is transformed into a string when generating the tileset(eg.PG)
 */
function isPotentiallyValidNumber(value) {
  return typeof value === 'string' && value.trim().length > 0;
}
const applyAggregationFunction = (aggFn, values, keys, operation) => {
  const normalizedKeys = normalizeKeys(keys);
  const elements = ((normalizedKeys == null ? void 0 : normalizedKeys.length) || 0) <= 1 ? filterFalsyElements(values, normalizedKeys || []) : values;
  return aggFn(elements, keys, operation);
};
function filterFalsyElements(values, keys) {
  const filterFn = value => value !== null && value !== undefined;
  if (!(keys != null && keys.length)) {
    return values.filter(filterFn);
  }
  return values.filter(v => filterFn(v[keys[0]]));
}
// Aggregation functions
function avg(values, keys, joinOperation) {
  return sum(values, keys, joinOperation) / (values.length || 1);
}
function sum(values, keys, joinOperation) {
  const normalizedKeys = normalizeKeys(keys);
  if (normalizedKeys) {
    return values.reduce((a, b) => a + aggregate(b, normalizedKeys, joinOperation), 0);
  }
  return values.reduce((a, b) => a + b, 0);
}
function min(values, keys, joinOperation) {
  const normalizedKeys = normalizeKeys(keys);
  if (normalizedKeys) {
    return values.reduce((a, b) => Math.min(a, aggregate(b, normalizedKeys, joinOperation)), Infinity);
  }
  return Math.min(...values);
}
function max(values, keys, joinOperation) {
  const normalizedKeys = normalizeKeys(keys);
  if (normalizedKeys) {
    return values.reduce((a, b) => Math.max(a, aggregate(b, normalizedKeys, joinOperation)), -Infinity);
  }
  return Math.max(...values);
}
// Aux
// Keys can come as a string (one column) or a strings array (multiple column)
// Use always an array to make the code easier
function normalizeKeys(keys) {
  return Array.isArray(keys) ? keys : typeof keys === 'string' ? [keys] : undefined;
}

/***
   Copyright 2013 Teun Duynstee

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
var thenBy_module = function () {
  function identity(v) {
    return v;
  }
  function ignoreCase(v) {
    return typeof v === "string" ? v.toLowerCase() : v;
  }
  function makeCompareFunction(f, opt) {
    opt = typeof opt === "object" ? opt : {
      direction: opt
    };
    if (typeof f != "function") {
      var prop = f;
      // make unary function
      f = function (v1) {
        return !!v1[prop] ? v1[prop] : "";
      };
    }
    if (f.length === 1) {
      // f is a unary function mapping a single item to its sort score
      var uf = f;
      var preprocess = opt.ignoreCase ? ignoreCase : identity;
      var cmp = opt.cmp || function (v1, v2) {
        return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;
      };
      f = function (v1, v2) {
        return cmp(preprocess(uf(v1)), preprocess(uf(v2)));
      };
    }
    const descTokens = {
      "-1": '',
      desc: ''
    };
    if (opt.direction in descTokens) return function (v1, v2) {
      return -f(v1, v2);
    };
    return f;
  }

  /* adds a secondary compare function to the target function (`this` context)
     which is applied in case the first one returns 0 (equal)
     returns a new compare function, which has a `thenBy` method as well */
  function tb(func, opt) {
    /* should get value false for the first call. This can be done by calling the 
    exported function, or the firstBy property on it (for es6 module compatibility)
    */
    var x = typeof this == "function" && !this.firstBy ? this : false;
    var y = makeCompareFunction(func, opt);
    var f = x ? function (a, b) {
      return x(a, b) || y(a, b);
    } : y;
    f.thenBy = tb;
    return f;
  }
  tb.firstBy = tb;
  return tb;
}();

/**
 * Apply sort structure to a collection of features
 * @param features
 * @param [sortOptions]
 * @param [sortOptions.sortBy] - One or more columns to sort by
 * @param [sortOptions.sortByDirection] - Direction by the columns will be sorted
 * @param [sortOptions.sortByColumnType] - Column type
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
function applySorting(features, {
  sortBy,
  sortByDirection = 'asc',
  sortByColumnType = 'string'
} = {}) {
  // If sortBy is undefined, pass all features
  if (sortBy === undefined) {
    return features;
  }
  // sortOptions exists, but are bad formatted
  const isValidSortBy = Array.isArray(sortBy) && sortBy.length ||
  // sortBy can be an array of columns
  typeof sortBy === 'string'; // or just one column
  if (!isValidSortBy) {
    throw new Error('Sorting options are bad formatted');
  }
  const sortFn = createSortFn({
    sortBy,
    sortByDirection,
    sortByColumnType: sortByColumnType || 'string'
  });
  return features.sort(sortFn);
}
// Aux
function createSortFn({
  sortBy,
  sortByDirection,
  sortByColumnType
}) {
  const [firstSortOption, ...othersSortOptions] = normalizeSortByOptions({
    sortBy,
    sortByDirection,
    sortByColumnType
  });
  let sortFn = thenBy_module.firstBy(...firstSortOption);
  for (const sortOptions of othersSortOptions) {
    sortFn = sortFn.thenBy(...sortOptions);
  }
  return sortFn;
}
function normalizeSortByOptions({
  sortBy,
  sortByDirection,
  sortByColumnType
}) {
  const numberFormat = sortByColumnType === 'number' && {
    cmp: (a, b) => a - b
  };
  if (!Array.isArray(sortBy)) {
    sortBy = [sortBy];
  }
  return sortBy.map(sortByEl => {
    // sortByEl is 'column'
    if (typeof sortByEl === 'string') {
      return [sortByEl, _extends({
        direction: sortByDirection
      }, numberFormat)];
    }
    if (Array.isArray(sortByEl)) {
      // sortBy is ['column']
      if (sortByEl[1] === undefined) {
        return [sortByEl, _extends({
          direction: sortByDirection
        }, numberFormat)];
      }
      // sortBy is ['column', { ... }]
      if (typeof sortByEl[1] === 'object') {
        const othersSortOptions = numberFormat ? _extends({}, numberFormat, sortByEl[1]) : sortByEl[1];
        return [sortByEl[0], _extends({
          direction: sortByDirection
        }, othersSortOptions)];
      }
    }
    return sortByEl;
  });
}

/** @privateRemarks Source: @carto/react-core */
function groupValuesByColumn({
  data,
  valuesColumns,
  joinOperation,
  keysColumn,
  operation
}) {
  if (Array.isArray(data) && data.length === 0) {
    return null;
  }
  const groups = data.reduce((accumulator, item) => {
    const group = item[keysColumn];
    const values = accumulator.get(group) || [];
    accumulator.set(group, values);
    const aggregatedValue = aggregate(item, valuesColumns, joinOperation);
    const isValid = (operation === 'count' ? true : aggregatedValue !== null) && aggregatedValue !== undefined;
    if (isValid) {
      values.push(aggregatedValue);
      accumulator.set(group, values);
    }
    return accumulator;
  }, new Map()); // We use a map to be able to maintain the type in the key value
  const targetOperation = aggregationFunctions[operation];
  if (targetOperation) {
    return Array.from(groups).map(([name, value]) => ({
      name,
      value: targetOperation(value)
    }));
  }
  return [];
}

/**
 * Returns midnight (local time) on the Monday preceeding a given date, in
 * milliseconds since the UNIX epoch.
 */
/**
 * Returns midnight (UTC) on the Monday preceeding a given date, in
 * milliseconds since the UNIX epoch.
 */
function getUTCMonday(date) {
  const dateCp = new Date(date);
  const day = dateCp.getUTCDay();
  const diff = dateCp.getUTCDate() - day + (day ? 1 : -6); // adjust when day is sunday
  dateCp.setUTCDate(diff);
  return Date.UTC(dateCp.getUTCFullYear(), dateCp.getUTCMonth(), dateCp.getUTCDate());
}

const GROUP_KEY_FN_MAPPING = {
  year: date => Date.UTC(date.getUTCFullYear()),
  month: date => Date.UTC(date.getUTCFullYear(), date.getUTCMonth()),
  week: date => getUTCMonday(date),
  day: date => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()),
  hour: date => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours()),
  minute: date => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()),
  second: date => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds())
};
/** @privateRemarks Source: @carto/react-core */
function groupValuesByDateColumn({
  data,
  valuesColumns,
  joinOperation,
  keysColumn,
  groupType,
  operation
}) {
  if (Array.isArray(data) && data.length === 0) {
    return null;
  }
  const groupKeyFn = GROUP_KEY_FN_MAPPING[groupType];
  if (!groupKeyFn) {
    return null;
  }
  const groups = data.reduce((acc, item) => {
    const value = item[keysColumn];
    const formattedValue = new Date(value);
    const groupKey = groupKeyFn(formattedValue);
    if (!isNaN(groupKey)) {
      let groupedValues = acc.get(groupKey);
      if (!groupedValues) {
        groupedValues = [];
        acc.set(groupKey, groupedValues);
      }
      const aggregatedValue = aggregate(item, valuesColumns, joinOperation);
      const isValid = aggregatedValue !== null && aggregatedValue !== undefined;
      if (isValid) {
        groupedValues.push(aggregatedValue);
        acc.set(groupKey, groupedValues);
      }
    }
    return acc;
  }, new Map());
  const targetOperation = aggregationFunctions[operation];
  return [...groups.entries()].map(([name, value]) => ({
    name,
    value: targetOperation(value)
  })).sort((a, b) => a.name - b.name);
}

/**
 * Histogram computation.
 * @privateRemarks Source: @carto/react-core
 */
function histogram({
  data,
  valuesColumns,
  joinOperation,
  ticks,
  operation
}) {
  if (Array.isArray(data) && data.length === 0) {
    return [];
  }
  const binsContainer = [Number.MIN_SAFE_INTEGER, ...ticks].map((tick, index, arr) => ({
    bin: index,
    start: tick,
    end: index === arr.length - 1 ? Number.MAX_SAFE_INTEGER : arr[index + 1],
    values: []
  }));
  data.forEach(feature => {
    const featureValue = aggregate(feature, valuesColumns, joinOperation);
    const isValid = featureValue !== null && featureValue !== undefined;
    if (!isValid) {
      return;
    }
    const binContainer = binsContainer.find(bin => bin.start <= featureValue && bin.end > featureValue);
    if (!binContainer) {
      return;
    }
    binContainer.values.push(featureValue);
  });
  const targetOperation = aggregationFunctions[operation];
  const transformedBins = binsContainer.map(binContainer => binContainer.values);
  return transformedBins.map(values => values.length ? targetOperation(values) : 0);
}

/**
 * Filters invalid features and formats  data.
 * @privateRemarks Source: @carto/react-core
 */
function scatterPlot({
  data,
  xAxisColumns,
  xAxisJoinOperation,
  yAxisColumns,
  yAxisJoinOperation
}) {
  return data.reduce((acc, feature) => {
    const xValue = aggregate(feature, xAxisColumns, xAxisJoinOperation);
    const xIsValid = xValue !== null && xValue !== undefined;
    const yValue = aggregate(feature, yAxisColumns, yAxisJoinOperation);
    const yIsValid = yValue !== null && yValue !== undefined;
    if (xIsValid && yIsValid) {
      acc.push([xValue, yValue]);
    }
    return acc;
  }, []);
}

/**
 * Source for Widget API requests on a data source defined by a tileset.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTilesetSource}, {@link h3TilesetSource}, or {@link quadbinTilesetSource},
 * which can be shared with map layers. Sources contain a `widgetSource`
 * property, for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTilesetSource } from '@carto/api-client';
 *
 * const data = vectorTilesetSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_rasters.my_tileset_source'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
class WidgetTilesetSource extends WidgetSource {
  constructor(...args) {
    super(...args);
    this._tiles = [];
    this._features = [];
    this._tileFeatureExtractOptions = {};
    this._tileFeatureExtractPreviousInputs = {};
  }
  getModelSource(filters, filterOwner) {
    return _extends({}, super._getModelSource(filters, filterOwner), {
      type: 'tileset',
      data: this.props.tableName
    });
  }
  /**
   * Loads features as a list of tiles (typically provided by deck.gl).
   * After tiles are loaded, {@link extractTileFeatures} must be called
   * before computing statistics on the tiles.
   */
  loadTiles(tiles) {
    this._tiles = tiles;
    this._features.length = 0;
  }
  /** Configures options used to extract features from tiles. */
  setTileFeatureExtractOptions(options) {
    this._tileFeatureExtractOptions = options;
    this._features.length = 0;
  }
  _extractTileFeatures(spatialFilter) {
    // When spatial filter has not changed, don't redo extraction. If tiles or
    // tile extract options change, features will have been cleared already.
    const prevInputs = this._tileFeatureExtractPreviousInputs;
    if (this._features.length && prevInputs.spatialFilter && booleanEqual(prevInputs.spatialFilter, spatialFilter)) {
      return;
    }
    this._features = tileFeatures(_extends({
      tiles: this._tiles,
      tileFormat: this.props.tileFormat
    }, this._tileFeatureExtractOptions, {
      spatialFilter,
      spatialDataColumn: this.props.spatialDataColumn,
      spatialDataType: this.props.spatialDataType
    }));
    prevInputs.spatialFilter = spatialFilter;
  }
  /**
   * Loads features as GeoJSON (used for testing).
   * @experimental
   * @internal Not for public use. Spatial filters in other method calls will be ignored.
   */
  loadGeoJSON({
    geojson,
    spatialFilter
  }) {
    this._features = geojsonFeatures(_extends({
      geojson,
      spatialFilter
    }, this._tileFeatureExtractOptions));
    this._tileFeatureExtractPreviousInputs.spatialFilter = spatialFilter;
  }
  async getFeatures() {
    throw new Error('getFeatures not supported for tilesets');
  }
  async getFormula({
    column = '*',
    operation = 'count',
    joinOperation,
    filters,
    filterOwner,
    spatialFilter
  }) {
    if (operation === 'custom') {
      throw new Error('Custom aggregation not supported for tilesets');
    }
    // Column is required except when operation is 'count'.
    if (column && column !== '*' || operation !== 'count') {
      assertColumn(this._features, column);
    }
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (filteredFeatures.length === 0 && operation !== 'count') {
      return {
        value: null
      };
    }
    const targetOperation = aggregationFunctions[operation];
    return {
      value: targetOperation(filteredFeatures, column, joinOperation)
    };
  }
  async getHistogram({
    operation = 'count',
    ticks,
    column,
    joinOperation,
    filters,
    filterOwner,
    spatialFilter
  }) {
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    assertColumn(this._features, column);
    if (!this._features.length) {
      return [];
    }
    return histogram({
      data: filteredFeatures,
      valuesColumns: normalizeColumns(column),
      joinOperation,
      ticks,
      operation
    });
  }
  async getCategories({
    column,
    operation = 'count',
    operationColumn,
    joinOperation,
    filters,
    filterOwner,
    spatialFilter
  }) {
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (!filteredFeatures.length) {
      return [];
    }
    assertColumn(this._features, column, operationColumn);
    const groups = groupValuesByColumn({
      data: filteredFeatures,
      valuesColumns: normalizeColumns(operationColumn || column),
      joinOperation,
      keysColumn: column,
      operation
    });
    return groups || [];
  }
  async getScatter({
    xAxisColumn,
    yAxisColumn,
    xAxisJoinOperation,
    yAxisJoinOperation,
    filters,
    filterOwner,
    spatialFilter
  }) {
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (!filteredFeatures.length) {
      return [];
    }
    assertColumn(this._features, xAxisColumn, yAxisColumn);
    return scatterPlot({
      data: filteredFeatures,
      xAxisColumns: normalizeColumns(xAxisColumn),
      xAxisJoinOperation,
      yAxisColumns: normalizeColumns(yAxisColumn),
      yAxisJoinOperation
    });
  }
  async getTable({
    columns,
    searchFilterColumn,
    searchFilterText,
    sortBy,
    sortDirection,
    sortByColumnType,
    offset = 0,
    limit = 10,
    filters,
    filterOwner,
    spatialFilter
  }) {
    // Filter.
    let filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (!filteredFeatures.length) {
      return {
        rows: [],
        totalCount: 0
      };
    }
    // Search.
    if (searchFilterColumn && searchFilterText) {
      filteredFeatures = filteredFeatures.filter(row => row[searchFilterColumn] && String(row[searchFilterColumn]).toLowerCase().includes(String(searchFilterText).toLowerCase()));
    }
    // Sort.
    let rows = applySorting(filteredFeatures, {
      sortBy,
      sortByDirection: sortDirection,
      sortByColumnType
    });
    const totalCount = rows.length;
    // Offset and limit.
    rows = rows.slice(Math.min(offset, totalCount), Math.min(offset + limit, totalCount));
    // Select columns.
    rows = rows.map(srcRow => {
      const dstRow = {};
      for (const column of columns) {
        dstRow[column] = srcRow[column];
      }
      return dstRow;
    });
    return {
      rows,
      totalCount
    };
  }
  async getTimeSeries({
    column,
    stepSize,
    operation,
    operationColumn,
    joinOperation,
    filters,
    filterOwner,
    spatialFilter
  }) {
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (!filteredFeatures.length) {
      return {
        rows: []
      };
    }
    assertColumn(this._features, column, operationColumn);
    const rows = groupValuesByDateColumn({
      data: filteredFeatures,
      valuesColumns: normalizeColumns(operationColumn || column),
      keysColumn: column,
      groupType: stepSize,
      operation,
      joinOperation
    }) || [];
    return {
      rows
    };
  }
  async getRange({
    column,
    filters,
    filterOwner,
    spatialFilter
  }) {
    assertColumn(this._features, column);
    const filteredFeatures = this._getFilteredFeatures(spatialFilter, filters, filterOwner);
    if (!this._features.length) {
      // TODO: Is this the only nullable response in the Widgets API? If so,
      // can we do something more consistent?
      return null;
    }
    return {
      min: aggregationFunctions.min(filteredFeatures, column),
      max: aggregationFunctions.max(filteredFeatures, column)
    };
  }
  /****************************************************************************
   * INTERNAL
   */
  _getFilteredFeatures(spatialFilter, filters, filterOwner) {
    assert(spatialFilter, 'spatialFilter required for tilesets');
    this._extractTileFeatures(spatialFilter);
    return applyFilters(this._features, getApplicableFilters(filterOwner, filters || this.props.filters), this.props.filtersLogicalOperator || 'and');
  }
}
function assertColumn(features, ...columnArgs) {
  // TODO(cleanup): Can drop support for multiple column shapes here?
  // Due to the multiple column shape, we normalise it as an array with normalizeColumns
  const columns = Array.from(new Set(columnArgs.map(normalizeColumns).flat()));
  const featureKeys = Object.keys(features[0]);
  const invalidColumns = columns.filter(column => !featureKeys.includes(column));
  if (invalidColumns.length) {
    throw new InvalidColumnError(`Missing column(s): ${invalidColumns.join(', ')}`);
  }
}
function normalizeColumns(columns) {
  return Array.isArray(columns) ? columns : typeof columns === 'string' ? [columns] : [];
}

const h3QuerySource = async function h3QuerySource(options) {
  const {
    aggregationExp,
    aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
    sqlQuery,
    spatialDataColumn = 'h3',
    queryParameters,
    filters
  } = options;
  const spatialDataType = 'h3';
  const urlParameters = {
    aggregationExp,
    spatialDataColumn,
    spatialDataType,
    q: sqlQuery
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (queryParameters) {
    urlParameters.queryParameters = queryParameters;
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('query', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetQuerySource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType
    }))
  }));
};

const h3TableSource = async function h3TableSource(options) {
  const {
    aggregationExp,
    aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
    spatialDataColumn = 'h3',
    tableName,
    filters
  } = options;
  const spatialDataType = 'h3';
  const urlParameters = {
    aggregationExp,
    name: tableName,
    spatialDataColumn,
    spatialDataType
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('table', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetTableSource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType
    }))
  }));
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const h3TilesetSource = async function h3TilesetSource(options) {
  const {
    tableName
  } = options;
  const urlParameters = {
    name: tableName
  };
  return baseSource('tileset', options, urlParameters);
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const rasterSource = async function rasterSource(options) {
  const {
    tableName,
    filters
  } = options;
  const urlParameters = {
    name: tableName
  };
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('raster', options, urlParameters);
};

const quadbinQuerySource = async function quadbinQuerySource(options) {
  const {
    aggregationExp,
    aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
    sqlQuery,
    spatialDataColumn = 'quadbin',
    queryParameters,
    filters
  } = options;
  const spatialDataType = 'quadbin';
  const urlParameters = {
    aggregationExp,
    q: sqlQuery,
    spatialDataColumn,
    spatialDataType
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (queryParameters) {
    urlParameters.queryParameters = queryParameters;
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('query', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetQuerySource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType
    }))
  }));
};

const quadbinTableSource = async function quadbinTableSource(options) {
  const {
    aggregationExp,
    aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
    spatialDataColumn = 'quadbin',
    tableName,
    filters
  } = options;
  const spatialDataType = 'quadbin';
  const urlParameters = {
    aggregationExp,
    name: tableName,
    spatialDataColumn,
    spatialDataType
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  return baseSource('table', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetTableSource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType
    }))
  }));
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const quadbinTilesetSource = async function quadbinTilesetSource(options) {
  const {
    tableName
  } = options;
  const urlParameters = {
    name: tableName
  };
  return baseSource('tileset', options, urlParameters);
};

const vectorQuerySource = async function vectorQuerySource(options) {
  const {
    columns,
    filters,
    spatialDataColumn = DEFAULT_GEO_COLUMN,
    sqlQuery,
    tileResolution = DEFAULT_TILE_RESOLUTION,
    queryParameters,
    aggregationExp
  } = options;
  const spatialDataType = 'geo';
  const urlParameters = {
    spatialDataColumn,
    spatialDataType,
    tileResolution: tileResolution.toString(),
    q: sqlQuery
  };
  if (columns) {
    urlParameters.columns = columns.join(',');
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  if (queryParameters) {
    urlParameters.queryParameters = queryParameters;
  }
  if (aggregationExp) {
    urlParameters.aggregationExp = aggregationExp;
  }
  return baseSource('query', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetQuerySource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType,
      tileResolution
    }))
  }));
};

const vectorTableSource = async function vectorTableSource(options) {
  const {
    columns,
    filters,
    spatialDataColumn = DEFAULT_GEO_COLUMN,
    tableName,
    tileResolution = DEFAULT_TILE_RESOLUTION,
    aggregationExp
  } = options;
  const spatialDataType = 'geo';
  const urlParameters = {
    name: tableName,
    spatialDataColumn,
    spatialDataType,
    tileResolution: tileResolution.toString()
  };
  if (columns) {
    urlParameters.columns = columns.join(',');
  }
  if (filters) {
    urlParameters.filters = filters;
  }
  if (aggregationExp) {
    urlParameters.aggregationExp = aggregationExp;
  }
  return baseSource('table', options, urlParameters).then(result => _extends({}, result, {
    widgetSource: new WidgetTableSource(_extends({}, options, {
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType,
      tileResolution
    }))
  }));
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const vectorTilesetSource = async function vectorTilesetSource(options) {
  const {
    tableName
  } = options;
  const urlParameters = {
    name: tableName
  };
  return baseSource('tileset', options, urlParameters);
};

const query = async function query(options) {
  const {
    apiBaseUrl = SOURCE_DEFAULTS.apiBaseUrl,
    maxLengthURL = SOURCE_DEFAULTS.maxLengthURL,
    clientId = getClient(),
    localCache,
    connectionName,
    sqlQuery,
    queryParameters
  } = options;
  const urlParameters = {
    q: sqlQuery
  };
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  const baseUrl = buildQueryUrl({
    apiBaseUrl,
    connectionName
  });
  const headers = _extends({
    Authorization: `Bearer ${options.accessToken}`
  }, options.headers);
  const parameters = _extends({
    client: clientId
  }, urlParameters);
  const errorContext = {
    requestType: 'SQL',
    connection: options.connectionName,
    type: 'query',
    source: JSON.stringify(parameters, undefined, 2)
  };
  return await requestWithParameters({
    baseUrl,
    parameters,
    headers,
    errorContext,
    maxLengthURL,
    localCache
  });
};

// Default tile display size in deck.gl, in viewport pixels. May differ
// from size or resolution assumed when generating the tile data,
const DEFAULT_TILE_SIZE = 512;
// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)
const BIAS = 2;
/**
 * Resolution conversion function. Takes a WebMercatorViewport and returns
 * a H3 resolution such that the screen space size of the hexagons is
 * "similar" to the given tileSize on screen. Intended for use with deck.gl.
 * @internal
 * @privateRemarks Source: https://github.com/visgl/deck.gl/blob/master/modules/carto/src/layers/h3-tileset-2d.ts
 */
function _getHexagonResolution(viewport, tileSize) {
  // Difference in given tile size compared to deck's internal 512px tile size,
  // expressed as an offset to the viewport zoom.
  const zoomOffset = Math.log2(tileSize / DEFAULT_TILE_SIZE);
  const hexagonScaleFactor = 2 / 3 * (viewport.zoom - zoomOffset);
  const latitudeScaleFactor = Math.log(1 / Math.cos(Math.PI * viewport.latitude / 180));
  // Clip and bias
  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));
}

export { ApiVersion, CartoAPIError, DEFAULT_API_BASE_URL, FEATURE_GEOM_PROPERTY, FilterType, Provider, SOURCE_DEFAULTS, SpatialIndex, TileFormat, WidgetBaseSource, WidgetQuerySource, WidgetRemoteSource, WidgetSource, WidgetTableSource, WidgetTilesetSource, _buildFeatureFilter, _getHexagonResolution, addFilter, aggregate, aggregationFunctions, applyFilters, applySorting, boundaryQuerySource, boundaryTableSource, buildBinaryFeatureFilter, buildPublicMapUrl, buildStatsUrl, clearFilters, createPolygonSpatialFilter, createViewportSpatialFilter, filterFunctions, geojsonFeatures, getClient, getDataFilterExtensionProps, getFilter, groupValuesByColumn, groupValuesByDateColumn, h3QuerySource, h3TableSource, h3TilesetSource, hasFilter, histogram, makeIntervalComplete, quadbinQuerySource, quadbinTableSource, quadbinTilesetSource, query, rasterSource, removeFilter, requestWithParameters, scatterPlot, setClient, tileFeatures, tileFeaturesGeometries, tileFeaturesSpatialIndex, transformToTileCoords, vectorQuerySource, vectorTableSource, vectorTilesetSource };
//# sourceMappingURL=api-client.modern.js.map
