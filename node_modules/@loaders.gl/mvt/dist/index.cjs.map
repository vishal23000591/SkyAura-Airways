{
  "version": 3,
  "sources": ["index.js", "lib/get-schemas-from-tilejson.js", "lib/parse-tilejson.js", "tilejson-loader.js", "lib/parse-mvt.js", "lib/utils/geometry-utils.js", "lib/vector-tile/vector-tile-feature.js", "lib/vector-tile/vector-tile-layer.js", "lib/vector-tile/vector-tile.js", "mvt-loader.js", "mvt-source.js", "table-tile-source.js", "lib/vector-tiler/proto-tile.js", "lib/vector-tiler/transform-tile.js", "lib/vector-tiler/tile-to-geojson.js", "lib/vector-tiler/features/proto-feature.js", "lib/vector-tiler/features/simplify-path.js", "lib/vector-tiler/features/convert-feature.js", "lib/vector-tiler/features/clip-features.js", "lib/vector-tiler/features/wrap-features.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TileJSONLoader\nexport { TileJSONLoader } from \"./tilejson-loader.js\";\n// MVTLoader\nexport { MVTLoader, MVTWorkerLoader } from \"./mvt-loader.js\";\n// MVTSource\nexport { MVTSource } from \"./mvt-source.js\";\n// TableTileSource (dynamically tiles a table)\nexport { TableTileSource } from \"./table-tile-source.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// LAYERS\nexport function getSchemaFromTileJSONLayer(layer) {\n    const fields = [];\n    if (layer.fields) {\n        for (const field of layer.fields) {\n            fields.push({\n                name: field.name,\n                type: getDataTypeFromTileJSONField(field),\n                metadata: getMetadataFromTileJSONField(field)\n            });\n        }\n    }\n    return {\n        metadata: getMetadataFromTileJSONLayer(layer),\n        fields\n    };\n}\nfunction getMetadataFromTileJSONLayer(layer) {\n    const metadata = {};\n    for (const [key, value] of Object.entries(layer)) {\n        if (key !== 'fields' && value) {\n            metadata[key] = JSON.stringify(value);\n        }\n    }\n    return metadata;\n}\n// FIELDS\nfunction getDataTypeFromTileJSONField(field) {\n    switch (field.type.toLowerCase()) {\n        case 'float32':\n            return 'float32';\n        case 'number':\n        case 'float64':\n            return 'float64';\n        case 'string':\n        case 'utf8':\n            return 'utf8';\n        case 'boolean':\n            return 'bool';\n        default:\n            return 'null';\n    }\n}\nfunction getMetadataFromTileJSONField(field) {\n    const metadata = {};\n    for (const [key, value] of Object.entries(field)) {\n        if (key !== 'name' && value) {\n            metadata[key] = JSON.stringify(value);\n        }\n    }\n    return metadata;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getSchemaFromTileJSONLayer } from \"./get-schemas-from-tilejson.js\";\nconst isObject = (x) => x !== null && typeof x === 'object';\n/**\n * Parse TileJSON from metadata\n * @param jsonMetadata - metadata object\n * @param options - options\n * @returns - parsed TileJSON\n */\n// eslint-disable-next-line complexity\nexport function parseTileJSON(jsonMetadata, options) {\n    if (!jsonMetadata || !isObject(jsonMetadata)) {\n        return null;\n    }\n    let tileJSON = {\n        name: jsonMetadata.name || '',\n        description: jsonMetadata.description || ''\n    };\n    // tippecanoe\n    if (typeof jsonMetadata.generator === 'string') {\n        tileJSON.generator = jsonMetadata.generator;\n    }\n    if (typeof jsonMetadata.generator_options === 'string') {\n        tileJSON.generatorOptions = jsonMetadata.generator_options;\n    }\n    // Tippecanoe emits `antimeridian_adjusted_bounds` instead of `bounds`\n    tileJSON.boundingBox =\n        parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);\n    // TODO - can be undefined - we could set to center of bounds...\n    tileJSON.center = parseCenter(jsonMetadata.center);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);\n    // Look for nested metadata embedded in .json field\n    // TODO - document what source this applies to, when is this needed?\n    if (typeof jsonMetadata?.json === 'string') {\n        // try to parse json\n        try {\n            tileJSON.metaJson = JSON.parse(jsonMetadata.json);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Failed to parse tilejson.json field', error);\n            // do nothing\n        }\n    }\n    // Look for fields in tilestats\n    const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;\n    const tileStatsLayers = parseTilestatsLayers(tilestats, options);\n    const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers); // eslint-disable-line camelcase\n    // TODO - merge in description from tilejson\n    const layers = mergeLayers(tileJSONlayers, tileStatsLayers);\n    tileJSON = {\n        ...tileJSON,\n        layers\n    };\n    if (tileJSON.maxZoom === null && layers.length > 0) {\n        tileJSON.maxZoom = layers[0].maxZoom || null;\n    }\n    if (tileJSON.minZoom === null && layers.length > 0) {\n        tileJSON.minZoom = layers[0].minZoom || null;\n    }\n    return tileJSON;\n}\nfunction parseTileJSONLayers(layers) {\n    // Look for fields in vector_layers\n    if (!Array.isArray(layers)) {\n        return [];\n    }\n    return layers.map((layer) => parseTileJSONLayer(layer));\n}\nfunction parseTileJSONLayer(layer) {\n    const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({\n        name: key,\n        ...attributeTypeToFieldType(String(datatype))\n    }));\n    const layer2 = { ...layer };\n    delete layer2.fields;\n    return {\n        name: layer.id || '',\n        ...layer2,\n        fields\n    };\n}\n/** parse Layers array from tilestats */\nfunction parseTilestatsLayers(tilestats, options) {\n    if (isObject(tilestats) && Array.isArray(tilestats.layers)) {\n        // we are in luck!\n        return tilestats.layers.map((layer) => parseTilestatsForLayer(layer, options));\n    }\n    return [];\n}\nfunction parseTilestatsForLayer(layer, options) {\n    const fields = [];\n    const indexedAttributes = {};\n    const attributes = layer.attributes || [];\n    for (const attribute of attributes) {\n        const name = attribute.attribute;\n        if (typeof name === 'string') {\n            // TODO - code copied from kepler.gl, need sample tilestats files to test\n            if (name.split('|').length > 1) {\n                // indexed field\n                const fname = name.split('|')[0];\n                indexedAttributes[fname] = indexedAttributes[fname] || [];\n                indexedAttributes[fname].push(attribute);\n                // eslint-disable-next-line no-console\n                console.warn('ignoring tilestats indexed field', fname);\n            }\n            else if (!fields[name]) {\n                fields.push(attributeToField(attribute, options));\n            }\n            else {\n                // return (fields[name], attribute);\n            }\n        }\n    }\n    return {\n        name: layer.layer || '',\n        dominantGeometry: layer.geometry,\n        fields\n    };\n}\nfunction mergeLayers(layers, tilestatsLayers) {\n    return layers.map((layer) => {\n        const tilestatsLayer = tilestatsLayers.find((tsLayer) => tsLayer.name === layer.name);\n        const fields = tilestatsLayer?.fields || layer.fields || [];\n        const mergedLayer = {\n            ...layer,\n            ...tilestatsLayer,\n            fields\n        };\n        mergedLayer.schema = getSchemaFromTileJSONLayer(mergedLayer);\n        return mergedLayer;\n    });\n}\n/**\n * bounds should be [minLng, minLat, maxLng, maxLat]\n *`[[w, s], [e, n]]`, indicates the limits of the bounding box using the axis units and order of the specified CRS.\n */\nfunction parseBounds(bounds) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]\n    const result = fromArrayOrString(bounds);\n    // validate bounds\n    if (Array.isArray(result) &&\n        result.length === 4 &&\n        [result[0], result[2]].every(isLng) &&\n        [result[1], result[3]].every(isLat)) {\n        return [\n            [result[0], result[1]],\n            [result[2], result[3]]\n        ];\n    }\n    return undefined;\n}\nfunction parseCenter(center) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [-91.505127,41.615442,14]\n    const result = fromArrayOrString(center);\n    if (Array.isArray(result) &&\n        result.length === 3 &&\n        isLng(result[0]) &&\n        isLat(result[1]) &&\n        isZoom(result[2])) {\n        return result;\n    }\n    return null;\n}\nfunction safeParseFloat(input) {\n    const result = typeof input === 'string' ? parseFloat(input) : typeof input === 'number' ? input : null;\n    return result === null || isNaN(result) ? null : result;\n}\n// https://github.com/mapbox/tilejson-spec/tree/master/2.2.0\nfunction isLat(num) {\n    return Number.isFinite(num) && num <= 90 && num >= -90;\n}\nfunction isLng(num) {\n    return Number.isFinite(num) && num <= 180 && num >= -180;\n}\nfunction isZoom(num) {\n    return Number.isFinite(num) && num >= 0 && num <= 22;\n}\nfunction fromArrayOrString(data) {\n    if (typeof data === 'string') {\n        return data.split(',').map(parseFloat);\n    }\n    else if (Array.isArray(data)) {\n        return data;\n    }\n    return null;\n}\n// possible types https://github.com/mapbox/tippecanoe#modifying-feature-attributes\nconst attrTypeMap = {\n    number: {\n        type: 'float32'\n    },\n    numeric: {\n        type: 'float32'\n    },\n    string: {\n        type: 'utf8'\n    },\n    vachar: {\n        type: 'utf8'\n    },\n    float: {\n        type: 'float32'\n    },\n    int: {\n        type: 'int32'\n    },\n    int4: {\n        type: 'int32'\n    },\n    boolean: {\n        type: 'boolean'\n    },\n    bool: {\n        type: 'boolean'\n    }\n};\nfunction attributeToField(attribute = {}, options) {\n    const fieldTypes = attributeTypeToFieldType(attribute.type);\n    const field = {\n        name: attribute.attribute,\n        // what happens if attribute type is string...\n        // filterProps: getFilterProps(fieldTypes.type, attribute),\n        ...fieldTypes\n    };\n    // attribute: \"_season_peaks_color\"\n    // count: 1000\n    // max: 0.95\n    // min: 0.24375\n    // type: \"number\"\n    if (typeof attribute.min === 'number') {\n        field.min = attribute.min;\n    }\n    if (typeof attribute.max === 'number') {\n        field.max = attribute.max;\n    }\n    if (typeof attribute.count === 'number') {\n        field.uniqueValueCount = attribute.count;\n    }\n    if (attribute.values) {\n        // Too much data? Add option?\n        field.values = attribute.values;\n    }\n    if (field.values && typeof options.maxValues === 'number') {\n        // Too much data? Add option?\n        field.values = field.values?.slice(0, options.maxValues);\n    }\n    return field;\n}\nfunction attributeTypeToFieldType(aType) {\n    const type = aType.toLowerCase();\n    if (!type || !attrTypeMap[type]) {\n        // console.warn(\n        //   `cannot convert attribute type ${type} to loaders.gl data type, use string by default`\n        // );\n    }\n    return attrTypeMap[type] || { type: 'string' };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseTileJSON } from \"./lib/parse-tilejson.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Loader for TileJSON metadata\n */\nexport const TileJSONLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'TileJSON',\n    id: 'tilejson',\n    module: 'pmtiles',\n    version: VERSION,\n    worker: true,\n    extensions: ['json'],\n    mimeTypes: ['application/json'],\n    text: true,\n    options: {\n        tilejson: {\n            maxValues: undefined\n        }\n    },\n    parse: async (arrayBuffer, options) => {\n        const jsonString = new TextDecoder().decode(arrayBuffer);\n        const json = JSON.parse(jsonString);\n        const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };\n        return parseTileJSON(json, tilejsonOptions);\n    },\n    parseTextSync: (text, options) => {\n        const json = JSON.parse(text);\n        const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };\n        return parseTileJSON(json, tilejsonOptions);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport { log } from '@loaders.gl/loader-utils';\nimport Protobuf from 'pbf';\nimport { VectorTile } from \"./vector-tile/vector-tile.js\";\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport function parseMVT(arrayBuffer, options) {\n    const mvtOptions = checkOptions(options);\n    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;\n    switch (shape) {\n        case 'columnar-table': // binary + some JS arrays\n            return { shape: 'columnar-table', data: parseToBinary(arrayBuffer, mvtOptions) };\n        case 'geojson-table': {\n            const table = {\n                shape: 'geojson-table',\n                type: 'FeatureCollection',\n                features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)\n            };\n            return table;\n        }\n        case 'geojson':\n            return parseToGeojsonFeatures(arrayBuffer, mvtOptions);\n        case 'binary-geometry':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        case 'binary':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        default:\n            throw new Error(shape || 'undefined shape');\n    }\n}\nfunction parseToBinary(arrayBuffer, options) {\n    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    binaryData.byteLength = arrayBuffer.byteLength;\n    return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n    const features = [];\n    const geometryInfo = {\n        coordLength: 2,\n        pointPositionsCount: 0,\n        pointFeaturesCount: 0,\n        linePositionsCount: 0,\n        linePathsCount: 0,\n        lineFeaturesCount: 0,\n        polygonPositionsCount: 0,\n        polygonObjectsCount: 0,\n        polygonRingsCount: 0,\n        polygonFeaturesCount: 0\n    };\n    if (arrayBuffer.byteLength <= 0) {\n        return [features, geometryInfo];\n    }\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);\n            const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return [features, geometryInfo];\n}\nfunction parseToGeojsonFeatures(arrayBuffer, options) {\n    if (arrayBuffer.byteLength <= 0) {\n        return [];\n    }\n    const features = [];\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);\n            const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return features;\n}\n/** Check that options are good */\nfunction checkOptions(options) {\n    if (!options?.mvt) {\n        throw new Error('mvt options required');\n    }\n    if (options.mvt?.coordinates === 'wgs84' && !options.mvt.tileIndex) {\n        throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n    }\n    if (options.gis) {\n        log.warn('MVTLoader: \"options.gis\" is deprecated, use \"options.mvt.shape\" instead')();\n    }\n    return options.mvt;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(feature, options, layerName) {\n    const decodedFeature = feature.toGeoJSONFeature(options.coordinates || 'local', options.tileIndex);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty) {\n        decodedFeature.properties ||= {};\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n    const decodedFeature = feature.toBinaryFeature(options.coordinates || 'local', options.tileIndex);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty && decodedFeature.properties) {\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n/**\n * This function projects local coordinates in a\n * [0 - bufferSize, this.extent + bufferSize] range to a\n * [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n * The resulting extent would be 1.\n * @param line\n * @param feature\n */\nexport function convertToLocalCoordinates(coordinates, extent) {\n    if (Array.isArray(coordinates[0])) {\n        for (const subcoords of coordinates) {\n            convertToLocalCoordinates(subcoords, extent);\n        }\n        return;\n    }\n    // Just a point\n    const p = coordinates;\n    p[0] /= extent;\n    p[1] /= extent;\n}\n/**\n * For the binary code path, the feature data is just\n * one big flat array, so we just divide each value\n * @param data\n * @param feature\n */\nexport function convertToLocalCoordinatesFlat(data, extent) {\n    for (let i = 0; i < data.length; ++i) {\n        data[i] /= extent;\n    }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\n */\nexport function projectToLngLat(line, tileIndex, extent) {\n    if (typeof line[0][0] !== 'number') {\n        for (const point of line) {\n            // @ts-expect-error\n            projectToLngLat(point, tileIndex, extent);\n        }\n        return;\n    }\n    const size = extent * Math.pow(2, tileIndex.z);\n    const x0 = extent * tileIndex.x;\n    const y0 = extent * tileIndex.y;\n    for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = ((p[0] + x0) * 360) / size - 180;\n        const y2 = 180 - ((p[1] + y0) * 360) / size;\n        p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n    }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\nexport function projectTileCoordinatesToLngLat(\n  points: number[][],\n  tileIndex: {x: number; y: number; z: number},\n  extent: number\n): void {\n  const {x, y, z} = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n\n  for (const p of points) {\n    p[0] = ((p[0] + x0) * 360) / size - 180;\n    const y2 = 180 - ((p[1] + y0) * 360) / size;\n    p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n */\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function projectToLngLatFlat(data, tileIndex, extent) {\n    const { x, y, z } = tileIndex;\n    const size = extent * Math.pow(2, z);\n    const x0 = extent * x;\n    const y0 = extent * y;\n    for (let j = 0, jl = data.length; j < jl; j += 2) {\n        data[j] = ((data[j] + x0) * 360) / size - 180;\n        const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n        data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n    }\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n    if (len <= 1)\n        return [rings];\n    const polygons = [];\n    let polygon;\n    let ccw;\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0)\n            continue; // eslint-disable-line no-continue\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon)\n                polygons.push(polygon);\n            polygon = [rings[i]];\n        }\n        else if (polygon)\n            polygon.push(rings[i]);\n    }\n    if (polygon)\n        polygons.push(polygon);\n    return polygons;\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRingsFlat(geom) {\n    const len = geom.indices.length;\n    const type = 'Polygon';\n    if (len <= 1) {\n        return {\n            type,\n            data: geom.data,\n            areas: [[getPolygonSignedArea(geom.data)]],\n            indices: [geom.indices]\n        };\n    }\n    const areas = [];\n    const polygons = [];\n    let ringAreas = [];\n    let polygon = [];\n    let ccw;\n    let offset = 0;\n    for (let endIndex, i = 0, startIndex; i < len; i++) {\n        startIndex = geom.indices[i] - offset;\n        endIndex = geom.indices[i + 1] - offset || geom.data.length;\n        const shape = geom.data.slice(startIndex, endIndex);\n        const area = getPolygonSignedArea(shape);\n        if (area === 0) {\n            // This polygon has no area, so remove it from the shape\n            // Remove the section from the data array\n            const before = geom.data.slice(0, startIndex);\n            const after = geom.data.slice(endIndex);\n            geom.data = before.concat(after);\n            // Need to offset any remaining indices as we have\n            // modified the data buffer\n            offset += endIndex - startIndex;\n            // Do not add this index to the output and process next shape\n            continue; // eslint-disable-line no-continue\n        }\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon.length) {\n                areas.push(ringAreas);\n                polygons.push(polygon);\n            }\n            polygon = [startIndex];\n            ringAreas = [area];\n        }\n        else {\n            ringAreas.push(area);\n            polygon.push(startIndex);\n        }\n    }\n    if (ringAreas)\n        areas.push(ringAreas);\n    if (polygon.length)\n        polygons.push(polygon);\n    return { type, areas, indices: polygons, data: geom.data };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { classifyRings, classifyRingsFlat, projectToLngLat, projectToLngLatFlat, convertToLocalCoordinates, convertToLocalCoordinatesFlat } from \"../utils/geometry-utils.js\";\nexport class VectorTileFeature {\n    properties;\n    extent;\n    type;\n    id;\n    _pbf;\n    _geometry;\n    _keys;\n    _values;\n    _geometryInfo;\n    static types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n    // eslint-disable-next-line max-params\n    constructor(pbf, end, extent, keys, values, geometryInfo) {\n        // Public\n        this.properties = {};\n        this.extent = extent;\n        this.type = 0;\n        this.id = null;\n        // Private\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n        // Only used by binary tiles\n        this._geometryInfo = geometryInfo;\n        pbf.readFields(readFeature, this, end);\n    }\n    toGeoJSONFeature(coordinates, tileIndex) {\n        const coords = this.loadGeometry();\n        switch (coordinates) {\n            case 'wgs84':\n                return _toGeoJSONFeature(this, coords, (line) => projectToLngLat(line, tileIndex, this.extent));\n            default:\n                return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);\n        }\n    }\n    /**\n     *\n     * @param options\n     * @returns\n     */\n    toBinaryFeature(coordinates, tileIndex) {\n        const geom = this.loadFlatGeometry();\n        switch (coordinates) {\n            case 'wgs84':\n                return this._toBinaryCoordinates(geom, (coords) => projectToLngLatFlat(coords, tileIndex, this.extent));\n            default:\n                return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);\n        }\n    }\n    /** Read a bounding box from the feature */\n    // eslint-disable-next-line max-statements\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        let x1 = Infinity;\n        let x2 = -Infinity;\n        let y1 = Infinity;\n        let y2 = -Infinity;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1)\n                    x1 = x;\n                if (x > x2)\n                    x2 = x;\n                if (y < y1)\n                    y1 = y;\n                if (y > y2)\n                    y2 = y;\n            }\n            else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return [x1, y1, x2, y2];\n    }\n    // BINARY HELPERS\n    /**\n     *\n     * @param transform\n     * @returns result\n     */\n    _toBinaryCoordinates(geom, transform) {\n        let geometry;\n        // Apply the supplied transformation to data\n        transform(geom.data, this.extent);\n        const coordLength = 2;\n        // eslint-disable-next-line default-case\n        switch (this.type) {\n            case 1: // Point\n                this._geometryInfo.pointFeaturesCount++;\n                this._geometryInfo.pointPositionsCount += geom.indices.length;\n                geometry = { type: 'Point', ...geom };\n                break;\n            case 2: // LineString\n                this._geometryInfo.lineFeaturesCount++;\n                this._geometryInfo.linePathsCount += geom.indices.length;\n                this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n                geometry = { type: 'LineString', ...geom };\n                break;\n            case 3: // Polygon\n                geometry = classifyRingsFlat(geom);\n                // Unlike Point & LineString geom.indices is a 2D array, thanks\n                // to the classifyRings method\n                this._geometryInfo.polygonFeaturesCount++;\n                this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n                for (const indices of geometry.indices) {\n                    this._geometryInfo.polygonRingsCount += indices.length;\n                }\n                this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n                break;\n            default:\n                throw new Error(`Invalid geometry type: ${this.type}`);\n        }\n        const result = { type: 'Feature', geometry, properties: this.properties };\n        if (this.id !== null) {\n            result.id = this.id;\n        }\n        return result;\n    }\n    // GEOJSON HELPER\n    // eslint-disable-next-line complexity, max-statements\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        const lines = [];\n        let line;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            switch (cmd) {\n                case 1:\n                case 2:\n                    x += pbf.readSVarint();\n                    y += pbf.readSVarint();\n                    if (cmd === 1) {\n                        // moveTo\n                        if (line)\n                            lines.push(line);\n                        line = [];\n                    }\n                    if (line)\n                        line.push([x, y]);\n                    break;\n                case 7:\n                    // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                    if (line) {\n                        line.push(line[0].slice()); // closePolygon\n                    }\n                    break;\n                default:\n                    throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        if (line)\n            lines.push(line);\n        return lines;\n    }\n    /**\n     * Expands the protobuf data to an intermediate Flat GeoJSON\n     * data format, which maps closely to the binary data buffers.\n     * It is similar to GeoJSON, but rather than storing the coordinates\n     * in multidimensional arrays, we have a 1D `data` with all the\n     * coordinates, and then index into this using the `indices`\n     * parameter, e.g.\n     *\n     * geometry: {\n     *   type: 'Point', data: [1,2], indices: [0]\n     * }\n     * geometry: {\n     *   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n     * }\n     * geometry: {\n     *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n     * }\n     * Thus the indices member lets us look up the relevant range\n     * from the data array.\n     * The Multi* versions of the above types share the same data\n     * structure, just with multiple elements in the indices array\n     */\n    // eslint-disable-next-line complexity, max-statements\n    loadFlatGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const endPos = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let cmdLen;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        let i = 0;\n        // Note: I attempted to replace the `data` array with a\n        // Float32Array, but performance was worse, both using\n        // `set()` and direct index access. Also, we cannot\n        // know how large the buffer should be, so it would\n        // increase memory usage\n        const indices = []; // Indices where geometries start\n        const data = []; // Flat array of coordinate data\n        while (pbf.pos < endPos) {\n            if (length <= 0) {\n                cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) {\n                    // New line\n                    indices.push(i);\n                }\n                data.push(x, y);\n                i += 2;\n            }\n            else if (cmd === 7) {\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (i > 0) {\n                    const start = indices[indices.length - 1]; // start index of polygon\n                    data.push(data[start], data[start + 1]); // closePolygon\n                    i += 2;\n                }\n            }\n            else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return { data, indices };\n    }\n}\nfunction _toGeoJSONFeature(vtFeature, coords, transform) {\n    let type = VectorTileFeature.types[vtFeature.type];\n    let i;\n    let j;\n    let coordinates;\n    switch (vtFeature.type) {\n        case 1:\n            const points = [];\n            for (i = 0; i < coords.length; i++) {\n                points[i] = coords[i][0];\n            }\n            coordinates = points;\n            transform(coordinates, vtFeature.extent);\n            break;\n        case 2:\n            coordinates = coords;\n            for (i = 0; i < coordinates.length; i++) {\n                transform(coordinates[i], vtFeature.extent);\n            }\n            break;\n        case 3:\n            coordinates = classifyRings(coords);\n            for (i = 0; i < coordinates.length; i++) {\n                for (j = 0; j < coordinates[i].length; j++) {\n                    transform(coordinates[i][j], vtFeature.extent);\n                }\n            }\n            break;\n        default:\n            throw new Error('illegal vector tile type');\n    }\n    if (coordinates.length === 1) {\n        // @ts-expect-error\n        coordinates = coordinates[0];\n    }\n    else {\n        type = `Multi${type}`;\n    }\n    const result = {\n        type: 'Feature',\n        geometry: {\n            type: type,\n            coordinates: coordinates\n        },\n        properties: vtFeature.properties\n    };\n    if (vtFeature.id !== null) {\n        result.properties ||= {};\n        result.properties.id = vtFeature.id;\n    }\n    return result;\n}\n// PBF READER UTILS\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nfunction readFeature(tag, feature, pbf) {\n    if (feature && pbf) {\n        if (tag === 1)\n            feature.id = pbf.readVarint();\n        else if (tag === 2)\n            readTag(pbf, feature);\n        else if (tag === 3)\n            feature.type = pbf.readVarint();\n        else if (tag === 4)\n            feature._geometry = pbf.pos;\n    }\n}\n/**\n *\n * @param pbf\n * @param feature\n */\nfunction readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const key = feature._keys[pbf.readVarint()];\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { VectorTileFeature } from \"./vector-tile-feature.js\";\nexport class VectorTileLayer {\n    version;\n    name;\n    extent;\n    length;\n    _pbf;\n    _keys;\n    _values;\n    _features;\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n        // Private\n        this._pbf = pbf;\n        this._keys = [];\n        this._values = [];\n        this._features = [];\n        pbf.readFields(readLayer, this, end);\n        this.length = this._features.length;\n    }\n    /**\n     * return feature `i` from this layer as a `VectorTileFeature`\n     * @param index\n     * @returns feature\n     */\n    getGeoJSONFeature(i) {\n        if (i < 0 || i >= this._features.length) {\n            throw new Error('feature index out of bounds');\n        }\n        this._pbf.pos = this._features[i];\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    }\n    /**\n     * return binary feature `i` from this layer as a `VectorTileFeature`\n     *\n     * @param index\n     * @param geometryInfo\n     * @returns binary feature\n     */\n    getBinaryFeature(i, geometryInfo) {\n        if (i < 0 || i >= this._features.length) {\n            throw new Error('feature index out of bounds');\n        }\n        this._pbf.pos = this._features[i];\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);\n    }\n}\n/**\n *\n * @param tag\n * @param layer\n * @param pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (layer && pbf) {\n        if (tag === 15)\n            layer.version = pbf.readVarint();\n        else if (tag === 1)\n            layer.name = pbf.readString();\n        else if (tag === 5)\n            layer.extent = pbf.readVarint();\n        else if (tag === 2)\n            layer._features.push(pbf.pos);\n        else if (tag === 3)\n            layer._keys.push(pbf.readString());\n        else if (tag === 4)\n            layer._values.push(readValueMessage(pbf));\n    }\n}\n/**\n *\n * @param pbf\n * @returns value\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n        value =\n            tag === 1\n                ? pbf.readString()\n                : tag === 2\n                    ? pbf.readFloat()\n                    : tag === 3\n                        ? pbf.readDouble()\n                        : tag === 4\n                            ? pbf.readVarint64()\n                            : tag === 5\n                                ? pbf.readVarint()\n                                : tag === 6\n                                    ? pbf.readSVarint()\n                                    : tag === 7\n                                        ? pbf.readBoolean()\n                                        : null;\n    }\n    return value;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport { VectorTileLayer } from \"./vector-tile-layer.js\";\nexport class VectorTile {\n    layers;\n    constructor(pbf, end) {\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n/**\n *\n * @param tag\n * @param layers\n * @param pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        if (pbf) {\n            const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n            if (layer.length && layers) {\n                layers[layer.name] = layer;\n            }\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// import type {MVTOptions} from './lib/types';\nimport { parseMVT } from \"./lib/parse-mvt.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n/**\n * Worker loader for the Mapbox Vector Tile format\n */\nexport const MVTWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Mapbox Vector Tile',\n    id: 'mvt',\n    module: 'mvt',\n    version: VERSION,\n    // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'\n    extensions: ['mvt', 'pbf'],\n    mimeTypes: [\n        // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile\n        'application/vnd.mapbox-vector-tile',\n        'application/x-protobuf'\n        // 'application/octet-stream'\n    ],\n    worker: true,\n    category: 'geometry',\n    options: {\n        mvt: {\n            shape: 'geojson',\n            coordinates: 'local',\n            layerProperty: 'layerName',\n            layers: undefined,\n            tileIndex: undefined\n        }\n    }\n};\n/**\n * Loader for the Mapbox Vector Tile format\n */\nexport const MVTLoader = {\n    ...MVTWorkerLoader,\n    parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),\n    parseSync: parseMVT,\n    binary: true\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getBinaryImageMetadata } from '@loaders.gl/images';\nimport { MVTLoader, TileJSONLoader } from '@loaders.gl/mvt';\n/** Creates an MVTTileSource */\nexport const MVTSource = {\n    name: 'MVT',\n    id: 'mvt',\n    module: 'mvt',\n    version: '0.0.0',\n    extensions: ['mvt'],\n    mimeTypes: ['application/octet-stream'],\n    options: {\n        mvt: {\n        // TODO - add options here\n        }\n    },\n    type: 'mvt',\n    fromUrl: true,\n    fromBlob: false,\n    testURL: (url) => true,\n    createDataSource(url, props) {\n        return new MVTTileSource(url, props);\n    }\n};\n/**\n * MVT data source for Mapbox Vector Tiles v1.\n */\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class MVTTileSource extends DataSource {\n    props;\n    url;\n    metadataUrl = null;\n    data;\n    schema = 'tms';\n    metadata;\n    extension;\n    mimeType = null;\n    constructor(url, props) {\n        super(props);\n        this.props = props;\n        this.url = resolvePath(url);\n        this.metadataUrl = props.mvt?.metadataUrl || `${this.url}/tilejson.json`;\n        this.extension = props.mvt?.extension || '.png';\n        this.data = this.url;\n        this.getTileData = this.getTileData.bind(this);\n        this.metadata = this.getMetadata();\n        if (isURLTemplate(this.url)) {\n            this.schema = 'template';\n        }\n    }\n    // @ts-ignore - Metadata type misalignment\n    async getMetadata() {\n        if (!this.metadataUrl) {\n            return null;\n        }\n        let response;\n        try {\n            // Annoyingly, on CORS errors, fetch doesn't use the response status/ok mechanism but instead throws\n            // CORS errors are common when requesting an unavailable sub resource such as a metadata file or an unavailable tile)\n            response = await this.fetch(this.metadataUrl);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.error(error.message);\n            return null;\n        }\n        if (!response.ok) {\n            // eslint-disable-next-line no-console\n            console.error(response.statusText);\n            return null;\n        }\n        const tileJSON = await response.text();\n        const metadata = TileJSONLoader.parseTextSync?.(tileJSON) || null;\n        // TODO add metadata attributions\n        // metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n        // if (metadata?.mimeType) {\n        //   this.mimeType = metadata?.tileMIMEType;\n        // }\n        return metadata;\n    }\n    getTileMIMEType() {\n        return this.mimeType;\n    }\n    async getTile(parameters) {\n        const { x, y, z } = parameters;\n        const tileUrl = this.getTileURL(x, y, z);\n        const response = await this.fetch(tileUrl);\n        if (!response.ok) {\n            return null;\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        return arrayBuffer;\n    }\n    // Tile Source interface implementation: deck.gl compatible API\n    // TODO - currently only handles image tiles, not vector tiles\n    async getTileData(parameters) {\n        const { x, y, z } = parameters.index;\n        // const metadata = await this.metadata;\n        // mimeType = metadata?.tileMIMEType || 'application/vnd.mapbox-vector-tile';\n        const arrayBuffer = await this.getTile({ x, y, z, layers: [] });\n        if (arrayBuffer === null) {\n            return null;\n        }\n        const imageMetadata = getBinaryImageMetadata(arrayBuffer);\n        this.mimeType =\n            this.mimeType || imageMetadata?.mimeType || 'application/vnd.mapbox-vector-tile';\n        switch (this.mimeType) {\n            case 'application/vnd.mapbox-vector-tile':\n                return await this._parseVectorTile(arrayBuffer, { x, y, z, layers: [] });\n            default:\n                return await this._parseImageTile(arrayBuffer);\n        }\n    }\n    // ImageTileSource interface implementation\n    async getImageTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;\n    }\n    async _parseImageTile(arrayBuffer) {\n        return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n    }\n    // VectorTileSource interface implementation\n    async getVectorTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;\n    }\n    async _parseVectorTile(arrayBuffer, tileParams) {\n        const loadOptions = {\n            shape: 'geojson-table',\n            mvt: {\n                coordinates: 'wgs84',\n                tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.z },\n                ...this.loadOptions?.mvt\n            },\n            ...this.loadOptions\n        };\n        return await MVTLoader.parse(arrayBuffer, loadOptions);\n    }\n    getMetadataUrl() {\n        return this.metadataUrl;\n    }\n    getTileURL(x, y, z) {\n        switch (this.schema) {\n            case 'xyz':\n                return `${this.url}/${x}/${y}/${z}${this.extension}`;\n            case 'tms':\n                return `${this.url}/${z}/${x}/${y}${this.extension}`;\n            case 'template':\n                return getURLFromTemplate(this.url, x, y, z, '0');\n            default:\n                throw new Error(this.schema);\n        }\n    }\n}\nexport function isURLTemplate(s) {\n    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);\n}\nconst xRegex = new RegExp('{x}', 'g');\nconst yRegex = new RegExp('{y}', 'g');\nconst zRegex = new RegExp('{z}', 'g');\n/**\n * Get a URL from a URL template\n * @note copied from deck.gl/modules/geo-layers/src/tileset-2d/utils.ts\n * @param template - URL template\n * @param x - tile x coordinate\n * @param y - tile y coordinate\n * @param z - tile z coordinate\n * @param id - tile id\n * @returns URL\n */\nexport function getURLFromTemplate(template, x, y, z, id = '0') {\n    if (Array.isArray(template)) {\n        const i = stringHash(id) % template.length;\n        template = template[i];\n    }\n    let url = template;\n    url = url.replace(xRegex, String(x));\n    url = url.replace(yRegex, String(y));\n    url = url.replace(zRegex, String(z));\n    // Back-compatible support for {-y}\n    if (Number.isInteger(y) && Number.isInteger(z)) {\n        url = url.replace(/\\{-y\\}/g, String(Math.pow(2, z) - y - 1));\n    }\n    return url;\n}\nfunction stringHash(s) {\n    return Math.abs(s.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0));\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright (c) vis.gl contributors\n// Based on https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { log } from '@loaders.gl/loader-utils';\nimport { deduceTableSchema } from '@loaders.gl/schema';\nimport { Stats, Stat } from '@probe.gl/stats';\nimport { createProtoTile } from \"./lib/vector-tiler/proto-tile.js\";\nimport { transformTile } from \"./lib/vector-tiler/transform-tile.js\"; // coordinate transformation\nimport { convertTileToGeoJSON } from \"./lib/vector-tiler/tile-to-geojson.js\"; // tile clipping and wrapping\nimport { convertFeaturesToProtoFeature } from \"./lib/vector-tiler/features/convert-feature.js\";\nimport { clipFeatures } from \"./lib/vector-tiler/features/clip-features.js\"; // stripe clipping algorithm\nimport { wrapFeatures } from \"./lib/vector-tiler/features/wrap-features.js\"; // date line processing\n/** Options to configure tiling */\nexport const TableTileSource = {\n    name: 'TableTiler',\n    id: 'table-tiler',\n    version: '0.0.0',\n    extensions: ['mvt'],\n    mimeTypes: ['application/octet-stream'],\n    options: {\n        table: {\n            coordinates: 'local',\n            promoteId: undefined,\n            maxZoom: 14,\n            indexMaxZoom: 5,\n            maxPointsPerTile: 10000,\n            tolerance: 3,\n            extent: 4096,\n            buffer: 64,\n            generateId: undefined\n        }\n    },\n    type: 'table',\n    testURL: (url) => url.endsWith('.geojson'),\n    createDataSource(url, options) {\n        const needsLoading = typeof url === 'string' || url instanceof Blob;\n        const loader = options?.table?.loaders?.[0];\n        const tablePromise = needsLoading ? loadTable(url, loader) : url;\n        return new DynamicVectorTileSource(tablePromise, options);\n    }\n    // @ts-expect-error\n};\nasync function loadTable(url, loader) {\n    if (typeof url === 'string') {\n        const response = await fetch(url);\n        const data = await response.arrayBuffer();\n        return (await loader.parse(data));\n    }\n    const data = await url.arrayBuffer();\n    return (await loader.parse(data)); //  options.loaders, options.loadOptions)\n}\n/**\n * Dynamically vector tiles a table (the table needs a geometry column)\n * - Tiles are generated when requested.\n * - Each tile contains a tables of clipped features.\n *\n * @note - Currently only accepts `GeoJSONTable` tables\n * @note - Currently only outputs `GeoJSONTable`\n * @note - (can be initialized with a promise that resolves to GeoJSONTable).\n *\n * @todo - metadata should scan all rows to determine schema\n * @todo - metadata scan all rows to determine tilestats (field values[] etc).\n * @todo - handle binary input tables\n * @todo - generate binary output tables\n * @todo - how does TileSourceLayer specify coordinates / decided which layer to render with\n */\nexport class DynamicVectorTileSource {\n    /** Global stats for all DynamicVectorTileSources */\n    static stats = new Stats({\n        id: 'table-tile-source-all',\n        stats: [new Stat('count', 'tiles'), new Stat('count', 'features')]\n    });\n    /** Stats for this DynamicVectorTileSource */\n    stats = new Stats({\n        id: 'table-tile-source',\n        stats: [new Stat('tiles', 'count'), new Stat('features', 'count')]\n    });\n    /** MIME type of the tiles emitted by this tile source */\n    mimeType = 'application/vnd.mapbox-vector-tile';\n    localCoordinates = true;\n    /** The props that this tile source was created with */\n    // @ts-expect-error\n    props;\n    /* Schema of the data */\n    schema = null;\n    /** Map of generated tiles, indexed by stringified tile coordinates */\n    tiles = {};\n    /** Array of tile coordinates */\n    tileCoords = [];\n    /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */\n    ready;\n    /** Metadata for the tile source (generated TileJSON/tilestats */\n    metadata;\n    constructor(table, props) {\n        // @ts-expect-error\n        this.props = { ...TableTileSource.options.table, ...props?.table };\n        this.getTileData = this.getTileData.bind(this);\n        this.ready = this.initializeTilesAsync(table);\n        this.metadata = this.getMetadata();\n    }\n    async initializeTilesAsync(tablePromise) {\n        const table = await tablePromise;\n        this.schema = deduceTableSchema(table);\n        this.createRootTiles(table);\n    }\n    async getMetadata() {\n        await this.ready;\n        return { schema: this.schema, minZoom: 0, maxZoom: this.props.maxZoom };\n    }\n    async getSchema() {\n        await this.ready;\n        return this.schema;\n    }\n    /**\n     * Get a tile at the specified index\n     * @param tileIndex z, x, y of tile\n     * @returns\n     */\n    async getVectorTile(tileIndex) {\n        await this.ready;\n        const table = this.getTileSync(tileIndex);\n        log.info(2, 'getVectorTile', tileIndex, table)();\n        return table;\n    }\n    async getTile(tileIndex) {\n        await this.ready;\n        return this.getTileSync(tileIndex);\n    }\n    async getTileData(tileParams) {\n        const { x, y, z } = tileParams.index;\n        const tile = await this.getVectorTile({ x, y, z });\n        return tile?.features || [];\n    }\n    // Implementation\n    /**\n     * Synchronously request a tile\n     * @note Application must await `source.ready` before calling sync methods.\n     */\n    getTileSync(tileIndex) {\n        const protoTile = this.getProtoTile(tileIndex);\n        if (!protoTile) {\n            return null;\n        }\n        return convertTileToGeoJSON(protoTile, {\n            coordinates: this.props.coordinates,\n            tileIndex,\n            extent: this.props.extent\n        });\n    }\n    /**\n     * Create the initial tiles\n     * @note the tiles stores all the features together with additional data\n     */\n    createRootTiles(table) {\n        if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {\n            throw new Error('maxZoom should be in the 0-24 range');\n        }\n        if (this.props.promoteId && this.props.generateId) {\n            throw new Error('promoteId and generateId cannot be used together.');\n        }\n        log.log(1, 'DynamicVectorTileSource creating root tiles', this.props)();\n        // projects and adds simplification info\n        log.time(1, 'preprocess table')();\n        let features = convertFeaturesToProtoFeature(table, this.props);\n        log.timeEnd(1, 'preprocess table')();\n        // wraps features (ie extreme west and extreme east)\n        log.time(1, 'generate tiles')();\n        features = wrapFeatures(features, this.props);\n        // start slicing from the top tile down\n        if (features.length === 0) {\n            log.log(1, 'DynamicVectorTileSource: no features generated')();\n            return;\n        }\n        this.splitTile(features, 0, 0, 0);\n        const rootTile = this.tiles[0];\n        log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();\n        log.timeEnd(1, 'generate tiles')();\n        log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get('total').count}`, this.stats)();\n    }\n    /**\n     * Return geojsonvt-style \"half formed\" vector tile\n     * @note Application must await `source.ready` before calling sync methods.\n     */\n    // eslint-disable-next-line complexity, max-statements\n    getProtoTile(tileIndex) {\n        const { z, y } = tileIndex;\n        let { x } = tileIndex;\n        // z = +z;\n        // x = +x;\n        // y = +y;\n        const { extent } = this.props;\n        if (z < 0 || z > 24) {\n            return null;\n        }\n        const z2 = 1 << z;\n        x = (x + z2) & (z2 - 1); // wrapFeatures tile x coordinate\n        const id = toID(z, x, y);\n        if (this.tiles[id]) {\n            return transformTile(this.tiles[id], extent);\n        }\n        log.log(log, 'drilling down to z%d-%d-%d', z, x, y)();\n        let z0 = z;\n        let x0 = x;\n        let y0 = y;\n        let parent;\n        while (!parent && z0 > 0) {\n            z0--;\n            x0 = x0 >> 1;\n            y0 = y0 >> 1;\n            parent = this.tiles[toID(z0, x0, y0)];\n        }\n        if (!parent || !parent.sourceFeatures) {\n            return null;\n        }\n        // if we found a parent tile containing the original geometry, we can drill down from it\n        log.log(1, 'found parent tile z%d-%d-%d', z0, x0, y0)();\n        log.time(1, 'drilling down')();\n        this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);\n        log.timeEnd(1, 'drilling down')();\n        return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n    }\n    /**\n     * splits features from a parent tile to sub-tiles.\n     * @param z, x, and y are the coordinates of the parent tile\n     * @param cz, cx, and cy are the coordinates of the target tile\n     *\n     * If no target tile is specified, splitting stops when we reach the maximum\n     * zoom or the number of points is low as specified in the props.\n     */\n    // eslint-disable-next-line max-params, max-statements, complexity\n    splitTile(features, z, x, y, cz, cx, cy) {\n        const stack = [features, z, x, y];\n        // avoid recursion by using a processing queue\n        while (stack.length) {\n            y = stack.pop();\n            x = stack.pop();\n            z = stack.pop();\n            features = stack.pop();\n            const z2 = 1 << z;\n            const id = toID(z, x, y);\n            let tile = this.tiles[id];\n            if (!tile) {\n                log.time(2, 'tile creation')();\n                tile = this.tiles[id] = createProtoTile(features, z, x, y, this.props);\n                this.tileCoords.push({ z, x, y });\n                const key = `z${z}`;\n                let stat = this.stats.get(key, 'count');\n                stat.incrementCount();\n                stat = this.stats.get('total');\n                stat.incrementCount();\n                stat = DynamicVectorTileSource.stats.get(key, 'count');\n                stat.incrementCount();\n                stat = DynamicVectorTileSource.stats.get('total');\n                stat.incrementCount();\n                log.log(2, 'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();\n                log.timeEnd(2, 'tile creation')();\n            }\n            // save reference to original geometry in tile so that we can drill down later if we stop now\n            tile.sourceFeatures = features;\n            /* eslint-disable no-continue */\n            // if it's the first-pass tiling\n            if (cz === undefined) {\n                // stop tiling if we reached max zoom, or if the tile is too simple\n                if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {\n                    continue;\n                }\n                // if a drilldown to a specific tile\n            }\n            else if (z === this.props.maxZoom || z === cz) {\n                // stop tiling if we reached base zoom or our target tile zoom\n                continue;\n            }\n            else if (cz !== undefined) {\n                // stop tiling if it's not an ancestor of the target tile\n                const zoomSteps = cz - z;\n                // @ts-expect-error TODO fix the types of cx cy\n                if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {\n                    continue;\n                }\n            }\n            // if we slice further down, no need to keep source geometry\n            tile.sourceFeatures = null;\n            if (features.length === 0)\n                continue;\n            log.time(2, 'clipping tile')();\n            // values we'll use for clipping\n            const k1 = (0.5 * this.props.buffer) / this.props.extent;\n            const k2 = 0.5 - k1;\n            const k3 = 0.5 + k1;\n            const k4 = 1 + k1;\n            let tl = null;\n            let bl = null;\n            let tr = null;\n            let br = null;\n            let left = clipFeatures(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);\n            let right = clipFeatures(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);\n            // @ts-expect-error - unclear why this is needed?\n            features = null;\n            if (left) {\n                tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n                bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n                left = null;\n            }\n            if (right) {\n                tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n                br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n                right = null;\n            }\n            log.timeEnd(2, 'clipping tile')();\n            stack.push(tl || [], z + 1, x * 2, y * 2);\n            stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n}\nfunction toID(z, x, y) {\n    return ((1 << z) * y + x) * 32 + z;\n}\n/*\n\n// eslint-disable-next-line max-statements, complexity\nfunction convertToGeoJSONTable(\n  vtTile: ProtoTile,\n  props: {\n    coordinates: 'local' | 'wgs84' | 'EPSG:4326';\n    tileIndex: {x: number; y: number; z: number};\n    extent: number;\n  }\n): GeoJSONTable | null {\n  const features: Feature[] = [];\n  for (const rawFeature of vtTile.features) {\n    if (!rawFeature || !rawFeature.geometry) {\n      continue;\n    }\n\n    let type:\n      | 'Point'\n      | 'MultiPoint'\n      | 'LineString'\n      | 'MultiLineString'\n      | 'Polygon'\n      | 'MultiPolygon';\n\n    let coordinates: any;\n\n    // raw geometry\n    switch (rawFeature.type) {\n      case 1:\n        if (rawFeature.geometry.length === 1) {\n          type = 'Point';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiPoint';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 2:\n        if (rawFeature.geometry.length === 1) {\n          type = 'LineString';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiLineString';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 3:\n        if (rawFeature.geometry.length > 1) {\n          type = 'MultiPolygon';\n          coordinates = [rawFeature.geometry];\n        } else {\n          type = 'Polygon';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      default:\n        continue;\n    }\n\n    switch (props.coordinates) {\n      case 'EPSG:4326':\n      case 'wgs84':\n        projectToLngLat(coordinates, props.tileIndex, props.extent);\n        break;\n\n      case 'local':\n        convertToLocalCoordinates(coordinates, props.extent);\n        break;\n\n      default:\n        throw new Error(`Unsupported CRS ${props.coordinates}`);\n    }\n\n    const feature: Feature = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates\n      },\n      properties: rawFeature.tags || {},\n      id: rawFeature.id\n    };\n\n    features.push(feature);\n  }\n\n  if (features.length === 0) {\n    return null;\n  }\n\n  const table: GeoJSONTable = {\n    shape: 'geojson-table',\n    type: 'FeatureCollection',\n    features\n  };\n\n  return table;\n}\n*/\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Create a tile from features and tile index\n */\nexport function createProtoTile(features, z, tx, ty, options) {\n    const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    const tile = {\n        protoFeatures: [],\n        sourceFeatures: null,\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: features.length,\n        x: tx,\n        y: ty,\n        z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (const feature of features) {\n        addProtoFeature(tile, feature, tolerance, options);\n    }\n    return tile;\n}\n// eslint-disable-next-line complexity, max-statements\nfunction addProtoFeature(tile, feature, tolerance, options) {\n    const geometry = feature.geometry;\n    const type = feature.type;\n    const simplifiedGeometry = [];\n    tile.minX = Math.min(tile.minX, feature.minX);\n    tile.minY = Math.min(tile.minY, feature.minY);\n    tile.maxX = Math.max(tile.maxX, feature.maxX);\n    tile.maxY = Math.max(tile.maxY, feature.maxY);\n    let simplifiedType;\n    switch (type) {\n        case 'Point':\n        case 'MultiPoint':\n            simplifiedType = 1;\n            for (let i = 0; i < geometry.length; i += 3) {\n                simplifiedGeometry.push(geometry[i], geometry[i + 1]);\n                tile.numPoints++;\n                tile.numSimplified++;\n            }\n            break;\n        case 'LineString':\n            simplifiedType = 2;\n            addProtoLine(simplifiedGeometry, geometry, tile, tolerance, false, false);\n            break;\n        case 'MultiLineString':\n            simplifiedType = 2;\n            for (let i = 0; i < geometry.length; i++) {\n                addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, false, i === 0);\n            }\n            break;\n        case 'Polygon':\n            simplifiedType = 3;\n            for (let i = 0; i < geometry.length; i++) {\n                addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, true, i === 0);\n            }\n            break;\n        case 'MultiPolygon':\n            simplifiedType = 3;\n            for (let k = 0; k < geometry.length; k++) {\n                const polygon = geometry[k];\n                for (let i = 0; i < polygon.length; i++) {\n                    addProtoLine(simplifiedGeometry, polygon[i], tile, tolerance, true, i === 0);\n                }\n            }\n            break;\n        default:\n            throw new Error(`Unknown geometry type: ${type}`);\n    }\n    if (simplifiedGeometry.length) {\n        let tags = feature.tags || null;\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (const key in feature.tags) {\n                tags[key] = feature.tags[key];\n            }\n            // @ts-expect-error adding fields to arrays\n            // eslint-disable-next-line camelcase\n            tags.mapbox_clip_start = geometry.start / geometry.size;\n            // @ts-expect-error adding fields to arrays\n            // eslint-disable-next-line camelcase\n            tags.mapbox_clip_end = geometry.end / geometry.size;\n        }\n        const tileFeature = {\n            geometry: simplifiedGeometry,\n            simplifiedType,\n            // @ts-expect-error\n            tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.protoFeatures.push(tileFeature);\n    }\n}\n// eslint-disable-next-line max-params, max-statements\nfunction addProtoLine(result, geometry, tile, tolerance, isPolygon, isOuter) {\n    const sqTolerance = tolerance * tolerance;\n    if (tolerance > 0 && geometry.size < (isPolygon ? sqTolerance : tolerance)) {\n        tile.numPoints += geometry.length / 3;\n        return;\n    }\n    const ring = [];\n    for (let i = 0; i < geometry.length; i += 3) {\n        if (tolerance === 0 || geometry[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geometry[i], geometry[i + 1]);\n        }\n        tile.numPoints++;\n    }\n    if (isPolygon)\n        rewind(ring, isOuter);\n    result.push(ring);\n}\nfunction rewind(ring, clockwise) {\n    let area = 0;\n    for (let i = 0, j = ring.length - 2; i < ring.length; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n            const x = ring[i];\n            const y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Transforms the coordinates of each protoFeature in the given protoTile from\n * mercator-projected space into (extent x extent) protoTile space.\n */\nexport function transformTile(protoTile, extent) {\n    if (protoTile.transformed) {\n        return protoTile;\n    }\n    const z2 = 1 << protoTile.z;\n    const tx = protoTile.x;\n    const ty = protoTile.y;\n    for (const protoFeature of protoTile.protoFeatures) {\n        const geom = protoFeature.geometry;\n        const simplifiedType = protoFeature.simplifiedType;\n        protoFeature.geometry = [];\n        if (simplifiedType === 1) {\n            for (let j = 0; j < geom.length; j += 2) {\n                protoFeature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        }\n        else {\n            for (let j = 0; j < geom.length; j++) {\n                const ring = [];\n                for (let k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                protoFeature.geometry.push(ring);\n            }\n        }\n    }\n    protoTile.transformed = true;\n    return protoTile;\n}\n// eslint-disable-next-line max-params\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [Math.round(extent * (x * z2 - tx)), Math.round(extent * (y * z2 - ty))];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { projectToLngLat, convertToLocalCoordinates } from \"../utils/geometry-utils.js\";\n// eslint-disable-next-line max-statements, complexity\nexport function convertTileToGeoJSON(protoTile, props) {\n    const features = [];\n    for (const rawFeature of protoTile.protoFeatures) {\n        if (!rawFeature || !rawFeature.geometry) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        let type;\n        let coordinates;\n        // raw geometry\n        switch (rawFeature.simplifiedType) {\n            case 1:\n                if (rawFeature.geometry.length === 1) {\n                    type = 'Point';\n                    coordinates = rawFeature.geometry[0];\n                }\n                else {\n                    type = 'MultiPoint';\n                    coordinates = rawFeature.geometry;\n                }\n                break;\n            case 2:\n                if (rawFeature.geometry.length === 1) {\n                    type = 'LineString';\n                    coordinates = rawFeature.geometry[0];\n                }\n                else {\n                    type = 'MultiLineString';\n                    coordinates = rawFeature.geometry;\n                }\n                break;\n            case 3:\n                if (rawFeature.geometry.length > 1) {\n                    type = 'MultiPolygon';\n                    coordinates = [rawFeature.geometry];\n                }\n                else {\n                    type = 'Polygon';\n                    coordinates = rawFeature.geometry;\n                }\n                break;\n            default:\n                throw new Error(`${rawFeature.simplifiedType}is not a valid simplified type`);\n        }\n        switch (props.coordinates) {\n            case 'EPSG:4326':\n            case 'wgs84':\n                projectToLngLat(coordinates, props.tileIndex, props.extent);\n                break;\n            default:\n                convertToLocalCoordinates(coordinates, props.extent);\n                break;\n        }\n        const feature = {\n            type: 'Feature',\n            geometry: {\n                type,\n                coordinates\n            },\n            properties: rawFeature.tags || {},\n            id: rawFeature.id\n        };\n        features.push(feature);\n    }\n    if (features.length === 0) {\n        return null;\n    }\n    const table = {\n        shape: 'geojson-table',\n        type: 'FeatureCollection',\n        features\n    };\n    return table;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nexport function createProtoFeature(id, type, geometry, tags) {\n    const feature = {\n        // eslint-disable-next-line\n        id: id == null ? null : id,\n        type,\n        simplifiedType: undefined, // TODO\n        geometry,\n        tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n    // TODO break out into separate function\n    switch (type) {\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n            calcLineBBox(feature, geometry);\n            break;\n        case 'MultiLineString':\n            for (const line of geometry) {\n                calcLineBBox(feature, line);\n            }\n            break;\n        case 'Polygon':\n            // the outer ring (ie [0]) contains all inner rings\n            calcLineBBox(feature, geometry[0]);\n            break;\n        case 'MultiPolygon':\n            for (const polygon of geometry) {\n                // the outer ring (ie [0]) contains all inner rings\n                calcLineBBox(feature, polygon[0]);\n            }\n            break;\n        default:\n            throw new Error(String(type));\n    }\n    return feature;\n}\nfunction calcLineBBox(feature, geometry) {\n    for (let i = 0; i < geometry.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geometry[i]);\n        feature.minY = Math.min(feature.minY, geometry[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geometry[i]);\n        feature.maxY = Math.max(feature.maxY, geometry[i + 1]);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Calculate simplification data using optimized Douglas-Peucker algorithm\n *\n * @param coords contiguous list of coordinates\n * @param first first coord to simplify\n * @param last last coord to simplify\n * @param sqTolerance tolerance (square distance)\n */\nexport function simplifyPath(coords, first, last, sqTolerance) {\n    let maxSqDist = sqTolerance;\n    const mid = (last - first) >> 1;\n    let minPosToMid = last - first;\n    let index;\n    const ax = coords[first];\n    const ay = coords[first + 1];\n    const bx = coords[last];\n    const by = coords[last + 1];\n    for (let i = first + 3; i < last; i += 3) {\n        const d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n        }\n        else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            const posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3)\n            simplifyPath(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3)\n            simplifyPath(coords, index, last, sqTolerance);\n    }\n}\n/** square distance from a point to a segment */\n// eslint-disable-next-line max-params\nfunction getSqSegDist(px, py, x, y, bx, by) {\n    let dx = bx - x;\n    let dy = by - y;\n    if (dx !== 0 || dy !== 0) {\n        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x = bx;\n            y = by;\n        }\n        else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n    dx = px - x;\n    dy = py - y;\n    return dx * dx + dy * dy;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\nimport { simplifyPath } from \"./simplify-path.js\";\n/**\n * converts a GeoJSON feature into an intermediate projected JSON vector format\n * with simplification data\n */\nexport function convertFeaturesToProtoFeature(data, options) {\n    const protoFeatures = [];\n    switch (data.type) {\n        case 'FeatureCollection':\n            let i = 0;\n            for (const feature of data.features) {\n                protoFeatures.push(convertFeature(feature, options, i++));\n            }\n            break;\n        case 'Feature':\n            protoFeatures.push(convertFeature(data, options));\n            break;\n        default:\n            // single geometry or a geometry collection\n            protoFeatures.push(convertFeature({ geometry: data }, options));\n    }\n    return protoFeatures;\n}\n/**\n * converts a GeoJSON feature into an intermediate projected JSON vector format\n * with simplification data\n */\nfunction convertFeature(geojson, options, index) {\n    // GeoJSON geometries can be null, but no vector tile will include them.\n    if (!geojson.geometry) {\n        return;\n    }\n    const coords = geojson.geometry.coordinates;\n    const type = geojson.geometry.type;\n    const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    let geometry = [];\n    let id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    }\n    else if (options.generateId) {\n        id = index || 0;\n    }\n    switch (type) {\n        case 'Point':\n            convertPoint(coords, geometry);\n            break;\n        case 'MultiPoint':\n            for (const p of coords) {\n                convertPoint(p, geometry);\n            }\n            break;\n        case 'LineString':\n            convertLine(coords, geometry, tolerance, false);\n            break;\n        case 'MultiLineString':\n            if (options.lineMetrics) {\n                // explode into linestrings to be able to track metrics\n                for (const line of coords) {\n                    geometry = [];\n                    convertLine(line, geometry, tolerance, false);\n                    features.push(createProtoFeature(id, 'LineString', geometry, geojson.properties));\n                }\n                return;\n                convertLines(coords, geometry, tolerance, false);\n            }\n            break;\n        case 'Polygon':\n            convertLines(coords, geometry, tolerance, true);\n            break;\n        case 'MultiPolygon':\n            for (const polygon of coords) {\n                const newPolygon = [];\n                convertLines(polygon, newPolygon, tolerance, true);\n                geometry.push(newPolygon);\n            }\n            break;\n        case 'GeometryCollection':\n            for (const singleGeometry of geojson.geometry.geometries) {\n                convertFeature(features, {\n                    id,\n                    geometry: singleGeometry,\n                    properties: geojson.properties\n                }, options, index);\n            }\n            break;\n        default:\n            throw new Error('Input data is not a valid GeoJSON object.');\n    }\n    return createProtoFeature(id, type, geometry, geojson.properties);\n}\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]), projectY(coords[1]), 0);\n}\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    let x0, y0;\n    let size = 0;\n    for (let j = 0; j < ring.length; j++) {\n        const x = projectX(ring[j][0]);\n        const y = projectY(ring[j][1]);\n        out.push(x, y, 0);\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            }\n            else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n    const last = out.length - 3;\n    out[2] = 1;\n    simplifyPath(out, 0, last, tolerance);\n    out[last + 2] = 1;\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (let i = 0; i < rings.length; i++) {\n        const geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\nfunction projectY(y) {\n    const sin = Math.sin((y * Math.PI) / 180);\n    const y2 = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\n/* eslint-disable no-continue */\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clipFeatures(features, scale, k1, k2, axis, minAll, maxAll, options) {\n    k1 /= scale;\n    k2 /= scale;\n    if (minAll >= k1 && maxAll < k2) {\n        return features;\n    }\n    // trivial accept\n    else if (maxAll < k1 || minAll >= k2) {\n        return null; // trivial reject\n    }\n    const clipped = [];\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        let type = feature.type;\n        const min = axis === 0 ? feature.minX : feature.minY;\n        const max = axis === 0 ? feature.maxX : feature.maxY;\n        if (min >= k1 && max < k2) {\n            // trivial accept\n            clipped.push(feature);\n            continue;\n        }\n        else if (max < k1 || min >= k2) {\n            // trivial reject\n            continue;\n        }\n        let newGeometry = [];\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n        }\n        else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n        }\n        else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n        }\n        else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n        }\n        else if (type === 'MultiPolygon') {\n            for (const polygon of geometry) {\n                const newPolygon = [];\n                clipLines(polygon, newPolygon, k1, k2, axis, true);\n                if (newPolygon.length) {\n                    newGeometry.push(newPolygon);\n                }\n            }\n        }\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (const line of newGeometry) {\n                    clipped.push(createProtoFeature(feature.id, type, line, feature.tags));\n                }\n                continue;\n            }\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    // @ts-expect-error TODO - use proper GeoJSON geometry types\n                    newGeometry = newGeometry[0];\n                }\n                else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n            clipped.push(createProtoFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n    return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (let i = 0; i < geom.length; i += 3) {\n        const a = geom[i + axis];\n        if (a >= k1 && a <= k2) {\n            addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n        }\n    }\n}\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n    let slice = newSlice(geom);\n    const intersect = axis === 0 ? intersectX : intersectY;\n    let len = geom.start;\n    let segLen;\n    let t;\n    for (let i = 0; i < geom.length - 3; i += 3) {\n        const ax = geom[i];\n        const ay = geom[i + 1];\n        const az = geom[i + 2];\n        const bx = geom[i + 3];\n        const by = geom[i + 4];\n        const a = axis === 0 ? ax : ay;\n        const b = axis === 0 ? bx : by;\n        let exited = false;\n        if (trackMetrics) {\n            segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n        }\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n        if (!isPolygon && exited) {\n            if (trackMetrics) {\n                slice.end = len + segLen * t;\n            }\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n        if (trackMetrics) {\n            len += segLen;\n        }\n    }\n    // add the last point\n    let last = geom.length - 3;\n    const ax = geom[last];\n    const ay = geom[last + 1];\n    const az = geom[last + 2];\n    const a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2)\n        addPoint(slice, ax, ay, az);\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\nclass Slice extends Array {\n    size;\n    start;\n    end;\n}\nfunction newSlice(line) {\n    const slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (const line of geom) {\n        clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\nfunction addPoint(out, x, y, z) {\n    out.push(x, y, z);\n}\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax, ay, bx, by, x) {\n    const t = (x - ax) / (bx - ax);\n    addPoint(out, x, ay + (by - ay) * t, 1);\n    return t;\n}\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax, ay, bx, by, y) {\n    const t = (y - ay) / (by - ay);\n    addPoint(out, ax + (bx - ax) * t, y, 1);\n    return t;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\nimport { clipFeatures } from \"./clip-features.js\";\n/**\n * Wrap across antemeridian, by clipping into two tiles, shifting the overflowing x coordinates\n * @param list of features to be wrapped\n * @param options buffer and extent\n * @returns\n */\nexport function wrapFeatures(features, options) {\n    const buffer = options.buffer / options.extent;\n    let merged = features;\n    const left = clipFeatures(features, 1, -1 - buffer, buffer, 0, -1, 2, options); // left world copy\n    const right = clipFeatures(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n    if (left || right) {\n        merged = clipFeatures(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n        if (left) {\n            merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        }\n        if (right) {\n            merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n        }\n    }\n    return merged;\n}\n/**\n * Shift the x coordinates of a list of features\n * @param features list of features to shift x coordinates for\n * @param offset\n * @returns\n */\nfunction shiftFeatureCoords(features, offset) {\n    const newFeatures = [];\n    for (let i = 0; i < features.length; i++) {\n        const feature = features[i];\n        const type = feature.type;\n        let newGeometry;\n        switch (type) {\n            case 'Point':\n            case 'MultiPoint':\n            case 'LineString':\n                newGeometry = shiftCoords(feature.geometry, offset);\n                break;\n            case 'MultiLineString':\n            case 'Polygon':\n                newGeometry = [];\n                for (const line of feature.geometry) {\n                    newGeometry.push(shiftCoords(line, offset));\n                }\n                break;\n            case 'MultiPolygon':\n                newGeometry = [];\n                for (const polygon of feature.geometry) {\n                    const newPolygon = [];\n                    for (const line of polygon) {\n                        // @ts-expect-error TODO\n                        newPolygon.push(shiftCoords(line, offset));\n                    }\n                    newGeometry.push(newPolygon);\n                }\n                break;\n            default:\n                throw new Error(String(type));\n        }\n        newFeatures.push(createProtoFeature(feature.id, type, newGeometry, feature.tags));\n    }\n    return newFeatures;\n}\nclass Points extends Array {\n    size;\n    start;\n    end;\n}\n/**\n * Shift the x coordinate of every point\n * @param points\n * @param offset\n * @returns\n */\nfunction shiftCoords(points, offset) {\n    const newPoints = [];\n    newPoints.size = points.size;\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n    for (let i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACIO,SAAS,2BAA2B,OAAO;AAC9C,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM,QAAQ;AACd,eAAW,SAAS,MAAM,QAAQ;AAC9B,aAAO,KAAK;AAAA,QACR,MAAM,MAAM;AAAA,QACZ,MAAM,6BAA6B,KAAK;AAAA,QACxC,UAAU,6BAA6B,KAAK;AAAA,MAChD,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AAAA,IACH,UAAU,6BAA6B,KAAK;AAAA,IAC5C;AAAA,EACJ;AACJ;AACA,SAAS,6BAA6B,OAAO;AACzC,QAAM,WAAW,CAAC;AAClB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC9C,QAAI,QAAQ,YAAY,OAAO;AAC3B,eAAS,GAAG,IAAI,KAAK,UAAU,KAAK;AAAA,IACxC;AAAA,EACJ;AACA,SAAO;AACX;AAEA,SAAS,6BAA6B,OAAO;AACzC,UAAQ,MAAM,KAAK,YAAY,GAAG;AAAA,IAC9B,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AAAA,IACL,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AAAA,IACL,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX;AACI,aAAO;AAAA,EACf;AACJ;AACA,SAAS,6BAA6B,OAAO;AACzC,QAAM,WAAW,CAAC;AAClB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC9C,QAAI,QAAQ,UAAU,OAAO;AACzB,eAAS,GAAG,IAAI,KAAK,UAAU,KAAK;AAAA,IACxC;AAAA,EACJ;AACA,SAAO;AACX;;;AClDA,IAAM,WAAW,CAAC,MAAM,MAAM,QAAQ,OAAO,MAAM;AAQ5C,SAAS,cAAc,cAAc,SAAS;AAZrD;AAaI,MAAI,CAAC,gBAAgB,CAAC,SAAS,YAAY,GAAG;AAC1C,WAAO;AAAA,EACX;AACA,MAAI,WAAW;AAAA,IACX,MAAM,aAAa,QAAQ;AAAA,IAC3B,aAAa,aAAa,eAAe;AAAA,EAC7C;AAEA,MAAI,OAAO,aAAa,cAAc,UAAU;AAC5C,aAAS,YAAY,aAAa;AAAA,EACtC;AACA,MAAI,OAAO,aAAa,sBAAsB,UAAU;AACpD,aAAS,mBAAmB,aAAa;AAAA,EAC7C;AAEA,WAAS,cACL,YAAY,aAAa,MAAM,KAAK,YAAY,aAAa,4BAA4B;AAE7F,WAAS,SAAS,YAAY,aAAa,MAAM;AAEjD,WAAS,UAAU,eAAe,aAAa,OAAO;AAEtD,WAAS,UAAU,eAAe,aAAa,OAAO;AAGtD,MAAI,QAAO,6CAAc,UAAS,UAAU;AAExC,QAAI;AACA,eAAS,WAAW,KAAK,MAAM,aAAa,IAAI;AAAA,IACpD,SACO,OAAP;AAEI,cAAQ,KAAK,uCAAuC,KAAK;AAAA,IAE7D;AAAA,EACJ;AAEA,QAAM,YAAY,aAAa,eAAa,cAAS,aAAT,mBAAmB;AAC/D,QAAM,kBAAkB,qBAAqB,WAAW,OAAO;AAC/D,QAAM,iBAAiB,oBAAoB,aAAa,aAAa;AAErE,QAAM,SAAS,YAAY,gBAAgB,eAAe;AAC1D,aAAW;AAAA,IACP,GAAG;AAAA,IACH;AAAA,EACJ;AACA,MAAI,SAAS,YAAY,QAAQ,OAAO,SAAS,GAAG;AAChD,aAAS,UAAU,OAAO,CAAC,EAAE,WAAW;AAAA,EAC5C;AACA,MAAI,SAAS,YAAY,QAAQ,OAAO,SAAS,GAAG;AAChD,aAAS,UAAU,OAAO,CAAC,EAAE,WAAW;AAAA,EAC5C;AACA,SAAO;AACX;AACA,SAAS,oBAAoB,QAAQ;AAEjC,MAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACxB,WAAO,CAAC;AAAA,EACZ;AACA,SAAO,OAAO,IAAI,CAAC,UAAU,mBAAmB,KAAK,CAAC;AAC1D;AACA,SAAS,mBAAmB,OAAO;AAC/B,QAAM,SAAS,OAAO,QAAQ,MAAM,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,KAAK,QAAQ,OAAO;AAAA,IACxE,MAAM;AAAA,IACN,GAAG,yBAAyB,OAAO,QAAQ,CAAC;AAAA,EAChD,EAAE;AACF,QAAM,SAAS,EAAE,GAAG,MAAM;AAC1B,SAAO,OAAO;AACd,SAAO;AAAA,IACH,MAAM,MAAM,MAAM;AAAA,IAClB,GAAG;AAAA,IACH;AAAA,EACJ;AACJ;AAEA,SAAS,qBAAqB,WAAW,SAAS;AAC9C,MAAI,SAAS,SAAS,KAAK,MAAM,QAAQ,UAAU,MAAM,GAAG;AAExD,WAAO,UAAU,OAAO,IAAI,CAAC,UAAU,uBAAuB,OAAO,OAAO,CAAC;AAAA,EACjF;AACA,SAAO,CAAC;AACZ;AACA,SAAS,uBAAuB,OAAO,SAAS;AAC5C,QAAM,SAAS,CAAC;AAChB,QAAM,oBAAoB,CAAC;AAC3B,QAAM,aAAa,MAAM,cAAc,CAAC;AACxC,aAAW,aAAa,YAAY;AAChC,UAAM,OAAO,UAAU;AACvB,QAAI,OAAO,SAAS,UAAU;AAE1B,UAAI,KAAK,MAAM,GAAG,EAAE,SAAS,GAAG;AAE5B,cAAM,QAAQ,KAAK,MAAM,GAAG,EAAE,CAAC;AAC/B,0BAAkB,KAAK,IAAI,kBAAkB,KAAK,KAAK,CAAC;AACxD,0BAAkB,KAAK,EAAE,KAAK,SAAS;AAEvC,gBAAQ,KAAK,oCAAoC,KAAK;AAAA,MAC1D,WACS,CAAC,OAAO,IAAI,GAAG;AACpB,eAAO,KAAK,iBAAiB,WAAW,OAAO,CAAC;AAAA,MACpD,OACK;AAAA,MAEL;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AAAA,IACH,MAAM,MAAM,SAAS;AAAA,IACrB,kBAAkB,MAAM;AAAA,IACxB;AAAA,EACJ;AACJ;AACA,SAAS,YAAY,QAAQ,iBAAiB;AAC1C,SAAO,OAAO,IAAI,CAAC,UAAU;AACzB,UAAM,iBAAiB,gBAAgB,KAAK,CAAC,YAAY,QAAQ,SAAS,MAAM,IAAI;AACpF,UAAM,UAAS,iDAAgB,WAAU,MAAM,UAAU,CAAC;AAC1D,UAAM,cAAc;AAAA,MAChB,GAAG;AAAA,MACH,GAAG;AAAA,MACH;AAAA,IACJ;AACA,gBAAY,SAAS,2BAA2B,WAAW;AAC3D,WAAO;AAAA,EACX,CAAC;AACL;AAKA,SAAS,YAAY,QAAQ;AAIzB,QAAM,SAAS,kBAAkB,MAAM;AAEvC,MAAI,MAAM,QAAQ,MAAM,KACpB,OAAO,WAAW,KAClB,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,EAAE,MAAM,KAAK,KAClC,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,EAAE,MAAM,KAAK,GAAG;AACrC,WAAO;AAAA,MACH,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,MACrB,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,IACzB;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,YAAY,QAAQ;AAIzB,QAAM,SAAS,kBAAkB,MAAM;AACvC,MAAI,MAAM,QAAQ,MAAM,KACpB,OAAO,WAAW,KAClB,MAAM,OAAO,CAAC,CAAC,KACf,MAAM,OAAO,CAAC,CAAC,KACf,OAAO,OAAO,CAAC,CAAC,GAAG;AACnB,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,eAAe,OAAO;AAC3B,QAAM,SAAS,OAAO,UAAU,WAAW,WAAW,KAAK,IAAI,OAAO,UAAU,WAAW,QAAQ;AACnG,SAAO,WAAW,QAAQ,MAAM,MAAM,IAAI,OAAO;AACrD;AAEA,SAAS,MAAM,KAAK;AAChB,SAAO,OAAO,SAAS,GAAG,KAAK,OAAO,MAAM,OAAO;AACvD;AACA,SAAS,MAAM,KAAK;AAChB,SAAO,OAAO,SAAS,GAAG,KAAK,OAAO,OAAO,OAAO;AACxD;AACA,SAAS,OAAO,KAAK;AACjB,SAAO,OAAO,SAAS,GAAG,KAAK,OAAO,KAAK,OAAO;AACtD;AACA,SAAS,kBAAkB,MAAM;AAC7B,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO,KAAK,MAAM,GAAG,EAAE,IAAI,UAAU;AAAA,EACzC,WACS,MAAM,QAAQ,IAAI,GAAG;AAC1B,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEA,IAAM,cAAc;AAAA,EAChB,QAAQ;AAAA,IACJ,MAAM;AAAA,EACV;AAAA,EACA,SAAS;AAAA,IACL,MAAM;AAAA,EACV;AAAA,EACA,QAAQ;AAAA,IACJ,MAAM;AAAA,EACV;AAAA,EACA,QAAQ;AAAA,IACJ,MAAM;AAAA,EACV;AAAA,EACA,OAAO;AAAA,IACH,MAAM;AAAA,EACV;AAAA,EACA,KAAK;AAAA,IACD,MAAM;AAAA,EACV;AAAA,EACA,MAAM;AAAA,IACF,MAAM;AAAA,EACV;AAAA,EACA,SAAS;AAAA,IACL,MAAM;AAAA,EACV;AAAA,EACA,MAAM;AAAA,IACF,MAAM;AAAA,EACV;AACJ;AACA,SAAS,iBAAiB,YAAY,CAAC,GAAG,SAAS;AAlOnD;AAmOI,QAAM,aAAa,yBAAyB,UAAU,IAAI;AAC1D,QAAM,QAAQ;AAAA,IACV,MAAM,UAAU;AAAA;AAAA;AAAA,IAGhB,GAAG;AAAA,EACP;AAMA,MAAI,OAAO,UAAU,QAAQ,UAAU;AACnC,UAAM,MAAM,UAAU;AAAA,EAC1B;AACA,MAAI,OAAO,UAAU,QAAQ,UAAU;AACnC,UAAM,MAAM,UAAU;AAAA,EAC1B;AACA,MAAI,OAAO,UAAU,UAAU,UAAU;AACrC,UAAM,mBAAmB,UAAU;AAAA,EACvC;AACA,MAAI,UAAU,QAAQ;AAElB,UAAM,SAAS,UAAU;AAAA,EAC7B;AACA,MAAI,MAAM,UAAU,OAAO,QAAQ,cAAc,UAAU;AAEvD,UAAM,UAAS,WAAM,WAAN,mBAAc,MAAM,GAAG,QAAQ;AAAA,EAClD;AACA,SAAO;AACX;AACA,SAAS,yBAAyB,OAAO;AACrC,QAAM,OAAO,MAAM,YAAY;AAC/B,MAAI,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;AAAA,EAIjC;AACA,SAAO,YAAY,IAAI,KAAK,EAAE,MAAM,SAAS;AACjD;;;ACpQA,IAAM,UAAU,OAAiC,UAAU;AAIpD,IAAM,iBAAiB;AAAA,EAC1B,UAAU;AAAA,EACV,WAAW;AAAA,EACX,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,YAAY,CAAC,MAAM;AAAA,EACnB,WAAW,CAAC,kBAAkB;AAAA,EAC9B,MAAM;AAAA,EACN,SAAS;AAAA,IACL,UAAU;AAAA,MACN,WAAW;AAAA,IACf;AAAA,EACJ;AAAA,EACA,OAAO,OAAO,aAAa,YAAY;AACnC,UAAM,aAAa,IAAI,YAAY,EAAE,OAAO,WAAW;AACvD,UAAM,OAAO,KAAK,MAAM,UAAU;AAClC,UAAM,kBAAkB,EAAE,GAAG,eAAe,QAAQ,UAAU,GAAG,mCAAS,SAAS;AACnF,WAAO,cAAc,MAAM,eAAe;AAAA,EAC9C;AAAA,EACA,eAAe,CAAC,MAAM,YAAY;AAC9B,UAAM,OAAO,KAAK,MAAM,IAAI;AAC5B,UAAM,kBAAkB,EAAE,GAAG,eAAe,QAAQ,UAAU,GAAG,mCAAS,SAAS;AACnF,WAAO,cAAc,MAAM,eAAe;AAAA,EAC9C;AACJ;;;AClCA,iBAAoC;AACpC,0BAAoB;AACpB,iBAAqB;;;ACFrB,qBAAqC;AAM9B,SAAS,WAAW,MAAM;AAC7B,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,IAAI,IAAI,IAAI,KAAK,QAAQ,IAAI,KAAK;AACnE,SAAK,KAAK,CAAC;AACX,SAAK,KAAK,CAAC;AACX,YAAQ,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC;AAAA,EAC1C;AACA,SAAO;AACX;AASO,SAAS,0BAA0B,aAAa,QAAQ;AAC3D,MAAI,MAAM,QAAQ,YAAY,CAAC,CAAC,GAAG;AAC/B,eAAW,aAAa,aAAa;AACjC,gCAA0B,WAAW,MAAM;AAAA,IAC/C;AACA;AAAA,EACJ;AAEA,QAAM,IAAI;AACV,IAAE,CAAC,KAAK;AACR,IAAE,CAAC,KAAK;AACZ;AAOO,SAAS,8BAA8B,MAAM,QAAQ;AACxD,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE,GAAG;AAClC,SAAK,CAAC,KAAK;AAAA,EACf;AACJ;AAMO,SAAS,gBAAgB,MAAM,WAAW,QAAQ;AACrD,MAAI,OAAO,KAAK,CAAC,EAAE,CAAC,MAAM,UAAU;AAChC,eAAW,SAAS,MAAM;AAEtB,sBAAgB,OAAO,WAAW,MAAM;AAAA,IAC5C;AACA;AAAA,EACJ;AACA,QAAM,OAAO,SAAS,KAAK,IAAI,GAAG,UAAU,CAAC;AAC7C,QAAM,KAAK,SAAS,UAAU;AAC9B,QAAM,KAAK,SAAS,UAAU;AAC9B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,UAAM,IAAI,KAAK,CAAC;AAChB,MAAE,CAAC,KAAM,EAAE,CAAC,IAAI,MAAM,MAAO,OAAO;AACpC,UAAM,KAAK,OAAQ,EAAE,CAAC,IAAI,MAAM,MAAO;AACvC,MAAE,CAAC,IAAK,MAAM,KAAK,KAAM,KAAK,KAAK,KAAK,IAAK,KAAK,KAAK,KAAM,GAAG,CAAC,IAAI;AAAA,EACzE;AACJ;AA6BO,SAAS,oBAAoB,MAAM,WAAW,QAAQ;AACzD,QAAM,EAAE,GAAG,GAAG,EAAE,IAAI;AACpB,QAAM,OAAO,SAAS,KAAK,IAAI,GAAG,CAAC;AACnC,QAAM,KAAK,SAAS;AACpB,QAAM,KAAK,SAAS;AACpB,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,KAAK,GAAG;AAC9C,SAAK,CAAC,KAAM,KAAK,CAAC,IAAI,MAAM,MAAO,OAAO;AAC1C,UAAM,KAAK,OAAQ,KAAK,IAAI,CAAC,IAAI,MAAM,MAAO;AAC9C,SAAK,IAAI,CAAC,IAAK,MAAM,KAAK,KAAM,KAAK,KAAK,KAAK,IAAK,KAAK,KAAK,KAAM,GAAG,CAAC,IAAI;AAAA,EAChF;AACJ;AAMO,SAAS,cAAc,OAAO;AACjC,QAAM,MAAM,MAAM;AAClB,MAAI,OAAO;AACP,WAAO,CAAC,KAAK;AACjB,QAAM,WAAW,CAAC;AAClB,MAAI;AACJ,MAAI;AACJ,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,UAAM,OAAO,WAAW,MAAM,CAAC,CAAC;AAChC,QAAI,SAAS;AACT;AACJ,QAAI,QAAQ;AACR,YAAM,OAAO;AACjB,QAAI,QAAQ,OAAO,GAAG;AAClB,UAAI;AACA,iBAAS,KAAK,OAAO;AACzB,gBAAU,CAAC,MAAM,CAAC,CAAC;AAAA,IACvB,WACS;AACL,cAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,EAC7B;AACA,MAAI;AACA,aAAS,KAAK,OAAO;AACzB,SAAO;AACX;AAWO,SAAS,kBAAkB,MAAM;AACpC,QAAM,MAAM,KAAK,QAAQ;AACzB,QAAM,OAAO;AACb,MAAI,OAAO,GAAG;AACV,WAAO;AAAA,MACH;AAAA,MACA,MAAM,KAAK;AAAA,MACX,OAAO,CAAC,KAAC,qCAAqB,KAAK,IAAI,CAAC,CAAC;AAAA,MACzC,SAAS,CAAC,KAAK,OAAO;AAAA,IAC1B;AAAA,EACJ;AACA,QAAM,QAAQ,CAAC;AACf,QAAM,WAAW,CAAC;AAClB,MAAI,YAAY,CAAC;AACjB,MAAI,UAAU,CAAC;AACf,MAAI;AACJ,MAAI,SAAS;AACb,WAAS,UAAU,IAAI,GAAG,YAAY,IAAI,KAAK,KAAK;AAChD,iBAAa,KAAK,QAAQ,CAAC,IAAI;AAC/B,eAAW,KAAK,QAAQ,IAAI,CAAC,IAAI,UAAU,KAAK,KAAK;AACrD,UAAM,QAAQ,KAAK,KAAK,MAAM,YAAY,QAAQ;AAClD,UAAM,WAAO,qCAAqB,KAAK;AACvC,QAAI,SAAS,GAAG;AAGZ,YAAM,SAAS,KAAK,KAAK,MAAM,GAAG,UAAU;AAC5C,YAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ;AACtC,WAAK,OAAO,OAAO,OAAO,KAAK;AAG/B,gBAAU,WAAW;AAErB;AAAA,IACJ;AACA,QAAI,QAAQ;AACR,YAAM,OAAO;AACjB,QAAI,QAAQ,OAAO,GAAG;AAClB,UAAI,QAAQ,QAAQ;AAChB,cAAM,KAAK,SAAS;AACpB,iBAAS,KAAK,OAAO;AAAA,MACzB;AACA,gBAAU,CAAC,UAAU;AACrB,kBAAY,CAAC,IAAI;AAAA,IACrB,OACK;AACD,gBAAU,KAAK,IAAI;AACnB,cAAQ,KAAK,UAAU;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI;AACA,UAAM,KAAK,SAAS;AACxB,MAAI,QAAQ;AACR,aAAS,KAAK,OAAO;AACzB,SAAO,EAAE,MAAM,OAAO,SAAS,UAAU,MAAM,KAAK,KAAK;AAC7D;;;ACzMO,IAAM,oBAAN,MAAwB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA,YAAY,KAAK,KAAK,QAAQ,MAAM,QAAQ,cAAc;AAEtD,SAAK,aAAa,CAAC;AACnB,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,SAAK,KAAK;AAEV,SAAK,OAAO;AACZ,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,UAAU;AAEf,SAAK,gBAAgB;AACrB,QAAI,WAAW,aAAa,MAAM,GAAG;AAAA,EACzC;AAAA,EACA,iBAAiB,aAAa,WAAW;AACrC,UAAM,SAAS,KAAK,aAAa;AACjC,YAAQ,aAAa;AAAA,MACjB,KAAK;AACD,eAAO,kBAAkB,MAAM,QAAQ,CAAC,SAAS,gBAAgB,MAAM,WAAW,KAAK,MAAM,CAAC;AAAA,MAClG;AACI,eAAO,kBAAkB,MAAM,QAAQ,yBAAyB;AAAA,IACxE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,aAAa,WAAW;AACpC,UAAM,OAAO,KAAK,iBAAiB;AACnC,YAAQ,aAAa;AAAA,MACjB,KAAK;AACD,eAAO,KAAK,qBAAqB,MAAM,CAAC,WAAW,oBAAoB,QAAQ,WAAW,KAAK,MAAM,CAAC;AAAA,MAC1G;AACI,eAAO,KAAK,qBAAqB,MAAM,6BAA6B;AAAA,IAC5E;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,OAAO;AACH,UAAM,MAAM,KAAK;AACjB,QAAI,MAAM,KAAK;AACf,UAAM,MAAM,IAAI,WAAW,IAAI,IAAI;AACnC,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,KAAK;AACT,WAAO,IAAI,MAAM,KAAK;AAClB,UAAI,UAAU,GAAG;AACb,cAAM,SAAS,IAAI,WAAW;AAC9B,cAAM,SAAS;AACf,iBAAS,UAAU;AAAA,MACvB;AACA;AACA,UAAI,QAAQ,KAAK,QAAQ,GAAG;AACxB,aAAK,IAAI,YAAY;AACrB,aAAK,IAAI,YAAY;AACrB,YAAI,IAAI;AACJ,eAAK;AACT,YAAI,IAAI;AACJ,eAAK;AACT,YAAI,IAAI;AACJ,eAAK;AACT,YAAI,IAAI;AACJ,eAAK;AAAA,MACb,WACS,QAAQ,GAAG;AAChB,cAAM,IAAI,MAAM,mBAAmB,KAAK;AAAA,MAC5C;AAAA,IACJ;AACA,WAAO,CAAC,IAAI,IAAI,IAAI,EAAE;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB,MAAM,WAAW;AAClC,QAAI;AAEJ,cAAU,KAAK,MAAM,KAAK,MAAM;AAChC,UAAM,cAAc;AAEpB,YAAQ,KAAK,MAAM;AAAA,MACf,KAAK;AACD,aAAK,cAAc;AACnB,aAAK,cAAc,uBAAuB,KAAK,QAAQ;AACvD,mBAAW,EAAE,MAAM,SAAS,GAAG,KAAK;AACpC;AAAA,MACJ,KAAK;AACD,aAAK,cAAc;AACnB,aAAK,cAAc,kBAAkB,KAAK,QAAQ;AAClD,aAAK,cAAc,sBAAsB,KAAK,KAAK,SAAS;AAC5D,mBAAW,EAAE,MAAM,cAAc,GAAG,KAAK;AACzC;AAAA,MACJ,KAAK;AACD,mBAAW,kBAAkB,IAAI;AAGjC,aAAK,cAAc;AACnB,aAAK,cAAc,uBAAuB,SAAS,QAAQ;AAC3D,mBAAW,WAAW,SAAS,SAAS;AACpC,eAAK,cAAc,qBAAqB,QAAQ;AAAA,QACpD;AACA,aAAK,cAAc,yBAAyB,SAAS,KAAK,SAAS;AACnE;AAAA,MACJ;AACI,cAAM,IAAI,MAAM,0BAA0B,KAAK,MAAM;AAAA,IAC7D;AACA,UAAM,SAAS,EAAE,MAAM,WAAW,UAAU,YAAY,KAAK,WAAW;AACxE,QAAI,KAAK,OAAO,MAAM;AAClB,aAAO,KAAK,KAAK;AAAA,IACrB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA,EAGA,eAAe;AACX,UAAM,MAAM,KAAK;AACjB,QAAI,MAAM,KAAK;AACf,UAAM,MAAM,IAAI,WAAW,IAAI,IAAI;AACnC,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,IAAI;AACR,QAAI,IAAI;AACR,UAAM,QAAQ,CAAC;AACf,QAAI;AACJ,WAAO,IAAI,MAAM,KAAK;AAClB,UAAI,UAAU,GAAG;AACb,cAAM,SAAS,IAAI,WAAW;AAC9B,cAAM,SAAS;AACf,iBAAS,UAAU;AAAA,MACvB;AACA;AACA,cAAQ,KAAK;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AACD,eAAK,IAAI,YAAY;AACrB,eAAK,IAAI,YAAY;AACrB,cAAI,QAAQ,GAAG;AAEX,gBAAI;AACA,oBAAM,KAAK,IAAI;AACnB,mBAAO,CAAC;AAAA,UACZ;AACA,cAAI;AACA,iBAAK,KAAK,CAAC,GAAG,CAAC,CAAC;AACpB;AAAA,QACJ,KAAK;AAED,cAAI,MAAM;AACN,iBAAK,KAAK,KAAK,CAAC,EAAE,MAAM,CAAC;AAAA,UAC7B;AACA;AAAA,QACJ;AACI,gBAAM,IAAI,MAAM,mBAAmB,KAAK;AAAA,MAChD;AAAA,IACJ;AACA,QAAI;AACA,YAAM,KAAK,IAAI;AACnB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,mBAAmB;AACf,UAAM,MAAM,KAAK;AACjB,QAAI,MAAM,KAAK;AACf,UAAM,SAAS,IAAI,WAAW,IAAI,IAAI;AACtC,QAAI,MAAM;AACV,QAAI;AACJ,QAAI,SAAS;AACb,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,IAAI;AAMR,UAAM,UAAU,CAAC;AACjB,UAAM,OAAO,CAAC;AACd,WAAO,IAAI,MAAM,QAAQ;AACrB,UAAI,UAAU,GAAG;AACb,iBAAS,IAAI,WAAW;AACxB,cAAM,SAAS;AACf,iBAAS,UAAU;AAAA,MACvB;AACA;AACA,UAAI,QAAQ,KAAK,QAAQ,GAAG;AACxB,aAAK,IAAI,YAAY;AACrB,aAAK,IAAI,YAAY;AACrB,YAAI,QAAQ,GAAG;AAEX,kBAAQ,KAAK,CAAC;AAAA,QAClB;AACA,aAAK,KAAK,GAAG,CAAC;AACd,aAAK;AAAA,MACT,WACS,QAAQ,GAAG;AAEhB,YAAI,IAAI,GAAG;AACP,gBAAM,QAAQ,QAAQ,QAAQ,SAAS,CAAC;AACxC,eAAK,KAAK,KAAK,KAAK,GAAG,KAAK,QAAQ,CAAC,CAAC;AACtC,eAAK;AAAA,QACT;AAAA,MACJ,OACK;AACD,cAAM,IAAI,MAAM,mBAAmB,KAAK;AAAA,MAC5C;AAAA,IACJ;AACA,WAAO,EAAE,MAAM,QAAQ;AAAA,EAC3B;AACJ;AAjPI,cAVS,mBAUF,SAAQ,CAAC,WAAW,SAAS,cAAc,SAAS;AAkP/D,SAAS,kBAAkB,WAAW,QAAQ,WAAW;AACrD,MAAI,OAAO,kBAAkB,MAAM,UAAU,IAAI;AACjD,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,UAAQ,UAAU,MAAM;AAAA,IACpB,KAAK;AACD,YAAM,SAAS,CAAC;AAChB,WAAK,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAChC,eAAO,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC;AAAA,MAC3B;AACA,oBAAc;AACd,gBAAU,aAAa,UAAU,MAAM;AACvC;AAAA,IACJ,KAAK;AACD,oBAAc;AACd,WAAK,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACrC,kBAAU,YAAY,CAAC,GAAG,UAAU,MAAM;AAAA,MAC9C;AACA;AAAA,IACJ,KAAK;AACD,oBAAc,cAAc,MAAM;AAClC,WAAK,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACrC,aAAK,IAAI,GAAG,IAAI,YAAY,CAAC,EAAE,QAAQ,KAAK;AACxC,oBAAU,YAAY,CAAC,EAAE,CAAC,GAAG,UAAU,MAAM;AAAA,QACjD;AAAA,MACJ;AACA;AAAA,IACJ;AACI,YAAM,IAAI,MAAM,0BAA0B;AAAA,EAClD;AACA,MAAI,YAAY,WAAW,GAAG;AAE1B,kBAAc,YAAY,CAAC;AAAA,EAC/B,OACK;AACD,WAAO,QAAQ;AAAA,EACnB;AACA,QAAM,SAAS;AAAA,IACX,MAAM;AAAA,IACN,UAAU;AAAA,MACN;AAAA,MACA;AAAA,IACJ;AAAA,IACA,YAAY,UAAU;AAAA,EAC1B;AACA,MAAI,UAAU,OAAO,MAAM;AACvB,WAAO,eAAe,CAAC;AACvB,WAAO,WAAW,KAAK,UAAU;AAAA,EACrC;AACA,SAAO;AACX;AAQA,SAAS,YAAY,KAAK,SAAS,KAAK;AACpC,MAAI,WAAW,KAAK;AAChB,QAAI,QAAQ;AACR,cAAQ,KAAK,IAAI,WAAW;AAAA,aACvB,QAAQ;AACb,cAAQ,KAAK,OAAO;AAAA,aACf,QAAQ;AACb,cAAQ,OAAO,IAAI,WAAW;AAAA,aACzB,QAAQ;AACb,cAAQ,YAAY,IAAI;AAAA,EAChC;AACJ;AAMA,SAAS,QAAQ,KAAK,SAAS;AAC3B,QAAM,MAAM,IAAI,WAAW,IAAI,IAAI;AACnC,SAAO,IAAI,MAAM,KAAK;AAClB,UAAM,MAAM,QAAQ,MAAM,IAAI,WAAW,CAAC;AAC1C,UAAM,QAAQ,QAAQ,QAAQ,IAAI,WAAW,CAAC;AAC9C,YAAQ,WAAW,GAAG,IAAI;AAAA,EAC9B;AACJ;;;AC/UO,IAAM,kBAAN,MAAsB;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,KAAK,KAAK;AAElB,SAAK,UAAU;AACf,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,SAAS;AAEd,SAAK,OAAO;AACZ,SAAK,QAAQ,CAAC;AACd,SAAK,UAAU,CAAC;AAChB,SAAK,YAAY,CAAC;AAClB,QAAI,WAAW,WAAW,MAAM,GAAG;AACnC,SAAK,SAAS,KAAK,UAAU;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,GAAG;AACjB,QAAI,IAAI,KAAK,KAAK,KAAK,UAAU,QAAQ;AACrC,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AACA,SAAK,KAAK,MAAM,KAAK,UAAU,CAAC;AAChC,UAAM,MAAM,KAAK,KAAK,WAAW,IAAI,KAAK,KAAK;AAC/C,WAAO,IAAI,kBAAkB,KAAK,MAAM,KAAK,KAAK,QAAQ,KAAK,OAAO,KAAK,OAAO;AAAA,EACtF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,GAAG,cAAc;AAC9B,QAAI,IAAI,KAAK,KAAK,KAAK,UAAU,QAAQ;AACrC,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AACA,SAAK,KAAK,MAAM,KAAK,UAAU,CAAC;AAChC,UAAM,MAAM,KAAK,KAAK,WAAW,IAAI,KAAK,KAAK;AAC/C,WAAO,IAAI,kBAAkB,KAAK,MAAM,KAAK,KAAK,QAAQ,KAAK,OAAO,KAAK,SAAS,YAAY;AAAA,EACpG;AACJ;AAOA,SAAS,UAAU,KAAK,OAAO,KAAK;AAChC,MAAI,SAAS,KAAK;AACd,QAAI,QAAQ;AACR,YAAM,UAAU,IAAI,WAAW;AAAA,aAC1B,QAAQ;AACb,YAAM,OAAO,IAAI,WAAW;AAAA,aACvB,QAAQ;AACb,YAAM,SAAS,IAAI,WAAW;AAAA,aACzB,QAAQ;AACb,YAAM,UAAU,KAAK,IAAI,GAAG;AAAA,aACvB,QAAQ;AACb,YAAM,MAAM,KAAK,IAAI,WAAW,CAAC;AAAA,aAC5B,QAAQ;AACb,YAAM,QAAQ,KAAK,iBAAiB,GAAG,CAAC;AAAA,EAChD;AACJ;AAMA,SAAS,iBAAiB,KAAK;AAC3B,MAAI,QAAQ;AACZ,QAAM,MAAM,IAAI,WAAW,IAAI,IAAI;AACnC,SAAO,IAAI,MAAM,KAAK;AAClB,UAAM,MAAM,IAAI,WAAW,KAAK;AAChC,YACI,QAAQ,IACF,IAAI,WAAW,IACf,QAAQ,IACJ,IAAI,UAAU,IACd,QAAQ,IACJ,IAAI,WAAW,IACf,QAAQ,IACJ,IAAI,aAAa,IACjB,QAAQ,IACJ,IAAI,WAAW,IACf,QAAQ,IACJ,IAAI,YAAY,IAChB,QAAQ,IACJ,IAAI,YAAY,IAChB;AAAA,EACtC;AACA,SAAO;AACX;;;ACrGO,IAAM,aAAN,MAAiB;AAAA,EACpB;AAAA,EACA,YAAY,KAAK,KAAK;AAClB,SAAK,SAAS,IAAI,WAAW,UAAU,CAAC,GAAG,GAAG;AAAA,EAClD;AACJ;AAOA,SAAS,SAAS,KAAK,QAAQ,KAAK;AAChC,MAAI,QAAQ,GAAG;AACX,QAAI,KAAK;AACL,YAAM,QAAQ,IAAI,gBAAgB,KAAK,IAAI,WAAW,IAAI,IAAI,GAAG;AACjE,UAAI,MAAM,UAAU,QAAQ;AACxB,eAAO,MAAM,IAAI,IAAI;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AACJ;;;AJZO,SAAS,SAAS,aAAa,SAAS;AAd/C;AAeI,QAAM,aAAa,aAAa,OAAO;AACvC,QAAM,UAAQ,wCAAS,QAAT,mBAAc,aAAU,wCAAS,QAAT,mBAAc,WAAS,mCAAS;AACtE,UAAQ,OAAO;AAAA,IACX,KAAK;AACD,aAAO,EAAE,OAAO,kBAAkB,MAAM,cAAc,aAAa,UAAU,EAAE;AAAA,IACnF,KAAK,iBAAiB;AAClB,YAAM,QAAQ;AAAA,QACV,OAAO;AAAA,QACP,MAAM;AAAA,QACN,UAAU,uBAAuB,aAAa,UAAU;AAAA,MAC5D;AACA,aAAO;AAAA,IACX;AAAA,IACA,KAAK;AACD,aAAO,uBAAuB,aAAa,UAAU;AAAA,IACzD,KAAK;AACD,aAAO,cAAc,aAAa,UAAU;AAAA,IAChD,KAAK;AACD,aAAO,cAAc,aAAa,UAAU;AAAA,IAChD;AACI,YAAM,IAAI,MAAM,SAAS,iBAAiB;AAAA,EAClD;AACJ;AACA,SAAS,cAAc,aAAa,SAAS;AACzC,QAAM,CAAC,qBAAqB,YAAY,IAAI,mBAAmB,aAAa,OAAO;AACnF,QAAM,iBAAa,gCAAoB,qBAAqB,YAAY;AAIxE,aAAW,aAAa,YAAY;AACpC,SAAO;AACX;AACA,SAAS,mBAAmB,aAAa,SAAS;AAC9C,QAAMA,YAAW,CAAC;AAClB,QAAM,eAAe;AAAA,IACjB,aAAa;AAAA,IACb,qBAAqB;AAAA,IACrB,oBAAoB;AAAA,IACpB,oBAAoB;AAAA,IACpB,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,uBAAuB;AAAA,IACvB,qBAAqB;AAAA,IACrB,mBAAmB;AAAA,IACnB,sBAAsB;AAAA,EAC1B;AACA,MAAI,YAAY,cAAc,GAAG;AAC7B,WAAO,CAACA,WAAU,YAAY;AAAA,EAClC;AACA,QAAM,OAAO,IAAI,WAAW,IAAI,WAAAC,QAAS,WAAW,CAAC;AACrD,QAAM,iBAAiB,WAAW,MAAM,QAAQ,QAAQ,MAAM,IAAI,QAAQ,SAAS,OAAO,KAAK,KAAK,MAAM;AAC1G,iBAAe,QAAQ,CAAC,cAAc;AAClC,UAAM,kBAAkB,KAAK,OAAO,SAAS;AAC7C,QAAI,CAAC,iBAAiB;AAClB;AAAA,IACJ;AACA,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC7C,YAAM,oBAAoB,gBAAgB,iBAAiB,GAAG,YAAY;AAC1E,YAAM,iBAAiB,wBAAwB,mBAAmB,SAAS,SAAS;AACpF,MAAAD,UAAS,KAAK,cAAc;AAAA,IAChC;AAAA,EACJ,CAAC;AACD,SAAO,CAACA,WAAU,YAAY;AAClC;AACA,SAAS,uBAAuB,aAAa,SAAS;AAClD,MAAI,YAAY,cAAc,GAAG;AAC7B,WAAO,CAAC;AAAA,EACZ;AACA,QAAMA,YAAW,CAAC;AAClB,QAAM,OAAO,IAAI,WAAW,IAAI,WAAAC,QAAS,WAAW,CAAC;AACrD,QAAM,iBAAiB,MAAM,QAAQ,QAAQ,MAAM,IAAI,QAAQ,SAAS,OAAO,KAAK,KAAK,MAAM;AAC/F,iBAAe,QAAQ,CAAC,cAAc;AAClC,UAAM,kBAAkB,KAAK,OAAO,SAAS;AAC7C,QAAI,CAAC,iBAAiB;AAClB;AAAA,IACJ;AACA,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC7C,YAAM,oBAAoB,gBAAgB,kBAAkB,CAAC;AAC7D,YAAM,iBAAiB,kBAAkB,mBAAmB,SAAS,SAAS;AAC9E,MAAAD,UAAS,KAAK,cAAc;AAAA,IAChC;AAAA,EACJ,CAAC;AACD,SAAOA;AACX;AAEA,SAAS,aAAa,SAAS;AApG/B;AAqGI,MAAI,EAAC,mCAAS,MAAK;AACf,UAAM,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AACA,QAAI,aAAQ,QAAR,mBAAa,iBAAgB,WAAW,CAAC,QAAQ,IAAI,WAAW;AAChE,UAAM,IAAI,MAAM,uDAAuD;AAAA,EAC3E;AACA,MAAI,QAAQ,KAAK;AACb,4BAAI,KAAK,yEAAyE,EAAE;AAAA,EACxF;AACA,SAAO,QAAQ;AACnB;AAMA,SAAS,kBAAkB,SAAS,SAAS,WAAW;AACpD,QAAM,iBAAiB,QAAQ,iBAAiB,QAAQ,eAAe,SAAS,QAAQ,SAAS;AAEjG,MAAI,QAAQ,eAAe;AACvB,mBAAe,eAAe,CAAC;AAC/B,mBAAe,WAAW,QAAQ,aAAa,IAAI;AAAA,EACvD;AACA,SAAO;AACX;AAMA,SAAS,wBAAwB,SAAS,SAAS,WAAW;AAC1D,QAAM,iBAAiB,QAAQ,gBAAgB,QAAQ,eAAe,SAAS,QAAQ,SAAS;AAEhG,MAAI,QAAQ,iBAAiB,eAAe,YAAY;AACpD,mBAAe,WAAW,QAAQ,aAAa,IAAI;AAAA,EACvD;AACA,SAAO;AACX;;;AKnIA,IAAME,WAAU,OAAiC,UAAU;AAIpD,IAAM,kBAAkB;AAAA,EAC3B,UAAU;AAAA,EACV,WAAW;AAAA,EACX,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,SAASA;AAAA;AAAA,EAET,YAAY,CAAC,OAAO,KAAK;AAAA,EACzB,WAAW;AAAA;AAAA,IAEP;AAAA,IACA;AAAA;AAAA,EAEJ;AAAA,EACA,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,SAAS;AAAA,IACL,KAAK;AAAA,MACD,OAAO;AAAA,MACP,aAAa;AAAA,MACb,eAAe;AAAA,MACf,QAAQ;AAAA,MACR,WAAW;AAAA,IACf;AAAA,EACJ;AACJ;AAIO,IAAM,YAAY;AAAA,EACrB,GAAG;AAAA,EACH,OAAO,OAAO,aAAa,YAAY,SAAS,aAAa,OAAO;AAAA,EACpE,WAAW;AAAA,EACX,QAAQ;AACZ;;;AC3CA,IAAAC,uBAAwC;AACxC,oBAAoD;AACpD,iBAA0C;AAEnC,IAAM,YAAY;AAAA,EACrB,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,YAAY,CAAC,KAAK;AAAA,EAClB,WAAW,CAAC,0BAA0B;AAAA,EACtC,SAAS;AAAA,IACL,KAAK;AAAA;AAAA,IAEL;AAAA,EACJ;AAAA,EACA,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,SAAS,CAAC,QAAQ;AAAA,EAClB,iBAAiB,KAAK,OAAO;AACzB,WAAO,IAAI,cAAc,KAAK,KAAK;AAAA,EACvC;AACJ;AAQO,IAAM,gBAAN,cAA4B,gCAAW;AAAA,EAC1C;AAAA,EACA;AAAA,EACA,cAAc;AAAA,EACd;AAAA,EACA,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX,YAAY,KAAK,OAAO;AA3C5B;AA4CQ,UAAM,KAAK;AACX,SAAK,QAAQ;AACb,SAAK,UAAM,kCAAY,GAAG;AAC1B,SAAK,gBAAc,WAAM,QAAN,mBAAW,gBAAe,GAAG,KAAK;AACrD,SAAK,cAAY,WAAM,QAAN,mBAAW,cAAa;AACzC,SAAK,OAAO,KAAK;AACjB,SAAK,cAAc,KAAK,YAAY,KAAK,IAAI;AAC7C,SAAK,WAAW,KAAK,YAAY;AACjC,QAAI,cAAc,KAAK,GAAG,GAAG;AACzB,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,cAAc;AAzDxB;AA0DQ,QAAI,CAAC,KAAK,aAAa;AACnB,aAAO;AAAA,IACX;AACA,QAAI;AACJ,QAAI;AAGA,iBAAW,MAAM,KAAK,MAAM,KAAK,WAAW;AAAA,IAChD,SACO,OAAP;AAEI,cAAQ,MAAM,MAAM,OAAO;AAC3B,aAAO;AAAA,IACX;AACA,QAAI,CAAC,SAAS,IAAI;AAEd,cAAQ,MAAM,SAAS,UAAU;AACjC,aAAO;AAAA,IACX;AACA,UAAM,WAAW,MAAM,SAAS,KAAK;AACrC,UAAM,aAAW,sCAAe,kBAAf,4BAA+B,cAAa;AAM7D,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,QAAQ,YAAY;AACtB,UAAM,EAAE,GAAG,GAAG,EAAE,IAAI;AACpB,UAAM,UAAU,KAAK,WAAW,GAAG,GAAG,CAAC;AACvC,UAAM,WAAW,MAAM,KAAK,MAAM,OAAO;AACzC,QAAI,CAAC,SAAS,IAAI;AACd,aAAO;AAAA,IACX;AACA,UAAM,cAAc,MAAM,SAAS,YAAY;AAC/C,WAAO;AAAA,EACX;AAAA;AAAA;AAAA,EAGA,MAAM,YAAY,YAAY;AAC1B,UAAM,EAAE,GAAG,GAAG,EAAE,IAAI,WAAW;AAG/B,UAAM,cAAc,MAAM,KAAK,QAAQ,EAAE,GAAG,GAAG,GAAG,QAAQ,CAAC,EAAE,CAAC;AAC9D,QAAI,gBAAgB,MAAM;AACtB,aAAO;AAAA,IACX;AACA,UAAM,oBAAgB,sCAAuB,WAAW;AACxD,SAAK,WACD,KAAK,aAAY,+CAAe,aAAY;AAChD,YAAQ,KAAK,UAAU;AAAA,MACnB,KAAK;AACD,eAAO,MAAM,KAAK,iBAAiB,aAAa,EAAE,GAAG,GAAG,GAAG,QAAQ,CAAC,EAAE,CAAC;AAAA,MAC3E;AACI,eAAO,MAAM,KAAK,gBAAgB,WAAW;AAAA,IACrD;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,aAAa,YAAY;AAC3B,UAAM,cAAc,MAAM,KAAK,QAAQ,UAAU;AACjD,WAAO,cAAc,KAAK,gBAAgB,WAAW,IAAI;AAAA,EAC7D;AAAA,EACA,MAAM,gBAAgB,aAAa;AAC/B,WAAO,MAAM,0BAAY,MAAM,aAAa,KAAK,WAAW;AAAA,EAChE;AAAA;AAAA,EAEA,MAAM,cAAc,YAAY;AAC5B,UAAM,cAAc,MAAM,KAAK,QAAQ,UAAU;AACjD,WAAO,cAAc,KAAK,iBAAiB,aAAa,UAAU,IAAI;AAAA,EAC1E;AAAA,EACA,MAAM,iBAAiB,aAAa,YAAY;AApIpD;AAqIQ,UAAM,cAAc;AAAA,MAChB,OAAO;AAAA,MACP,KAAK;AAAA,QACD,aAAa;AAAA,QACb,WAAW,EAAE,GAAG,WAAW,GAAG,GAAG,WAAW,GAAG,GAAG,WAAW,EAAE;AAAA,QAC/D,IAAG,UAAK,gBAAL,mBAAkB;AAAA,MACzB;AAAA,MACA,GAAG,KAAK;AAAA,IACZ;AACA,WAAO,MAAM,qBAAU,MAAM,aAAa,WAAW;AAAA,EACzD;AAAA,EACA,iBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,WAAW,GAAG,GAAG,GAAG;AAChB,YAAQ,KAAK,QAAQ;AAAA,MACjB,KAAK;AACD,eAAO,GAAG,KAAK,OAAO,KAAK,KAAK,IAAI,KAAK;AAAA,MAC7C,KAAK;AACD,eAAO,GAAG,KAAK,OAAO,KAAK,KAAK,IAAI,KAAK;AAAA,MAC7C,KAAK;AACD,eAAO,mBAAmB,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG;AAAA,MACpD;AACI,cAAM,IAAI,MAAM,KAAK,MAAM;AAAA,IACnC;AAAA,EACJ;AACJ;AACO,SAAS,cAAc,GAAG;AAC7B,SAAO,wEAAwE,KAAK,CAAC;AACzF;AACA,IAAM,SAAS,IAAI,OAAO,OAAO,GAAG;AACpC,IAAM,SAAS,IAAI,OAAO,OAAO,GAAG;AACpC,IAAM,SAAS,IAAI,OAAO,OAAO,GAAG;AAW7B,SAAS,mBAAmB,UAAU,GAAG,GAAG,GAAG,KAAK,KAAK;AAC5D,MAAI,MAAM,QAAQ,QAAQ,GAAG;AACzB,UAAM,IAAI,WAAW,EAAE,IAAI,SAAS;AACpC,eAAW,SAAS,CAAC;AAAA,EACzB;AACA,MAAI,MAAM;AACV,QAAM,IAAI,QAAQ,QAAQ,OAAO,CAAC,CAAC;AACnC,QAAM,IAAI,QAAQ,QAAQ,OAAO,CAAC,CAAC;AACnC,QAAM,IAAI,QAAQ,QAAQ,OAAO,CAAC,CAAC;AAEnC,MAAI,OAAO,UAAU,CAAC,KAAK,OAAO,UAAU,CAAC,GAAG;AAC5C,UAAM,IAAI,QAAQ,WAAW,OAAO,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC;AAAA,EAC/D;AACA,SAAO;AACX;AACA,SAAS,WAAW,GAAG;AACnB,SAAO,KAAK,IAAI,EAAE,MAAM,EAAE,EAAE,OAAO,CAAC,GAAG,OAAQ,KAAK,KAAK,IAAI,EAAE,WAAW,CAAC,IAAK,GAAG,CAAC,CAAC;AACzF;;;AC7LA,IAAAC,uBAAoB;AACpB,oBAAkC;AAClC,mBAA4B;;;ACCrB,SAAS,gBAAgBC,WAAU,GAAG,IAAI,IAAI,SAAS;AAC1D,QAAM,YAAY,MAAM,QAAQ,UAAU,IAAI,QAAQ,cAAc,KAAK,KAAK,QAAQ;AACtF,QAAM,OAAO;AAAA,IACT,eAAe,CAAC;AAAA,IAChB,gBAAgB;AAAA,IAChB,WAAW;AAAA,IACX,eAAe;AAAA,IACf,aAAaA,UAAS;AAAA,IACtB,GAAG;AAAA,IACH,GAAG;AAAA,IACH;AAAA,IACA,aAAa;AAAA,IACb,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,EACV;AACA,aAAW,WAAWA,WAAU;AAC5B,oBAAgB,MAAM,SAAS,WAAW,OAAO;AAAA,EACrD;AACA,SAAO;AACX;AAEA,SAAS,gBAAgB,MAAM,SAAS,WAAW,SAAS;AACxD,QAAM,WAAW,QAAQ;AACzB,QAAM,OAAO,QAAQ;AACrB,QAAM,qBAAqB,CAAC;AAC5B,OAAK,OAAO,KAAK,IAAI,KAAK,MAAM,QAAQ,IAAI;AAC5C,OAAK,OAAO,KAAK,IAAI,KAAK,MAAM,QAAQ,IAAI;AAC5C,OAAK,OAAO,KAAK,IAAI,KAAK,MAAM,QAAQ,IAAI;AAC5C,OAAK,OAAO,KAAK,IAAI,KAAK,MAAM,QAAQ,IAAI;AAC5C,MAAI;AACJ,UAAQ,MAAM;AAAA,IACV,KAAK;AAAA,IACL,KAAK;AACD,uBAAiB;AACjB,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AACzC,2BAAmB,KAAK,SAAS,CAAC,GAAG,SAAS,IAAI,CAAC,CAAC;AACpD,aAAK;AACL,aAAK;AAAA,MACT;AACA;AAAA,IACJ,KAAK;AACD,uBAAiB;AACjB,mBAAa,oBAAoB,UAAU,MAAM,WAAW,OAAO,KAAK;AACxE;AAAA,IACJ,KAAK;AACD,uBAAiB;AACjB,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,qBAAa,oBAAoB,SAAS,CAAC,GAAG,MAAM,WAAW,OAAO,MAAM,CAAC;AAAA,MACjF;AACA;AAAA,IACJ,KAAK;AACD,uBAAiB;AACjB,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,qBAAa,oBAAoB,SAAS,CAAC,GAAG,MAAM,WAAW,MAAM,MAAM,CAAC;AAAA,MAChF;AACA;AAAA,IACJ,KAAK;AACD,uBAAiB;AACjB,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,cAAM,UAAU,SAAS,CAAC;AAC1B,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,uBAAa,oBAAoB,QAAQ,CAAC,GAAG,MAAM,WAAW,MAAM,MAAM,CAAC;AAAA,QAC/E;AAAA,MACJ;AACA;AAAA,IACJ;AACI,YAAM,IAAI,MAAM,0BAA0B,MAAM;AAAA,EACxD;AACA,MAAI,mBAAmB,QAAQ;AAC3B,QAAI,OAAO,QAAQ,QAAQ;AAC3B,QAAI,SAAS,gBAAgB,QAAQ,aAAa;AAC9C,aAAO,CAAC;AACR,iBAAW,OAAO,QAAQ,MAAM;AAC5B,aAAK,GAAG,IAAI,QAAQ,KAAK,GAAG;AAAA,MAChC;AAGA,WAAK,oBAAoB,SAAS,QAAQ,SAAS;AAGnD,WAAK,kBAAkB,SAAS,MAAM,SAAS;AAAA,IACnD;AACA,UAAM,cAAc;AAAA,MAChB,UAAU;AAAA,MACV;AAAA;AAAA,MAEA;AAAA,IACJ;AACA,QAAI,QAAQ,OAAO,MAAM;AACrB,kBAAY,KAAK,QAAQ;AAAA,IAC7B;AACA,SAAK,cAAc,KAAK,WAAW;AAAA,EACvC;AACJ;AAEA,SAAS,aAAa,QAAQ,UAAU,MAAM,WAAW,WAAW,SAAS;AACzE,QAAM,cAAc,YAAY;AAChC,MAAI,YAAY,KAAK,SAAS,QAAQ,YAAY,cAAc,YAAY;AACxE,SAAK,aAAa,SAAS,SAAS;AACpC;AAAA,EACJ;AACA,QAAM,OAAO,CAAC;AACd,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AACzC,QAAI,cAAc,KAAK,SAAS,IAAI,CAAC,IAAI,aAAa;AAClD,WAAK;AACL,WAAK,KAAK,SAAS,CAAC,GAAG,SAAS,IAAI,CAAC,CAAC;AAAA,IAC1C;AACA,SAAK;AAAA,EACT;AACA,MAAI;AACA,WAAO,MAAM,OAAO;AACxB,SAAO,KAAK,IAAI;AACpB;AACA,SAAS,OAAO,MAAM,WAAW;AAC7B,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK,GAAG;AACjE,aAAS,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC;AAAA,EAC3D;AACA,MAAI,OAAO,MAAM,WAAW;AACxB,aAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,MAAM,GAAG,KAAK,GAAG;AACpD,YAAM,IAAI,KAAK,CAAC;AAChB,YAAM,IAAI,KAAK,IAAI,CAAC;AACpB,WAAK,CAAC,IAAI,KAAK,MAAM,IAAI,CAAC;AAC1B,WAAK,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,CAAC;AAC9B,WAAK,MAAM,IAAI,CAAC,IAAI;AACpB,WAAK,MAAM,IAAI,CAAC,IAAI;AAAA,IACxB;AAAA,EACJ;AACJ;;;ACjIO,SAAS,cAAc,WAAW,QAAQ;AAC7C,MAAI,UAAU,aAAa;AACvB,WAAO;AAAA,EACX;AACA,QAAM,KAAK,KAAK,UAAU;AAC1B,QAAM,KAAK,UAAU;AACrB,QAAM,KAAK,UAAU;AACrB,aAAW,gBAAgB,UAAU,eAAe;AAChD,UAAM,OAAO,aAAa;AAC1B,UAAM,iBAAiB,aAAa;AACpC,iBAAa,WAAW,CAAC;AACzB,QAAI,mBAAmB,GAAG;AACtB,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACrC,qBAAa,SAAS,KAAK,eAAe,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,QAAQ,IAAI,IAAI,EAAE,CAAC;AAAA,MACvF;AAAA,IACJ,OACK;AACD,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,cAAM,OAAO,CAAC;AACd,iBAAS,IAAI,GAAG,IAAI,KAAK,CAAC,EAAE,QAAQ,KAAK,GAAG;AACxC,eAAK,KAAK,eAAe,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,EAAE,IAAI,CAAC,GAAG,QAAQ,IAAI,IAAI,EAAE,CAAC;AAAA,QAC5E;AACA,qBAAa,SAAS,KAAK,IAAI;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AACA,YAAU,cAAc;AACxB,SAAO;AACX;AAEA,SAAS,eAAe,GAAG,GAAG,QAAQ,IAAI,IAAI,IAAI;AAC9C,SAAO,CAAC,KAAK,MAAM,UAAU,IAAI,KAAK,GAAG,GAAG,KAAK,MAAM,UAAU,IAAI,KAAK,GAAG,CAAC;AAClF;;;AClCO,SAAS,qBAAqB,WAAW,OAAO;AACnD,QAAMC,YAAW,CAAC;AAClB,aAAW,cAAc,UAAU,eAAe;AAC9C,QAAI,CAAC,cAAc,CAAC,WAAW,UAAU;AAErC;AAAA,IACJ;AACA,QAAI;AACJ,QAAI;AAEJ,YAAQ,WAAW,gBAAgB;AAAA,MAC/B,KAAK;AACD,YAAI,WAAW,SAAS,WAAW,GAAG;AAClC,iBAAO;AACP,wBAAc,WAAW,SAAS,CAAC;AAAA,QACvC,OACK;AACD,iBAAO;AACP,wBAAc,WAAW;AAAA,QAC7B;AACA;AAAA,MACJ,KAAK;AACD,YAAI,WAAW,SAAS,WAAW,GAAG;AAClC,iBAAO;AACP,wBAAc,WAAW,SAAS,CAAC;AAAA,QACvC,OACK;AACD,iBAAO;AACP,wBAAc,WAAW;AAAA,QAC7B;AACA;AAAA,MACJ,KAAK;AACD,YAAI,WAAW,SAAS,SAAS,GAAG;AAChC,iBAAO;AACP,wBAAc,CAAC,WAAW,QAAQ;AAAA,QACtC,OACK;AACD,iBAAO;AACP,wBAAc,WAAW;AAAA,QAC7B;AACA;AAAA,MACJ;AACI,cAAM,IAAI,MAAM,GAAG,WAAW,8CAA8C;AAAA,IACpF;AACA,YAAQ,MAAM,aAAa;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AACD,wBAAgB,aAAa,MAAM,WAAW,MAAM,MAAM;AAC1D;AAAA,MACJ;AACI,kCAA0B,aAAa,MAAM,MAAM;AACnD;AAAA,IACR;AACA,UAAM,UAAU;AAAA,MACZ,MAAM;AAAA,MACN,UAAU;AAAA,QACN;AAAA,QACA;AAAA,MACJ;AAAA,MACA,YAAY,WAAW,QAAQ,CAAC;AAAA,MAChC,IAAI,WAAW;AAAA,IACnB;AACA,IAAAA,UAAS,KAAK,OAAO;AAAA,EACzB;AACA,MAAIA,UAAS,WAAW,GAAG;AACvB,WAAO;AAAA,EACX;AACA,QAAM,QAAQ;AAAA,IACV,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAAA;AAAA,EACJ;AACA,SAAO;AACX;;;AC3EO,SAAS,mBAAmB,IAAI,MAAM,UAAU,MAAM;AACzD,QAAM,UAAU;AAAA;AAAA,IAEZ,IAAI,MAAM,OAAO,OAAO;AAAA,IACxB;AAAA,IACA,gBAAgB;AAAA;AAAA,IAChB;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,EACV;AAEA,UAAQ,MAAM;AAAA,IACV,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACD,mBAAa,SAAS,QAAQ;AAC9B;AAAA,IACJ,KAAK;AACD,iBAAW,QAAQ,UAAU;AACzB,qBAAa,SAAS,IAAI;AAAA,MAC9B;AACA;AAAA,IACJ,KAAK;AAED,mBAAa,SAAS,SAAS,CAAC,CAAC;AACjC;AAAA,IACJ,KAAK;AACD,iBAAW,WAAW,UAAU;AAE5B,qBAAa,SAAS,QAAQ,CAAC,CAAC;AAAA,MACpC;AACA;AAAA,IACJ;AACI,YAAM,IAAI,MAAM,OAAO,IAAI,CAAC;AAAA,EACpC;AACA,SAAO;AACX;AACA,SAAS,aAAa,SAAS,UAAU;AACrC,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AACzC,YAAQ,OAAO,KAAK,IAAI,QAAQ,MAAM,SAAS,CAAC,CAAC;AACjD,YAAQ,OAAO,KAAK,IAAI,QAAQ,MAAM,SAAS,IAAI,CAAC,CAAC;AACrD,YAAQ,OAAO,KAAK,IAAI,QAAQ,MAAM,SAAS,CAAC,CAAC;AACjD,YAAQ,OAAO,KAAK,IAAI,QAAQ,MAAM,SAAS,IAAI,CAAC,CAAC;AAAA,EACzD;AACJ;;;ACvCO,SAAS,aAAa,QAAQ,OAAO,MAAM,aAAa;AAC3D,MAAI,YAAY;AAChB,QAAM,MAAO,OAAO,SAAU;AAC9B,MAAI,cAAc,OAAO;AACzB,MAAI;AACJ,QAAM,KAAK,OAAO,KAAK;AACvB,QAAM,KAAK,OAAO,QAAQ,CAAC;AAC3B,QAAM,KAAK,OAAO,IAAI;AACtB,QAAM,KAAK,OAAO,OAAO,CAAC;AAC1B,WAAS,IAAI,QAAQ,GAAG,IAAI,MAAM,KAAK,GAAG;AACtC,UAAM,IAAI,aAAa,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,GAAG,IAAI,IAAI,IAAI,EAAE;AAC/D,QAAI,IAAI,WAAW;AACf,cAAQ;AACR,kBAAY;AAAA,IAChB,WACS,MAAM,WAAW;AAItB,YAAM,WAAW,KAAK,IAAI,IAAI,GAAG;AACjC,UAAI,WAAW,aAAa;AACxB,gBAAQ;AACR,sBAAc;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,YAAY,aAAa;AACzB,QAAI,QAAQ,QAAQ;AAChB,mBAAa,QAAQ,OAAO,OAAO,WAAW;AAClD,WAAO,QAAQ,CAAC,IAAI;AACpB,QAAI,OAAO,QAAQ;AACf,mBAAa,QAAQ,OAAO,MAAM,WAAW;AAAA,EACrD;AACJ;AAGA,SAAS,aAAa,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI;AACxC,MAAI,KAAK,KAAK;AACd,MAAI,KAAK,KAAK;AACd,MAAI,OAAO,KAAK,OAAO,GAAG;AACtB,UAAM,MAAM,KAAK,KAAK,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK;AAC5D,QAAI,IAAI,GAAG;AACP,UAAI;AACJ,UAAI;AAAA,IACR,WACS,IAAI,GAAG;AACZ,WAAK,KAAK;AACV,WAAK,KAAK;AAAA,IACd;AAAA,EACJ;AACA,OAAK,KAAK;AACV,OAAK,KAAK;AACV,SAAO,KAAK,KAAK,KAAK;AAC1B;;;ACvDO,SAAS,8BAA8B,MAAM,SAAS;AACzD,QAAM,gBAAgB,CAAC;AACvB,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACD,UAAI,IAAI;AACR,iBAAW,WAAW,KAAK,UAAU;AACjC,sBAAc,KAAK,eAAe,SAAS,SAAS,GAAG,CAAC;AAAA,MAC5D;AACA;AAAA,IACJ,KAAK;AACD,oBAAc,KAAK,eAAe,MAAM,OAAO,CAAC;AAChD;AAAA,IACJ;AAEI,oBAAc,KAAK,eAAe,EAAE,UAAU,KAAK,GAAG,OAAO,CAAC;AAAA,EACtE;AACA,SAAO;AACX;AAKA,SAAS,eAAe,SAAS,SAAS,OAAO;AAE7C,MAAI,CAAC,QAAQ,UAAU;AACnB;AAAA,EACJ;AACA,QAAM,SAAS,QAAQ,SAAS;AAChC,QAAM,OAAO,QAAQ,SAAS;AAC9B,QAAM,YAAY,KAAK,IAAI,QAAQ,cAAc,KAAK,QAAQ,WAAW,QAAQ,SAAS,CAAC;AAC3F,MAAI,WAAW,CAAC;AAChB,MAAI,KAAK,QAAQ;AACjB,MAAI,QAAQ,WAAW;AACnB,SAAK,QAAQ,WAAW,QAAQ,SAAS;AAAA,EAC7C,WACS,QAAQ,YAAY;AACzB,SAAK,SAAS;AAAA,EAClB;AACA,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,mBAAa,QAAQ,QAAQ;AAC7B;AAAA,IACJ,KAAK;AACD,iBAAW,KAAK,QAAQ;AACpB,qBAAa,GAAG,QAAQ;AAAA,MAC5B;AACA;AAAA,IACJ,KAAK;AACD,kBAAY,QAAQ,UAAU,WAAW,KAAK;AAC9C;AAAA,IACJ,KAAK;AACD,UAAI,QAAQ,aAAa;AAErB,mBAAW,QAAQ,QAAQ;AACvB,qBAAW,CAAC;AACZ,sBAAY,MAAM,UAAU,WAAW,KAAK;AAC5C,mBAAS,KAAK,mBAAmB,IAAI,cAAc,UAAU,QAAQ,UAAU,CAAC;AAAA,QACpF;AACA;AACA,qBAAa,QAAQ,UAAU,WAAW,KAAK;AAAA,MACnD;AACA;AAAA,IACJ,KAAK;AACD,mBAAa,QAAQ,UAAU,WAAW,IAAI;AAC9C;AAAA,IACJ,KAAK;AACD,iBAAW,WAAW,QAAQ;AAC1B,cAAM,aAAa,CAAC;AACpB,qBAAa,SAAS,YAAY,WAAW,IAAI;AACjD,iBAAS,KAAK,UAAU;AAAA,MAC5B;AACA;AAAA,IACJ,KAAK;AACD,iBAAW,kBAAkB,QAAQ,SAAS,YAAY;AACtD,uBAAe,UAAU;AAAA,UACrB;AAAA,UACA,UAAU;AAAA,UACV,YAAY,QAAQ;AAAA,QACxB,GAAG,SAAS,KAAK;AAAA,MACrB;AACA;AAAA,IACJ;AACI,YAAM,IAAI,MAAM,2CAA2C;AAAA,EACnE;AACA,SAAO,mBAAmB,IAAI,MAAM,UAAU,QAAQ,UAAU;AACpE;AACA,SAAS,aAAa,QAAQ,KAAK;AAC/B,MAAI,KAAK,SAAS,OAAO,CAAC,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC,GAAG,CAAC;AACxD;AACA,SAAS,YAAY,MAAM,KAAK,WAAW,WAAW;AAClD,MAAI,IAAI;AACR,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,UAAM,IAAI,SAAS,KAAK,CAAC,EAAE,CAAC,CAAC;AAC7B,UAAM,IAAI,SAAS,KAAK,CAAC,EAAE,CAAC,CAAC;AAC7B,QAAI,KAAK,GAAG,GAAG,CAAC;AAChB,QAAI,IAAI,GAAG;AACP,UAAI,WAAW;AACX,iBAAS,KAAK,IAAI,IAAI,MAAM;AAAA,MAChC,OACK;AACD,gBAAQ,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC;AAAA,MAC/D;AAAA,IACJ;AACA,SAAK;AACL,SAAK;AAAA,EACT;AACA,QAAM,OAAO,IAAI,SAAS;AAC1B,MAAI,CAAC,IAAI;AACT,eAAa,KAAK,GAAG,MAAM,SAAS;AACpC,MAAI,OAAO,CAAC,IAAI;AAChB,MAAI,OAAO,KAAK,IAAI,IAAI;AACxB,MAAI,QAAQ;AACZ,MAAI,MAAM,IAAI;AAClB;AACA,SAAS,aAAa,OAAO,KAAK,WAAW,WAAW;AACpD,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,OAAO,CAAC;AACd,gBAAY,MAAM,CAAC,GAAG,MAAM,WAAW,SAAS;AAChD,QAAI,KAAK,IAAI;AAAA,EACjB;AACJ;AACA,SAAS,SAAS,GAAG;AACjB,SAAO,IAAI,MAAM;AACrB;AACA,SAAS,SAAS,GAAG;AACjB,QAAM,MAAM,KAAK,IAAK,IAAI,KAAK,KAAM,GAAG;AACxC,QAAM,KAAK,MAAO,OAAO,KAAK,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAK,KAAK;AACjE,SAAO,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI;AACrC;;;ACzHO,SAAS,aAAaC,WAAU,OAAO,IAAI,IAAI,MAAM,QAAQ,QAAQ,SAAS;AACjF,QAAM;AACN,QAAM;AACN,MAAI,UAAU,MAAM,SAAS,IAAI;AAC7B,WAAOA;AAAA,EACX,WAES,SAAS,MAAM,UAAU,IAAI;AAClC,WAAO;AAAA,EACX;AACA,QAAM,UAAU,CAAC;AACjB,aAAW,WAAWA,WAAU;AAC5B,UAAM,WAAW,QAAQ;AACzB,QAAI,OAAO,QAAQ;AACnB,UAAM,MAAM,SAAS,IAAI,QAAQ,OAAO,QAAQ;AAChD,UAAM,MAAM,SAAS,IAAI,QAAQ,OAAO,QAAQ;AAChD,QAAI,OAAO,MAAM,MAAM,IAAI;AAEvB,cAAQ,KAAK,OAAO;AACpB;AAAA,IACJ,WACS,MAAM,MAAM,OAAO,IAAI;AAE5B;AAAA,IACJ;AACA,QAAI,cAAc,CAAC;AACnB,QAAI,SAAS,WAAW,SAAS,cAAc;AAC3C,iBAAW,UAAU,aAAa,IAAI,IAAI,IAAI;AAAA,IAClD,WACS,SAAS,cAAc;AAC5B,eAAS,UAAU,aAAa,IAAI,IAAI,MAAM,OAAO,QAAQ,WAAW;AAAA,IAC5E,WACS,SAAS,mBAAmB;AACjC,gBAAU,UAAU,aAAa,IAAI,IAAI,MAAM,KAAK;AAAA,IACxD,WACS,SAAS,WAAW;AACzB,gBAAU,UAAU,aAAa,IAAI,IAAI,MAAM,IAAI;AAAA,IACvD,WACS,SAAS,gBAAgB;AAC9B,iBAAW,WAAW,UAAU;AAC5B,cAAM,aAAa,CAAC;AACpB,kBAAU,SAAS,YAAY,IAAI,IAAI,MAAM,IAAI;AACjD,YAAI,WAAW,QAAQ;AACnB,sBAAY,KAAK,UAAU;AAAA,QAC/B;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,YAAY,QAAQ;AACpB,UAAI,QAAQ,eAAe,SAAS,cAAc;AAC9C,mBAAW,QAAQ,aAAa;AAC5B,kBAAQ,KAAK,mBAAmB,QAAQ,IAAI,MAAM,MAAM,QAAQ,IAAI,CAAC;AAAA,QACzE;AACA;AAAA,MACJ;AACA,UAAI,SAAS,gBAAgB,SAAS,mBAAmB;AACrD,YAAI,YAAY,WAAW,GAAG;AAC1B,iBAAO;AAEP,wBAAc,YAAY,CAAC;AAAA,QAC/B,OACK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,UAAI,SAAS,WAAW,SAAS,cAAc;AAC3C,eAAO,YAAY,WAAW,IAAI,UAAU;AAAA,MAChD;AACA,cAAQ,KAAK,mBAAmB,QAAQ,IAAI,MAAM,aAAa,QAAQ,IAAI,CAAC;AAAA,IAChF;AAAA,EACJ;AACA,SAAO,QAAQ,SAAS,UAAU;AACtC;AACA,SAAS,WAAW,MAAM,SAAS,IAAI,IAAI,MAAM;AAC7C,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACrC,UAAM,IAAI,KAAK,IAAI,IAAI;AACvB,QAAI,KAAK,MAAM,KAAK,IAAI;AACpB,eAAS,SAAS,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC;AAAA,IACvD;AAAA,EACJ;AACJ;AAEA,SAAS,SAAS,MAAM,SAAS,IAAI,IAAI,MAAM,WAAW,cAAc;AACpE,MAAI,QAAQ,SAAS,IAAI;AACzB,QAAM,YAAY,SAAS,IAAI,aAAa;AAC5C,MAAI,MAAM,KAAK;AACf,MAAI;AACJ,MAAI;AACJ,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG;AACzC,UAAMC,MAAK,KAAK,CAAC;AACjB,UAAMC,MAAK,KAAK,IAAI,CAAC;AACrB,UAAMC,MAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAMC,KAAI,SAAS,IAAIH,MAAKC;AAC5B,UAAM,IAAI,SAAS,IAAI,KAAK;AAC5B,QAAI,SAAS;AACb,QAAI,cAAc;AACd,eAAS,KAAK,KAAK,KAAK,IAAID,MAAK,IAAI,CAAC,IAAI,KAAK,IAAIC,MAAK,IAAI,CAAC,CAAC;AAAA,IAClE;AACA,QAAIE,KAAI,IAAI;AAER,UAAI,IAAI,IAAI;AACR,YAAI,UAAU,OAAOH,KAAIC,KAAI,IAAI,IAAI,EAAE;AACvC,YAAI,cAAc;AACd,gBAAM,QAAQ,MAAM,SAAS;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ,WACSE,KAAI,IAAI;AAEb,UAAI,IAAI,IAAI;AACR,YAAI,UAAU,OAAOH,KAAIC,KAAI,IAAI,IAAI,EAAE;AACvC,YAAI,cAAc;AACd,gBAAM,QAAQ,MAAM,SAAS;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ,OACK;AACD,eAAS,OAAOD,KAAIC,KAAIC,GAAE;AAAA,IAC9B;AACA,QAAI,IAAI,MAAMC,MAAK,IAAI;AAEnB,UAAI,UAAU,OAAOH,KAAIC,KAAI,IAAI,IAAI,EAAE;AACvC,eAAS;AAAA,IACb;AACA,QAAI,IAAI,MAAME,MAAK,IAAI;AAEnB,UAAI,UAAU,OAAOH,KAAIC,KAAI,IAAI,IAAI,EAAE;AACvC,eAAS;AAAA,IACb;AACA,QAAI,CAAC,aAAa,QAAQ;AACtB,UAAI,cAAc;AACd,cAAM,MAAM,MAAM,SAAS;AAAA,MAC/B;AACA,cAAQ,KAAK,KAAK;AAClB,cAAQ,SAAS,IAAI;AAAA,IACzB;AACA,QAAI,cAAc;AACd,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,MAAI,OAAO,KAAK,SAAS;AACzB,QAAM,KAAK,KAAK,IAAI;AACpB,QAAM,KAAK,KAAK,OAAO,CAAC;AACxB,QAAM,KAAK,KAAK,OAAO,CAAC;AACxB,QAAM,IAAI,SAAS,IAAI,KAAK;AAC5B,MAAI,KAAK,MAAM,KAAK;AAChB,aAAS,OAAO,IAAI,IAAI,EAAE;AAE9B,SAAO,MAAM,SAAS;AACtB,MAAI,aAAa,QAAQ,MAAM,MAAM,IAAI,MAAM,MAAM,CAAC,KAAK,MAAM,OAAO,CAAC,MAAM,MAAM,CAAC,IAAI;AACtF,aAAS,OAAO,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,EAChD;AAEA,MAAI,MAAM,QAAQ;AACd,YAAQ,KAAK,KAAK;AAAA,EACtB;AACJ;AAMA,SAAS,SAAS,MAAM;AACpB,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,KAAK;AAClB,QAAM,QAAQ,KAAK;AACnB,QAAM,MAAM,KAAK;AACjB,SAAO;AACX;AAEA,SAAS,UAAU,MAAM,SAAS,IAAI,IAAI,MAAM,WAAW;AACvD,aAAW,QAAQ,MAAM;AACrB,aAAS,MAAM,SAAS,IAAI,IAAI,MAAM,WAAW,KAAK;AAAA,EAC1D;AACJ;AACA,SAAS,SAAS,KAAK,GAAG,GAAG,GAAG;AAC5B,MAAI,KAAK,GAAG,GAAG,CAAC;AACpB;AAEA,SAAS,WAAW,KAAK,IAAI,IAAI,IAAI,IAAI,GAAG;AACxC,QAAM,KAAK,IAAI,OAAO,KAAK;AAC3B,WAAS,KAAK,GAAG,MAAM,KAAK,MAAM,GAAG,CAAC;AACtC,SAAO;AACX;AAEA,SAAS,WAAW,KAAK,IAAI,IAAI,IAAI,IAAI,GAAG;AACxC,QAAM,KAAK,IAAI,OAAO,KAAK;AAC3B,WAAS,KAAK,MAAM,KAAK,MAAM,GAAG,GAAG,CAAC;AACtC,SAAO;AACX;;;ACrMO,SAAS,aAAaG,WAAU,SAAS;AAC5C,QAAM,SAAS,QAAQ,SAAS,QAAQ;AACxC,MAAI,SAASA;AACb,QAAM,OAAO,aAAaA,WAAU,GAAG,KAAK,QAAQ,QAAQ,GAAG,IAAI,GAAG,OAAO;AAC7E,QAAM,QAAQ,aAAaA,WAAU,GAAG,IAAI,QAAQ,IAAI,QAAQ,GAAG,IAAI,GAAG,OAAO;AACjF,MAAI,QAAQ,OAAO;AACf,aAAS,aAAaA,WAAU,GAAG,CAAC,QAAQ,IAAI,QAAQ,GAAG,IAAI,GAAG,OAAO,KAAK,CAAC;AAC/E,QAAI,MAAM;AACN,eAAS,mBAAmB,MAAM,CAAC,EAAE,OAAO,MAAM;AAAA,IACtD;AACA,QAAI,OAAO;AACP,eAAS,OAAO,OAAO,mBAAmB,OAAO,EAAE,CAAC;AAAA,IACxD;AAAA,EACJ;AACA,SAAO;AACX;AAOA,SAAS,mBAAmBA,WAAU,QAAQ;AAC1C,QAAM,cAAc,CAAC;AACrB,WAAS,IAAI,GAAG,IAAIA,UAAS,QAAQ,KAAK;AACtC,UAAM,UAAUA,UAAS,CAAC;AAC1B,UAAM,OAAO,QAAQ;AACrB,QAAI;AACJ,YAAQ,MAAM;AAAA,MACV,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,sBAAc,YAAY,QAAQ,UAAU,MAAM;AAClD;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AACD,sBAAc,CAAC;AACf,mBAAW,QAAQ,QAAQ,UAAU;AACjC,sBAAY,KAAK,YAAY,MAAM,MAAM,CAAC;AAAA,QAC9C;AACA;AAAA,MACJ,KAAK;AACD,sBAAc,CAAC;AACf,mBAAW,WAAW,QAAQ,UAAU;AACpC,gBAAM,aAAa,CAAC;AACpB,qBAAW,QAAQ,SAAS;AAExB,uBAAW,KAAK,YAAY,MAAM,MAAM,CAAC;AAAA,UAC7C;AACA,sBAAY,KAAK,UAAU;AAAA,QAC/B;AACA;AAAA,MACJ;AACI,cAAM,IAAI,MAAM,OAAO,IAAI,CAAC;AAAA,IACpC;AACA,gBAAY,KAAK,mBAAmB,QAAQ,IAAI,MAAM,aAAa,QAAQ,IAAI,CAAC;AAAA,EACpF;AACA,SAAO;AACX;AAYA,SAAS,YAAY,QAAQ,QAAQ;AACjC,QAAM,YAAY,CAAC;AACnB,YAAU,OAAO,OAAO;AACxB,MAAI,OAAO,UAAU,QAAW;AAC5B,cAAU,QAAQ,OAAO;AACzB,cAAU,MAAM,OAAO;AAAA,EAC3B;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACvC,cAAU,KAAK,OAAO,CAAC,IAAI,QAAQ,OAAO,IAAI,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;AAAA,EACnE;AACA,SAAO;AACX;;;AR/EO,IAAM,kBAAkB;AAAA,EAC3B,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,SAAS;AAAA,EACT,YAAY,CAAC,KAAK;AAAA,EAClB,WAAW,CAAC,0BAA0B;AAAA,EACtC,SAAS;AAAA,IACL,OAAO;AAAA,MACH,aAAa;AAAA,MACb,WAAW;AAAA,MACX,SAAS;AAAA,MACT,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,YAAY;AAAA,IAChB;AAAA,EACJ;AAAA,EACA,MAAM;AAAA,EACN,SAAS,CAAC,QAAQ,IAAI,SAAS,UAAU;AAAA,EACzC,iBAAiB,KAAK,SAAS;AAnCnC;AAoCQ,UAAM,eAAe,OAAO,QAAQ,YAAY,eAAe;AAC/D,UAAM,UAAS,8CAAS,UAAT,mBAAgB,YAAhB,mBAA0B;AACzC,UAAM,eAAe,eAAe,UAAU,KAAK,MAAM,IAAI;AAC7D,WAAO,IAAI,wBAAwB,cAAc,OAAO;AAAA,EAC5D;AAAA;AAEJ;AACA,eAAe,UAAU,KAAK,QAAQ;AAClC,MAAI,OAAO,QAAQ,UAAU;AACzB,UAAM,WAAW,MAAM,MAAM,GAAG;AAChC,UAAMC,QAAO,MAAM,SAAS,YAAY;AACxC,WAAQ,MAAM,OAAO,MAAMA,KAAI;AAAA,EACnC;AACA,QAAM,OAAO,MAAM,IAAI,YAAY;AACnC,SAAQ,MAAM,OAAO,MAAM,IAAI;AACnC;AAgBO,IAAM,2BAAN,MAA8B;AAAA;AAAA,EAOjC,QAAQ,IAAI,mBAAM;AAAA,IACd,IAAI;AAAA,IACJ,OAAO,CAAC,IAAI,kBAAK,SAAS,OAAO,GAAG,IAAI,kBAAK,YAAY,OAAO,CAAC;AAAA,EACrE,CAAC;AAAA;AAAA,EAED,WAAW;AAAA,EACX,mBAAmB;AAAA;AAAA;AAAA,EAGnB;AAAA;AAAA,EAEA,SAAS;AAAA;AAAA,EAET,QAAQ,CAAC;AAAA;AAAA,EAET,aAAa,CAAC;AAAA;AAAA,EAEd;AAAA;AAAA,EAEA;AAAA,EACA,YAAY,OAAO,OAAO;AAEtB,SAAK,QAAQ,EAAE,GAAG,gBAAgB,QAAQ,OAAO,GAAG,+BAAO,MAAM;AACjE,SAAK,cAAc,KAAK,YAAY,KAAK,IAAI;AAC7C,SAAK,QAAQ,KAAK,qBAAqB,KAAK;AAC5C,SAAK,WAAW,KAAK,YAAY;AAAA,EACrC;AAAA,EACA,MAAM,qBAAqB,cAAc;AACrC,UAAM,QAAQ,MAAM;AACpB,SAAK,aAAS,iCAAkB,KAAK;AACrC,SAAK,gBAAgB,KAAK;AAAA,EAC9B;AAAA,EACA,MAAM,cAAc;AAChB,UAAM,KAAK;AACX,WAAO,EAAE,QAAQ,KAAK,QAAQ,SAAS,GAAG,SAAS,KAAK,MAAM,QAAQ;AAAA,EAC1E;AAAA,EACA,MAAM,YAAY;AACd,UAAM,KAAK;AACX,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,WAAW;AAC3B,UAAM,KAAK;AACX,UAAM,QAAQ,KAAK,YAAY,SAAS;AACxC,6BAAI,KAAK,GAAG,iBAAiB,WAAW,KAAK,EAAE;AAC/C,WAAO;AAAA,EACX;AAAA,EACA,MAAM,QAAQ,WAAW;AACrB,UAAM,KAAK;AACX,WAAO,KAAK,YAAY,SAAS;AAAA,EACrC;AAAA,EACA,MAAM,YAAY,YAAY;AAC1B,UAAM,EAAE,GAAG,GAAG,EAAE,IAAI,WAAW;AAC/B,UAAM,OAAO,MAAM,KAAK,cAAc,EAAE,GAAG,GAAG,EAAE,CAAC;AACjD,YAAO,6BAAM,aAAY,CAAC;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,WAAW;AACnB,UAAM,YAAY,KAAK,aAAa,SAAS;AAC7C,QAAI,CAAC,WAAW;AACZ,aAAO;AAAA,IACX;AACA,WAAO,qBAAqB,WAAW;AAAA,MACnC,aAAa,KAAK,MAAM;AAAA,MACxB;AAAA,MACA,QAAQ,KAAK,MAAM;AAAA,IACvB,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,OAAO;AACnB,QAAI,KAAK,MAAM,UAAU,KAAK,KAAK,MAAM,UAAU,IAAI;AACnD,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACzD;AACA,QAAI,KAAK,MAAM,aAAa,KAAK,MAAM,YAAY;AAC/C,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACvE;AACA,6BAAI,IAAI,GAAG,+CAA+C,KAAK,KAAK,EAAE;AAEtE,6BAAI,KAAK,GAAG,kBAAkB,EAAE;AAChC,QAAIC,YAAW,8BAA8B,OAAO,KAAK,KAAK;AAC9D,6BAAI,QAAQ,GAAG,kBAAkB,EAAE;AAEnC,6BAAI,KAAK,GAAG,gBAAgB,EAAE;AAC9B,IAAAA,YAAW,aAAaA,WAAU,KAAK,KAAK;AAE5C,QAAIA,UAAS,WAAW,GAAG;AACvB,+BAAI,IAAI,GAAG,gDAAgD,EAAE;AAC7D;AAAA,IACJ;AACA,SAAK,UAAUA,WAAU,GAAG,GAAG,CAAC;AAChC,UAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,6BAAI,IAAI,GAAG,uBAAuB,SAAS,wBAAwB,SAAS,WAAW,EAAE;AACzF,6BAAI,QAAQ,GAAG,gBAAgB,EAAE;AACjC,6BAAI,IAAI,GAAG,6CAA6C,KAAK,MAAM,IAAI,OAAO,EAAE,SAAS,KAAK,KAAK,EAAE;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,WAAW;AACpB,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,QAAI,EAAE,EAAE,IAAI;AAIZ,UAAM,EAAE,OAAO,IAAI,KAAK;AACxB,QAAI,IAAI,KAAK,IAAI,IAAI;AACjB,aAAO;AAAA,IACX;AACA,UAAM,KAAK,KAAK;AAChB,QAAK,IAAI,KAAO,KAAK;AACrB,UAAM,KAAK,KAAK,GAAG,GAAG,CAAC;AACvB,QAAI,KAAK,MAAM,EAAE,GAAG;AAChB,aAAO,cAAc,KAAK,MAAM,EAAE,GAAG,MAAM;AAAA,IAC/C;AACA,6BAAI,IAAI,0BAAK,8BAA8B,GAAG,GAAG,CAAC,EAAE;AACpD,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI;AACJ,WAAO,CAAC,UAAU,KAAK,GAAG;AACtB;AACA,WAAK,MAAM;AACX,WAAK,MAAM;AACX,eAAS,KAAK,MAAM,KAAK,IAAI,IAAI,EAAE,CAAC;AAAA,IACxC;AACA,QAAI,CAAC,UAAU,CAAC,OAAO,gBAAgB;AACnC,aAAO;AAAA,IACX;AAEA,6BAAI,IAAI,GAAG,+BAA+B,IAAI,IAAI,EAAE,EAAE;AACtD,6BAAI,KAAK,GAAG,eAAe,EAAE;AAC7B,SAAK,UAAU,OAAO,gBAAgB,IAAI,IAAI,IAAI,GAAG,GAAG,CAAC;AACzD,6BAAI,QAAQ,GAAG,eAAe,EAAE;AAChC,WAAO,KAAK,MAAM,EAAE,IAAI,cAAc,KAAK,MAAM,EAAE,GAAG,MAAM,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAUA,WAAU,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI;AACrC,UAAM,QAAQ,CAACA,WAAU,GAAG,GAAG,CAAC;AAEhC,WAAO,MAAM,QAAQ;AACjB,UAAI,MAAM,IAAI;AACd,UAAI,MAAM,IAAI;AACd,UAAI,MAAM,IAAI;AACd,MAAAA,YAAW,MAAM,IAAI;AACrB,YAAM,KAAK,KAAK;AAChB,YAAM,KAAK,KAAK,GAAG,GAAG,CAAC;AACvB,UAAI,OAAO,KAAK,MAAM,EAAE;AACxB,UAAI,CAAC,MAAM;AACP,iCAAI,KAAK,GAAG,eAAe,EAAE;AAC7B,eAAO,KAAK,MAAM,EAAE,IAAI,gBAAgBA,WAAU,GAAG,GAAG,GAAG,KAAK,KAAK;AACrE,aAAK,WAAW,KAAK,EAAE,GAAG,GAAG,EAAE,CAAC;AAChC,cAAM,MAAM,IAAI;AAChB,YAAI,OAAO,KAAK,MAAM,IAAI,KAAK,OAAO;AACtC,aAAK,eAAe;AACpB,eAAO,KAAK,MAAM,IAAI,OAAO;AAC7B,aAAK,eAAe;AACpB,eAAO,yBAAwB,MAAM,IAAI,KAAK,OAAO;AACrD,aAAK,eAAe;AACpB,eAAO,yBAAwB,MAAM,IAAI,OAAO;AAChD,aAAK,eAAe;AACpB,iCAAI,IAAI,GAAG,6DAA6D,GAAG,GAAG,GAAG,KAAK,aAAa,KAAK,WAAW,KAAK,aAAa,EAAE;AACvI,iCAAI,QAAQ,GAAG,eAAe,EAAE;AAAA,MACpC;AAEA,WAAK,iBAAiBA;AAGtB,UAAI,OAAO,QAAW;AAElB,YAAI,MAAM,KAAK,MAAM,gBAAgB,KAAK,aAAa,KAAK,MAAM,kBAAkB;AAChF;AAAA,QACJ;AAAA,MAEJ,WACS,MAAM,KAAK,MAAM,WAAW,MAAM,IAAI;AAE3C;AAAA,MACJ,WACS,OAAO,QAAW;AAEvB,cAAM,YAAY,KAAK;AAEvB,YAAI,MAAM,MAAM,aAAa,MAAM,MAAM,WAAW;AAChD;AAAA,QACJ;AAAA,MACJ;AAEA,WAAK,iBAAiB;AACtB,UAAIA,UAAS,WAAW;AACpB;AACJ,+BAAI,KAAK,GAAG,eAAe,EAAE;AAE7B,YAAM,KAAM,MAAM,KAAK,MAAM,SAAU,KAAK,MAAM;AAClD,YAAM,KAAK,MAAM;AACjB,YAAM,KAAK,MAAM;AACjB,YAAM,KAAK,IAAI;AACf,UAAI,KAAK;AACT,UAAI,KAAK;AACT,UAAI,KAAK;AACT,UAAI,KAAK;AACT,UAAI,OAAO,aAAaA,WAAU,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AACzF,UAAI,QAAQ,aAAaA,WAAU,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AAE1F,MAAAA,YAAW;AACX,UAAI,MAAM;AACN,aAAK,aAAa,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AAC/E,aAAK,aAAa,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AAC/E,eAAO;AAAA,MACX;AACA,UAAI,OAAO;AACP,aAAK,aAAa,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AAChF,aAAK,aAAa,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK;AAChF,gBAAQ;AAAA,MACZ;AACA,+BAAI,QAAQ,GAAG,eAAe,EAAE;AAChC,YAAM,KAAK,MAAM,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;AACxC,YAAM,KAAK,MAAM,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,CAAC;AAC5C,YAAM,KAAK,MAAM,CAAC,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,CAAC;AAC5C,YAAM,KAAK,MAAM,CAAC,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;AAAA,IACpD;AAAA,EACJ;AACJ;AAzPO,IAAM,0BAAN;AAAA;AAEH,cAFS,yBAEF,SAAQ,IAAI,mBAAM;AAAA,EACrB,IAAI;AAAA,EACJ,OAAO,CAAC,IAAI,kBAAK,SAAS,OAAO,GAAG,IAAI,kBAAK,SAAS,UAAU,CAAC;AACrE,CAAC;AAqPL,SAAS,KAAK,GAAG,GAAG,GAAG;AACnB,WAAS,KAAK,KAAK,IAAI,KAAK,KAAK;AACrC;",
  "names": ["features", "Protobuf", "VERSION", "import_loader_utils", "import_loader_utils", "features", "features", "features", "ax", "ay", "az", "a", "features", "data", "features"]
}
