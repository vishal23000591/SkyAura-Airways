/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{ChapmanRaymarching as e}from"../views/3d/environment/ChapmanRaymarching.glsl.js";import{Gamma as r}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js";import{addMainLightDirection as a}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Float3PassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as o,If as n}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as l}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{ScreenSpacePassAtmosphere as s}from"../views/3d/webgl-engine/shaders/ScreenSpacePassAtmosphere.glsl.js";import{SphereIntersect as c}from"../views/3d/webgl-engine/shaders/SphereIntersect.glsl.js";import{ToneMapping as m}from"../views/3d/webgl-engine/shaders/ToneMapping.glsl.js";import{ShaderBuilder as d}from"../views/webgl/ShaderBuilder.js";function g(g){const h=new d;h.include(s);const{reduced:p}=g,{fragment:u}=h;return a(u),u.include(r),u.include(c),u.include(m),u.include(e,!1),u.uniforms.add(new t("backgroundColor",(e=>e.backgroundColor)),new i("innerFadeDistance",(e=>e.innerFadeDistance)),new i("altitudeFade",(e=>e.altitudeFade)),new l("depthTexture",(e=>e.mainDepth))).code.add(o`vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {
float rayPlanetDistance = heightParameters[1] - radii[0] * radii[0];
vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, rayPlanetDistance);
if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {
return fragColor;
}
float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));
vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);
float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;
if (relDist > 1.0) {
return surfaceColor;
}
return mix(fragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));
}
float getGlow(float dist, float radius, float intensity) {
return pow(radius / max(dist, 1e-6), intensity);
}
vec3 getSun(vec3 cameraPos, vec3 rayDir, vec3 lightDir){
float scaleFract = (length(cameraPos) - radii[0]) / scaleHeight;
float sunOpticalDepth = getOpticalDepth(cameraPos, rayDir, max(scaleFract, 0.0));
vec3 sunTransmittance = exp(-(mix(betaCombined, betaRayleigh, 0.5)) * max(0.0, sunOpticalDepth));
float mu = clamp(dot(rayDir, lightDir), 0.0, 1.0);
float sunDisc = 256.0 * smoothstep(0.0, 128.0, clamp(getGlow(1.0 - mu, 3e-5, 3.0), 0.0, 128.0));
return normalize(sunTransmittance) * sunDisc;
}`).main.add(o`
      vec3 rayDir = normalize(worldRay);
      float terrainDepth = -1.0;
      ${n(!p,o`float depthSample = texture(depthTexture, uv).r;
             if (depthSample != 1.0) {
                fragColor = vec4(0);
                return;
             }`)}

      vec3 col = linearizeGamma(backgroundColor);
      col += raymarchAtmosphere(cameraPosition, rayDir, mainLightDirection, terrainDepth);
      col += getSun(cameraPosition, rayDir, mainLightDirection);
      float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));

      col = tonemapACES(col);
      fragColor = delinearizeGamma(vec4(col, alpha));
      fragColor = applyUndergroundAtmosphere(rayDir, mainLightDirection, fragColor);
  `),h}const h=Object.freeze(Object.defineProperty({__proto__:null,build:g},Symbol.toStringTag,{value:"Module"}));export{h as C,g as b};
