/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{G as e}from"./SimpleGeometryCursor.js";import{E as t,n as s,a as r}from"./MultiPathImpl.js";import{c as n,G as o,g as a,a as i}from"./Geometry.js";import{Envelope2D as m}from"./Envelope2D.js";import{i as l,b as g,P as h}from"./Envelope.js";import{O as u,m as c,q as p,t as P,C as y,u as _}from"./ProjectionTransformation.js";class d{getOperatorType(){return 10700}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,s,r=1){return new I(e,t,s,r)}}class I extends e{constructor(e,t,s,r){super(),this.m_progressTracker=s,this.m_inputGeoms=e,this.m_spatialReference=t,this.m_currentGeometry=null,this.m_singlePartIndex=-1,this.m_singlePartCount=-1,this.m_polygonStart=-1,this.m_index=-1,this.m_options=r}tock(){return!0}getRank(){return 1}next(){if(this.m_singlePartIndex===this.m_singlePartCount){const e=this.m_inputGeoms.next();if(null===e)return null;if(n(e),e.getGeometryType()===o.enumPolygon)if(1===this.m_options)this.m_currentGeometry=(new u).execute(e,this.m_spatialReference,!1,this.m_progressTracker);else if(2===this.m_options)if(e.getPathCount()<2)this.m_currentGeometry=e;else{const n=[0],o=e.getImpl().getIsSimple(0,n);if(l(o))this.m_currentGeometry=e;else{const n=new t,o=n.addGeometry(e);let i=null;if(n.hasCurves()){i=new y;const t=new m;e.queryEnvelope(t);const s=g(null,e,!0),r=c(s.total(),t);p(n,r,s.total(),12e3,null,i,null,this.m_progressTracker)}const l=n.createPathUserIndex();{let e=0;for(let t=n.getFirstPath(o);t!==s;t=n.getNextPath(t))n.setPathUserIndex(t,l,e++)}const h=P(n,o,this.m_progressTracker);a(h>=0);const u=[];for(let e=n.getFirstPath(o);e!==s;e=n.getNextPath(e))u.push(e);u.sort(((e,t)=>Math.abs(n.getPathUserIndex(e,h))-Math.abs(n.getPathUserIndex(t,h))));const _=e,d=new r({vd:e.getDescription()});d.reserveParts(_.getPointCount(),_.getPathCount());for(let e=0,t=u.length;e<t;e++){const t=u[e],s=n.getPathUserIndex(t,l),r=_.calculateRingArea2D(s)>0,o=n.getPathUserIndex(t,h)>=0;d.addPath(_,s,r===o)}this.m_currentGeometry=d}}else i("");else this.m_currentGeometry=e;this.m_singlePartCount=f(this.m_currentGeometry),this.m_singlePartIndex=0,this.m_polygonStart=0,this.m_index=this.m_inputGeoms.getGeometryID()}const e=this.getSingleGeometry(this.m_singlePartIndex,this.m_singlePartCount,this.m_polygonStart,this.m_currentGeometry);return e.getGeometryType()===o.enumPolygon&&(this.m_polygonStart+=e.getPathCount()),this.m_singlePartIndex++,e}getGeometryID(){return this.m_index}getSingleGeometry(e,t,s,r){let n=null;switch(r.getGeometryType()){case o.enumMultiPoint:n=new h({vd:r.getDescription()}),r.isEmpty()||r.getPointByVal(e,n);break;case o.enumPolyline:if(1===t)n=r;else{n=r.createInstance(),n.getImpl().addPath(r.getImpl(),e,!0);const t=[0],s=r.getImpl().getIsSimple(0,t);n.getImpl().setIsSimple(s,t[0],!0)}break;case o.enumPolygon:if(1===t)n=r;else{n=r.createInstance();const e=n.getImpl(),t=r.getImpl(),o=t.getPathFlagsStreamRef();let a=s;const i=t.getPathCount();do{e.addPath(t,a,!0),a++}while(a<i&&!(8&o.read(a)));e.getPathFlagsStreamRef().setBits(0,8);const m=[0],l=t.getIsSimple(0,m);e.setIsSimple(l,m[0],!0)}break;default:n=r}return n}}function f(e){return e.isEmpty()?1:_(e)}export{d as O};
