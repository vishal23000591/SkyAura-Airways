/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{ChapmanRaymarching as e}from"../views/3d/environment/ChapmanRaymarching.glsl.js";import{ReadDepth as r}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js";import{Gamma as t}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js";import{addMainLightDirection as a}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{FloatPassUniform as i}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as n,If as o}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as l}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{ScreenSpacePassAtmosphere as d}from"../views/3d/webgl-engine/shaders/ScreenSpacePassAtmosphere.glsl.js";import{SphereIntersect as s}from"../views/3d/webgl-engine/shaders/SphereIntersect.glsl.js";import{ToneMapping as p}from"../views/3d/webgl-engine/shaders/ToneMapping.glsl.js";import{ShaderBuilder as c}from"../views/webgl/ShaderBuilder.js";function h(h){const m=new c,{fragment:g}=m;m.include(d),a(g),g.include(t),g.include(r),g.include(s),g.include(p),g.include(e,!0),g.uniforms.add(new l("depthTexture",(e=>e.mainDepth)),new i("hazeStrength",(e=>e.hazeStrength)));const{reduced:u}=h;return u&&g.code.add(n`float getDepth(vec2 uv){
return linearDepthFromTexture(depthTexture, uv);
}
float textureBilinear(vec2 uv) {
vec2 depthTextureSize = vec2(textureSize(depthTexture, 0));
vec2 texelSize = 1.0 / depthTextureSize;
vec2 depthUV = (uv * depthTextureSize) - vec2(0.5);
vec2 f = fract(depthUV);
vec2 snapUV = (floor(depthUV) + vec2(0.5)) / depthTextureSize;
float d0 = getDepth(snapUV);
float d1 = getDepth(snapUV + vec2(texelSize.x, 0.0));
float d2 = getDepth(snapUV + vec2(0.0, texelSize.y));
float d3 = getDepth(snapUV + texelSize);
return mix(mix(d0, d1, f.x), mix(d2, d3, f.x), f.y);
}`),g.main.add(n`
      vec3 rayDir = normalize(worldRay);
      float terrainDepth = -1.0;

      float depthSample = texture(depthTexture, uv).r;
      if (depthSample != 1.0) {
        vec3 cameraSpaceRay = normalize(eyeDir);
        cameraSpaceRay /= cameraSpaceRay.z;

        cameraSpaceRay *= ${o(u,"-textureBilinear(uv)","-linearDepthFromTexture(depthTexture, uv)")};
        terrainDepth = max(0.0, length(cameraSpaceRay));
      } else {
        discard;
      }

      // Alpha is ignored for haze blending
      vec3 col = vec3(0);
      float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);
      if(depthSample != 1.0){
        col = (1.0 - fadeOut) * hazeStrength * raymarchAtmosphere(cameraPosition, rayDir, mainLightDirection, terrainDepth);
      }
      float alpha = 1.0;

      col = tonemapACES(col);
      fragColor = delinearizeGamma(vec4(col, alpha));
  `),m}const m=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:"Module"}));export{m as H,h as b};
