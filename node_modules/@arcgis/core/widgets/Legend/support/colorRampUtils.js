/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import l from"../../../Color.js";import{isSome as e}from"../../../core/arrayUtils.js";import{createStopLabel as o}from"./utils.js";const r=new l([64,64,64]);function n(l,e){const r=[],n=l.length-1;return 5===l.length?r.push(0,2,4):r.push(0,n),l.map(((l,t)=>r.includes(t)?o(l,t,n,e):null))}async function t(l,o,r){let t=!1,u=[],s=[];if(l.stops){const e=l.stops;u=e.map((l=>l.value)),t=e.some((l=>!!l.label)),t&&(s=e.map((l=>l.label)))}const i=u[0],c=u[u.length-1];if(null==i&&null==c)return null;const p=t?null:n(u,r);return(await Promise.all(u.map((async(e,r)=>{const n="opacity"===l.type?await a(e,l,o):(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getColor(l,e),u=t?s[r]:p?.[r]??"";return null==n?null:{value:e,color:n,label:u}})))).filter(e).reverse()}async function a(e,o,n){const t=new l(n??r),a=(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getOpacity(o,e);return null!=a&&(t.a=a),t}function u(l){let e=!1,o=[],r=[];o=l.map((l=>l.value)),e=l.some((l=>!!l.label)),e&&(r=l.map((l=>l.label??"")));const t=o[0],a=o[o.length-1];if(null==t&&null==a)return null;const u=e?null:n(o);return o.map(((o,n)=>({value:o,color:s(o,l),label:e?r[n]:u?.[n]??""}))).reverse()}function s(e,o){const{startIndex:r,endIndex:n,weight:t}=i(e,o);if(r===n)return o[r].color;const a=l.blendColors(o[r].color,o[n].color,t);return new l(a)}function i(l,e){let o=0,r=e.length-1;return e.some(((e,n)=>l<e.value?(r=n,!0):(o=n,!1))),{startIndex:o,endIndex:r,weight:(l-e[o].value)/(e[r].value-e[o].value)}}function c(e,o){let r=[];if(e&&"multipart"===e.type)e.colorRamps.reverse().forEach(((n,t)=>{0===t?r.push({value:o.max,color:new l(n.toColor),label:"high"}):r.push({value:null,color:new l(n.toColor),label:""}),t===e.colorRamps.length-1?r.push({value:o.min,color:new l(n.fromColor),label:"low"}):r.push({value:null,color:new l(n.fromColor),label:""})}));else{let n,t;e&&"algorithmic"===e.type?(n=e.fromColor,t=e.toColor):(n=[0,0,0,1],t=[255,255,255,1]),r=[{value:o.max,color:new l(t),label:"high"},{value:o.min,color:new l(n),label:"low"}]}return r}export{s as getColorFromPointCloudStops,t as getRampStops,u as getRampStopsForPointCloud,c as getStretchRampStops};
