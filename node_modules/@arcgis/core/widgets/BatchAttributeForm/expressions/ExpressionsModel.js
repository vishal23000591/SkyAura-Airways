/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{isSome as e,pushIfSome as t}from"../../../core/arrayUtils.js";import{getOrCreateMapValue as n}from"../../../core/MapUtils.js";import o from"../../../core/Queue.js";import{addMany as s,last as r}from"../../../core/SetUtils.js";import{isFieldElementTemplate as i}from"../templates/support/templateUtils.js";let c=0;class a{constructor(e){this.arcadeExecutorUses=new Map,this.components=[],this.preserveFieldValuesWhenHidden=!1,this.executorMap=e.executorMap,this.preserveFieldValuesWhenHidden=!0===e.preserveFieldValuesWhenHidden,this.elementTemplateMap=new Map;for(const t of this.executorMap.keys())this.elementTemplateMap.set(t.elementId,t);this._buildDependencyGraph()}_buildDependencyGraph(){const e=f(this.executorMap),t={components:[],arcadeExecutorUses:this.arcadeExecutorUses,elementTemplatesById:new Map([...this.executorMap.keys()].map((e=>[e.elementId,e]))),executorMap:this.executorMap,fieldElementTemplateMap:u(this.executorMap),fieldReferencesMap:new Map,geometryReferences:new Set,nextIndex:0,nodeInfoMap:e,nodeStack:new o(r),shouldConsiderVisibility:!this.preserveFieldValuesWhenHidden};for(const o of this.executorMap.keys()){const e=this.executorMap.get(o);e.editableExpression&&n(this.arcadeExecutorUses,e.editableExpression,(()=>[])).push({elementId:o.elementId,executorPurpose:"editable"}),e.valueExpression&&n(this.arcadeExecutorUses,e.valueExpression,(()=>[])).push({elementId:o.elementId,executorPurpose:"value"}),e?.visibilityExpression&&n(this.arcadeExecutorUses,e.visibilityExpression,(()=>[])).push({elementId:o.elementId,executorPurpose:"visibility"}),e?.requiredExpression&&n(this.arcadeExecutorUses,e.requiredExpression,(()=>[])).push({elementId:o.elementId,executorPurpose:"required"})}for(const n of this.arcadeExecutorUses.values())n.sort((e=>"editable"===e.executorPurpose?-1:1));for(const n of e.values())-1===n.index&&p(n,t);this.dependencyGraphComponents=m(t.nodeInfoMap),this.fieldReferencesMap=x(t),this.geometryReferences=h(t),this.components=t.components}}function p(e,t){e.index=e.lowlink=t.nextIndex++,t.nodeStack.push(e);for(const n of l(e,t))-1===n.index?(p(n,t),e.lowlink=Math.min(e.lowlink,n.lowlink)):n.index<e.index&&t.nodeStack.contains(n)&&(e.lowlink=Math.min(e.lowlink,n.index)),t.nodeStack.contains(n)||e.crossLinkNeighbors.add(n);if(e.lowlink===e.index){const n=y();for(t.components.push(n);w(t.nodeStack)>=e.index;){const e=t.nodeStack.pop();if(null!=e){e.component=n,n.executors.add(e.executor);for(const t of e.crossLinkNeighbors)null!=t.component&&n.adjacencyList.add(t.component)}}}}function l({executor:t},o){const r=new Set;for(const e of t.fieldsUsed){const i=e.toLowerCase();n(o.fieldReferencesMap,i,(()=>new Set)).add(t),s(r,d(i,o))}t.geometryUsed&&o.geometryReferences.add(t);const i=o.arcadeExecutorUses.get(t)?.filter((e=>"value"===e.executorPurpose))??[];for(const e of i){const n=o.executorMap.get(o.elementTemplatesById.get(e.elementId));n?.editableExpression&&n.editableExpression!==t&&r.add(n.editableExpression)}return Array.from(r).map((e=>o.nodeInfoMap.get(e))).filter(e)}function d(e,{executorMap:n,fieldElementTemplateMap:o,shouldConsiderVisibility:s}){const r=[],i=o.get(e);if(null==i)return r;const c=n.get(i);if(null==c)return r;if(t(r,c.editableExpression),t(r,c.valueExpression),s){t(r,c?.visibilityExpression);const{group:e}=i;if(null!=e){const o=n.get(e)?.visibilityExpression;t(r,o)}}return r}function u(e){const t=new Map;for(const n of e.keys())i(n)&&t.set(n.fieldName.toLowerCase(),n);return t}function f(t){const n=Array.from(t.values()).filter(e),o=new Set(n.flatMap((e=>Array.from(Object.values(e))))),s=Array.from(o).map((e=>({component:null,crossLinkNeighbors:new Set,executor:e,index:-1,lowlink:-1,onStack:!1})));return new Map(s.map((e=>[e.executor,e])))}function m(e){return new Map([...e.values()].map((({component:e,executor:t})=>[t,e])))}function x({fieldReferencesMap:e,nodeInfoMap:t}){const n=new Map;for(const[o,s]of e.entries())n.set(o,M(s,t));return n}function h({geometryReferences:e,nodeInfoMap:t}){return M(e,t)}function M(e,t){const n=new Set;for(const o of e){const e=t.get(o);e?.component&&n.add(e.component)}return n}function y(){c++;const e=c.toString();return{executors:new Set,adjacencyList:new Set,componentId:e}}function w(e){return e.peek()?.index??-1}export{a as ExpressionsModel,l as getDirectDependencies};
