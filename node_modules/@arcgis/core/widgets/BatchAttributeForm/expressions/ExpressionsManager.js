/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import r from"../../../core/Error.js";import s from"../../../core/Logger.js";import{getOrCreateMapValue as o}from"../../../core/MapUtils.js";import{whenOrAbort as a}from"../../../core/promiseUtils.js";import i from"../../../core/ReactiveMap.js";import{property as n}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/RandomLCG.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import{DateOnly as u}from"../../../core/sql/DateOnly.js";import{TimeOnly as c}from"../../../core/sql/TimeOnly.js";import{makeUseId as p}from"../inputs/support/inputUtils.js";import{isGroupElementTemplate as d,isFieldElementTemplate as f}from"../templates/support/templateUtils.js";let m=null,h=class extends t{constructor(e){super(e),this.calculating=!1,this.arcadeContext=null,this._abortController=new AbortController,this.layerExpressionsModelMap=new Map,this.evaluatedExpressions=new i,this.expressionEvaluationFailed=!1}abort(){this._abortController.abort()}async runAllExpressions(e,t=!1){return this._evaluateSpecifiedComponentsForEachFeature(e,v,t)}async runGeometryDependentExpressions(e,t=!1){return this._evaluateSpecifiedComponentsForEachFeature(e,x,t)}async valueChanged(e,t,r=!0){try{this.calculating=!0;const s=t.map((t=>this.evaluateValueChangedForFeature(e,t,r)));await Promise.all(s)}catch(o){s.getLogger(this).error(o),this.expressionEvaluationFailed=!0}finally{this.calculating=!1}}async evaluateValueChangedForFeature(e,t,r){if(this._abortController.signal.aborted)return;const s=this.layerExpressionsModelMap.get(t.layer);if(!s||0===s.components.length)return;const o=new Set,a=new Set([e]),i=new Set;for(;a.size>0;){const[e]=a;if(a.delete(e),o.has(e))continue;o.add(e);const n=s.fieldReferencesMap.get(e.toLowerCase());if(!n)continue;for(const t of n)i.has(t)&&n.delete(t);if(0===n.size)continue;const l=new Set;await this.evaluateAffectedComponents([...n],t,s,r,l);for(const t of n)i.add(t);for(const t of l)o.has(t)||a.add(t)}}async evaluateAffectedComponents(e,t,r,s,o){const a=new Map;for(const n of e)a.has(n)||a.set(n,this.createSccEvaluator(n,t,a,r));if(0===a.size)return;const i=[...a.values()].map((e=>e.evaluate(s,o)));await Promise.all(i)}createSccEvaluator(e,t,r,s){const a=new g(e,t,this.arcadeContext,s,this.evaluatedExpressions,this._abortController);for(const i of e.adjacencyList)a.dependentEvaluators.push(o(r,i,(()=>this.createSccEvaluator(i,t,r,s))));return a}async _evaluateSpecifiedComponentsForEachFeature(e,t,r=!1){this.calculating=!0;try{const s=[];for(const o of e){const e=this.layerExpressionsModelMap.get(o.layer);if(!e||0===e.components.length)continue;const a=new Set;s.push(this.evaluateAffectedComponents(t(e),o,e,r,a))}await a(Promise.all(s),this._abortController)}catch(o){s.getLogger(this).error(o),this.expressionEvaluationFailed=!0}finally{this.calculating=!1}}};e([n()],h.prototype,"calculating",void 0),e([n({constructOnly:!0})],h.prototype,"arcadeContext",void 0),e([n()],h.prototype,"_abortController",void 0),e([n()],h.prototype,"layerExpressionsModelMap",void 0),e([n()],h.prototype,"evaluatedExpressions",void 0),e([n()],h.prototype,"expressionEvaluationFailed",void 0),h=e([l("esri.widgets.BatchAttributeForm.expressions.ExpressionsManager")],h);class g{constructor(e,t,r,s,o,a){this.scc=e,this.feature=t,this.arcadeContextInfo=r,this.expressionsModel=s,this.evaluatedExpressions=o,this._abortController=a,this.dependentEvaluators=[],this._evaluatorPromise=null}get baseContext(){const{editType:e,map:t,spatialReference:r,timeZone:s}=this.arcadeContextInfo,o=this.feature.layer,a="scene"===o?.type&&null!=o.associatedLayer?o.associatedLayer:o;return{variables:{$originalfeature:this.feature.original,$editcontext:{editType:e},$layer:a,$featureset:a,$datastore:a?.url,$feature:this.feature.plainGraphic,$map:t},executeContext:{rawOutput:!0,spatialReference:r??void 0,timeZone:s,abortSignal:this._abortController.signal}}}evaluate(e,t){return null==this._evaluatorPromise&&(this._evaluatorPromise=this._evaluate(e,t)),this._evaluatorPromise}async _evaluate(e,t){null===m&&(m=await import("../../../arcade/languageUtils.js"));const s=this.dependentEvaluators.map((r=>r.evaluate(e,t)));await a(Promise.all(s),this._abortController);for(const a of this.scc.executors){const s=this.baseContext;if(this._abortController.signal.aborted)break;const l=this.expressionsModel.arcadeExecutorUses.get(a)??[],u=o(this.evaluatedExpressions,this.feature,(()=>new i));let c=null,m=null;try{c=a.isAsync?await a.executeAsync(s.variables,s.executeContext):a.execute(s.variables,s.executeContext),m={result:c,status:"success"}}catch(n){m={error:n,status:"error"}}for(const r of l){const s=this.expressionsModel.elementTemplateMap.get(r.elementId);switch(r.executorPurpose){case"editable":case"required":u.set(p(r.elementId,r.executorPurpose),m);break;case"value":{if("error"===m?.status)continue;const e=s.getExpressionExecutorsForLayer(this.feature.layer);let r=!0;if(e?.editableExpression&&(r=!1===u.get(p(s.elementId,"editable"))?.result),r){const e=this.feature.getAttribute(s.fieldName)??null,r=y(m.result,this.feature,s.fieldName,this.arcadeContextInfo.timeZone);r!==e&&(this.feature.setAttribute(s.fieldName,r),t.add(s.fieldName))}}break;case"visibility":if(u.set(p(r.elementId,r.executorPurpose),m),!this.expressionsModel.preserveFieldValuesWhenHidden&&!1===m.result&&e)if(d(s)){for(const e of s.elements)if(f(e)){null!==this.feature.getAttribute(e.fieldName)&&t.add(e.fieldName),this.feature.setAttribute(e.fieldName,null)}}else if(f(s)){null!==this.feature.getAttribute(s.fieldName)&&t.add(s.fieldName),this.feature.setAttribute(s.fieldName,null)}}}if("error"===m?.status){const e=new Set;for(const t of l){const r=this.expressionsModel.elementTemplateMap.get(t.elementId);if(r)switch(t.executorPurpose){case"editable":e.add(r.label+" - Editable expression");break;case"required":e.add(r.label+" - Required expression");break;case"value":e.add(r.label+" - Value expression");break;case"visibility":e.add(r.label+" - Visibility expression")}}if(e.size>0)throw new r("expression-evaluation-failed","Arcade evaluation failed ("+[...e].join(",")+")");throw new r("expression-evaluation-failed","Arcade evaluation failed ")}}}}function y(e,t,s,o){if(null===e)return null;const a=t.layer.fieldsIndex.get(s);if(!a)throw new r("field-not-found","Unable set field value as the field cannot be found. ("+s+")");switch(a.type){case"big-integer":case"integer":case"long":case"oid":case"small-integer":case"single":case"double":return m.toNumber(e);case"global-id":case"guid":case"string":return m.toString(e);case"date":{if(m.isDate(e))return e.getTime();const t=m.toDate(e,o);if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+s+")");return t.getTime()}case"date-only":{if(m.isDateOnly(e))return e.toStorageFormat();if(m.isDate(e))return u.fromDateTime(e.toDateTime()).toStorageFormat();const t=u.fromString(m.toString(e));if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type.");return t.toStorageFormat()}case"time-only":{if(m.isTime(e))return e.toStorageString();if(m.isDate(e)){return c.fromDateTime(e.toDateTime()).toStorageString()}const t=c.fromString(m.toString(e));if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type.");return t.toStorageString()}case"timestamp-offset":{if(m.isDate(e))return e.toISOString(!1);const t=m.toDate(e,o);if(!t)throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+s+")");return t.toISOString(!1)}}throw new r("unsupported-value-type","Arcade return type is not a supported field type. ("+s+")")}function v(e){return e.components}function x(e){return Array.from(e.geometryReferences)}export{h as ExpressionsManager};
