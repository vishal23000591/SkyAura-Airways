/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{isSupportedLayer as e}from"../../../arcade/featureset/support/shared.js";import r from"../../../core/Logger.js";import t from"../../../layers/FeatureLayer.js";import{applyTextFormattingHTML as a,htmlEntities as n}from"./featureUtils.js";import{globalCss as s}from"../../support/globalCss.js";const o="esri.widgets.Feature.support.arcadeFeatureUtils",i=()=>r.getLogger(o);function c(e){return"string"==typeof e?a(n(e)):Array.isArray(e)?p(e):"esri.arcade.Dictionary"===e?.declaredClass?u(e):e}function p(e){return`<ul class="esri-widget__list">${e.map((e=>`<li>${"string"==typeof e?a(n(e)):e}</li>`)).join("")}</ul>`}function u(e){const r=e.keys().map((r=>{const t=e.field(r);return`<tr><th>${r}</th><td>${"string"==typeof t?a(n(t)):t}</td></tr>`})).join("");return`<table class="${s.table}">${r}</table>`}async function l(){const[e,r]=await Promise.all([import("../../../arcade.js"),import("../../../arcade/arcade.js")]);return{executor:e,syntaxUtils:r}}function d(e){return"createQuery"in e&&"queryFeatures"in e}async function y({graphic:e,view:r,options:t}){const{isAggregate:a}=e,n=e.layer??e.sourceLayer;if(!a||!n||"2d"!==r?.type)return[];const s=await r.whenLayerView(n);if(!d(s))return[];const o=s.createQuery(),i=e.getObjectId();o.aggregateIds=null!=i?[i]:[];const{features:c}=await s.queryFeatures(o,t);return c}function f({layer:e,aggregatedFeatures:r,interceptor:a}){const{fields:n,objectIdField:s,geometryType:o,spatialReference:i,displayField:c}=e;return new t({fields:n,objectIdField:s,geometryType:o,spatialReference:i,displayField:c,interceptor:a,..."feature"===e.type?{templates:e.templates,typeIdField:e.typeIdField,types:e.types}:null,source:r})}function g(e){const r="esri.views.3d.layers.VoxelGraphic"===e.declaredClass;return e.isAggregate?"popup-feature-reduction":r?"popup-voxel":"popup"}function w(e){return{scale:e?.scale,timeProperties:{currentStart:e?.timeExtent?.start,currentEnd:e?.timeExtent?.end,startIncluded:!0,endIncluded:!0}}}function m(e){return{$voxel:e}}async function x(e,r,t,a,n){let s=null;if(n.has("$aggregatedfeatures")){const n=await y({graphic:e,view:r,options:t}),o=e.sourceLayer||e.layer;s=f({layer:o,aggregatedFeatures:n,interceptor:a})}return{vars:{$feature:e,$aggregatedFeatures:s,$view:w(r)},[Symbol.dispose]:()=>s?.[Symbol.dispose]()}}function v(r,t,a,n){const s=(r.sourceLayer||r.layer)??void 0;return{$feature:r,$layer:null!=s&&e(s)?s:"scene"===s?.type&&null!=s.associatedLayer?s.associatedLayer:void 0,$map:t,$datastore:s?.url,$userInput:a,$graph:"knowledge-graph-sublayer"===s?.type?s?.parentCompositeLayer?.knowledgeGraph:void 0,$view:w(n)}}async function h(e,{graphic:r,map:t,location:a,view:n,options:s,interceptor:o,arcadeExecutor:i}){switch(e){case"popup":return{vars:v(r,t,a,n),[Symbol.dispose](){}};case"popup-feature-reduction":{const e=new Set(i.variablesUsed);return await x(r,n,s,o,e)}case"popup-voxel":return{vars:m(r),[Symbol.dispose](){}};default:throw new Error(`Unexpected profile name ${e}`)}}async function $({expressionInfo:e,arcade:{executor:r,syntaxUtils:t},graphic:a}){const n=e?.expression;if(!n)return null;const s=g(a),o=r.createArcadeProfile(s);let c;try{c=await r.createArcadeExecutor(n,o)}catch(u){return i().error("arcade-executor-error",{error:u,expressionInfo:e}),null}const p=new Set;return c.variablesUsed.includes("$view")&&(t.scriptUsesViewProperties(c.syntaxTree,["scale"])&&p.add("view-scale"),t.scriptUsesViewProperties(c.syntaxTree,["timeProperties"])&&p.add("view-time-extent")),{dependencies:p,async evaluate({graphic:r,interceptor:t,location:a,map:n,options:o,spatialReference:p,view:l}){const d=await h(s,{graphic:r,map:n,location:a,view:l,options:o,interceptor:t,arcadeExecutor:c}),y={abortSignal:o?.signal??void 0,interceptor:t??void 0,rawOutput:!0,spatialReference:p??void 0,timeZone:l?.timeZone,console(...e){i().info(...e)}};try{return await c.executeAsync(d.vars,y)}catch(u){if(o?.signal?.aborted)return;return void i().error("arcade-execution-error",{error:u,graphic:r,expressionInfo:e})}finally{d[Symbol.dispose]()}}}}async function b(e,r){if(!e?.length)return{dependencies:new Set,expressions:new Map};const t=await l(),a=new Set,n=new Map;for(const s of e){const e=await $({expressionInfo:s,arcade:t,graphic:r});n.set(`expression/${s.name}`,e),e?.dependencies.forEach((e=>a.add(e)))}return{dependencies:a,expressions:n}}export{$ as compileExpression,b as compileExpressionInfos,c as formatArcadeValue,l as loadArcade};
