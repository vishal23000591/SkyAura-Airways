/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{rad2deg as t}from"../../core/mathUtils.js";import{throwIfAborted as e}from"../../core/promiseUtils.js";import{formatArea as n,formatLength as r}from"../../core/quantityFormatUtils.js";import{createArea as a,createLength as o}from"../../core/quantityUtils.js";import{set as s,determinant as i}from"../../core/libs/gl-matrix-2/math/mat3.js";import{create as c}from"../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as u,fromValues as l}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{distance as f}from"../../core/libs/gl-matrix-2/math/vec2.js";import{i as m,h as p,a as h}from"../../chunks/vec32.js";import y from"../../geometry/Point.js";import g from"../../geometry/Polygon.js";import x from"../../geometry/Polyline.js";import{projectWithZConversion as w,project as M}from"../../geometry/projectionUtils.js";import R from"../../geometry/SpatialReference.js";import{e as z}from"../../chunks/areaOperator.js";import{l as d,e as P}from"../../chunks/geodeticAreaOperator.js";import{l as v,e as j}from"../../chunks/geodeticDensifyOperator.js";import{l as b,e as O}from"../../chunks/geodeticLengthOperator.js";import{e as E}from"../../chunks/lengthOperator.js";import{execute as q}from"../../geometry/operators/projectOperator.js";import{e as W}from"../../chunks/simplifyOperator.js";import{isSupported as k,geodesicLengths as L,geodesicAreas as I}from"../../geometry/support/geodesicUtils.js";import{imageToWorldPanoramic as G,imageToWorld as A}from"../../layers/orientedImagery/transformations/imageToWorld.js";import{convertSphereVertexToPixelLocation as D,scaleWithFactor as U}from"../../layers/orientedImagery/transformations/utils.js";import{worldToImagePanoramic as S,worldToImage as B}from"../../layers/orientedImagery/transformations/worldToImage.js";const F=1e5;function T(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function H(t,e){let n=180*Math.atan2(-t.y+e.y,t.x-e.x)/Math.PI;return n<0&&(n+=180),n*Math.PI/180}function V(t,e,n){if(!t?.length||!e?.length||!n)return;const[r,a]=t,[,o]=e,s=o-a;return[r+s*Math.cos(n),a+s*Math.sin(n)]}async function C(t,e,n){if(await v(),k(t)){const t=L([e],"meters")[0];return{area:I([n],"square-meters")[0],perimeter:t}}const r=R.WGS84,a=M(e,r),o=M(n,r);let s=j(o,F);if(s=s?W(s):null,!s)return null;const i=L([a],"meters")[0];return{area:I([s],"square-meters")[0],perimeter:i}}async function J(t,n,r,a,o=!1,s){if(n.length<2||!a||!r||!t)return null;const i=dt(r,t);if(!i)return null;const c=n.map((t=>[t.x,t.y])),u=c.at(0),l=c.at(-1);if(!u||!l)return null;const f=i.map((e=>qt([u,l],e,t,o,!1))),m=await Promise.all(f);e(s);let p=0;for(const e of m){if(!e)return null;const t=Math.abs(e-a);p=Math.max(t,p)}return p}async function K(t,n,r,a,o,s=!1,i){if(n.length<2||!a||!r||!t)throw new Error("Missing parameters");const c=Pt(r,t),u=n.map((t=>[t.x,t.y])),l=u.at(0),f=u.at(-1),m=c.map((e=>Wt([l,f],e,t,o,s,!1))),p=await Promise.all(m);e(i);let h=0;for(const e of p){if(!e)return 0;const t=Math.abs(e-a);h=Math.max(t,h)}return h}function N(t,e,n=1){const r=Rt(t,!1);if(!r?.length)return;return 20*f([r[0].x,r[0].y],[r.at(-1).x,r.at(-1).y])*n/e}async function Q(t){await b();const e=t.spatialReference;if(e.isGeographic){if(k(e))return L([t],"meters")[0];const n=M(t,R.WGS84);return L([n],"meters")[0]}return e.isWebMercator?O(t):E(t)}function X(t){if(!t?.length)throw new Error("Invalid deviations array");const[e,n,r]=[0,1,2].map((e=>t.map((t=>t[e])).filter((t=>null!==t)))).map((t=>t.length?bt(t):0));return[e,n,r]}function Y(t,e){const n=W(e);if(!n)return null;const r=E(t);return{area:z(n),perimeter:r}}function Z(t,e){return[(t[1][0]-t[0][0])/e,(t[1][1]-t[0][1])/e,(t[1][2]-t[0][2])/e]}async function $(t,e){await Promise.all([d(),v(),b()]);let n=j(e,F);if(n=n?W(n):null,!n)return null;const r=O(t);return{area:P(n),perimeter:r}}async function _(t,n,r){if(!n||!t)throw new Error("Missing required parameters");const a=await A(t,n);e(r);const o=a.clone();o.z?o.z+=20:o.z=20;const{averageElevation:s,cameraPitch:i,cameraRoll:c,farDistance:u,...l}=n;return B(o,l)}async function tt(t,n,r,a){const{attributes:o}=r,{location:s}=o,{updateElevationProps:i,...c}=n;if(!t||!n)throw new Error("Missing parameters");let u=s.clone();u.spatialReference.isGeographic&&(u=await w(u,R.WebMercator));const l=await G(t,{...c,cameraLocation:u},i);e(a);const f=l.clone();return f.z?f.z+=20:f.z=20,S(f,c)}function et(t,e,n,r,a=0,o=1,s){const{averageElevation:i,cameraPitch:c,cameraRoll:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*Et(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=B(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),x=n.at(0),w=n.at(-1);if(!x||!w)return null;const M=f([x.x,x.y],[w.x,w.y])*t/g;return et(M,e,n,r,a+1,Math.abs(t-M))}function nt(t,e,n,r,a=0,o=1,s){const{averageElevation:i,horizontalFieldOfView:c,verticalFieldOfView:u,farDistance:l,...m}=r;if(a>=5||o<=.1){return{value:t*Et(r.cameraLocation.spatialReference)}}const p=new y({x:e.x,y:e.y,z:e.z?e.z+t:t,spatialReference:r.cameraLocation.spatialReference}),h=S(p,m),g=f([n[0].x,n[0].y],[h.x,h.y]),x=n.at(0),w=n.at(-1);if(!x||!w)return null;const M=f([x.x,x.y],[w.x,w.y])*t/g;return nt(M,e,n,r,a+1,Math.abs(t-M))}function rt(t,e,n){return new x({paths:[[[t.x,t.y,t.z??0],[e.x,e.y,e.z??0]]],spatialReference:n})}function at(t){return 1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/6378137)))}function ot(t,e){return Math.sqrt((Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e)**2+(t[0][2]-t[1][2])**2)}function st(t,e,n){return Math.sqrt((t.z??0-(e.z??0))**2+(Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)/n)**2)*n}function it(t,e,n,r){return Bt(St([t.x,t.y,t.z??0],[e.x,e.y,e.z??0]),1/n,1/r)}function ct(t,e){return Math.sqrt((t[0][0]-t[1][0])**2+(t[0][1]-t[1][1])**2)/e}function ut(e){return t(Math.atan((e[1][2]-e[0][2])/Math.sqrt((e[1][0]-e[0][0])**2+(e[1][1]-e[0][1])**2)))}function lt(e){let n=90-t(Math.atan2(e[1][1]-e[0][1],e[1][0]-e[0][0]));return n<0&&(n+=360),n}function ft(t,e){return new y({x:(t.pointOnA[0]+t.pointOnB[0])/2,y:(t.pointOnA[1]+t.pointOnB[1])/2,z:(t.pointOnA[2]+t.pointOnB[2])/2,spatialReference:e})}async function mt(t){if(2===t?.length){const e=[];let n=1;const[r,a]=t,o=r.camera.spatialReference,{measurePoints:s}=r;for(let t=0;t<s.length;t++){const s=rt(r.camera,r.measurePoints[t],o),i=rt(a.camera,a.measurePoints[t],o),c=await At(s,i);if(!c)return null;const u=ft(c,o);u.spatialReference.isWebMercator&&(n=at(u.y)),e.push([u.x,u.y,u.z??0])}if(e?.length>1){return{distance:ot(e,n),horizontalDistance:ct(e,n),verticalDistance:Math.abs(e[0][2]-e[1][2]),slope:ut(e),aspect:lt(e)}}}return null}async function pt(t){const e=t[0].camera.spatialReference;if(2!==t?.length)return null;const[n,r]=t,{camera:a,measurePoints:o}=n,{camera:s,measurePoints:i}=r,c=rt(a,o[0],e),u=rt(s,i[0],e),l=await At(c,u);return l?ft(l,e)??null:null}async function ht(t,e){if(!t?.length)return null;const n=[],r=t[0],a=t[1],o=r.camera.spatialReference,{measurePoints:s}=r;for(let l=0;l<s.length;l++){const t=rt(r.camera,r.measurePoints[l],o),e=rt(a.camera,a.measurePoints[l],o),s=await At(t,e);if(!s)return null;const i=ft(s,o);n.push([i.x,i.y,i.z??0])}if(n?.length<2)return null;const i=new x({paths:[n],spatialReference:e}),c=new g({rings:[n],spatialReference:e});if(e.isGeographic){const t=await C(e,i,c);return t?.area??null}if(e.isWebMercator){const t=await $(i,c);return t?.area??null}const u=Y(i,c);return u?.area??null}function yt(t,e){if(!t)return null;const n=e.geometry.clone(),r=Array.isArray(t)?t:[t],a=[];return r.forEach((t=>{let e=!1;t.spatialReference.isWGS84&&(t=q(t,new R({wkid:3857})),e=!0);const r=t.spatialReference.isWebMercator?at(t.y):1,o=st(t,n,r),s=it(t,n,o,r),i=((t.z??0)-(n.z??0))/s[2]*r;let c=new y({spatialReference:t.spatialReference,x:n.x+i*s[0],y:n.y+i*s[1],z:(n.z??0)+i*s[2]/r});e&&(c=q(c,new R({wkid:4326}))),a.push(c)})),{camera:n,measurePoints:r,tempMeasurePoints:a}}async function gt(t,e){const{updateElevationProps:n,...r}=e;return await A(t,r,n)}async function xt(t,e){const{updateElevationProps:n,...r}=e;return G(t,r,n)}function wt(t){navigator.clipboard.writeText(t).catch((t=>{throw t}))}function Mt(t){const e=t.map((t=>[t.x,t.y])),n=t[0].spatialReference;return new x({paths:[e],spatialReference:n})}function Rt(t,e){return t.map((t=>({x:e?.5+t[0]:t[0],y:e?.5-t[1]:t[1]})))}function zt(t,e,n,a,s){const i="measurement"===t?e:n;if(s&&i)return r(a,o(i,"meters"),s,3)||null}function dt(t,e){const{cameraPitch:n,cameraRoll:r,cameraLocation:a}=t,{x:o,y:s,z:i,spatialReference:c}=a;if(e.every((t=>0===t))||!e||!e.length)return null;const[u,l,,f,m]=e,p=[-f,0,f],h=[-m,0,m],g=[-u,0,u],x=[-l,0,l],w=[];for(const M of p)for(const e of h)for(const a of g)for(const u of g)for(const l of x){const f={...t};f.cameraPitch=n+M,f.cameraRoll=r+e,f.cameraLocation=new y({x:o+a,y:s+u,z:i?i+l:0,spatialReference:{wkid:c.wkid}}),w.push(f)}return w}function Pt(t,e){const{cameraHeading:n,cameraLocation:r}=t,{x:a,y:o,z:s,spatialReference:i}=r;if(e.every((t=>0===t))||!e||!e.length)throw new Error("Invalid parameters");const[c,u,l]=e,f=l>0?[-l,0,l]:[],m=c>0?[-c,0,c]:[],p=u>0?[-u,0,u]:[],h=[];for(const g of f)for(const e of m)for(const r of m)for(const c of p){const u={...t};u.cameraHeading=n+g,u.cameraLocation=new y({x:a+e,y:o+r,z:s?s+c:0,spatialReference:{wkid:i.wkid}}),h.push(u)}return h}function vt(t,e,n,a,s){const i="measurement"===t?e:bt(n);if(s&&i)return r(a,o(i,"meters"),s,3)||null}function jt(t,e,r,o,s){const i="measurement"===t?e:r;if(s&&i)return n(o,a(i,"square-meters"),s,3)||null}function bt(t){return Math.sqrt(t.reduce(((t,e)=>t+e**2),0))}function Ot(t,e,n){if("default"===e)return t;const r={x:t[0],y:t[1],z:t[2]},a=D(r,n[0],n[1]);return[a.x,a.y]}function Et(t){return t.metersPerUnit}async function qt(t,n,r,a=!1,o=!1,s){if(!t||!n||t.length<2)return null;const i=Rt(t,a);if(!i||i.length<2)return null;const[c,u]=[i[0],i.at(-1)];if(!u)return null;const l=[c],m=await A(c,n);e(s);const p=m.clone();p.z?p.z+=20:p.z=20;const{averageElevation:h,cameraPitch:y,cameraRoll:g,farDistance:x,...w}=n,M=B(p,w),R=f([c.x,c.y],[M.x,M.y]),z=T(c,M);if(!z)return;const d=V([c.x,c.y],[u.x,u.y],z);if(!d?.length)return;l.push({x:d[0],y:d[1]});const P=20*f([l[0].x,l[0].y],[l[1].x,l[1].y])*Et(n.cameraLocation.spatialReference)/R;if(!o)return P;const v=et(P,m,l,n,0,1);return v?.value}async function Wt(t,n,r,a,o=!1,s=!1,i){const{attributes:c}=a,{location:u}=c,{updateElevationProps:l,...m}=n;if(!t||!n||t.length<2)throw new Error("Invalid parameters");const p=Rt(t,o),[h,y]=[p[0],p.at(-1)],g=[h];let x=u.clone();x.spatialReference.isGeographic&&(x=await w(x,R.WebMercator));const M=await G(h,{...m,cameraLocation:x},l);e(i);const z=M.clone();z.z?z.z+=20:z.z=20;const d=S(z,m),P=f([h.x,h.y],[d.x,d.y]),v=T(h,d);if(!v)return;const j=V([h.x,h.y],[y.x,y.y],v);if(!j?.length)return;g.push({x:j[0],y:j[1]});const b=20*f([g[0].x,g[0].y],[g[1].x,g[1].y])*Et(n.cameraLocation.spatialReference)/P;if(!s)return b;const O=nt(b,M,g,n,0,1);return O?.value}async function kt(t,e,n=!1){if(t.length<3)return null;const r=Rt(t,n),a=await gt(r,e),o=a.map((({x:t,y:e})=>[t,e]));t.push(t[0]),o.push(o[0]);const s=a[0].spatialReference,i=new x({paths:[o],spatialReference:s}),c=new g({rings:[o],spatialReference:s});return s.isGeographic?C(s,i,c):s.isWebMercator?$(i,c):Y(i,c)}async function Lt(t,n,r=!1,a){if(t.length<3)return null;const o=Rt(t,r),s=await xt(o,n);e(a);const i=s.map((({x:t,y:e})=>[t,e]));t.push(t[0]),i.push(i[0]);const c=s[0].spatialReference,u=new x({paths:[i],spatialReference:c}),l=new g({rings:[i],spatialReference:c});return c.isGeographic?C(c,u,l):c.isWebMercator?$(u,l):Y(u,l)}async function It(t,e,n=!1){const r=Rt(t,n);return Q(Mt(await gt(r,e)))}async function Gt(t,n,r=!1,a){const o=Rt(t,r),s=await xt(o,n);e(a);return Q(Mt(s))}async function At(t,e){const n=c(),r=t.paths[0][0],a=e.paths[0][0];let o,u;t.spatialReference.isWGS84||t.spatialReference.isWebMercator?(await b(),o=O(t),u=O(e)):(o=E(t),u=E(e));const l=Z(t.paths[0],o),f=Z(e.paths[0],u),m=Dt(l,f),[p,h,y]=l,[g,x,w]=f.map((t=>-t)),[M,R,z]=m,[d,P,v]=[a[0]-r[0],a[1]-r[1],a[2]-r[2]];s(n,p,g,M,h,x,R,y,w,z);const j=i(n);if(0===j)return null;s(n,d,g,M,P,x,R,v,w,z);const q=i(n);s(n,p,d,M,h,P,R,y,v,z);const W=i(n);s(n,p,g,d,h,x,P,y,w,v);const k=q/j,L=W/j,I=i(n)/j;return{distance:Math.abs(I/Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2])),pointOnA:Ut(r,k,l),pointOnB:Ut(a,L,f)}}function Dt(t,e){const n=u(),r=m(u(),t[0],t[1],t[2]),a=m(u(),e[0],e[1],e[2]),o=p(n,r,a);return[o[0],o[1],o[2]]}function Ut(t,e,n){return[t[0]+e*n[0],t[1]+e*n[1],t[2]+e*n[2]]}function St(t,e){const n=l(t[0],t[1],t[2]),r=l(e[0],e[1],e[2]);return h(u(),n,r)}function Bt(t,e,n){const r=U(t,e,n);return[r[0],r[1],r[2]]}export{T as calculateAngle,H as calculateAnglePano,V as calculateCorrectedPixel,J as calculateHeightAccuracy,K as calculateHeightAccuracyPanoramic,N as calculateHeightFromTemporaryDistance,X as calculateLocationAccuracyFromDeviations,tt as calculateReferenceImagePointPanoramic,_ as calculateTempImagePoint,et as computeHeightIteratively,nt as computeHeightIterativelyPanoramic,ht as computeTriangulatedAreaMeasurement,mt as computeTriangulatedDistanceMeasurement,pt as computeTriangulatedPoint,yt as computeTriangulatedVector,wt as copyToClipboard,Rt as formatPixels,dt as generateCombinations,Pt as generateCombinationsPanoramic,jt as getConvertedArea,vt as getConvertedDistance,zt as getConvertedHeight,Ot as getModeCorrectedPoint,bt as getRootOfSumOfSquaredErrors,Et as getUnitRateFromSpatialReference,qt as heightMeasurement2D,Wt as heightMeasurementPanoramic,kt as pixelAreaMeasurement2D,Lt as pixelAreaMeasurementPanoramic,It as pixelDistanceMeasurement2D,Gt as pixelDistanceMeasurementPanoramic,Bt as scale,At as solveSkewLinesIntersection,St as subtract};
