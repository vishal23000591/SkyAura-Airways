/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import{throwIfAborted as i,waitTick as r}from"../../../../core/promiseUtils.js";import o from"../../../../geometry/Mesh.js";import a from"../../../../geometry/Point.js";import{projectWithZConversion as s}from"../../../../geometry/projectionUtils.js";import{MeshVertexAttributes as n}from"../../../../geometry/support/MeshVertexAttributes.js";import{projectVertices as l,updateFrustum as c,createCoveragePolygon as m}from"../../../../layers/orientedImagery/core/coverageUtils.js";import{activeFrustumSymbol as u,additionalFrustumSymbol as p}from"../../symbols.js";class d{constructor(a){this.viewModel=a,this._updateBestFeatureFootprintElevation=!1,this.createFootprints=async r=>{const{coverageFrustums:a,currentBestFeature:c,isAdditionalCoverageVisible:m,view:d}=this.viewModel,f=a.filter(t);for(const t of f){let a=t.clone();if(!d.spatialReference.equals(a.spatialReference)){const{components:e,spatialReference:t,origin:c,vertexAttributes:m,vertexSpace:u}=a;if("local"===u.type){const e=await s(c,d.spatialReference,r);i(r),a.centerAt(e)}else{const s=m.position,c=Float64Array.from(await l([...s],t.clone(),d.spatialReference.clone(),r));i(r),a=new o({vertexAttributes:new n({position:c}),components:e,spatialReference:d.spatialReference.clone()})}}t.imageID===c.attributes.objectId?(this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t.imageID},geometry:a,symbol:u.clone(),visible:!1}),this._updateBestFeatureFootprintElevation=!0):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t.imageID},geometry:a,symbol:p.clone(),visible:m}))}},this.updateFootprint=async(r,o)=>{const{bestFeatureFootprint:a,currentBestFeature:n,activeViewer:l,footprintExtent:m,view:p}=this.viewModel,d=l?.imageSize;if(!(n&&a?.geometry&&d&&m))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:w,location:v,cameraPitch:g,horizontalFieldOfView:h,verticalFieldOfView:y,cameraRoll:b},elevationSample:F}=n;F&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([a],F),this._updateBestFeatureFootprintElevation=!1);const M=v.toArray(),{vertexAttributes:{position:R},spatialReference:V}=a.geometry,j=await f(R,V,v.spatialReference),A=await this.viewModel.getMapPoint(r,{feature:n,mode:"default",imageSize:d});i(o);let I=A.filter(t);if(!I.length)return;I[0].spatialReference.equals(v.spatialReference)||(I=await Promise.all(I.map((async e=>{const t=await s(e,v.spatialReference,o);return i(o),t}))));const P=await c(r.map((({x:e,y:t})=>[e,t])),I.map((e=>e.toArray())),{cameraHeight:w,cameraLocation:M,cameraPitch:g,frustumVertices:j,horizontalFieldOfView:h,imageHeight:d[1],imageWidth:d[0],inSRS:{wkid:v.spatialReference.wkid},outSRS:{wkid:p.spatialReference.wkid},verticalFieldOfView:y,cameraRoll:b??0,options:o});this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:n.attributes.objectId},geometry:P,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(t,i)=>{await r(i);const{horizontalFieldOfView:o,pitch:a,verticalFieldOfView:s,yaw:n}=t,l=this.viewModel.currentBestFeature?.clone();if(!l)return;const{attributes:c}=l;c.orientedImageryType=null,c.cameraHeading=(n+c.cameraHeading)%360,c.cameraPitch=a,c.horizontalFieldOfView=o,c.verticalFieldOfView=s,c.cameraRoll=0;const{frustum:p}=m(c);p?this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:c.objectId},geometry:p,symbol:u.clone(),visible:this.viewModel.currentCoverageVisible})):this.viewModel.updateCurrentCoveragePolygon(null)}}updateGroundElevation(e,t){const{geometry:i}=this.viewModel.currentBestFeature,r=t.queryElevation(i);e.forEach((e=>{const{geometry:t}=e;switch(t?.type){case"mesh":{const{vertexAttributes:{position:e}}=t,i=Math.floor(e.length/3);for(let t=0;t<i;t+=1)e[3*t+2]+=r?.z??0;break}case"point":t.z=(t.z??0)+(r?.z??0)}}))}}async function f(e,t,i,r){return Float64Array.from((await Promise.all(e.reduce(((e,t,i)=>{const r=Math.floor(i/3);return e[r]=e[r]??[],e[r].push(t),e}),new Array).map((async e=>(await s(new a(e,t),i,r)).toArray())))).flat())}export{d as default};
