/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import o from"../../../../core/Logger.js";import{waitTick as i,throwIfAborted as r,isAbortError as s}from"../../../../core/promiseUtils.js";import a from"../../../../geometry/Polygon.js";import{convertOrientationToPixelLocation as n}from"../../../../layers/orientedImagery/transformations/utils.js";import{fixedImageSize as l}from"../../constants.js";import{activePolygonSymbol as u,polygonSymbol as c}from"../../symbols.js";class m{constructor(m){this.viewModel=m,this.createFootprints=async t=>{await i(t);const{coveragePolygons:o,currentBestFeature:r,isAdditionalCoverageVisible:s}=this.viewModel;for(const i of o)i?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:i?.imageID},geometry:i,symbol:u,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:i?.imageID},geometry:i,symbol:c.clone(),visible:s}))},this.updateFootprint=async(i,n)=>{const{activeViewer:c,mode:m,currentBestFeature:p,currentCoverageVisible:g,footprintExtent:d}=this.viewModel,v="video"===m?l:c?.imageSize;if(p&&v&&d)try{const o=await this.viewModel.getMapPoint(i,{feature:p,mode:"default",imageSize:v});r(n);const s=o.filter(t);if(!s.length)return;const l=[s.map((({x:e,y:t})=>[e,t,1]))];l[0].push(l[0][0]);const c=new a({rings:l,spatialReference:s[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:c,attributes:{imageID:p.attributes.objectId},symbol:u,visible:g}))}catch(h){s(h)||o.getLogger(this.viewModel).error("update-footprint",h)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,o)=>{const{horizontalFieldOfView:i,pitch:s,verticalFieldOfView:l,yaw:c}=t,{activeViewer:m,currentBestFeature:p,currentCoverageVisible:g,footprintExtent:d}=this.viewModel,v=m?.imageSize;if(!p||!v||!d)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:h,objectId:f}=p.attributes;if(s+h-l/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const w=[],y=l/2,b=i/2,M=s-y,C=h+M,P=h+(s+y);if(C>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const j=M<0,F=[-b,y],I=[b,y],D=[b,-y],V=[-b,-y];if(C<180&&P>180){w.push(j?D:V);const e=Math.floor(i/5),t=i/e;for(let o=0;o<=e;o++)w.push([o*t-b,90-s]);w.push(j?V:D)}P<180&&(w.push(F,I),j?w.push(V,D):w.push(D,V));const x=w.map((([e,t])=>n(c+e,s+t,v[0],v[1]))),z=await this.viewModel.getMapPoint(x,{feature:p,mode:"panorama",imageSize:v});r(o);const R=[z.map((({x:e,y:t})=>[e,t,1]))];R[0].push(R[0][0]);const S=new a({rings:R,spatialReference:z[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:S,attributes:{imageID:f},symbol:u.clone(),visible:g}))}}}export{m as default};
