/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../Graphic.js";import{createTask as a}from"../../../../core/asyncUtils.js";import s from"../../../../core/Promise.js";import{throwIfAborted as i}from"../../../../core/promiseUtils.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as o}from"../../../../core/accessorSupport/decorators/subclass.js";import n from"../../../../geometry/Polygon.js";import c from"../../../../geometry/Polyline.js";import{load as l}from"../../../../geometry/projectionUtils.js";import m from"../../../../geometry/SpatialReference.js";import{convertSphereVertexToPixelLocation as h}from"../../../../layers/orientedImagery/transformations/utils.js";import{formatPixels as u}from"../../imageMeasurementUtils.js";import{SketchHandlerMixin as d}from"../../mixins/SketchHandlerMixin.js";let y=[],p=[],M=0,g=class extends(d(s)){constructor(e){super(e),this.type="measurement",this.measurementArray=[],this.pixelMeasurement=0,this.pixelAreaMeasurement=0,this.polygonVertices=[],this._calculationTask=null,this._distanceCalculation=0,this._areaCalculation=null}initialize(){this.addResolvingPromise(l())}async handleCreate(e){const t=e.toolEventInfo;switch(e.tool){case"polyline":this.handlePolylineEvents(e,t);break;case"polygon":this.handlePolygonEvents(e,t)}}handleDelete(e){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}handleDestroy(){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}cursorUpdatePolylineHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;if("default"===t)this.measurementArray.push(e.coordinates);else{const t={x:e.coordinates[0],y:e.coordinates[1],z:e.coordinates[2]},s=h(t,a.imageSize[0],a.imageSize[1]);this.measurementArray.push([s.x,s.y])}const s=p.reduce(((e,t)=>e+t),0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=s}async cursorUpdatePolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;const s=e.coordinates;if(y=[...this.polygonVertices],"default"===t)y.push(s);else{const e={x:s[0],y:s[1],z:s[2]},t=h(e,a?.imageSize[0],a?.imageSize[1]);y.push([t.x,t.y])}if(y.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const i=y[0];y=y.filter(((e,t)=>0===t||t===y.length-1||JSON.stringify(e)!==JSON.stringify(i)));const r=await this._getAreaFromTask(y);r?.area&&r?.perimeter&&(M=r.area)}async handlePolylineEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetDistanceMeasurements(),this.viewModel.distanceMeasurementResult=0,this.viewModel.distanceAccuracyArray=[],void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.paths[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetDistanceMeasurements()}switch(t?.type){case"cursor-update":this.cursorUpdatePolylineHandler(t);break;case"vertex-add":if(this.measurementArray.length&&a){const e=await this._getAccuracyFromTask();e&&this.viewModel.distanceAccuracyArray.push(e)}this.vertexUpdatePolylineHandler()}const s=await this._getDistanceFromTask();this.pixelMeasurement=s??this.pixelMeasurement}async handlePolygonEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetAreaMeasurements(),this.viewModel.areaMeasurementResult=0,this.viewModel.areaMeasurementAccuracy=0,void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),a){const e=await this._getAreaAccuracyFromTask(this.polygonVertices);this.viewModel.areaMeasurementAccuracy=e&&e>this.viewModel.areaMeasurementAccuracy?e:this.viewModel.areaMeasurementAccuracy}if(this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.rings[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetAreaMeasurements()}switch(t?.type){case"vertex-add":await this.vertexAddPolygonHandler(t);break;case"cursor-update":await this.cursorUpdatePolygonHandler(t)}this.viewModel.areaMeasurementResult=M>0?M:this.pixelAreaMeasurement}async vertexAddPolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel,s=e.added,i=s[s.length-1];if(!Array.isArray(i)||"none"===t||!a?.imageSize)return;if("default"===t)this.polygonVertices.push(i);else{const e={x:i[0],y:i[1],z:i[2]},t=h(e,a?.imageSize[0],a?.imageSize[1]);this.polygonVertices.push([t.x,t.y])}if(this.polygonVertices.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const r=this.polygonVertices[0];this.polygonVertices=this.polygonVertices.filter(((e,t)=>0===t||t===this.polygonVertices.length-1||JSON.stringify(e)!==JSON.stringify(r)));const o=await this._getAreaFromTask(this.polygonVertices);if(!o?.area||!o?.perimeter)return;const{area:n}=o;this.pixelAreaMeasurement=n}vertexUpdatePolylineHandler(){this.measurementArray=this.measurementArray.slice(-1);const e=p.reduce(((e,t)=>e+t),0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=e,this.pixelMeasurement>0&&p.push(this.pixelMeasurement)}resetDistanceMeasurements(){this.measurementArray=[],this.pixelMeasurement=0,p=[]}resetAreaMeasurements(){this.polygonVertices=[],this.pixelAreaMeasurement=0,M=0}async _overlayFirstMeasurement(e,t){switch(t){case"polyline":this._overlayFirstDistanceMeasurement(e);break;case"polygon":this._overlayFirstAreaGeometry(e)}}async _overlayFirstDistanceMeasurement(e){const a=e.geometry?.clone(),s=e.symbol?.clone(),i=[...a.paths[0]],r=u(i,!0),o=await this.viewModel.getMeasurementProperties(),n=await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer);if(r?.length&&o&&n){const e=(await this.viewModel.imageToImageTransform(r,o,n)).map((e=>[e.x-.5,-.5-e.y])),a=new c({paths:[e],spatialReference:m.WebMercator}),i=new t({geometry:a,symbol:s});this.viewModel.editOverlayedGraphics(i)}}async _overlayFirstAreaGeometry(e){const a=e.geometry?.clone(),s=e.symbol?.clone(),i=[...a.rings[0]],r=u(i,!0),o=await this.viewModel.getMeasurementProperties(),c=await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer);if(r?.length&&o&&c){const e=(await this.viewModel.imageToImageTransform(r,o,c)).map((e=>[e.x-.5,-.5-e.y])),a=new n({rings:[e],spatialReference:m.WebMercator}),i=new t({geometry:a,symbol:s});this.viewModel.editOverlayedGraphics(i)}}async _getAreaFromTask(e){const{mode:t}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a((async a=>{this._areaCalculation=null;const s=await this.viewModel.calculateAreaMeasurement(e,t,a);i(a),this._areaCalculation=s})),await this._calculationTask.promise,this._areaCalculation}async _getDistanceFromTask(){const{mode:e}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a((async t=>{this._distanceCalculation=0;const a=await this.viewModel.calculateDistanceMeasurement(this.measurementArray,e,t);i(t),this._distanceCalculation=a})),await this._calculationTask.promise,this._distanceCalculation}async _getAccuracyFromTask(){const{mode:e}=this.viewModel;return"none"===e?null:(this._calculationTask?.abort(),this._calculationTask=a((async t=>{this._distanceCalculation=0;const a="default"===e?await this.viewModel.calculateAccuracy(this.measurementArray,"distance",t):await this.viewModel.calculateAccuracyPanoramic(this.measurementArray,"distance",t);i(t),this._distanceCalculation=a})),await this._calculationTask.promise,this._distanceCalculation)}async _getAreaAccuracyFromTask(e){const{mode:t}=this.viewModel;return"none"===t?null:(this._calculationTask?.abort(),this._calculationTask=a((async a=>{this._distanceCalculation=0;const s="default"===t?await this.viewModel.calculateAccuracy(e,"area",a):await this.viewModel.calculateAccuracyPanoramic(e,"area",a);i(a),this._distanceCalculation=s})),await this._calculationTask.promise,this._distanceCalculation)}};e([r()],g.prototype,"type",void 0),e([r()],g.prototype,"measurementArray",void 0),e([r()],g.prototype,"pixelMeasurement",void 0),e([r()],g.prototype,"pixelAreaMeasurement",void 0),e([r()],g.prototype,"polygonVertices",void 0),g=e([o("esri.widgets.OrientedImageryViewer.adapters.sketch.MeasurementAdapter")],g);const w=g;export{w as default};
