/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Promise.js";import{property as a}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{projectWithZConversion as r}from"../../../../geometry/projectionUtils.js";import{computeTriangulatedVector as i,computeTriangulatedAreaMeasurement as o,computeTriangulatedDistanceMeasurement as n}from"../../imageMeasurementUtils.js";import{TriangulatedSketchHandlerMixin as c}from"../../mixins/TriangulatedSketchHandlerMixin.js";let m=[],u=class extends(c(t)){constructor(e){super(e),this.type="measurement"}async handleUpdate(e){const{measureType:t,updatingTriangularMeasurementState:a}=this.viewModel;if("distance"===t){const t=e.graphics[0].geometry;m=t.paths[0]}else if("area"===t){const t=e.graphics[0].geometry;m=t.rings[0]}"complete"===e.state&&(this.viewModel.triangulatedMeasurementGraphic=e.graphics.at(-1),a?this._updateTriangularMeasurements(m):await this.viewModel.processMeasurementVectors(m))}async _computeMeasurementVector(e,t){const{activeViewer:a,mode:s,view:o}=this.viewModel,n=a?.imageSize;if(!e||!t||!n)return;const c=e.map((e=>[e[0]-.5,-.5-e[1]])),m=o?.spatialReference,u=[];for(let i=0;i<c.length;i++){const e={x:c[i][0],y:c[i][1]};let a=await this.viewModel.getMapPoint(e,{feature:t,imageSize:n,mode:s});m&&!a.spatialReference.equals(m)&&(a=await r(a,m)),u.push(a)}return i(u,t)}async _updateTriangularMeasurements(e){const{measureType:t,triangularMeasurementActive:a,currentBestFeatureMeasurementImage:s,updatingTriangularMeasurementState:r}=this.viewModel;if(!a||!s||!r||2!==this.viewModel.measurementVectors?.length)return;this.viewModel.measurementVectors.splice(-1);const i=await this._computeMeasurementVector(e,s);if(i&&this.viewModel.measurementVectors.push(i),2===this.viewModel.measurementVectors.length){switch(t){case"distance":{this.viewModel.triangulatedDistanceMeasurement=await n(this.viewModel.measurementVectors);const t=await this.viewModel.calculateAccuracy(e,"distance");if(t&&this.viewModel.triangulatedDistanceMeasurement?.distance){const e=Math.atan(t/this.viewModel.triangulatedDistanceMeasurement.distance);this.viewModel.triangulatedDistanceAccuracy={distanceAccuracy:t,angleAccuracy:e}}break}case"area":if(s?.geometry.spatialReference){const e=await o(this.viewModel.measurementVectors,s.geometry.spatialReference);this.viewModel.triangulatedAreaMeasurement=e}}this.viewModel.updatingTriangularMeasurementState=!1}}};e([a()],u.prototype,"type",void 0),u=e([s("esri.widgets.OrientedImageryViewer.adapters.sketch.TriangulatedMeasurementAdapter")],u);const l=u;export{l as default};
