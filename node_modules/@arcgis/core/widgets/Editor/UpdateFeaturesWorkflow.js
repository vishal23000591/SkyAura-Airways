/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{unique as e,isSome as r}from"../../core/arrayUtils.js";import o from"../../core/Collection.js";import i from"../../core/Error.js";import s from"../../core/Logger.js";import{destroyMaybe as a}from"../../core/maybe.js";import{whenOnce as n}from"../../core/reactiveUtils.js";import{property as l}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import{subclass as d}from"../../core/accessorSupport/decorators/subclass.js";import{isTable as u}from"../../layers/support/layerUtils.js";import{hasEffectiveFeatureExpressionInfo as p}from"../../support/elevationInfoUtils.js";import c from"../BatchAttributeForm/BatchAttributeFormViewModel.js";import f from"./UpdateFeaturesWorkflowData.js";import h from"./Workflow.js";import{whenEditorLayerView as m,makeMultipleSourceLayersError as y}from"./workflowUtils.js";import{SketchController as w}from"./support/SketchController.js";var g;const F=()=>s.getLogger("esri.widgets.Editor.UpdateFeaturesWorkflow");let _=g=class extends h{constructor(t){super(t),this.type="update-features",this._formViewModel=null,this._sketchController=null}async initialize(){this._initializeFormViewModel();try{await this._updatingHandles.addPromise((async()=>{const{fullFeatures:t}=await this.data.when();this._formViewModel.features=new o(t),await this._initializeVisuals(t)})())}catch(t){this.cancel({force:!0,error:new i("update-features-workflow:initialize","Failed to initialize the workflow data.",t)})}}destroy(){this._sketchController=a(this._sketchController),this._formViewModel.destroy()}get features(){return this.data.features}get formViewModel(){return this._formViewModel}get hasPendingEdits(){const{data:t}=this;return t.features.some((e=>!!t.getPendingEditsForFeature(e)?.modified))}get parent(){return this.data.parent}get parentLayer(){return this.parent?.data.editorItem.layer}get selectedFeature(){return this.data.selectedFeature}get sketchViewModel(){return this._sketchController?.viewModel}get updating(){return this._updatingHandles.updating||this._formViewModel.updating||!!this._sketchController?.updating}async commit(){const{data:t,_formViewModel:e}=this;for(const r of t.fullFeatures)E(t.getPendingEditsForFeature(r),e.getValues(r));await super.commit()}static create(t){const{applyEdits:o,applyEditsFeatureService:i,...s}=t,a=e(t.features.map((t=>t.sourceLayer??t.layer))).map((e=>t.viewModel.editorItems.find((t=>t.layer===e)))).filter(r),n=new g({data:new f({...s,editorItems:a}),onCommit:M(t.applyEdits)});return n._set("steps",b()),n}async deleteAndCommit(){return this.data.stageDelete(),this.commit()}enter(){throw new Error("Method not implemented.")}exit(t){throw new Error("Method not implemented.")}async reset(){}async save(){const{formViewModel:t}=this;t.submit(),t.valid&&await super.save()}async start(){await super.start(),await n((()=>!this.updating))}_initializeFormViewModel(){const{data:t}=this,e=t.viewModel.view,r=t.getEditorItemForLayer(k(t)),o=new c({editType:"UPDATE",map:e?.map,readOnly:!1===r?.capabilities.update.attributes,spatialReference:e?.spatialReference,timeZone:t.timeZone});this._formViewModel=o,this.addHandles(o.on("value-change",(e=>{for(const r of e.features)t.getPendingEditsForFeature(r)?.setAttribute(e.fieldName,e.value);this._sketchController?.notifyAttributesChanged(e)})))}async _initializeHighlights(t,e,r){const o=await m(r,e);this.addHandles(o.highlight(t))}async _initializeSketchController(t,e,r){const o=new w({sourceLayer:e,view:r,features:t});this._sketchController=o,await n((()=>!o.updating));const{data:i}=this;await o.startUpdatingFeatures(t,(t=>{const e=[];for(const{feature:r,geometry:o}of t)i.getPendingEditsForFeature(r)?.updateGeometry(o),e.push(r);this._formViewModel.notifyGeometriesChanged(e)}),(()=>{F().warnOnce("editor:batch-update-visual-variables","UpdateFeaturesWorkflow does not currently support modifying visual variables through the scale and rotate tools.")}))}async _initializeVisuals(t){const{data:e}=this,{view:r}=e.viewModel;if(!r)return;const o=k(e);if(u(o))return;const i=e.getEditorItemForLayer(o);return!i?.capabilities.update.geometry||"3d"===r?.type&&p(o.elevationInfo)?this._initializeHighlights(t,o,r):this._initializeSketchController(t,o,r)}};t([l()],_.prototype,"features",null),t([l()],_.prototype,"formViewModel",null),t([l()],_.prototype,"hasPendingEdits",null),t([l()],_.prototype,"parent",null),t([l()],_.prototype,"parentLayer",null),t([l()],_.prototype,"selectedFeature",null),t([l()],_.prototype,"sketchViewModel",null),t([l()],_.prototype,"type",void 0),t([l()],_.prototype,"updating",null),t([l()],_.prototype,"_formViewModel",void 0),t([l()],_.prototype,"_sketchController",void 0),_=g=t([d("esri.widgets.Editor.UpdateFeaturesWorkflow")],_);const v=_;function b(){return[{id:"editing-features",async setUp(){},async tearDown(){}}]}function M(t){return async e=>{const r=k(e),o=[],i=[];for(const t of e.fullFeatures){const r=e.getPendingEditsForFeature(t),s=r?.stagedForDelete;if(!r?.modified&&!s)continue;const a=t.clone();if(!r?.attributesModified||s){const e=t.sourceLayer;if(!e){F().warn("Feature has no sourceLayer. It will not be included in any applyEdits payload.");continue}const r=e.objectIdField;if(a.attributes={[r]:t.getAttribute(r)},"scene"===e.type&&null!=e.infoFor3D){const r=e.associatedLayer?.globalIdField;null!=r&&a.setAttribute(r,t.getAttribute(r))}}r?.geometryModified&&!s||(a.geometry=null),s?i.push(a):o.push(a)}if(o.length+i.length===0)return void F().warn("No edits to apply. Workflow will finish without sending an applyEdits request.");const s={updateFeatures:o.length>0?o:void 0,deleteFeatures:i.length>0?i:void 0};await t(r,s)}}function k(t){if(t.layers.length>1)throw y();return t.layers[0]}function E(t,e){if(!t||!t.feature)return;const{attributes:r}=t.feature;Object.keys(e).some((t=>e[t]!==r[t]))&&t.updateAttributes(e)}export{v as default};
