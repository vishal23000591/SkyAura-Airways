/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import{isSome as i}from"../../../core/arrayUtils.js";import s from"../../../core/Error.js";import{abortHandle as r}from"../../../core/handleUtils.js";import{debounce as a}from"../../../core/promiseUtils.js";import{whenOnce as o,watch as n}from"../../../core/reactiveUtils.js";import{first as l}from"../../../core/SetUtils.js";import{property as c}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as h}from"../../../core/support/UpdatingHandles.js";import d from"../../../layers/GraphicsLayer.js";import u from"../../../views/interactive/sketch/SketchOptions.js";import{getVisualVariablesForLayer as m,updateGraphicSymbolWhenRequired as y,setVisualVariablesAndElevationInfoForUpdate as w,swapForEditingSession as g,visualVariableInteractiveUpdate as f,getSizeVariableAttribute as v,getRotationVariableAttribute as _}from"../workflowUtils.js";import b from"../../Sketch/SketchViewModel.js";const k=Symbol();let L=class extends t{constructor(e){super(e),this.features=[],this.sketchOptions=new u,this.snappingManager=null,this.sourceLayer=null,this.view=null,this.viewModel=null,this._sketchGraphics=new Map,this._sketchLayer=null,this._updatingHandles=new h,this._visualVariableAttributes=new Map,this._visualVariablesForLayer=null,this._webStyleCache=new Map}async initialize(){this._visualVariablesForLayer=m(this.sourceLayer),this._initializeSketchGraphics(),this._initializeSketchLayer(),await this._updatingHandles.addPromise(this._initializeSketchViewModel())}destroy(){const{_sketchLayer:e,view:t}=this;t?.destroyed||t?.map.remove(e),e.destroy(),this.viewModel.destroy()}get updating(){return this._updatingHandles.updating}async enter(){throw new Error("enter() not implemented")}async exit(){throw new Error("exit() not implemented")}notifyAttributesChanged({features:e,fieldName:t}){const i=this._webStyleCache,s=this.view.scale,r=this._updatingHandles;for(const a of e){const e=this._sketchGraphics.get(a),o=a.getAttribute(t);if(!e||e.getAttribute(t)===o)continue;e.setAttribute(t,o);const n=this._visualVariableAttributes.get(a);null==n?.size||n.size.isUpdatingInteractively||n.size.field!==t||n.size.setInitialValue(o),null==n?.rotation||n.rotation.isUpdatingInteractively||n.rotation.field!==t||n.rotation.setInitialValue(o),r.addPromise(y(e,i,s))}}async startUpdatingFeatures(e,t,s){const{_sketchGraphics:a,sourceLayer:n,view:l,viewModel:c,_webStyleCache:p}=this,h=e.map((e=>a.get(e))).filter(i),d={};this.removeHandles(k),c.complete();let u=null;if(1===e.length){const t=e[0],i=this._visualVariableAttributes.get(t);!(!i?.rotation&&!i?.size)&&(w({sketchViewModel:c,graphic:h[0],sourceLayer:n,visualVariables:i,webStyleCache:p}),"point"===n.geometryType&&(d.enableRotation=null!=i.rotation,d.enableScaling=null!=i.size,u=async e=>{const r=e.graphics[0];f(l,r,e,i)&&(s?.([{feature:t,attributes:r.attributes}],e),this._updatingHandles.addPromise(y(r,p,"2d"===l.type?l.scale:null)))}))}else d.tool="move";const m=()=>c.update(h,d),g=c.on("update",(s=>{if("complete"===s.state){if(null===l.activeTool)return void m();const e=new AbortController,t=r(e);return this.addHandles(t,k),void this._updatingHandles.addPromise(o((()=>null===l.activeTool),e.signal).then((async()=>{e.signal.aborted||(e.abort(),await m())})))}const n=e.map((e=>{const t=a.get(e);return t?{feature:e,geometry:t.geometry}:null})).filter(i);t(n,s),u?.(s)}));await m(),this.addHandles(g,k),c.addHandles(g)}_initializeSketchGraphics(){const{features:e,_sketchGraphics:t,sourceLayer:i,_visualVariableAttributes:s}=this,r=this._visualVariablesForLayer,a=r.rotation?.field,o=r.size?.field,n={rotation:a?i.getField(a):null,size:o?i.getField(o):null},l=!(!n.rotation&&!n.size);for(const c of e)t.set(c,c.clone()),l&&s.set(c,z(r,n))}_initializeSketchLayer(){const{view:e}=this,t=new d({elevationInfo:this.sourceLayer.elevationInfo,internal:!0,listMode:"hide"});this._sketchLayer=t,e.map.add(t),this._updatingHandles.addPromise(e.whenLayerView(t))}async _initializeSketchViewModel(){const{_sketchGraphics:e,view:t,_webStyleCache:i}=this,s=Array.from(e.entries()),r=new b({allowDeleteKey:!1,defaultUpdateOptions:{multipleSelectionEnabled:!1},layer:this._sketchLayer,sketchOptions:this.sketchOptions,snappingManager:this.snappingManager,updateOnGraphicClick:!1,view:this.view});this.viewModel=r;const o=a((e=>Promise.all(s.map((([,t])=>y(t,i,e))))));await o("2d"===t.type?t.scale:null),"2d"===t.type&&this.addHandles(n((()=>t.scale),(e=>o(e)))),this.addHandles(await Promise.all(s.map((([e,t])=>g(r,e,t)))))}};function S({features:e,sketchOptions:t,snappingManager:i,view:r}){const a=new Set(e.map((e=>e.sourceLayer)));if(1!==a.size)throw new s("editor:features-must-belong-to-same-layer","All features must belong to the same layer.");const o=l(a);return new L({view:r,features:e,sketchOptions:t,snappingManager:i,sourceLayer:o})}function z({rotation:e,size:t},i){return{rotation:e?_(e,i.rotation):null,size:t?v(t,i.size):null}}e([c()],L.prototype,"features",void 0),e([c()],L.prototype,"sketchOptions",void 0),e([c()],L.prototype,"snappingManager",void 0),e([c()],L.prototype,"sourceLayer",void 0),e([c()],L.prototype,"updating",null),e([c()],L.prototype,"view",void 0),e([c()],L.prototype,"viewModel",void 0),e([c()],L.prototype,"_sketchGraphics",void 0),e([c()],L.prototype,"_sketchLayer",void 0),e([c()],L.prototype,"_visualVariablesForLayer",void 0),L=e([p("esri.widgets.Editor.support.SketchController")],L);export{L as SketchController,S as createSketchController};
