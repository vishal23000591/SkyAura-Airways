/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{toPt as r}from"../../core/screenUtils.js";import{ensureClass as a}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import s from"../../renderers/ClassBreaksRenderer.js";import l from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as u}from"../../renderers/support/utils.js";import m from"../../renderers/visualVariables/SizeVariable.js";import{castSizeFromStringOrNumber as p}from"../../renderers/visualVariables/support/castSizeVariable.js";import d from"../../renderers/visualVariables/support/SizeStop.js";import c from"../../renderers/visualVariables/support/SizeVariableLegendOptions.js";import{TransformationType as f}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import y from"../heuristics/ageUnit.js";import v from"../heuristics/outline.js";import z from"../heuristics/referenceSize.js";import w from"../heuristics/sizeRange.js";import{getTypeSchemeData as h}from"./type.js";import{createPrimitiveOverrides as b,updateReferenceSizeSymbol as g,createReferenceSizeSymbol as S}from"./support/referenceSizeUtils.js";import{isSizeVV as x,getAuthoringInfoVisualVariable as V,spliceVisualVariables as T,updateAuthoringInfoVisualVariable as E,processRegenerateParams as k,getRendererToUpdate as O,getStyleType as I,hasScaleDependentSizeVV as B,hasOutlineVV as F,findSizeVVIndex as j,findOutlineVVIndex as q}from"./support/regenerateUtils.js";import{createPrimitiveOverrides as R,updateSpikeSymbol as D,createSpikeSymbol as G,defaultSpikeSymbolStyle as U}from"./support/spikeUtils.js";import{getSummaryStatistics as P,errorCallback as M,getClassBreaks as C,getTitleAndExpressionForAgeRenderer as W,updateAgeRendererAuthoringInfoVV as $,verifyBasicFieldValidity as A,getSizeRangeForAxis as H,getDataRange as L,createSymbol as J,getSymbolOutlineFromScheme as K,getSymbolSizeFromScheme as N,getBasemapInfo as Q}from"./support/utils.js";import{verifyDates as X,supportedAgeUnits as Y}from"../statistics/support/ageUtils.js";import{verifyBinningParams as Z}from"../support/binningUtils.js";import{getFieldsList as _,isAnyDateField as ee,getNormalizationType as ie}from"../support/utils.js";import{binningCapableLayerTypes as re,featureCapableLayerTypes as ae,createLayerAdapter as ne,getLayerTypeLabels as se}from"../support/adapters/support/layerUtils.js";import{cloneScheme as le,getSchemes as te}from"../symbology/size.js";import{getColorFromSymbol as oe}from"../../symbols/support/utils.js";const ue=2**53-1,me=[5,112.5];async function pe(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new i("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new i("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&Z(e,"size-visual-variable");const r={...e},a=e.forBinning?re:ae,n=ne(r.layer,a,e.forBinning);if(!n)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+se(a).join(", "));"height"===r.axis&&(r.sizeOptimizationEnabled=!1);const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(r.worldScale){if("polyline"===l||"polygon"===l)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!r.view||"3d"!==r.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===r.theme&&!e.forBinning&&"polygon"!==l)throw new i("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===r.theme&&!e.forBinning&&"polygon"!==l&&"point"!==l)throw new i("size-visual-variable:invalid-parameters","Spike is only supported for point and polygon layers");const t=await _({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),o=A(n,t,"size-visual-variable:invalid-parameters");if(o)throw o;return"spike"!==r.theme||r.spikeOptions?.symbolStyle||(r.spikeOptions??={},r.spikeOptions.symbolStyle=U),await ce(r),{...r,layer:n}}async function de(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&Z(e,"size-continuous-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0;const a=e.forBinning?re:ae,n=ne(r.layer,a,e.forBinning);if(!n)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+se(a).join(", "));const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType,t=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="reference-size"!==r.theme&&"spike"!==r.theme&&"polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===r.theme&&!e.forBinning&&"polygon"!==l)throw new i("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");if("spike"===r.theme&&!e.forBinning&&"polygon"!==l&&"point"!==l)throw new i("size-continuous-renderer:invalid-parameters","Spike is only supported for point and polygon layers");const o=await _({field:r.field,normalizationField:r.normalizationField,valueExpression:r.valueExpression}),u=A(n,o,"size-continuous-renderer:invalid-parameters");if(u)throw u;return"spike"!==r.theme||r.spikeOptions?.symbolStyle||(r.spikeOptions??={},r.spikeOptions.symbolStyle=U),await ce(r),{...r,layer:n}}async function ce(e){const i=e.layer;if(("polygon"===i.geometryType||e.forBinning)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await z({layer:i,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function fe(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new i("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:r,forBinning:a}=e,n=e.forBinning?re:ae,s=ne(e.layer,n,e.forBinning);if(!s)throw new i("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+se(n).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some((e=>"reference-size"===e.theme)))throw new i("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const u=e.isGrid??(await z({view:r,layer:l,forBinning:a}))?.isGrid;return{...e,isGrid:u,renderer:t,layer:s}}async function ye(e){if(!e||!e.layer||!e.sizeStops)throw new i("update-renderer-with-spike:missing-parameters","'layer' and 'sizeStops' parameters are required");const r=e.forBinning?re:ae,a=ne(e.layer,r,e.forBinning);if(!a)throw new i("update-renderer-with-spike:invalid-parameters","'layer' must be one of these types: "+se(r).join(", "));await a.load();const n=a.layer;let s=e.renderer;if(!s)if(e.forBinning){if(!("featureReduction"in n&&n.featureReduction&&"renderer"in n.featureReduction&&n.featureReduction.renderer)||"class-breaks"!==n.featureReduction.renderer.type&&"unique-value"!==n.featureReduction.renderer.type)throw new i("update-renderer-with-spike:invalid-parameters","Feature reduction renderer is not supported");s=n.featureReduction.renderer}else{if(!("renderer"in n)||!n.renderer||"class-breaks"!==n.renderer.type&&"unique-value"!==n.renderer.type)throw new i("update-renderer-with-spike:invalid-parameters","Renderer is not supported");s=n.renderer}const l=s.authoringInfo,t=l?.visualVariables.find((e=>"spike"===e.theme));if(!t)throw new i("update-renderer-with-spike:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'spike'");const o=e.spikeOptions??{};return o.symbolStyle??=t?.spikeSymbolStyle?void 0:U,{...e,renderer:s,layer:a,spikeOptions:o}}async function ve(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&Z(e,"size-class-breaks-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0,r.classificationMethod??="equal-interval",r.normalizationType=ie(r);const a=e.forBinning?re:ae,n=ne(r.layer,a,e.forBinning);if(!n)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+se(a).join(", "));if(!(null!=r.minValue&&null!=r.maxValue)&&(null!=r.minValue||null!=r.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=r.signal?{signal:r.signal}:null;await n.load(s);const l=n.geometryType,t=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===l&&r.outlineOptimizationEnabled,"mesh"===l)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await _({field:r.field,normalizationField:r.normalizationField}),u=A(n,o,"size-class-breaks-renderer:invalid-parameters");if(u)throw u;return{...r,layer:n}}function ze(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}function we(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric"),a=i;return a.worldScale=r,r&&(a.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,a}async function he(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const r={...e};r.symbolType??="2d",r.defaultSymbolEnabled??=!0;const a=ne(r.layer,ae);if(!a)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+se(ae).join(", "));const n=null!=r.signal?{signal:r.signal}:null;await a.load(n);const s=a.geometryType,l=r.symbolType.includes("3d");if(r.outlineOptimizationEnabled="polygon"===s&&r.outlineOptimizationEnabled,"mesh"===s)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=X(a,r.startTime,r.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(r.unit&&!Y.includes(r.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${Y.join(", ")}`);return{...r,layer:a}}async function be(e){const r="regenerate-size-visual-variables";k(e,r);const a=await O(e),n=I(a);if(!n||!["size-continuous","univariate-color-size","color-size","relationship-size","type-size"].includes(n))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const s=V(a,"size");if(!s)throw new i(`${r}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const l=s.theme,t="reference-size"===l,o="spike"===l,u=a.visualVariables?.find(x);if(!u&&!t&&!o)throw new i(`${r}:invalid-parameters`,"Renderer does not have a size visual variable");let m=s.field,p=s.normalizationField,d=null,c=null;m||(u?.field?(m=u.field,p=u.normalizationField):a.field?(m=a.field,p=a.normalizationField):(d=u?.valueExpression??a.valueExpression,c=u?.valueExpressionTitle??a.valueExpressionTitle));const{layer:f,forBinning:y,filter:v,view:z,signal:w}=e,h=B(a),b=await pe({layer:f,field:m,valueExpression:d,valueExpressionTitle:c,normalizationField:p,theme:l,sizeOptimizationEnabled:h,forBinning:y,filter:v,view:z,signal:w});return{...e,creatorParameters:b,renderer:a}}async function ge(e){const r="regenerate-size-continuous-renderer";k(e,r);const a=await O(e),n=I(a);if(!n||!["size-continuous","univariate-color-size"].includes(n))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:s,field:l,normalizationField:t,valueExpression:o,valueExpressionTitle:u}=a,m=s?.visualVariables.find((e=>"size"===e.type)),p=m.theme,{layer:d,forBinning:c,filter:f,view:y,signal:v}=e,z=F(a),w=B(a),h=await de({layer:d,field:l,valueExpression:o,valueExpressionTitle:u,normalizationField:t,theme:p,outlineOptimizationEnabled:z,sizeOptimizationEnabled:w,forBinning:c,filter:f,view:y,signal:v});return{...e,creatorParameters:h,renderer:a}}async function Se(e){const r="regenerate-size-class-breaks-renderer";await k(e,r);const a=await O(e);if("size-class-breaks"!==I(a))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:u,valueExpressionTitle:m}=a,{classificationMethod:p,standardDeviationInterval:d}=n,c=a.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:z,signal:w}=e,h=F(a),b=await ve({layer:f,field:s,valueExpression:u,valueExpressionTitle:m,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:p,standardDeviationInterval:d,numClasses:c,outlineOptimizationEnabled:h,forBinning:y,filter:v,view:z,signal:w});return{...e,creatorParameters:b,renderer:a}}async function xe(e){const r="regenerate-size-age-renderer";await k(e,r);const a=await O(e);if("size-age"!==I(a))throw new i(`${r}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n}=a,s=n?.visualVariables.find((e=>"size"===e.type)),l=s.startTime,t=s.endTime,o=s.units,u=s.theme,{layer:m,filter:p,view:d,signal:c}=e,f=F(a),y=B(a),v=await he({layer:m,startTime:l,endTime:t,unit:o,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:p,view:d,signal:c});return{...e,creatorParameters:v,renderer:a}}async function Ve(e){let i=e.sizeScheme,r=null,a=null;const n=await Q(e.basemap,e.view);if(r=null!=n.basemapId?n.basemapId:null,a=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:le(i),basemapId:r,basemapTheme:a};const s=te({basemapTheme:a,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,r=s.basemapId,a=s.basemapTheme),{scheme:i,basemapId:r,basemapTheme:a}}function Te(e,i){switch(i){case"point":case"multipoint":{const i=e;return[p(i.minSize),p(i.maxSize)]}case"polyline":{const i=e;return[p(i.minWidth),p(i.maxWidth)]}case"polygon":{const i=e;return[p(i.marker.minSize),p(i.marker.maxSize)]}}}function Ee(e,i){e.transformationType===f.ClampedLinear&&"below"===i&&e.flipSizes()}async function ke(e,i,r,a,n,s){const l=Oe(e,i,r,a);return l||Te(n,s)}function Oe(e,i,r,a){return"spike"===a?[r?.minHeight??me[0],r?.maxHeight??me[1]]:"reference-size"===a&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function Ie(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,r=0,a=0,n=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,u=0!==s?o/s:0,m=l>a&&l<n&&t<2*n&&u<.5,p=l>r&&l<i&&t<2*i&&u<.5;return{minDataValue:m?a:p?r:l,maxDataValue:m?n:p?i:s+2*o,defaultValuesUsed:!1}}const{theme:r,field:a}=i,n=i.layer,s=a&&!("function"==typeof a)?n.getField(a):null,l=ee(s);return L(e,r,l,"above"===r||"below"===r)}function Be(e,r){if(("spike"===r||"reference-size"===r)&&null!=e.minDataValue&&null!=e.maxDataValue&&null!=e.minSize&&null!=e.maxSize&&"number"==typeof e.minSize&&"number"==typeof e.maxSize)return[new d({value:e.minDataValue,size:e.minSize}),new d({value:e.maxDataValue,size:e.maxSize})];throw new i("get-size-stops-for-theme","Invalid size variable or theme")}async function Fe(e,r,n,s){const{theme:u,field:p,normalizationField:d,minValue:f,maxValue:y,axis:v}=e,z=e.layer.geometryType,w=await Ve({basemap:e.basemap,geometryType:z,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=w.scheme;if(!h)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const b=await ke(n,s,e.spikeOptions,u,h,z),{minDataValue:g,maxDataValue:S,defaultValuesUsed:x}=Ie(r,e),V=[],T="height"===v,E=T?v:void 0,k=b[0];let O=b[1];if(T&&"number"==typeof k&&"number"==typeof O){const e=H({minSize:k,maxSize:O},E);V.push(new m({axis:"width-and-depth",minSize:e.minSize})),O=e.maxSize}const I=new m({field:p??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:d,axis:E,minSize:k,maxSize:O,minDataValue:g,maxDataValue:S,legendOptions:a(c,e.legendOptions)});Ee(I,u),V.unshift(I);const B=new o("reference-size"===u?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:Be(I,u).map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),theme:u,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}:"spike"===u?{type:"size",field:e.field,normalizationField:e.normalizationField,spikeSymbolStyle:e.spikeOptions?.symbolStyle,sizeStops:Be(I,u).map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),theme:u,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}:{type:"size",theme:u,minSliderValue:null!=f?f:r.min,maxSliderValue:null!=y?y:r.max}),F=new l({visualVariables:[B]});return{basemapId:w.basemapId,basemapTheme:w.basemapTheme,visualVariables:V,statistics:r,isGrid:s?.isGrid,defaultValuesUsed:x,sizeScheme:le(h),authoringInfo:F}}async function je(e,i,r,a,l){const t=await n("esri/smartMapping/t9n/smartMapping"),o=l.layer,u=l.field,m=o.geometryType,p=l.defaultSymbolEnabled,d=le(e.sizeScheme),c="polygon"===m,f=c?d.marker:d,y=c?d.background:null,v=c?"point":m,z=i?.opacity,w=e.isGrid,h=l.theme,g="reference-size"===h,x="spike"===h,V=g||x?[]:e.visualVariables.map((e=>e.clone()));i?.visualVariables?.length&&V.push(...i.visualVariables.map((e=>e.clone())));const T=g?S({type:l.referenceSizeOptions?.symbolStyle||"circle",color:f.color,primitiveOverrides:b({view:l.view,field:u,normalizationField:a,sizeStops:Be(e.visualVariables[0],h),sizeByScaleEnabled:w||!!l.sizeOptimizationEnabled})}):x?G({color:f.color,strokeColor:f.outline.color,baseWidth:l.spikeOptions?.baseWidth,strokeWidth:l.spikeOptions?.strokeWidth,defaultHeight:l.spikeOptions?.defaultHeight,primitiveOverrides:R({field:u,normalizationField:a,sizeStops:Be(e.visualVariables[0],h)}),symbolStyle:l.spikeOptions?.symbolStyle}):J(v,{type:l.symbolType,color:f.color,size:N(f,v),outline:K(f,v,z)});return{renderer:new s({backgroundFillSymbol:!w&&y?J(m,{type:l.symbolType,color:y.color,outline:K(y,m,z)}):null,classBreakInfos:[{minValue:-9007199254740991,maxValue:ue,symbol:T}],defaultLabel:p?t.other:null,defaultSymbol:!p||g||x?null:J(v,{type:l.symbolType,color:f.noDataColor,size:N(f,v,!0),outline:K(f,v,z)}),field:u,normalizationField:a,normalizationType:r,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:V,authoringInfo:e.authoringInfo?.clone()}),visualVariables:e.visualVariables.map((e=>e.clone())),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,isGrid:w,sizeScheme:le(e.sizeScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}function qe(e,i){const a=r(e.minSize),n=(r(e.maxSize)-a)/(i>=4?i-1:i),s=[];for(let r=0;r<i;r++)s.push(a+n*r);return s}async function Re(e,i){const r=await n("esri/smartMapping/t9n/smartMapping"),a=e.layer,t=e.defaultSymbolEnabled,o=a.geometryType,m="polygon"===o,p=e.symbolType?.includes("3d-volumetric"),d=await Ve({basemap:e.basemap,geometryType:o,sizeScheme:e.sizeScheme,worldScale:p,view:e.view}),c=d.scheme,{result:f,outlineResult:y}=i,v=f?.classBreakInfos??[],z=e.classificationMethod,w=e.normalizationType,h=m?c.marker:c,b=m?c.background:null,g=m?"point":o,S=Te(h,g),x=p?H({minSize:S[0],maxSize:S[1]},"height"):null,V=qe({minSize:S[0],maxSize:x?x.maxSize:S[1]},v.length),T=y?.opacity,E=new s({backgroundFillSymbol:b&&J(o,{type:e.symbolType,color:b.color,outline:K(b,o,T)}),classBreakInfos:v.map(((i,r)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:J(g,{type:e.symbolType,color:h.color,size:V[r],widthAndDepth:x?.minSize,outline:K(h,g,T)}),label:i.label}))),defaultLabel:t?r.other:null,defaultSymbol:t?J(g,{type:e.symbolType,color:h.noDataColor,size:N(h,g,!0),widthAndDepth:x?.minSize,outline:K(h,g,T)}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?f?.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new l({type:"class-breaks-size",classificationMethod:z,standardDeviationInterval:e.standardDeviationInterval})});return"standard-deviation"!==z&&u({classBreakInfos:E.classBreakInfos,classificationMethod:z,normalizationType:w,round:!0}),y?.visualVariables?.length&&(E.visualVariables=y.visualVariables.map((e=>e.clone()))),{renderer:E,sizeScheme:le(c),classBreaksResult:f,defaultValuesUsed:!!i.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function De(e){const i=await pe(e),{view:r,field:a,valueExpression:n,minValue:s,maxValue:l,layer:t,normalizationField:o,signal:u,statistics:m,filter:p}=i,d=o?"field":void 0,[c,f]=await Promise.all([m??P({layer:t,field:a,valueExpression:n,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:d,normalizationField:o,filter:p,minValue:s,maxValue:l,view:r,signal:u}),i.sizeOptimizationEnabled?w({view:r,layer:t,signal:u,filter:p}).catch(M):null]);return Fe(i,c,f,i.referenceSizeResult)}async function Ge(e){const{view:i,filter:r,renderer:a,signal:n,creatorParameters:s}=await be(e),{field:l,normalizationField:o,valueExpression:u,theme:p,layer:d,sizeOptimizationEnabled:c,spikeOptions:f,referenceSizeResult:y,valueExpressionTitle:v}=s,z=o?"field":void 0,[h,b]=await Promise.all([P({layer:d,field:l,valueExpression:u,normalizationField:o,normalizationType:z,filter:r,view:i,signal:n}),c?w({view:i,layer:d,signal:n,filter:r}).catch(M):null]),g=Oe(b,y,f,p),{minDataValue:S,maxDataValue:T}=Ie(h,{theme:p,layer:d,field:l}),E=a.visualVariables?.find(x),k=(E?.stops?null:E)??new m({field:l??void 0,valueExpression:u,valueExpressionTitle:v,valueUnit:"unknown",normalizationField:o});g&&(k.minSize=g[0],k.maxSize=g[1]),k.minDataValue=S,k.maxDataValue=T,Ee(k,p);const O=V(a,"size");O.minSliderValue=h.min,O.maxSliderValue=h.max;const I="reference-size"===p;return(I||"spike"===p)&&(O.sizeStops=Be(k,p).map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),I&&(O.referenceSizeScale=y?.isGrid||c?i?.scale:void 0)),{visualVariables:"reference-size"===p||"spike"===p?[]:[k],isGrid:!!y?.isGrid,authoringInfo:a.authoringInfo?.clone(),statistics:h}}async function Ue(e){const i=await de(e),r={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[a,n]=await Promise.all([De(we(i)),i.outlineOptimizationEnabled?v(r).catch(M):null]),s=i.normalizationField;return je(a,n,s?"field":void 0,s,i)}async function Pe(e){const{renderer:i,view:r,signal:a,filter:n,creatorParameters:s,forBinning:l}=await ge(e),{layer:t,outlineOptimizationEnabled:o,theme:u,referenceSizeResult:m}=s,[p,d]=await Promise.all([Ge({...e,referenceSizeResult:m}),o?v({layer:t,view:r,filter:n,signal:a}).catch(M):null]),c="reference-size"===u,f="spike"===u;T(i,p.visualVariables,j),T(i,d?.visualVariables,q),E(i,p.authoringInfo,"size");const y=p.statistics;if(!c&&!f)return{renderer:i,statistics:y};if(f){return{renderer:await Ce({layer:t,renderer:i,forBinning:l,sizeStops:V(i,"size","spike")?.sizeStops}),statistics:y}}const z=p.isGrid;return{renderer:await Me({layer:t,renderer:i,view:r,forBinning:l,sizeStops:V(i,"size","reference-size")?.sizeStops,isGrid:z}),isGrid:z,statistics:y}}async function Me(r){const{layer:a,referenceSizeOptions:n,renderer:s,sizeScheme:o,sizeStops:u,typeScheme:m,view:p,isGrid:d}=await fe(r),c=s.clone();c.authoringInfo??=new l;const f=c.authoringInfo.visualVariables.find((e=>"reference-size"===e.theme)),y=r.field??f?.field,v=r.normalizationField??f?.normalizationField;if(!y)throw new i("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const z=b({view:p,field:y,normalizationField:v,sizeStops:u,sizeByScaleEnabled:d||!!r.sizeOptimizationEnabled}),w=n?.symbolStyle||f?.referenceSizeSymbolStyle||"circle";if("class-breaks"===c.type){const e="polygon"===("geometryType"in a?a.geometryType:null)&&o&&"marker"in o?o.marker:null;c.classBreakInfos.forEach((i=>{const r=e?.color??oe(i.symbol,1);"cim"===i.symbol.type?g(i.symbol,{type:w,color:r,primitiveOverrides:z}):r&&(i.symbol=S({type:w,color:r,primitiveOverrides:z}))}))}else if("unique-value"===c.type){const i=c.uniqueValueGroups,r="polygon"===("geometryType"in a?a.geometryType:null)&&m&&"colors"in m?m.colors:null,n=r?e(r,c.uniqueValueInfos?.length??0):null;let s=0;if(i){for(const e of i)for(const i of e.classes??[]){const e=n?n[s]:oe(i.symbol,1);"cim"===i.symbol?.type?g(i.symbol,{type:w,color:e,primitiveOverrides:z}):e&&(i.symbol=S({type:w,color:e,primitiveOverrides:z})),s++}c.uniqueValueGroups=i}}return f&&(f.field=y,f.normalizationField=v,f.sizeStops=u.map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),f.referenceSizeScale=d||r.sizeOptimizationEnabled?p.scale:void 0,f.referenceSizeSymbolStyle=w),c}async function Ce(r){const{layer:a,renderer:n,sizeScheme:s,sizeStops:o,typeScheme:u,spikeOptions:m}=await ye(r),p=n.clone();p.authoringInfo??=new l;const d=p.authoringInfo.visualVariables.find((e=>"spike"===e.theme)),c=r.field??d?.field,f=r.normalizationField??d?.normalizationField;if(!c)throw new i("update-renderer-with-spike:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const y=R({field:c,normalizationField:f,sizeStops:o}),v="geometryType"in a?a.geometryType:null,z={primitiveOverrides:y,...m},w=m?.symbolStyle,b=w&&w.includes("outline")&&(w.includes("solid-fill")||w.includes("gradient-fill"));if("class-breaks"===p.type){if(s||b){const e=v?await Ve({geometryType:v,sizeScheme:s,view:r.view}):null,i=e?.scheme,a="polygon"===v&&i&&"marker"in i?i.marker:i;if(s){const e=a&&"color"in a?a?.color:void 0;z.color=e}if(b){const e=a&&"outline"in a?a.outline.color:void 0;z.strokeColor=e}}p.classBreakInfos.forEach((e=>{if("cim"===e.symbol.type)D(e.symbol,z);else{const i=z.color??oe(e.symbol,1)??void 0;i&&(e.symbol=G({...z,color:i}))}}))}else if("unique-value"===p.type){const i=p.uniqueValueGroups,a=p.uniqueValueInfos?.length??0;let n=null;if(u||b){const i=v&&a?await h({numColors:a,geometryType:v,typeScheme:u,view:r.view}):null,s=i?.scheme;if(u){const i=s&&"colors"in s?s.colors:null;n=i?e(i,a):null}if(b){const e=s&&"outline"in s?s.outline.color:void 0;z.strokeColor=e}}let s=0;if(i){for(const e of i)for(const i of e.classes??[]){if("cim"===i.symbol?.type)D(i.symbol,{...z,color:n?.[s]});else{const e=n?.[s]??oe(i.symbol,1)??void 0;e&&(i.symbol=G({...z,color:e}))}s++}p.uniqueValueGroups=i}}return d&&(d.field=c,d.normalizationField=f,d.sizeStops=o.map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),w&&(d.spikeSymbolStyle=w)),p}async function We(e){const i=await ve(e);return Re(i,await C(ze(i),i.outlineOptimizationEnabled))}async function $e(e){const{renderer:r,creatorParameters:a}=await Se(e),{outlineOptimizationEnabled:n,normalizationType:s,classificationMethod:l}=a,{result:t,outlineResult:o}=await C(ze(a),n),m=t.classBreakInfos;if(a.numClasses!==m.length)throw new i("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return r.classBreakInfos.forEach(((e,i)=>{e.minValue=m[i].minValue,e.maxValue=m[i].maxValue,e.label=m[i].label})),r.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&u({classBreakInfos:r.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),T(r,o?.visualVariables,q),{renderer:r}}async function Ae(e){const i=await he(e),{defaultSymbolEnabled:r,view:a,startTime:n,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:u,filter:m,layer:p}=i,[d,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await y({view:a,layer:p,startTime:n,endTime:s,minValue:t,maxValue:o,signal:u,filter:m}),i.outlineOptimizationEnabled?v({layer:p,view:a,filter:m,signal:u}).catch(M):null]),{unit:f,statistics:z}=d,{valueExpression:w,title:h}=await W(i,f),b=await De(we({layer:p,basemap:i.basemap,valueExpression:w,symbolType:l,statistics:z,legendOptions:{title:h},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:m,signal:u})),g={layer:p,valueExpression:w,defaultSymbolEnabled:r,symbolType:l},S=await je(b,c,null,null,g),x=S.renderer.authoringInfo?.visualVariables;return x?.forEach((e=>$(e,n,s,f))),{...S,unit:f}}async function He(e){const{renderer:i,creatorParameters:r}=await xe(e),{layer:a,outlineOptimizationEnabled:n,sizeOptimizationEnabled:s,startTime:l,endTime:t,theme:o,view:u,signal:m,filter:p}=r,[d,c]=await Promise.all([y({view:u,layer:a,startTime:l,endTime:t,signal:m,filter:p}),n?v({layer:a,view:u,filter:p,signal:m}).catch(M):null]),{unit:f,statistics:z}=d,{valueExpression:w,title:h}=await W(r,f),b=await De(we({layer:a,valueExpression:w,statistics:z,legendOptions:{title:h},sizeOptimizationEnabled:s,theme:o,view:u,filter:p,signal:m}));T(i,b.visualVariables,j),T(i,c?.visualVariables,q),i.authoringInfo=b.authoringInfo.clone();const g=i.authoringInfo?.visualVariables;return g?.forEach((e=>$(e,l,t,f))),{renderer:i}}export{Ae as createAgeRenderer,We as createClassBreaksRenderer,Ue as createContinuousRenderer,De as createVisualVariables,Be as getSizeStopsForTheme,He as regenerateAgeRenderer,$e as regenerateClassBreaksRenderer,Pe as regenerateContinuousRenderer,Ge as regenerateVisualVariables,Me as updateRendererWithReferenceSize,Ce as updateRendererWithSpike};
