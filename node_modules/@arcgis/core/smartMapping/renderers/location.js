/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import i from"../../renderers/SimpleRenderer.js";import o from"../heuristics/outline.js";import r from"../heuristics/sizeRange.js";import{errorCallback as a,createSymbol as n,getSymbolOutlineFromScheme as l,getSymbolSizeFromScheme as s,getBasemapInfo as t}from"./support/utils.js";import{verifyBinningParams as m}from"../support/binningUtils.js";import{binningCapableLayerTypes as p,featureCapableLayerTypes as c,createLayerAdapter as u,getLayerTypeLabels as y}from"../support/adapters/support/layerUtils.js";import{cloneScheme as d,getSchemes as b}from"../symbology/location.js";async function f(i){if(!i?.layer)throw new e("location-renderer:missing-parameters","'layer' parameter is required");i.forBinning&&m(i,"location-renderer");const o={...i,layer:i.layer};o.symbolType=o.symbolType||"2d";const r=i.forBinning?p:c,a=u(o.layer,r,i.forBinning);if(!a)throw new e("location-renderer:invalid-parameters","'layer' must be one of these types: "+y(r).join(", "));o.layer=a;const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);const l=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&o.sizeOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new e("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new e("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return o}async function h(e,i){let o=e.locationScheme,r=null,a=null;const n=await t(e.basemap,e.view);if(r=null!=n.basemapId?n.basemapId:null,a=null!=n.basemapTheme?n.basemapTheme:null,o)return{scheme:d(o),basemapId:r,basemapTheme:a};const l=b({basemapTheme:a,geometryType:i,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view});return l&&(o=l.primaryScheme,r=l.basemapId,a=l.basemapTheme),{scheme:o,basemapId:r,basemapTheme:a}}async function w(t){const m=await f(t),p=m.layer.geometryType,c=await h(m,p),u=c.scheme;if(!u)throw new e("location-renderer:insufficient-info","Unable to find location scheme");const{view:y,layer:b,signal:w,filter:v}=m,[T,g]=await Promise.all([m.outlineOptimizationEnabled?o({view:y,layer:b,signal:w,filter:v}).catch(a):null,m.sizeOptimizationEnabled?r({view:y,layer:b,signal:w,filter:v}).catch(a):null]),z=T?.opacity,j=new i({symbol:n(p,{type:m.symbolType,color:u.color,size:s(u,p),outline:l(u,p,z),meshInfo:{colorMixMode:m.colorMixMode,edgesType:m.edgesType}})});return T?.visualVariables.length&&(j.visualVariables=T.visualVariables.map((e=>e.clone()))),g?.minSize&&(j.visualVariables?j.visualVariables.push(g.minSize):j.visualVariables=[g.minSize]),{renderer:j,locationScheme:d(u),basemapId:c.basemapId,basemapTheme:c.basemapTheme}}export{w as createRenderer};
