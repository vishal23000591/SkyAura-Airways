/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{isTimeOnlyField as r}from"../../layers/support/fieldUtils.js";import o from"../../renderers/PointCloudUniqueValueRenderer.js";import t from"../../renderers/UniqueValueRenderer.js";import s from"../../renderers/support/RendererLegendOptions.js";import{createUniqueValueLabel as a,calculateDateFormatInterval as u,dateFormatIntervalOptions as p}from"../../renderers/support/utils.js";import m from"../../renderers/support/pointCloud/ColorUniqueValueInfo.js";import d from"../heuristics/outline.js";import c from"../heuristics/sizeRange.js";import{spliceVisualVariables as f,processRegenerateParams as y,getRendererToUpdate as v,getStyleType as b,hasOutlineVV as w,hasScaleDependentSizeVV as g,findOutlineVVIndex as h,findScaleDependentSizeVVIndex as T}from"./support/regenerateUtils.js";import{getBasemapInfo as z,errorCallback as E,getPointSizeAlgorithm as x,verifyBasicFieldValidity as I,getSymbolSizeFromScheme as V,getSymbolOutlineFromScheme as M,createSymbol as j,isValidPointSize as S}from"./support/utils.js";import O from"../statistics/uniqueValues.js";import{verifyBinningParams as q}from"../support/binningUtils.js";import{getFieldsList as U,fieldDelimiter as C,isAnyDateField as B}from"../support/utils.js";import{binningCapableLayerTypes as P,featureCapableLayerTypes as Z,createLayerAdapter as F,getLayerTypeLabels as R,LayerType as D}from"../support/adapters/support/layerUtils.js";import{cloneScheme as L,getSchemes as k}from"../symbology/type.js";async function A(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new i("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&q(e,"type-renderer");const n={...e,layer:e.layer};n.symbolType=n.symbolType||"2d",n.defaultSymbolEnabled??=!0,n.sortBy??="count",n.sortEnabled??=!0,n.statistics=l(n.statistics);const r=null==n.numTypes?10:n.numTypes,o=e.forBinning?P:Z,t=F(n.layer,o,e.forBinning);if(!t)throw new i("type-renderer:invalid-parameters","'layer' must be one of these types: "+R(o).join(", "));const s=null!=n.signal?{signal:n.signal}:null;await t.load(s);const a=t.geometryType;if(n.outlineOptimizationEnabled="polygon"===a&&n.outlineOptimizationEnabled,n.sizeOptimizationEnabled=("point"===a||"multipoint"===a||"polyline"===a)&&n.sizeOptimizationEnabled,"mesh"===a)n.symbolType="3d-volumetric",n.colorMixMode=n.colorMixMode||"replace",n.edgesType=n.edgesType||"none";else{if("3d-volumetric-uniform"===n.symbolType&&"point"!==a)throw new i("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(n.symbolType.includes("3d-volumetric")&&(!n.view||"3d"!==n.view.type))throw new i("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await U({field:n.field,field2:n.field2,field3:n.field3,valueExpression:n.valueExpression}),p=I(t,u,"type-renderer:invalid-parameters");if(p)throw p;return{...n,layer:t,numTypes:r}}async function $(e){const l="regenerate-type-renderer";await y(e,l);const n=await v(e),r=b(n);if(!r||!["type","type-size"].includes(r))throw new i(`${l}:invalid-parameters`,"Renderer is invalid");const{field:o,field2:t,field3:s,valueExpression:a,valueExpressionTitle:u}=n,p=n.uniqueValueInfos.length,{layer:m,forBinning:d,filter:c,view:f,signal:h}=e,T=w(n),z=g(n),E=await A({layer:m,field:o,field2:t,field3:s,valueExpression:a,valueExpressionTitle:u,numTypes:p,outlineOptimizationEnabled:T,sizeOptimizationEnabled:z,forBinning:d,filter:c,view:f,signal:h});return{...e,creatorParameters:E,renderer:n}}async function G(e){if(!e?.layer||!e.field)throw new i("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const n={...e,layer:e.layer};n.statistics=l(n.statistics);const r=[D.PointCloudLayer],o=F(n.layer,r);if(!o)throw new i("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+R(r).join(", "));if(n.layer=o,n.density=n.density||25,n.size=n.size||"100%",!S(n.size))throw new i("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const t=null!=n.signal?{signal:n.signal}:null;await o.load(t);const s=await U({field:n.field}),a=I(o,s,"type-point-cloud-class-renderer:invalid-parameters");if(a)throw a;return n}async function H(e){let i=e.typeScheme,l=null,n=null;const r=await z(e.basemap,e.view);if(l=null!=r.basemapId?r.basemapId:null,n=null!=r.basemapTheme?r.basemapTheme:null,i)return{scheme:L(i),basemapId:l,basemapTheme:n};const o=k({numColors:e.numColors,basemapTheme:n,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return o&&(i=o.primaryScheme,l=o.basemapId,n=o.basemapTheme),{scheme:i,basemapId:l,basemapTheme:n}}function J(e,i){let l;return l=e.label<i.label?-1:e.label>i.label?1:0,l}function K(e,i){let l;return l=e.value<i.value?-1:e.value>i.value?1:0,l}function N(e,i){let l=i.count-e.count;return 0===l&&(l=J(e,i)),l}function Q(e,i){let l=i.count-e.count;return 0===l&&(l=K(e,i)),l}function W(e,i,l){let n;"count"===i?(n=Q,l&&"codedValues"in l&&l.codedValues&&(n=N)):"value"===i&&(n=K,l&&"codedValues"in l&&l.codedValues&&(n=J)),n&&e.sort(n)}async function X(e,i,l,r){const o=await n("esri/smartMapping/t9n/smartMapping"),{field:u,field2:p,field3:m}=i,d=e.uniqueValueInfos,c=i.layer,f=u?c.getField(u):null,y=f?c.getFieldDomain(f.name):null,v=-1===i.numTypes?d.length:i.numTypes,b=c.geometryType,w=new t({field:u,field2:p,field3:m,fieldDelimiter:u&&p?C:null}),g=[],h=[],T={value:null,domain:y,fieldInfo:f};d.forEach(((e,i)=>{T.value=e.value,e.label=a(T);const l=e.value;(null===l||"string"==typeof l&&l.toLowerCase().includes("<null>"))&&g.unshift(i)}));for(const n of g)h.unshift(d.splice(n,1)[0]);!1!==i.sortEnabled&&W(d,i.sortBy,y),Y(T,i,d);const z=l?.opacity,E=await H({numColors:d.length,basemap:i.basemap,geometryType:b,typeScheme:i.typeScheme,worldScale:!!i.symbolType?.includes("3d-volumetric"),view:i.view}),x=E.scheme,I=x.colors.map((e=>e.clone())),S=V(x,b),O=M(x,b,z);d.forEach(((e,l)=>{T.value=e.value,e.label=a(T),e.symbol=j(b,{type:i.symbolType,color:I[l],size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})),i.valueExpression&&(w.valueExpression=i.valueExpression,w.valueExpressionTitle=i.valueExpressionTitle),i.legendOptions&&(w.legendOptions=new s(i.legendOptions));for(let n=0;n<v;n++){const e=d[n];e&&w.addUniqueValueInfo({value:e.value,label:e.label,symbol:j(b,{type:i.symbolType,color:I[n].clone(),size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})}i.defaultSymbolEnabled&&(w.defaultSymbol=j(b,{type:i.symbolType,color:x.noDataColor,size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),w.defaultLabel=o.other);for(const n of h)n.symbol=j(b,{type:i.symbolType,color:x.noDataColor,size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),d.push(n);const q=[],U=w.uniqueValueInfos?.length??0,B=U===d.length?-1:U;if(B>-1)for(let n=B;n<d.length;n++)q.push({...d[n]});return l?.visualVariables?.length&&(w.visualVariables=l.visualVariables.map((e=>e.clone()))),r?.minSize&&(w.visualVariables?w.visualVariables.push(r.minSize):w.visualVariables=[r.minSize]),{renderer:w,uniqueValueInfos:d,excludedUniqueValueInfos:q,typeScheme:L(x),basemapId:E.basemapId,basemapTheme:E.basemapTheme}}function Y(e,i,l){const{field:n,numTypes:o,layer:t,view:s}=i,a=n?t.getField(n):null;if(a&&(B(a)||r(a))){const i=l.filter(((e,i)=>i<o)).map((e=>e.value)),n=r(a)?null:u(i),m=n?p[n]:void 0;if(e.dateFormatOptions={fieldType:a.type,format:m},s){const i=t.layer;e.dateFormatOptions.timeZoneOptions={layerTimeZone:"preferredTimeZone"in i?i.preferredTimeZone:null,viewTimeZone:s.timeZone,datesInUnknownTimezone:"datesInUnknownTimezone"in i&&i.datesInUnknownTimezone}}}}async function _(i,l){const n=i.uniqueValueInfos,r=await H({numColors:n.length,basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:l}),o=r?.scheme,t="point-cloud-class"===o?.theme,s=t?o.colors:e(o?.colors??[],n.length);return W(n,"value"),n.map(((e,i)=>{const l=e.value;let n=null;return t?(n=s[l],n||(n=s[s.length-1])):n=s[i],new m({values:[l],color:n,label:e.label})}))}async function ee(e){const i=await A(e),{layer:l,view:n,signal:r,filter:o}=i,t={layer:l,field:i.field,field2:i.field2,field3:i.field3,valueExpression:i.valueExpression,returnAllCodedValues:i.returnAllCodedValues,view:n,filter:o,signal:r},[s,a,u]=await Promise.all([null!=i.statistics?i.statistics:O(t),i.outlineOptimizationEnabled?d({layer:l,view:n,signal:r,filter:o}).catch(E):null,i.sizeOptimizationEnabled?c({layer:l,view:n,signal:r,filter:o}).catch(E):null]);return X(s,i,a,u)}async function ie(e){const{creatorParameters:i,view:l,signal:n,filter:r,renderer:o}=await $(e),{layer:t,outlineOptimizationEnabled:s,sizeOptimizationEnabled:a}=i,[u,p]=await Promise.all([s?d({layer:t,view:l,signal:n,filter:r}).catch(E):null,a?c({layer:t,view:l,signal:n,filter:r}).catch(E):null]);return f(o,u?.visualVariables,h),f(o,p?.minSize,T),{renderer:o}}async function le(e){const i=await G(e),l=null!=i.statistics?i.statistics:await O({layer:i.layer,field:i.field,signal:i.signal});return{renderer:new o({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:x(i.size),colorUniqueValueInfos:await _(l,i.typeScheme)})}}export{le as createPCClassRenderer,ee as createRenderer,H as getTypeSchemeData,ie as regenerateRenderer};
