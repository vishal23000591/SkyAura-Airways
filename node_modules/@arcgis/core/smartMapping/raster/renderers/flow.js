/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../../core/colorUtils.js";import r from"../../../core/Error.js";import a from"../../../renderers/support/AuthoringInfo.js";import i from"../../../renderers/support/AuthoringInfoVisualVariable.js";import{createFlowRenderer as t,estimateMagnitudeRange as n}from"../../../renderers/support/rasterRendererHelper.js";import o from"../../../renderers/support/RendererLegendOptions.js";import s from"../../../renderers/visualVariables/ColorVariable.js";import l from"../../../renderers/visualVariables/OpacityVariable.js";import m from"../../../renderers/visualVariables/SizeVariable.js";import p from"../../../renderers/visualVariables/support/ColorStop.js";import u from"../../../renderers/visualVariables/support/OpacityStop.js";import c from"../../../renderers/visualVariables/support/SizeStop.js";import{processRasterRendererParameters as f}from"../support/utils.js";import{getDataRange as d,createDataValues as h,getBasemapInfo as w}from"../../renderers/support/utils.js";import{cloneScheme as b,getSchemes as y}from"../../symbology/flow.js";const V=5;async function v(e){const r={...e};return r.theme||(r.theme="flow-line"),f(r)}async function S(e){let r=e.flowScheme,a=null,i=null;const t=await w(null,e.view);if(a=null!=t.basemapId?t.basemapId:null,i=null!=t.basemapTheme?t.basemapTheme:null,r)return{scheme:b(r),basemapId:a,basemapTheme:i};const n=y({basemapTheme:i,theme:e.theme,hasSizeVariable:e.hasSizeVariable});return n&&(r=n.primaryScheme,a=n.basemapId,i=n.basemapTheme),{scheme:r,basemapId:a,basemapTheme:i}}async function g(t,f){f.flowRepresentation&&(t.flowRepresentation=f.flowRepresentation);const w=await S({theme:f.theme,flowScheme:f.flowScheme,view:f.view,hasSizeVariable:f.includeSizeVariable}),y=w.scheme;if(!y)throw new r("flow-renderer:insufficient-info","Unable to find flow scheme");t.flowSpeed=y.flowSpeed,t.density=y.density,t.trailLength=y.trailLength,t.trailWidth=y.trailWidth,t.trailCap=y.trailCap,t.color=y.color;const v=[],g=[],x="Magnitude",j=f.layer.serviceRasterInfo,z=null==j?.statistics||"vector-magdir"!==j.dataType&&"vector-uv"!==j.dataType?{minMagnitude:0,maxMagnitude:10}:n(j.dataType,j.statistics);if(null==z?.minMagnitude||null==z.maxMagnitude)throw new r("flow-renderer:insufficient-info","stats not available");const I={min:z.minMagnitude,max:z.maxMagnitude},T={min:I.min,max:null!=I.max?I.max/2:null},O=d(T,null,null),M=h(O,T,null);if(f.includeColorVariable){const a=e(y.colors,V);if(a.length<V)throw new r("flow-renderer:insufficient-info","Flow scheme does not have enough colors");const t=new s({field:x,stops:M.map(((e,r)=>new p({value:e,color:a[r]})))});v.push(t);const n=new i({type:"color",minSliderValue:I.min,maxSliderValue:I.max,theme:"high-to-low"});g.push(n)}if(f.includeOpacityVariable){const e=new l({field:x,stops:[new u({value:M[0],opacity:y.minOpacity}),new u({value:M[4],opacity:y.maxOpacity})]});v.push(e);const r=new i({type:"opacity",minSliderValue:I.min,maxSliderValue:I.max});g.push(r)}if(f.includeSizeVariable){const e=new m({field:x,stops:[new c({value:I.min,size:y.minSize}),new c({value:I.max,size:y.maxSize})]});v.push(e);const r=new i({type:"size",minSliderValue:I.min,maxSliderValue:I.max,theme:"high-to-low"});g.push(r)}const R=new a({type:"flow",visualVariables:g.length?g:void 0,flowTheme:y.theme});return t.visualVariables=v,t.authoringInfo=R,t.legendOptions=o.from(f.legendOptions),{renderer:t,visualVariables:v.map((e=>e.clone())),flowScheme:b(y),basemapId:w.basemapId,basemapTheme:w.basemapTheme,layerEffect:y.layerEffect,statistics:I}}async function x(e){e=await v(e);const a=t(e.layer.serviceRasterInfo);if(null==a)throw new r("flow-renderer:not-supported","Only vector data is supported");return g(a,e)}export{x as createRenderer};
