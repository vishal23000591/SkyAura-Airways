/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import"../../core/has.js";import e from"../../core/Error.js";import{px2pt as n}from"../../core/screenUtils.js";import{getScale as s}from"../../geometry/support/scaleUtils.js";import l from"../../renderers/visualVariables/SizeVariable.js";import i from"../../renderers/visualVariables/support/SizeStop.js";import a from"./scaleRange.js";import{verifyBinningParams as t}from"../support/binningUtils.js";import{binningCapableLayerTypes as r,featureCapableLayerTypes as o,createLayerAdapter as c,getLayerTypeLabels as u}from"../support/adapters/support/layerUtils.js";const p=1e8,m=1128.497176,v=591657527.591555,f=[10,8,4,2],w=[100,100,60,30],g=[2,1,.75,.5],S=[32,18,12,6],h=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];async function y(n){const{view:s}=n;if(!(n&&s&&n.layer))throw new e("size-range:missing-parameters","'view' and 'layer' parameters are required");n.forBinning&&t(n,"size-range");const{layer:l,...i}=n,a=n.forBinning?r:o,p=c(l,a,n.forBinning);if(!p)throw new e("size-range:invalid-parameters","'layer' must be one of these types: "+u(a).join(", "));const m={layerAdapter:p,...i,view:s};await s.when();const v=null!=m.signal?{signal:m.signal}:null;await p.load(v);const f=p.geometryType;if("point"!==f&&"multipoint"!==f&&"polyline"!==f&&"polygon"!==f)throw new e("size-range:not-supported",`sizeRange is not supported for geometryType: ${f}`);return m}function z(e,n){const s=Math.ceil(e/n);let l=Math.ceil(s/4);l<4?l=4:l>16&&(l=16);const i=5*l;return{min:l,max:i<50?50:i}}function d(n,s){const{view:l}=n;if(!l)throw new e("scale-range:invalid-parameters","'view' is required");const i=s.minScale||p,a=l.constraints&&"effectiveLODs"in l.constraints&&l.constraints.effectiveLODs||h,t=[];for(let e=0;e<a.length;e++){if(a[e].scale>i)continue;const n=Number(e),s=[n-3,n,n+3,n+6];for(const e of s)e>-1&&e<a.length&&t.push(a[e].scale);break}return t.sort(((e,n)=>e-n))}function x(n,l){const{view:i,layerAdapter:a}=n;if(!i)throw new e("scale-range:invalid-parameters","'view' is required");const t=a.fullExtent,r=a.minScale||m,o=a.maxScale||v,c=l.minScale||0,u=l.maxScale||0;let p=null!=t?s(i,t):0;p=p<r&&p>o?p:0;return{scales:[r,o,c,u,p].map(Math.round).sort(((e,n)=>e-n)).filter(((e,n,s)=>!!e&&s.indexOf(e)===n)).filter(((e,n,s)=>!n||Math.abs(e-s[n-1])>5)),fullExtentScale:p}}function E(s,a){const{minScale:t,maxScale:r}=a,o=d(s,{minScale:t});if(!o.length)throw new e("scale-range:insufficient-info","not enough scale values");return{minSize:new l({valueExpression:"$view.scale",stops:o.map(((e,s)=>new i({value:e,size:n(f[s])})))}),maxSize:new l({valueExpression:"$view.scale",stops:o.map(((e,s)=>new i({value:e,size:n(w[s])})))})}}function j(s,a){const{minScale:t,maxScale:r}=a,o=d(s,{minScale:t});if(!o.length)throw new e("scale-range:insufficient-info","not enough scale values");return{minSize:new l({valueExpression:"$view.scale",stops:o.map(((e,s)=>new i({value:e,size:n(g[s])})))}),maxSize:new l({valueExpression:"$view.scale",stops:o.map(((e,s)=>new i({value:e,size:n(S[s])})))})}}function b(s,a){const{spatialStatistics:t,minScale:r,maxScale:o}=a;if(!("avgSize"in t)||!t.avgSize)throw new e("size-range:insufficient-info","average polygon size is invalid");const c=t.avgSize,{view:u}=s;if(!u)throw new e("scale-range:invalid-parameters","'view' is required");const{resolution:p,scale:m}=u,v=p/m,{scales:f,fullExtentScale:w}=x(s,{minScale:r,maxScale:o}),g=[],S=[];f.forEach(((e,s)=>{const{min:l,max:a}=z(c,v*e),t=f.indexOf(w),r=t>-1&&s>t?2:1;g.push(new i({value:e,size:n(l/r)})),S.push(new i({value:e,size:n(a/r)}))}));return{minSize:new l({valueExpression:"$view.scale",stops:g}),maxSize:new l({valueExpression:"$view.scale",stops:S})}}async function $(e){const n=await y(e),{view:s,layerAdapter:l,signal:i,filter:t}=n,r=await a({layer:l,view:s,signal:i,filter:t});switch(l.geometryType){case"point":case"multipoint":return E(n,r);case"polyline":return j(n,r);case"polygon":return b(n,r);case"mesh":case"multipatch":return null}return null}export{$ as default};
