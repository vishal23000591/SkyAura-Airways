/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../Dictionary.js";import{StringEnum as n}from"../enum.js";import{ArcadeExecutionError as t,ExecutionErrorCodes as r}from"../executionError.js";import{w as s,u as a,j as i}from"../../chunks/languageUtils.js";import{assertIsSome as o}from"../../core/maybe.js";import{isString as c,isNumber as u,isArray as d}from"../../support/guards.js";const l=e=>(n,t,r=14)=>+e(n,t).toFixed(r),h=(e,n)=>e+n,g=(e,n)=>e-n,m=(e,n)=>e*n,_=(e,n)=>e/n,f=(e,n,t)=>l(h)(e,n,t),w=(e,n,t)=>l(g)(e,n,t),A=(e,n,t)=>l(m)(e,n,t),D=(e,n,t)=>l(_)(e,n,t),p=360,T=400,E=2*Math.PI,S=3600,R=3240,F=60,v=60,M=180*S/Math.PI,L=p*F*v,U=90*S,z=180*S,x=270*S,N=String.fromCharCode(7501),b="Â°";function O(e){if(!1===c(e))throw new t(null,r.InvalidParameter,null);return e}function G(e,n){const t=10**n;return Math.round(e*t)/t}function I(e,n){return e%n}function y(e){const n=parseFloat(e.toString().replace(Math.trunc(e).toString(),"0"))*Math.sign(e);if(e<0){return{fraction:n,integer:Math.ceil(e)}}return{fraction:n,integer:Math.floor(e)}}var H,k,q;function P(e,n){switch(e){case H.north:return"SHORT"===n?"N":"North";case H.east:return"SHORT"===n?"E":"East";case H.south:return"SHORT"===n?"S":"South";case H.west:return"SHORT"===n?"W":"West"}}function j(e,n){return e-Math.floor(e/n)*n}function Q(e){switch(e){case k.truncated_degrees:case k.decimal_degrees:return p;case k.radians:return E;case k.gradians:return T;case k.seconds:return L;case k.fractional_degree_minutes:return F;case k.fractional_minute_seconds:return v;default:throw new t(null,r.LogicError,null,{reason:"unsupported evaluations"})}}!function(e){e[e.north=0]="north",e[e.east=1]="east",e[e.south=2]="south",e[e.west=3]="west"}(H||(H={})),function(e){e[e.decimal_degrees=1]="decimal_degrees",e[e.seconds=2]="seconds",e[e.degrees_minutes_seconds=3]="degrees_minutes_seconds",e[e.radians=4]="radians",e[e.gradians=5]="gradians",e[e.truncated_degrees=6]="truncated_degrees",e[e.fractional_degree_minutes=7]="fractional_degree_minutes",e[e.fractional_minute_seconds=8]="fractional_minute_seconds"}(k||(k={})),function(e){e[e.north_azimuth=1]="north_azimuth",e[e.polar=2]="polar",e[e.quadrant=3]="quadrant",e[e.south_azimuth=4]="south_azimuth"}(q||(q={}));const C=new n([],[["NORTH",q.north_azimuth],["NORTH AZIMUTH",q.north_azimuth],["POLAR",q.polar],["QUADRANT",q.quadrant],["SOUTH",q.south_azimuth],["SOUTH AZIMUTH",q.south_azimuth]]);function W(e){const n=C.lookup(e);if(null==n)throw new t(null,r.LogicError,null,{reason:"unsupported directionType"});return n}const B=new n([],[["D",k.decimal_degrees],["DD",k.decimal_degrees],["DECIMAL DEGREE",k.decimal_degrees],["DEGREE",k.decimal_degrees],["DECIMAL DEGREES",k.decimal_degrees],["DEGREES",k.decimal_degrees],["DMS",k.degrees_minutes_seconds],["DEGREES MINUTES SECONDS",k.degrees_minutes_seconds],["R",k.radians],["RAD",k.radians],["RADS",k.radians],["RADIAN",k.radians],["RADIANS",k.radians],["G",k.gradians],["GON",k.gradians],["GONS",k.gradians],["GRAD",k.gradians],["GRADS",k.gradians],["GRADIAN",k.gradians],["GRADIANS",k.gradians]]);function V(e){const n=B.lookup(e);if(null==n)throw new t(null,r.LogicError,null,{reason:"unsupported units"});return n}var X;!function(e){e[e.meridian=0]="meridian",e[e.direction=1]="direction"}(X||(X={}));class Z{constructor(e,n,t){this.m_degrees=e,this.m_minutes=n,this.m_seconds=t}getField(e){switch(e){case k.decimal_degrees:case k.truncated_degrees:return this.m_degrees;case k.fractional_degree_minutes:return this.m_minutes;case k.seconds:case k.fractional_minute_seconds:return this.m_seconds;default:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"})}}static secondsToDMS(e){const n=y(e).fraction;let t=y(e).integer;const r=Math.floor(t/S);t-=r*S;const s=Math.floor(t/v);return t-=s*v,new Z(r,s,t+n)}static numberToDms(e){const n=y(e).fraction,t=y(e).integer,r=A(y(100*n).fraction,100),s=y(100*n).integer;return new Z(t,s,r)}format(e,n){let t=G(this.m_seconds,n),r=this.m_minutes,s=this.m_degrees;if(e===k.seconds||e===k.fractional_minute_seconds)v<=t&&(t-=v,++r),F<=r&&(r=0,++s),p<=s&&(s=0);else if(e===k.fractional_degree_minutes)t=0,r=30<=this.m_seconds?this.m_minutes+1:this.m_minutes,s=this.m_degrees,F<=r&&(r=0,++s),p<=s&&(s=0);else if(e===k.decimal_degrees||e===k.truncated_degrees){const e=D(this.m_seconds,S),n=D(this.m_minutes,F);s=Math.round(this.m_degrees+n+e),r=0,t=0}return new Z(s,r,t)}static dmsToSeconds(e,n,t){return e*S+n*v+t}}class J{constructor(e,n,t){this.meridian=e,this.angle=n,this.direction=t}fetchAzimuth(e){return e===X.meridian?this.meridian:this.direction}}class K{constructor(e){this._angle=e}static createFromAngleAndDirection(e,n){return new K(new $(K._convertDirectionFormat(e.extractAngularUnits(k.seconds),n,q.north_azimuth)))}getAngle(e){const n=this._angle.extractAngularUnits(k.seconds);switch(e){case q.north_azimuth:case q.south_azimuth:case q.polar:return new $(K._convertDirectionFormat(n,q.north_azimuth,e));case q.quadrant:{const e=K.secondsNorthAzimuthToQuadrant(n);return new $(e.angle)}}}getMeridian(e){const n=this._angle.extractAngularUnits(k.seconds);switch(e){case q.north_azimuth:return H.north;case q.south_azimuth:return H.south;case q.polar:return H.east;case q.quadrant:return K.secondsNorthAzimuthToQuadrant(n).meridian}}getDirection(e){const n=this._angle.extractAngularUnits(k.seconds);switch(e){case q.north_azimuth:return H.east;case q.south_azimuth:return H.west;case q.polar:return H.north;case q.quadrant:return K.secondsNorthAzimuthToQuadrant(n).direction}}static secondsNorthAzimuthToQuadrant(e){const n=e<=U||e>=x?H.north:H.south,t=n===H.north?Math.min(L-e,e):Math.abs(e-z),r=e>z?H.west:H.east;return new J(n,t,r)}static createFromAngleMeridianAndDirection(e,n,t){return new K(new $(K.secondsQuadrantToNorthAzimuth(e.extractAngularUnits(k.seconds),n,t)))}static secondsQuadrantToNorthAzimuth(e,n,t){return n===H.north?t===H.east?e:L-e:t===H.east?z-e:z+e}static _convertDirectionFormat(e,n,s){let a=0;switch(n){case q.north_azimuth:a=e;break;case q.polar:a=U-e;break;case q.quadrant:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"});case q.south_azimuth:a=e+z}let i=0;switch(s){case q.north_azimuth:i=a;break;case q.polar:i=U-a;break;case q.quadrant:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"});case q.south_azimuth:i=a-z}return i=I(i,L),i<0?L+i:i}}function Y(e,n,s){let a=null;switch(n){case k.decimal_degrees:a=A(e,S);break;case k.seconds:a=e;break;case k.gradians:a=A(e,R);break;case k.radians:a=A(e,M);break;default:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"})}switch(s){case k.decimal_degrees:return D(a,S);case k.seconds:return a;case k.gradians:return D(a,R);case k.radians:return a/M;default:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"})}}class ${constructor(e){this._seconds=e}static createFromAngleAndUnits(e,n){return new $(Y(e,n,k.seconds))}extractAngularUnits(e){return Y(this._seconds,k.seconds,ee(e))}static createFromDegreesMinutesSeconds(e,n,t){return new $(f(f(A(e,S),A(n,v)),t))}}function ee(e){switch(o(e),e){case k.decimal_degrees:case k.truncated_degrees:case k.degrees_minutes_seconds:return k.decimal_degrees;case k.gradians:return k.gradians;case k.fractional_degree_minutes:return k.fractional_degree_minutes;case k.radians:return k.radians;case k.seconds:case k.fractional_minute_seconds:return k.seconds}}class ne{constructor(e,n,t,r){this.view=e,this.angle=n,this.merdian=t,this.direction=r,this._dms=null,this._formattedDms=null}static createFromStringAndBearing(e,n,t){return new ne(e,n.getAngle(t),n.getMeridian(t),n.getDirection(t))}fetchAngle(){return this.angle}fetchMeridian(){return this.merdian}fetchDirection(){return this.direction}fetchView(){return this.view}fetchDms(){return null===this._dms&&this._calculateDms(),this._dms}fetchFormattedDms(){return null===this._formattedDms&&this._calculateDms(),this._formattedDms}_calculateDms(){let e=null,n=k.truncated_degrees,t=0;for(let r=0;r<this.view.length;r++){const s=this.view[r];switch(s){case"m":e=ge(this.view,r,s),n=n===k.truncated_degrees?k.fractional_degree_minutes:n,r=e.newpos;continue;case"s":e=ge(this.view,r,s),n=k.fractional_minute_seconds,t=t<e.rounding?e.rounding:t,r=e.newpos;continue;default:continue}}this._dms=Z.secondsToDMS(this.angle.extractAngularUnits(k.seconds)),this._formattedDms=Z.secondsToDMS(this.angle.extractAngularUnits(k.seconds)).format(n,t)}}function te(e,n,s,a,i){let o=null;switch(n){case k.decimal_degrees:case k.radians:case k.gradians:return o=j(G(e.extractAngularUnits(n),a),Q(n)),o.toFixed(a).padStart(s+a+(a>0?1:0),"0");case k.truncated_degrees:case k.fractional_degree_minutes:return o=j(i.fetchFormattedDms().getField(n),Q(n)),o.toFixed(a).padStart(s+a+(a>0?1:0),"0");case k.fractional_minute_seconds:return o=j(G(i.fetchDms().getField(n),a),Q(n)),o.toFixed(a).padStart(s+a+(a>0?1:0),"0");default:throw new t(null,r.LogicError,null,{reason:"unexpected evaluation"})}}function re(e,n,s){if(s===q.quadrant)throw new t(null,r.LogicError,null,{reason:"conversion error"});if(n===k.degrees_minutes_seconds){const n=Z.numberToDms(e);return K.createFromAngleAndDirection($.createFromDegreesMinutesSeconds(n.m_degrees,n.m_minutes,n.m_seconds),s)}return K.createFromAngleAndDirection($.createFromAngleAndUnits(e,ee(n)),s)}function se(e){switch(a(e)){case 1:return{first:H.north,second:H.east};case 2:return{first:H.south,second:H.east};case 3:return{first:H.south,second:H.west};case 4:return{first:H.north,second:H.west}}return null}function ae(e){switch(e.toUpperCase().trim()){case"N":case"NORTH":return H.north;case"E":case"EAST":return H.east;case"S":case"SOUTH":return H.south;case"W":case"WEST":return H.west}return null}function ie(e){const n=parseFloat(e);if(u(n)){if(isNaN(n))throw new t(null,r.LogicError,null,{reason:"invalid conversion"});return n}throw new t(null,r.LogicError,null,{reason:"invalid conversion"})}function oe(e,n,a){const i=a===q.quadrant;let o=null,c=null,u=0,d=0,l=0;if(i){if(e.length<2)throw new t(null,r.LogicError,null,{reason:"conversion error"});l=1;const n=se(s(e[e.length-1]));if(n?(o=n.first,c=n.second):(u=1,o=ae(s(e[0])),c=ae(s(e[e.length-1]))),null===o||null===c)throw new t(null,r.LogicError,null,{reason:"invalid conversion"})}switch(n){case k.decimal_degrees:case k.radians:case k.gradians:if(0===e.length)throw new t(null,r.LogicError,null,{reason:"invalid conversion"});return i?K.createFromAngleMeridianAndDirection($.createFromAngleAndUnits(ie(e[u]),ee(n)),o,c):K.createFromAngleAndDirection($.createFromAngleAndUnits(ie(e[u]),ee(n)),a);case k.degrees_minutes_seconds:if(d=e.length-l-u,3===d){const n=$.createFromDegreesMinutesSeconds(ie(e[u]),ie(e[u+1]),ie(e[u+2]));return i?K.createFromAngleMeridianAndDirection(n,o,c):K.createFromAngleAndDirection(n,a)}if(1===d){const n=ie(e[u]),t=Z.numberToDms(n),r=$.createFromDegreesMinutesSeconds(t.m_degrees,t.m_minutes,t.m_seconds);return i?K.createFromAngleMeridianAndDirection(r,o,c):K.createFromAngleAndDirection(r,a)}}throw new t(null,r.LogicError,null,{reason:"invalid conversion"})}function ce(e){const n=new Set([" ","-","/","'",'"',"\\","^",b,N,"\t","\r","\n","*"]);let t="";for(let r=0;r<e.length;r++){const s=e.charAt(r);n.has(s)?t+="RRSPLITRRSPLITRR":t+=s}return t.split("RRSPLITRRSPLITRR").filter((e=>""!==e))}function ue(e,n,s){if(u(e))return re(a(e),n,s);if(c(e))return oe(ce(e),n,s);if(d(e))return oe(e,n,s);if(i(e))return oe(e.toArray(),n,s);throw new t(null,r.LogicError,null,{reason:"conversion error"})}function de(e,n,s){const a=ee(s);if(a&&s!==k.degrees_minutes_seconds){return e.getAngle(n).extractAngularUnits(a)}throw new t(null,r.LogicError,null,{reason:"conversion error"})}function le(e,n,t){const r=e.getAngle(n);if(n===q.quadrant&&t===k.degrees_minutes_seconds){const t=Z.secondsToDMS(r.extractAngularUnits(k.seconds));return[P(e.getMeridian(n),"SHORT"),t.m_degrees,t.m_minutes,t.m_seconds,P(e.getDirection(n),"SHORT")]}if(t===k.degrees_minutes_seconds){const e=Z.secondsToDMS(r.extractAngularUnits(k.seconds));return[e.m_degrees,e.m_minutes,e.m_seconds]}return n===q.quadrant?[P(e.getMeridian(n),"SHORT"),r.extractAngularUnits(t),P(e.getDirection(n),"SHORT")]:[r.extractAngularUnits(t)]}function he(e,n){let s="";switch(e){case k.decimal_degrees:s=n===q.quadrant?"DD.DD"+b:"DDD.DD"+b;break;case k.degrees_minutes_seconds:s=n===q.quadrant?"dd"+b+" mm' ss\"":"ddd"+b+" mm' ss.ss\"";break;case k.radians:s="R.RR";break;case k.gradians:s="GGG.GG"+N;break;default:throw new t(null,r.LogicError,null,{reason:"conversion error"})}return n===q.quadrant&&(s="p "+s+" b"),s}function ge(e,n,t){const r={padding:0,rounding:0,newpos:n};let s=!1;for(;n<e.length;){const a=e[n];if(a===t)s?r.rounding++:r.padding++,n++;else{if("."!==a)break;s=!0,n++}}return r.newpos=n-1,r}function me(e,n,t){const r={escaped:"",newpos:n};for(n++;n<e.length;){const t=e[n];if(n++,"]"===t)break;r.escaped+=t}return r.newpos=n-1,r}function _e(e,n,t){let r="",s=null,a=null;const i=ne.createFromStringAndBearing(n,e,t),o={D:k.decimal_degrees,d:k.truncated_degrees,m:k.fractional_degree_minutes,s:k.fractional_minute_seconds,R:k.radians,G:k.gradians};for(let c=0;c<n.length;c++){const u=n[c];switch(u){case"[":s=me(n,c),r+=s.escaped,c=s.newpos;continue;case"D":case"d":case"m":case"s":case"R":case"G":s=ge(n,c,u),a=e.getAngle(t),r+=te(a,o[u],s.padding,s.rounding,i),c=s.newpos;continue;case"P":case"p":r+=P(i.fetchMeridian(),"p"===u?"SHORT":"LONG");continue;case"B":case"b":r+=P(i.fetchDirection(),"b"===u?"SHORT":"LONG");continue;default:r+=u}}return r}const fe=new n(["TEXT","VALUE"]);function we(n,a,i){if(!(a instanceof e))throw new t(null,r.InvalidParameter,null);if(!1===a.hasField("directionType"))throw new t(null,r.LogicError,null,{reason:"missing directionType"});if(!1===a.hasField("angleType"))throw new t(null,r.LogicError,null,{reason:"missing angleType"});const o=W(O(a.field("directiontype"))),c=ue(n,V(O(a.field("angletype"))),o);if(!(i instanceof e))throw new t(null,r.InvalidParameter,null);if(!1===i.hasField("directionType"))throw new t(null,r.LogicError,null,{reason:"missing directionType"});if(!1===i.hasField("outputType"))throw new t(null,r.LogicError,null,{reason:"missing angleType"});const u=W(O(i.field("directiontype"))),d=i.hasField("angleType")?V(O(i.field("angletype"))):null,l=fe.get(O(i.field("outputType")));if(!u||!l)throw new t(null,r.LogicError,null,{reason:"conversion error"});if(!(d||"TEXT"===l&&i.hasField("format")))throw new t(null,r.LogicError,null,{reason:"invalid unit"});switch(l){case"VALUE":return u===q.quadrant||d===k.degrees_minutes_seconds?le(c,u,d):de(c,u,d);case"TEXT":{let e="";return i.hasField("format")&&(e=s(i.field("format"))),null!==e&&""!==e||(e=he(d,u)),_e(c,e,u)}default:throw new t(null,r.InvalidParameter,null)}}export{we as convertDirection,f as preciseAdd,D as preciseDivide,w as preciseMinus,A as preciseMultiply};
