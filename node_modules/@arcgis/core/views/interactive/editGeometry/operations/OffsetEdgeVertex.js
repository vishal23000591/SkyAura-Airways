/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{clamp as t,deg2rad as i}from"../../../../core/mathUtils.js";import{subtract as e,normalize as s,dot as n}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as r}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{E as h,i as o,h as a,n as _,g as c,e as l,u as p,f as g,m as d,G as u,c as m}from"../../../../chunks/vec32.js";import{create as f}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as D,fromPositionAndNormal as E,signedDistance as x,getNormal as b,copy as I,intersectLine as M,isPointInside as V,projectPoint as N}from"../../../../geometry/support/plane.js";import{angle as X,projectPointSignedLength as Y}from"../../../../geometry/support/vector.js";import{intersectLineAndRay as T,LineType as Z}from"../../../support/geometry2dUtils.js";class P{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(t,i,e,s=0,n=j.IMMEDIATE){this._helper=t,this._planeType=i,this._edge=e,this.distance=s,this._plane=D(),this._offsetPlane=D(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===j.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this._edge.leftVertex.pos),i=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),e=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=h(f(),t,e),i?(this._left=this._computeNeighbor(t,i,this._edgeDirection),this._right=this._computeNeighbor(e,s,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(e,s,this._edgeDirection),this._left=this._computeNeighbor(t,i,this._edgeDirection,this._right))}_toXYZ(t){return null!=t?this._helper.toXYZ(t):null}_pointToXYZ(t){return this._toXYZ(this._helper.pointToVector(t))}_computeNeighbor(t,i,e,s){const n=f();if(i){h(n,t,i);const s=!this._passesBisectingAngleThreshold(n,e);return{start:t,end:i,direction:s?this._bisectVectorsPerpendicular(e,n):n,isOriginalDirection:!s}}return this._helper.hasZ()?s&&(a(n,e,s.direction),a(n,n,e),_(n,n),Math.sign(n[1])!==Math.sign(e[0])&&c(n,n,-1)):o(n,-e[1],e[0],0),{start:t,end:i,direction:n,isOriginalDirection:!0}}_passesBisectingAngleThreshold(t,i){const e=Math.abs(X(i,t));return e>=y&&e<=Math.PI-y}_bisectVectorsPerpendicular(t,i){const e=l(t,i)<0?t:p(f(),t),s=Math.abs(l(e,i));if(!(s<A||s>1-A))return this._bisectDirection(e,i);const n=a(f(),e,[0,0,1]);return _(n,n)}_bisectDirection(t,i){const e=g(f(),t,i);return _(e,e)}_initializePlane(){const t=this._computeNormalDirection(this._left),i=this._computeNormalDirection(this._right);l(t,i)<0&&p(i,i),E(this._left.start,this._bisectDirection(t,i),this._plane)}_computeNormalDirection(t){const i=a(f(),t.direction,this._edgeDirection);_(i,i);const e=a(f(),this._edgeDirection,i);return this._planeType===z.XY&&(e[2]=0),_(e,e)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(x(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(x(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const i=b(t),h=this._edgeDirection,o=g(f(),this._left.start,this._left.direction),a=g(f(),this._right.start,this._right.direction),_=this._pointInBasis2D(r(),i,h,this._left.start),l=this._pointInBasis2D(r(),i,h,o),p=this._pointInBasis2D(r(),i,h,this._right.start),d=this._pointInBasis2D(r(),i,h,a),[u]=T({start:l,end:_,type:Z.LINE},{start:d,end:p,type:Z.LINE});if(!u)return;const m=e(r(),_,l);s(m,m);const D=e(r(),u,l),E=n(m,D),I=g(f(),o,c(f(),this._left.direction,-E)),M=x(t,I);this._updateDistanceConstraint(M)}_pointInBasis2D(t,i,e,s){return t[0]=Y(i,s),t[1]=Y(e,s),t}_offset(t,i){Number.isFinite(this._minDistance)&&(i=Math.max(this._minDistance,i)),Number.isFinite(this._maxDistance)&&(i=Math.min(this._maxDistance,i)),I(this._offsetPlane,this._plane),this._offsetPlane[3]-=i;const e=(t,i,e)=>null!=i&&M(this._offsetPlane,t,g(f(),t,i),e),s=f();(t===this._edge.leftVertex?e(this._left.start,this._left.direction,s):e(this._right.start,this._right.direction,s))&&this._helper.copy(this._helper.fromXYZ(s,void 0,this._helper.getM(t.pos)),t.pos)}selectArrowFromStartPoint(t){this._selectedArrow=V(this.plane,this._pointToXYZ(t))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(t){return x(this.plane,this._pointToXYZ(t))}clampedStartAndEnd(i){const e=this._helper.toXYZ(this._helper.pointToVector(i)),s=N(this._plane,e,f()),n=x(this._plane,e),r=t(n,this._minDistance,this._maxDistance);return d(e,s,e,r/n),{start:s,end:e}}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof P&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&u(b(this._plane),b(t._plane))}accumulate(t,i){const e=this._plane[3]-i._plane[3]+i.distance;this._offset(t,e)}accumulateParams(t){const i=t.distance-t._plane[3];this.distance=i+this._plane[3]}clone(){const t=new P(this._helper,this._planeType,this._edge,this.distance,j.DEFERRED);return I(t._plane,this._plane),I(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=m(f(),this._edgeDirection),t}_maybeEqualsVec3(t,i){return null==t&&null==i||null!=t&&null!=i&&u(t,i)}_cloneNeighbor({start:t,end:i,direction:e,isOriginalDirection:s}){return{start:m(f(),t),end:null!=i?m(f(),i):null,direction:m(f(),e),isOriginalDirection:s}}}const y=i(15),A=.001;var z,j;!function(t){t[t.XYZ=0]="XYZ",t[t.XY=1]="XY"}(z||(z={})),function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(j||(j={}));export{P as OffsetEdgeVertex,z as PlaneType};
