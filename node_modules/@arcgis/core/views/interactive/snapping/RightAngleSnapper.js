/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{cyclical2PI as e}from"../../../core/Cyclical.js";import{createAngle as t,valueInUnit as i}from"../../../core/quantityUtils.js";import{subtract as r,dot as s,squaredLength as n,scaleAndAdd as o}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{b as c,d as p,i as g}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as d}from"../../../support/elevationInfoUtils.js";import{VerticalHalfPlaneConstraint as l}from"../sketch/constraints.js";import{fromAnyMapPoint as f,asVec2 as m,markAsTarget as u,fromValues as x,fromVec3 as V}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as E}from"./SnappingAlgorithm.js";import{squaredScreenDistance as v}from"./snappingUtils.js";import{SelfSnappingRightAngleType as j,RightAngleSnappingCandidate as S,OtherVertexType as k}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as C}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as _,pointFromDistanceAlongAzimuth as w}from"../../support/angularMeasurementUtils.js";class y extends E{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],r=[];if(i.vertices.length<2)return r;const{view:s}=this,n=C(e,t.spatialReference,d,s),o=i.vertices.at(-1);this._checkForSnappingCandidate(j.LastVertex,r,o.leftEdge,o,o.leftEdge.leftVertex,e,n,t);const a=i.vertices[0];return this._checkForSnappingCandidate(j.FirstVertex,r,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),r}snapExistingVertex(e,t){const i=[],r=t.vertexHandle;if(r.component.vertices.length<3)return i;const{view:s}=this,n=C(e,t.spatialReference,d,s),o=r.leftEdge,a=r.rightEdge;if(o?.leftVertex.leftEdge){const r=o.leftVertex.leftEdge;this._checkForSnappingCandidate(j.ExistingEdge,i,r,r.rightVertex,r.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const r=a.rightVertex.rightEdge;this._checkForSnappingCandidate(j.ExistingEdge,i,r,r.leftVertex,r.rightVertex,e,n,t)}return i}_checkForSnappingCandidate(e,t,i,r,s,n,o,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const c=this.view,p=f(r.pos,c,a),g=f(s.pos,c,a);F(P,g,p,n,a,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,g,p,P,n,o,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,a,p,g,f,E){const{spatialReference:j,pointer:_}=E,w=r(M,m(g),m(a)),y=s(p,w)/n(p),F=o(M,m(a),p,y),R=u(x(F[0],F[1],g[2]));if(v(f,C(R,j,d,this.view))>this.squaredProximityThreshold(_)||this.isVertical(R,a,E)||this.isVertical(a,i,E))return;const U=c(h(),a,p,Math.sign(y));t.push(new S({targetPoint:R,constraint:new l(a,V(U)),previousVertex:i,otherVertex:a,otherVertexType:k.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===E.elevationInfo?.mode}))}}function F(e,t,i,r,s,n){R(e,t,i,r,s,n)||U(e,t,i)}function R(r,s,n,o,{spatialReference:a},c){const g=_(s,n,a,a);if(null==g)return!1;const d=_(n,o,a,a);if(null==d)return!1;const l=Math.sign(e.shortestSignedDiff(g,d))*Math.PI*.5,f=t(g+l,"radians","geographic"),m=h(),u=c.geodesicDistance(n,o,a);return null!=u&&(w(m,n,a,i(u,"meters"),f,"geodesic"),p(r,m,n),!0)}function U(e,t,i){const s=r(M,m(i),m(t));g(e,s[1],-s[0],0)}const M=a(),P=h();export{y as RightAngleSnapper};
