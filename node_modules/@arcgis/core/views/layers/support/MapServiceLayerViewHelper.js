/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../Color.js";import r from"../../../core/Accessor.js";import{isSome as s}from"../../../core/arrayUtils.js";import i from"../../../core/Error.js";import has from"../../../core/has.js";import{getOrCreateMapValue as o}from"../../../core/MapUtils.js";import{debounce as a,throwIfAborted as l}from"../../../core/promiseUtils.js";import{on as n}from"../../../core/reactiveUtils.js";import{sqlAnd as p}from"../../../core/sql.js";import{getMetersPerUnitForSR as c}from"../../../core/unitUtils.js";import{property as u}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/Logger.js";import{subclass as h}from"../../../core/accessorSupport/decorators/subclass.js";import y from"../../../geometry/Extent.js";import{getResolutionForScale as m}from"../../../geometry/support/scaleUtils.js";import{collectFields as d}from"../../../layers/support/fieldUtils.js";import{getLayerFloorFilterClause as f}from"../../../layers/support/floorFilterUtils.js";import{calculateTolerance as g}from"../../../renderers/support/clickToleranceUtils.js";import{identify as b}from"../../../rest/identify.js";import w from"../../../rest/support/IdentifyParameters.js";import{loadArcade as v}from"../../../support/loadArcade.js";import j from"../../../symbols/SimpleMarkerSymbol.js";import{getRequiredFields as x,getFetchPopupTemplate as S}from"./popupUtils.js";let F=null;function _(e,t){return"tile"===t.type||"map-image"===t.type}let P=class extends r{constructor(e){super(e),this._featuresResolutions=new WeakMap,this.highlightGraphics=null,this.highlightGraphicUpdated=null,this.updateHighlightedFeatures=a((async e=>{this.destroyed||this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e).catch((()=>{})))}))}initialize(){const e=e=>{for(const t of e){const{sourceLayer:e}=t;null!=e&&"geometryType"in e&&"point"===e.geometryType&&t.visible&&(t.visible=!1,this.highlightGraphicUpdated?.({graphic:t,property:"visible",oldValue:!0,newValue:!1}))}this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e).catch((()=>{}))),this.updateHighlightedFeatures(this._highlightGeometriesResolution)};this.addHandles([n((()=>this.highlightGraphics),"change",(t=>e(t.added)),{onListenerAdd:t=>e(t)})])}async fetchPopupFeaturesAtLocation(e,t){const{layerView:{layer:r,view:{scale:s}}}=this;if(!e)throw new i("fetchPopupFeatures:invalid-area","Nothing to fetch without area",{layer:r});const o=G(r.sublayers,s,t);if(!o.length)return[];const a=await U(r,o);if(!((r.capabilities?.operations?.supportsIdentify??!0)&&r.version>=10.5)&&!a)throw new i("fetchPopupFeatures:not-supported","query operation is disabled for this service",{layer:r});return a?this._fetchPopupFeaturesUsingQueries(e,o,t):this._fetchPopupFeaturesUsingIdentify(e,o,t)}clearHighlights(){this.highlightGraphics?.removeAll()}async _updateHighlightedFeaturesSymbols(e){for(const t of e)this._updateSymbology(t)}_updateSymbology(e){if("point"===e.geometry?.type)return this._updatePointSymbology(e)}_setGraphicSymbol(e,t){if(!t)return;const r=e.symbol;e.symbol=t,this.highlightGraphicUpdated?.({graphic:e,property:"symbol",oldValue:r,newValue:t})}_updatePointSymbology(e){const r=e.sourceLayer&&"renderer"in e.sourceLayer&&e.sourceLayer.renderer,{highlightGraphicUpdated:s,highlightGraphics:i,layerView:{view:o}}=this,a=e=>{e.visible||(e.visible=!0,s?.({graphic:e,property:"visible",oldValue:!1,newValue:!0}))};r&&"getSymbolAsync"in r?r.getSymbolAsync(e).then((async s=>{s||=new j;let l=null;const n="visualVariables"in r?r.visualVariables?.find((e=>"size"===e.type)):void 0;n&&(F||(F=(await import("../../../renderers/visualVariables/support/visualVariableUtils.js")).getSize),l=F(n,e,{view:o.type,scale:o.scale,shape:"simple-marker"===s.type?s.style:null})),l||="width"in s&&"height"in s&&null!=s.width&&null!=s.height?Math.max(s.width,s.height):"size"in s?s.size:16,i?.includes(e)&&(this._setGraphicSymbol(e,new j({style:"square",size:l,color:new t([255,255,255,1/255]),xoffset:"xoffset"in s?s.xoffset:0,yoffset:"yoffset"in s?s.yoffset:0})),a(e))})):a(e)}async _updateHighlightedFeaturesGeometries(e){const{layerView:{layer:t,view:r},highlightGraphics:s,highlightGraphicUpdated:i}=this;if(this._highlightGeometriesResolution=e,!i||!s?.length||!t.capabilities.operations.supportsQuery)return;const a=this._getTargetResolution(e),l=new Map;for(const c of s)if(!this._featuresResolutions.has(c)||this._featuresResolutions.get(c)>a){const e=c.sourceLayer;o(l,e,(()=>new Map)).set(c.getObjectId(),c)}const n=Array.from(l,(([e,t])=>{const s=e.createQuery();return s.objectIds=[...t.keys()],s.outFields=[e.objectIdField],s.returnGeometry=!0,s.maxAllowableOffset=a,s.outSpatialReference=r.spatialReference,e.queryFeatures(s)})),p=await Promise.all(n);if(!this.destroyed)for(const{features:o}of p)for(const e of o){const t=e.sourceLayer,r=l.get(t).get(e.getObjectId());if(r&&s.includes(r)){const t=r.geometry;r.geometry=e.geometry,i({graphic:r,property:"geometry",oldValue:t,newValue:r.geometry}),this._featuresResolutions.set(r,a)}}}_getTargetResolution(e){const t=e*c(this.layerView.view.spatialReference),r=t/16;return r<=10?0:e/t*r}async _fetchPopupFeaturesUsingIdentify(e,t,r){const s=await this._createIdentifyParameters(e,t,r);if(null==s)return[];const{results:i}=await b(this.layerView.layer.parsedUrl,s,r);return i.map((e=>e.feature))}async _createIdentifyParameters(e,t,r){const{floors:s,layer:i,timeExtent:o,view:{spatialReference:a,scale:l}}=this.layerView;if(!t.length)return null;await Promise.all(t.map((({sublayer:e})=>e.load(r).catch((()=>{})))));const n=Math.min(has("mapservice-popup-identify-max-tolerance"),i.allSublayers.reduce(((e,t)=>t.renderer?g({renderer:t.renderer,pointerType:r?.pointerType}):e),2)),p=this.createFetchPopupFeaturesQueryGeometry(e,n),c=m(l,a),u=Math.round(p.width/c),h=new y({xmin:p.center.x-c*u,ymin:p.center.y-c*u,xmax:p.center.x+c*u,ymax:p.center.y+c*u,spatialReference:p.spatialReference});return new w({floors:s,gdbVersion:"gdbVersion"in i?i.gdbVersion:void 0,geometry:e,height:u,layerOption:"popup",mapExtent:h,returnGeometry:!0,spatialReference:a,sublayers:i.sublayers,timeExtent:o,tolerance:n,width:u})}async _fetchPopupFeaturesUsingQueries(e,t,r){const{layerView:{floors:i,timeExtent:o}}=this,a=t.map((async({sublayer:t,popupTemplate:s})=>{if(await t.load(r).catch((()=>{})),t.capabilities&&!t.capabilities.operations.supportsQuery)return[];const a=t.createQuery(),n=g({renderer:t.renderer,pointerType:r?.pointerType}),c=this.createFetchPopupFeaturesQueryGeometry(e,n),u=new Set,[h]=await Promise.all([x(t,s),t.renderer?.collectRequiredFields(u,t.fieldsIndex)]);l(r),d(u,t.fieldsIndex,h);const y=Array.from(u).sort();a.geometry=c,a.outFields=y,a.timeExtent=o;const m=f(i,t);if(a.where=p(a.where,m),t.capabilities?.query.supportsOrderBy&&t.orderBy?.[0]){const e=t.orderBy[0],r=!e.valueExpression&&e.field,s="ascending"===e.order?"asc":"desc";r&&(a.orderByFields=[`${r} ${s}`])}const b=this._getTargetResolution(c.width/n),w=await V(s);l(r);const v="point"===t.geometryType||w&&w.arcadeUtils.hasGeometryOperations(s);v||(a.maxAllowableOffset=b);let{features:j}=await t.queryFeatures(a,r);const S=v?0:b;j=await R(t,j,r);for(const e of j)this._featuresResolutions.set(e,S);return j}));return(await Promise.allSettled(a)).reduce(((e,t)=>"fulfilled"===t.status?[...e,...t.value]:e),[]).filter(s)}};function G(e,t,r){const s=[];if(!e)return s;const i=e=>{const o=0===e.minScale||t<=e.minScale,a=0===e.maxScale||t>=e.maxScale;if(e.visible&&o&&a)if(e.sublayers)e.sublayers.forEach(i);else if(e.popupEnabled){const t=S(e,{...r,defaultPopupTemplateEnabled:!1});null!=t&&s.unshift({sublayer:e,popupTemplate:t})}};return e.map(i),s}function V(e){return e.expressionInfos?.length||Array.isArray(e.content)&&e.content.some((e=>"expression"===e.type))?v():Promise.resolve()}async function U(e,t){if(e.capabilities?.operations?.supportsQuery)return!0;try{return await Promise.any(t.map((({sublayer:e})=>e.load().then((()=>e.capabilities.operations.supportsQuery)))))}catch{return!1}}async function R(e,t,r){const s=e.renderer;return s&&"defaultSymbol"in s&&!s.defaultSymbol&&(t=s.valueExpression?await Promise.all(t.map((e=>s.getSymbolAsync(e,r).then((t=>t?e:null))))).then((e=>e.filter((e=>null!=e)))):t.filter((e=>null!=s.getSymbol(e)))),t}e([u({constructOnly:!0})],P.prototype,"createFetchPopupFeaturesQueryGeometry",void 0),e([u({constructOnly:!0})],P.prototype,"layerView",void 0),e([u({constructOnly:!0})],P.prototype,"highlightGraphics",void 0),e([u({constructOnly:!0})],P.prototype,"highlightGraphicUpdated",void 0),e([u({constructOnly:!0})],P.prototype,"updatingHandles",void 0),P=e([h("esri.views.layers.support.MapServiceLayerViewHelper")],P);export{P as MapServiceLayerViewHelper,G as collectPopupProviders,_ as isMapServiceLayerView};
