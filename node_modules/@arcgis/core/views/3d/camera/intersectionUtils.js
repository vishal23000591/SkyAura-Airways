/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{c as e,s as r,g as t,d as n,f as i,e as o,l as s}from"../../../chunks/vec32.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as c}from"../../../geometry/ellipsoidUtils.js";import{containsPoint as l}from"../../../geometry/support/aaBoundingRect.js";import d from"../webgl/RenderCamera.js";import{DepthRange as g}from"../webgl-engine/lib/DepthRange.js";import{Intersector as f}from"../webgl-engine/lib/Intersector.js";function u(e,r,t,n){return null!=e.renderCoordsHelper.fromRenderCoords(r.eye,M,n)&&l(t,M)}function m(e,r){return e.elevationProvider?e.elevationProvider.getElevation(r[0],r[1],r[2],e.renderCoordsHelper.spatialReference,"ground")??0:0}function p(o,s,a,c){const l=o.state.camera.clone();s&&a&&c&&(l.eye=s,l.center=a,l.up=c),v(o,l.ray,j)||e(j,l.center);const d=o.state.constraints,g=d.minimumPoiDistance;if(r(l.eye,j)<g){const r=d.collision.enabled;e(R,l.viewForward),t(R,R,g),r?l.eye=n(M,j,R):i(j,l.eye,R);const s=o.renderCoordsHelper,a=s.getAltitude(l.eye),c=d.collision.elevationMargin;r&&a<c&&(n(R,j,l.eye),l.eye=s.setAltitude(M,c,l.eye),i(j,l.eye,R))}return l.center=j,l}function y(e,t,n){if(!e.state.isGlobal||!e.stateManager.constraintsManager)return!1;const i=m(e,t),o=e.stateManager.constraintsManager.nearFarHeuristic;let s=C.get(e);void 0===s&&(s=new d,C.set(e,s)),s.eye=t,s.center=n;const{far:a}=o.compute(s,e.renderDataExtent,g.infinite,i),c=a*a;return r(t,n)>c}function v(e,r,t){let n=w[e.viewingMode];n||(n=new f(e.state.viewingMode),n.options.backfacesTerrain=!e.state.isGlobal,n.options.invisibleTerrain=!0,w[e.viewingMode]=n);const{isGlobal:i}=e.state;return!(!e.sceneIntersectionHelper.intersectRay(r,n,t)||y(e,r.origin,t))||(!(!e.renderCoordsHelper.intersectManifold(r,0,t)||y(e,r.origin,t))||!!i&&b(r,t,c(e.spatialReference).radius))}function b(e,r,n){const a=o(e.origin,e.origin)-n*n,c=a>0?Math.sqrt(a)/3:1;return t(r,e.direction,c/s(e.direction)),i(r,r,e.origin),!0}const w={},M=a(),j=a(),R=a(),C=new WeakMap;export{p as cameraOnContentAlongViewDirection,u as eyeWithinExtent,m as surfaceElevationBelowRenderLocation};
