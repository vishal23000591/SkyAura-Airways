/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{valueInUnit as e}from"../../../../../core/quantityUtils.js";import{createScreenPointArray as r,createRenderScreenPointArray3 as o}from"../../../../../core/screenUtils.js";import{getMetersPerUnitForSR as t}from"../../../../../core/unitUtils.js";import{fromValues as n}from"../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{h as s,E as i,k as c,d as l,b as a}from"../../../../../chunks/vec32.js";import{create as p}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectPoint as m}from"../../../../../geometry/projectionUtils.js";import{projectVectorToVector as u}from"../../../../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as f,inverseGeodeticSolver as d,InverseGeodeticSolverResult as j,directGeodeticSolver as g}from"../../../../../geometry/support/geodesicUtils.js";import{getNormal as y,fromPositionAndNormal as h,create as R}from"../../../../../geometry/support/plane.js";import{makeDehydratedPoint as v}from"../../../../../layers/graphics/dehydratedPoint.js";import{getZForElevationMode as x}from"../../../../../support/elevationInfoUtils.js";import{PlaneType as C,OffsetEdgeVertex as U}from"../../../../interactive/editGeometry/operations/OffsetEdgeVertex.js";function H(e,r,o){const t="on-the-ground"===o.mode?C.XY:C.XYZ;return new U(e,t,r,0)}function w(e,r,o){const t=p();if(!e.renderCoordsHelper.toRenderCoords(r,t))return null;const n=T(e,r,y(o.plane)),i=T(e,r,o.edgeDirection);if(null==n||null==i)return null;const c=s(p(),n,i);return h(t,c,R())}function T(e,r,o){const t=v(r.x+o[0],r.y+o[1],r.z+o[2],r.spatialReference),n=p(),s=p();return e.renderCoordsHelper.toRenderCoords(r,n)&&e.renderCoordsHelper.toRenderCoords(t,s)?i(s,n,s):null}function b(e,r,o){const t=y(e),c=i(p(),r,o),l=s(p(),c,t),a=s(p(),c,l);return n(c[0],c[1],c[2],0,l[0],l[1],l[2],0,a[0],a[1],a[2],0,0,0,0,1)}function q(e,r,t){const n=t.projectToRenderScreen(e,o()),s=t.projectToRenderScreen(r,o());return null!=n&&null!=s?c(l(n,n,s)):0}function A(e,o,t,n){const{elevationInfo:s,operations:i}=t;if(!i||!e)return null;const c=n.manipulator.elevationAlignedLocation,l=x(c,o,s),a=o.sceneIntersectionHelper.intersectElevationFromScreen(r(e.x,e.y),s,l);return a&&m(a,a,i.data.spatialReference)?a:null}function E(r,o,n,{data:{coordinateHelper:s,spatialReference:i}}){const c=e(r,"meters"),l=t(i),m=Math.sign(c*n.selectedArrow),h=f(i),R=y(n.plane),v=s.pointToXYZ(o),x=p();a(x,v,R,m*(I/l));const C=c*n.selectedArrow/l;if(!h||!u(v,i,v,h)||!u(x,i,x,h))return C;const U=new j;if(d(U,v,x,h),g(x,v,U.azimuth,c,h),!u(x,h,x,i))return C;const H=x[0]-o.x,w=x[1]-o.y,T=Math.sqrt(H*H+w*w)*m,[b,q]=R,A=Math.sqrt(b*b+q*q);return 0===A?0:T/A}const I=10;export{w as createEdgeOffsetIntersectionPlane,H as createEdgeOffsetOperation,b as edgeOffsetRotationMatrix,E as getDistanceInGeometrySR,A as getMapPointAtEdgeOffsetManipulatorElevation,q as screenEdgeLengthSquared};
