/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{c as t,f as e,d as s,n as r,m as i,g as o}from"../../../../../chunks/vec32.js";import{create as n,clone as c}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{canProjectWithoutEngine as p}from"../../../../../geometry/projectionUtils.js";import{getSphericalPCPF as a}from"../../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectVectorToVector as h}from"../../../../../geometry/projection/projectVectorToVector.js";import{sv3d as d}from"../../../../../geometry/support/vectorStacks.js";import{slerpTangent as l,slerp as f}from"../../../support/mathUtils.js";class m{constructor(t=n(),e=n()){this.startRenderSpace=t,this.endRenderSpace=e,this.type="euclidean"}eval(t,e,o){return i(e,this.startRenderSpace,this.endRenderSpace,t),o&&(s(o,this.endRenderSpace,this.startRenderSpace),r(o,o)),e}createRenderGeometry(t,e){const r=[],i=[],o=(e,o)=>{const n=j;s(n,e,t),r.push([n[0],n[1],n[2]]),i.push([o[0],o[1],o[2]])},n=e.worldUpAtPosition(this.eval(.5,R),d.get());return o(this.startRenderSpace,n),o(this.endRenderSpace,n),{points:r,normals:i}}static fromPositionAndVector(t,s,r=1){return o(R,s,r),e(R,t,R),new m(c(t),c(R))}}class _{_projectIn(e,s){this._project?h(e,this.renderSpatialReference,s,this._pcpf):t(s,e)}constructor(t,e,s){this.startRenderSpace=t,this.endRenderSpace=e,this.renderSpatialReference=s,this.type="geodesic",this._start=n(),this._end=n(),this._pcpf=a(s),this._project=p(s,this._pcpf),this._projectIn(t,this._start),this._projectIn(e,this._end)}eval(t,o,n){if(this._project)if(n){const i=j;l(this._start,this._end,t,o,i),e(S,o,i),h(o,this._pcpf,o,this.renderSpatialReference),h(S,this._pcpf,S,this.renderSpatialReference),s(n,S,o),r(n,n)}else f(this._start,this._end,t,o),h(o,this._pcpf,o,this.renderSpatialReference);else i(o,this._start,this._end,t),n&&(s(n,this._end,this._start),r(n,n));return o}createRenderGeometry(t,e){const r=[],i=[],o=(e,o)=>{const n=S;s(n,e,t),r.push([n[0],n[1],n[2]]),i.push([o[0],o[1],o[2]])},n=128+1&-2;for(let s=0;s<n;++s){const t=s/(n-1),r=R,i=j;this.eval(t,r),e.worldUpAtPosition(r,i),o(r,i)}return{points:r,normals:i}}}const R=n(),j=n(),S=n();export{m as EuclideanSegment,_ as GeodesicSegment};
