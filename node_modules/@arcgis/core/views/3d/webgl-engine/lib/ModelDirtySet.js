/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import"../../../../core/has.js";import{NestedMap as r}from"../../../../core/NestedMap.js";import{nullUid as o}from"../../../../core/uid.js";import{property as s}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as d}from"../../../../core/accessorSupport/decorators/subclass.js";import{DirtyOperation as i,DirtyState as c}from"./ModelDirtyTypes.js";import{assert as n}from"./Util.js";class a{constructor(e,t,r,o){this.operation=e,this.geometry=t,this.states=r,this.sync=o}}let m=class extends t{constructor(e){super(e),this._residentGeomRecords=new r,this._dirtyGeomRecords=new r,this._dirtyRecordCount=0}get dirty(){return this._dirtyRecordCount>0}commitLayer(e,t){const r=this._dirtyGeomRecords.getInner(e),o=this.model.getLayer(e);if(!r||!o)return;let s=0;r.forEach(((r,d)=>{const a=this._ensureGeomRecord(e,d);this._dirtyGeomRecords.delete(e,d),s+=r.size,r.forEach((({geometry:e,operation:r,states:s},m)=>{let y=!1;if(r===i.UPDATE){const r=a.get(m);if(r){if(s&c.TRANSFORMATION){const t=o.getObject(d);this.model.updateRenderGeometryTransformation(t,e,r)&&(y=!0)}y||t.updates.push({renderGeometry:r,updateType:s})}else n(!1,"ModelDirtySet.commitLayer: invalid update")}if(r===i.REMOVE||y){const e=a.get(m);e?(t.removes.push(e),a.delete(m)):r===i.REMOVE&&n(!1,"ModelDirtySet.commitLayer: invalid remove")}if(r===i.ADD||y){const r=o.getObject(d);if(null!=r){const o=this.model.getRenderGeometry(r,e);t.adds.push(o),a.set(m,o)}}})),0===a.size&&this._residentGeomRecords.delete(e,d)})),this._dirtyRecordCount-=s}commitSyncUpdates(e,t){const r=this._dirtyGeomRecords.getInner(e),o=this.model.getLayer(e);r&&o&&r.forEach(((r,s)=>{const d=this._ensureGeomRecord(e,s);r.forEach((({geometry:e,operation:r,states:a,sync:m},y)=>{let h=!1;if(r===i.UPDATE&&m){const r=d.get(y);if(r){if(a&c.TRANSFORMATION){const t=o.getObject(s);this.model.updateRenderGeometryTransformation(t,e,r)&&(h=!0)}h||t.updates.push({renderGeometry:r,updateType:a})}else n(!1,"ModelDirtySet.commitSyncUpdates: invalid update")}}))}))}_objectStateChanged(e,t){for(const r of t.geometries)this._updateOrCreateDirtyRecord(t,r,i.UPDATE,e)}visibilityChanged(e){this._objectStateChanged(c.VISIBILITY,e)}highlightChanged(e){this._objectStateChanged(c.HIGHLIGHT,e)}occlusionChanged(e){this._objectStateChanged(c.OCCLUDEE,e)}attributesChanged({object:e,geometry:t,sync:r}){this._updateOrCreateDirtyRecord(e,t,i.UPDATE,c.GEOMETRY,r)}layerAdded(e){e.objects.forEach((e=>this.layerObjectAdded(e)))}layerRemoved(e){e.objects.forEach((e=>this.layerObjectRemoved(e)))}layerObjectAdded(e){for(const t of e.geometries)this._geometryAdded(e,t)}layerObjectRemoved(e){for(const t of e.geometries)this._geometryRemoved(e,t)}layerObjectsAdded(e){for(const t of e)this.layerObjectAdded(t)}layerObjectsRemoved(e){for(const t of e)this.layerObjectRemoved(t)}transformationChanged(e){const t=this._getLayerId(e),r=e.id;this._ensureGeomRecord(t,r).forEach((({geometry:t})=>this._updateOrCreateDirtyRecord(e,t,i.UPDATE,c.TRANSFORMATION)))}shaderTransformationChanged(e){const t=this._getLayerId(e),r=e.id;this._ensureGeomRecord(t,r).forEach((t=>t.objectShaderTransformationChanged(e.shaderTransformation)))}geometryAdded(e){this._geometryAdded(e.object,e.geometry)}_geometryAdded(e,t){this._updateOrCreateDirtyRecord(e,t,i.ADD)}geometryRemoved(e){this._geometryRemoved(e.object,e.geometry)}_geometryRemoved(e,t){this._updateOrCreateDirtyRecord(e,t,i.REMOVE)}_updateOrCreateDirtyRecord(e,t,r,o=c.NONE,s=!1){const d=this._getLayerId(e),m=e.id,y=t.id,h=this._ensureDirtyRecord(d,m),l=h.get(y);if(l){const e=l.operation;e===i.REMOVE&&r===i.ADD&&l.states!==c.NONE?l.operation=i.UPDATE:e===i.REMOVE&&r===i.ADD||e===i.ADD&&r===i.REMOVE?(h.delete(y),this._dirtyRecordCount--):e!==i.UPDATE||r!==i.REMOVE&&r!==i.UPDATE?(n((e===i.REMOVE||e===i.ADD)&&r===i.UPDATE,"ModelDirtySet.objectGeometryAdded: inconsistent state"),l.states|=o):(l.operation=r,l.states|=o),l.sync=l.sync||s}else h.set(y,new a(r,t,o,s)),this._dirtyRecordCount++}_ensureGeomRecord(e,t){let r=this._residentGeomRecords.get(e,t);return r||(r=new Map,this._residentGeomRecords.set(e,t,r)),r}assertLayerClean(e){n(null==this._dirtyGeomRecords.getInner(e),"Dirty geometry records for removed layer")}_ensureDirtyRecord(e,t){const r=this.model.getLayer(e);n(null!=r,"Updating geometry record for an unregistered layer");let o=this._dirtyGeomRecords.get(e,t);return o||(o=new Map,this._dirtyGeomRecords.set(e,t,o)),o}_getLayerId(e){return e.layer?.id??o}formatDebugInfo(){const e=["ADD","UPD",void 0,"REM"];let t="";return this._dirtyGeomRecords.forAll(((r,o,s)=>{t.length>0&&(t+="\n"),t+=o+"."+s;const d=[];r.forEach((e=>{const t=e.operation;d[t]||(d[t]=[]),d[t].push(e.geometry.id)}));for(let i=0;i<d.length;i++)if(d[i]){t+=" "+e[i-1]+": ";for(let e=0;e<d[i].length;e++)t+=d[i][e]+", "}})),t}get test(){}};e([s({constructOnly:!0})],m.prototype,"model",void 0),e([s()],m.prototype,"_dirtyRecordCount",void 0),m=e([d("esri.views.3d.webgl-engine.lib.ModelDirtySet")],m);const y=m;export{y as default};
