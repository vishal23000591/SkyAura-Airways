/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{f as t,t as r}from"../../../../chunks/vec32.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as i,fromPoints as e,copy as n}from"../../../../geometry/support/ray.js";import{ViewingMode as a}from"../../../ViewingMode.js";import o from"../../webgl/RenderCamera.js";import{HUDTarget as h,HUDIntersectorResult as c}from"./HUDIntersectorResult.js";import{IntersectorOptions as l,StoreResults as f}from"./IntersectorInterfaces.js";import{IntersectorResult as d}from"./IntersectorResult.js";import{IntersectorType as m}from"./IntersectorType.js";import{IntersectorTransform as u,getVerticalOffsetObject3D as y}from"./verticalOffsetUtils.js";const _=1e-5;class g{constructor(t){this.options=new l,this._results=new O,this.transform=new u,this.camera=new o,this.tolerance=_,this.verticalOffset=null,this._ray=i(),this._rayEnd=s(),this._rayBeginTransformed=s(),this._rayEndTransformed=s(),this.viewingMode=t??a.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,r,s){this.resetWithRay(e(t,r,this._ray),s)}resetWithRay(r,s){this.camera=s,r!==this._ray&&n(r,this._ray),0!==this.options.verticalOffset?this.viewingMode===a.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,t(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,r,s,i,e){this.point=r,this.filterPredicate=i,this.tolerance=s??_;const n=y(this.verticalOffset);if(t&&t.length>0){const r=e?t=>{e(t)&&this.intersectObject(t)}:t=>{this.intersectObject(t)};for(const s of t){const t=s.getSpatialQueryAccelerator?.();null!=t?(null!=n?t.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,r,n):t.forEachAlongRay(this._ray.origin,this._ray.direction,r),this.options.selectionMode&&this.options.hud&&t.forEachDegenerateObject(r)):s.objects.forEach((t=>r(t)))}}this.sortResults()}intersectObject(t){const s=t.geometries;if(!s)return;const i=t.effectiveTransformation,e=y(this.verticalOffset);for(const n of s){if(!n.visible)continue;const{material:s,id:a}=n;if(!s.visible)continue;this.transform.setAndInvalidateLazyTransforms(i,n.transformation),r(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),r(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const o=this.transform.transform;null!=e&&(e.objectTransform=this.transform),s.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,((r,s,i,e)=>this.handleObjectIntersection({object:t,geometryId:a,primitiveIndex:i},r,s,o,e)))}}handleObjectIntersection(t,r,s,i,e){if(r<0||null!=this.filterPredicate&&!this.filterPredicate(this._ray.origin,this._rayEnd,r))return;const n=e?this._results.hud:this._results;t=e?new h(t,e):t;const a=e?i=>i.set(m.HUD,t,r,s):e=>e.set(m.OBJECT,t,r,s,i);if((null==n.min.distance||r<n.min.distance)&&a(n.min),this.options.store!==f.MIN&&(null==n.max.distance||r>n.max.distance)&&a(n.max),this.options.store===f.ALL)if(e){const t=new c(this._ray);a(t),this._results.hud.all.push(t)}else{const t=new d(this._ray);a(t),this._results.all.push(t)}}sortResults(t=this._results.all){t.sort(((t,r)=>t.distance!==r.distance?(t.distance??0)-(r.distance??0):t.drapedLayerOrder!==r.drapedLayerOrder?p(t.drapedLayerOrder,r.drapedLayerOrder):p(t.renderPriority,r.renderPriority)))}}function p(t,r){return(r??-Number.MAX_VALUE)-(t??-Number.MAX_VALUE)}class O{constructor(){this.min=new d(i()),this.max=new d(i()),this.hud={min:new c(i()),max:new c(i()),all:new Array},this.ground=new d(i()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}export{g as Intersector,_ as defaultTolerance};
