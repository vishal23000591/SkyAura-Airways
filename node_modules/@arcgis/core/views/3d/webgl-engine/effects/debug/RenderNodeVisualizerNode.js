/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{property as r}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as t}from"../../../../../core/accessorSupport/decorators/subclass.js";import{ZEROS as o}from"../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{RenderCategory as n}from"../../../webgl.js";import i from"../../../webgl/RenderNode.js";import{ColorFormat as c}from"../../core/FBOCacheFormats.js";import{glsl as s,If as a}from"../../core/shaderModules/glsl.js";import{Default3D as l}from"../../lib/DefaultVertexAttributeLocations.js";import{checkWebGLError as u}from"../../../../webgl/checkWebGLError.js";import{FramebufferBit as p,ColorAttachment0 as h,BlendFactor as f,SizedPixelFormat as d,PixelFormat as m,DataType as v}from"../../../../webgl/enums.js";import{alphaCutoff as g}from"../../../../../webscene/support/AlphaCutoff.js";let x=class extends i{constructor(e){super(e),this.destroyedCB=null,this.produces=n.FINAL,this.consumes={required:[n.FINAL]},this.clearColor=o,this._focusedFBOType=0,this._program=new Map}destroy(){this._program.forEach((e=>e.dispose())),this._program.clear(),this.destroyedCB()}render(e){const r=e.find((({name:e})=>e===n.FINAL));if(!this._focusedFBO)return r;const t=this.renderingContext;t.bindFramebuffer(r.fbo),t.setClearColor(0,0,0,0),t.clear(p.COLOR);const o=this._focusedFBO.getTexture(),i=[R(o)],c=this._ensureShader(t,!1,i);return t.useProgram(c),t.bindTexture(o,0),c.setUniform1i("colorTex0",0),c.setUniform1i("inputType",this._focusedFBOType),3===this._focusedFBOType&&c.setUniform2fv("nearFar",this.camera.nearFar),t.screen.draw(),r}getDownscaledFBO(e,r,t,o,n){r===F.ON&&(o=e.width,n=e.height);const i=e.colorAttachments.length,a=[],l=new Array(i);for(let c=0;c<i;++c){const r=e.getColorTexture(h+c);if(r){const e=R(r);a.push(e);const{descriptor:t}=r;"float"!==e||t.hasMipmap||t.isImmutable||(r.generateMipmap(),l[c]=!0)}}const m=this.renderingContext,{depthStencilTexture:v}=e,g=this._ensureShader(m,null!=v,a),x=this.fboCache.acquire(o,n,"fbo visualizer");m.useProgram(g),m.bindFramebuffer(x.fbo);const T=[];for(let u=0;u<i;++u){const r=h+u,t=`colorTex${s.int(u)}`;m.bindTexture(e.getColorTexture(r),u),g.setUniform1i(t,u),u>0&&x.acquireColor(r,c.RGBA8UNORM),T.push(r)}const b=v?.descriptor.linearFilterDepth??!1;if(v){const e=i;v.setShadowFiltering(!1),m.bindTexture(v,e),g.setUniform1i("depthTex",e);const r=h+e;r>h&&x.acquireColor(r,c.RGBA8UNORM,"depth to color"),T.push(r)}m.gl.drawBuffers(T),u(m.gl);const C=m.getViewport();m.setViewport(0,0,o,n),m.setClearColor(0,0,0,0),m.clear(p.COLOR),m.setBlendingEnabled(!0),m.setBlendFunction(f.ONE,f.ONE_MINUS_SRC_ALPHA);const B="linear-depth"===t||t.includes("shadow"),A="overlay highlight"===t||"highlights"===t||"highlight mix"===t,I="highlight coverage"===t,O=e.colorTexture?.descriptor,w=O?.internalFormat,y=B?3:A?5:I?6:w===d.R16F||w===d.R32F||w===d.R8?1:w===d.RG8?2:w===d.RGBA16F?4:w===d.RG8UI?7:0;g.setUniform1i("inputType",y),g.setUniform2fv("nearFar",this.camera.nearFar),m.screen.draw(),u(m.gl),m.bindFramebuffer(null),m.setViewport(C.x,C.y,C.width,C.height),r===F.ON&&(this._focusedFBO=x,this._focusedFBOType=y);for(let c=0;c<i;++c)if(l[c]){const r=e.getColorTexture(h+c);r?.clearMipmap()}return v&&v.setShadowFiltering(b),x}clearFocusedFBO(){this._focusedFBO=null}getPreviewContent(e,r,t,o){if(!t)return null;const n=this.renderingContext,i=this.fboCache.acquire(e,r,"fbo visualizer");n.bindFramebuffer(i?.fbo),n.setClearColor(this.clearColor[0],this.clearColor[1],this.clearColor[2],this.clearColor[3]),n.clear(p.COLOR),n.setBlendingEnabled(!0),n.setBlendFunction(f.ONE,f.ONE_MINUS_SRC_ALPHA);const c=t.getColorTexture(o);n.setViewport(0,0,e,r);const s=this._ensureShader(n,!1,[R(c)]);n.useProgram(s),n.bindTexture(c,0),s.setUniform1i("colorTex0",0),s.setUniform1i("inputType",0),n.screen.draw();const a=new ImageData(new Uint8ClampedArray(e*r*4),e,r);return n.gl.readPixels(0,0,e,r,m.RGBA,v.UNSIGNED_BYTE,new Uint8Array(a.data.buffer)),u(n.gl),n.bindFramebuffer(null),i?.release(),a}_ensureShader(e,r,t){const o=b({hasDepthAttachment:r,colorAttachmentTypes:t}),n=this._program.get(o);if(n)return n;const i="#version 300 es\n      in vec2 position;\n      out vec2 uv;\n\n      void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n        uv = position * 0.5 + vec2(0.5);\n      }",c=e=>{let r="";for(let t=0;t<e.length;++t){const o=e[t];r+=`layout(location = ${s.int(t)}) out vec4 fragColor${s.int(t)};\n                uniform ${T(o)} colorTex${s.int(t)};`}return r},u=e=>{let r="";for(let t=1;t<e.length;++t){const o=e[t],n=`texture(colorTex${s.int(t)}, uv)`,i="float"===o?n:`vec4( vec2(${n}), 0.0, 1.0)`;r+=`fragColor${s.int(t)} = ${i};`}return r},p=t.length,h=`#version 300 es\n      precision highp float;\n      precision highp usampler2D;\n\n      in vec2 uv;\n      ${c(t)}\n      ${a(r,`layout(location = ${s.int(p)}) out vec4 fragDepth;\n         uniform sampler2D depthTex;`)}\n\n      uniform int inputType;\n      uniform vec2 nearFar;\n\n      // Factors to convert rgba back to float\n      const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n        255.0 / (256.0),\n        255.0 / (256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n      );\n\n\n      float rgbaTofloat(vec4 rgba) {\n        // Convert components from 0->1 back to 0->255 and then add the components together with their corresponding\n        // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n        return dot(rgba, RGBA_2_FLOAT_FACTORS);\n      }\n\n      float linearDepthFromFloat(float depth) {\n        depth = pow(depth, 0.2);\n        return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);\n      }\n\n      float linearDepthFromRGBA(vec4 depth) {\n        return linearDepthFromFloat(rgbaTofloat(depth));\n      }\n\n      ${"float"===t[0]?"float linearDepthFromTexture(sampler2D depthTex, vec2 uv) {\n          ivec2 iuv = ivec2(uv * vec2(textureSize(depthTex, 0)));\n          return linearDepthFromRGBA(texelFetch(depthTex, iuv, 0));\n        }":"float linearDepthFromTexture(usampler2D depthTex, vec2 uv) {\n        ivec2 iuv = ivec2(uv * vec2(textureSize(depthTex, 0)));\n        return linearDepthFromRGBA(vec4(texelFetch(depthTex, iuv, 0)) * 255.0);\n      }"}\n\n      void main() {\n        ${a(t.length>0,s`
        vec4 color;
        if (inputType == 1) {
          color = vec4(vec3(texture(colorTex0, uv).r), 1.0);
        } else if (inputType == 2) {
          color = vec4(texture(colorTex0, uv).rg, 0.0, 1.0);
        } else if (inputType == 3) {
          float depth = 1.0 - ((-linearDepthFromTexture(colorTex0, uv) - nearFar[0]) / (nearFar[1] - nearFar[0]));
          color = vec4(vec3(depth), depth >= 0.999 ? 0.0 : 1.0);
        } else if (inputType == 4) {
          color = vec4(texture(colorTex0, uv));
          color = vec4(color.rgb / color.a, color.a);
        } else if (inputType == 5) {
          color = vec4(texture(colorTex0, uv)) * 255.0;
          color = vec4(color.rgb / color.a, color.a);
        } else if(inputType == 6) {
          vec2 texDim =  vec2(textureSize(colorTex0, 0));
          ivec2 iuv = ivec2(uv*texDim);
          uvec2 hh = uvec2(texelFetch(colorTex0,iuv,0).rg);
          color = vec4(
             ((hh & uvec2(0x55u)) != uvec2(0u)) ? 1.0 : 0.0,
             ((hh & uvec2(0xaau)) != uvec2(0u)) ? 1.0 : 0.0,
             0.0,
             1.0);
        } else {
          color = vec4(texture(colorTex0, uv));
        }


        if(color.a < ${s.float(g)})
          discard;
        fragColor0 = color;
        ${a(t.length>1,u(t))}
        `)}\n\n        ${a(r,"float depth = 1.0 - pow(texture(depthTex, uv).r, 10.0);\n            fragDepth = vec4(vec3(depth), depth < 0.000001 ? 0.0 : 1.0);")}        \n      }`,f=e.programCache.acquire(i,h,l);return this._program.set(o,f),f}};var F;function T(e){switch(e){case"float":return"sampler2D";case"uint":return"usampler2D";case"int":return"isampler2D"}}function R(e){if(!e)return"float";const{internalFormat:r}=e.descriptor;switch(r){case d.R8I:case d.R16I:case d.R32I:case d.RG8I:case d.RG16I:case d.RG32I:case d.RGB8I:case d.RGB16I:case d.RGB32I:case d.RGBA8I:case d.RGBA16I:case d.RGBA32I:return"int";case d.R8UI:case d.R16UI:case d.R32UI:case d.RG8UI:case d.RG16UI:case d.RG32UI:case d.RGB8UI:case d.RGB16UI:case d.RGB32UI:case d.RGBA8UI:case d.RGBA16UI:case d.RGBA32UI:return"uint";default:return"float"}}function b(e){const{hasDepthAttachment:r,colorAttachmentTypes:t}=e;return`${r?"Depth":""}${t.reduceRight(((e,r)=>e+`|C${r}`),"")}`}e([r()],x.prototype,"destroyedCB",void 0),e([r()],x.prototype,"produces",void 0),e([r()],x.prototype,"consumes",void 0),e([r()],x.prototype,"clearColor",void 0),x=e([t("esri.views.3d.webgl-engine.effects.debug.RenderNodeVisualizerNode")],x),function(e){e[e.ON=0]="ON",e[e.OFF=1]="OFF"}(F||(F={}));export{F as FocusState,x as RenderNodeVisualizerNode};
