/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{lerp as t,clamp as s,smoothstep as r}from"../../../../../core/mathUtils.js";import{disposeMaybe as i}from"../../../../../core/maybe.js";import{watch as o,syncAndInitial as a}from"../../../../../core/reactiveUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/has.js";import"../../../../../core/RandomLCG.js";import"../../../../../core/Error.js";import{subclass as n}from"../../../../../core/accessorSupport/decorators/subclass.js";import{set as m}from"../../../../../core/libs/gl-matrix-2/math/vec2.js";import{l as h,k as c}from"../../../../../chunks/vec32.js";import{s as p}from"../../../../../chunks/vec42.js";import{earth as u}from"../../../../../geometry/support/Ellipsoid.js";import{InternalRenderCategory as d}from"../../../webgl.js";import{ColorFormat as l}from"../../core/FBOCacheFormats.js";import{TransparentEnvironment as f}from"../TransparentEnvironment.js";import{H as _}from"../../../../../chunks/HazeCompositing.glsl.js";import{HazeCompositingTechnique as g}from"./HazeCompositingTechnique.js";import{HazePassParameters as b,HazeTechnique as w}from"./HazeTechnique.js";import{HazeTechniqueConfiguration as P}from"./HazeTechniqueConfiguration.js";import{createQuadVAO as j,Layout as v}from"../../lib/glUtil3D.js";import{applyTextureResizeModulo as A}from"../../lib/textureUtils.js";import{DepthStencilAttachment as C,PrimitiveType as T}from"../../../../webgl/enums.js";let x=class extends f{constructor(e){super(e),this._compositingPassParameters=new _,this._passParameters=new b,this._hazeConfiguration=new P,this._vao=null,this.requireGeometryDepth=!0,this._oldAmount=1,this._newAmount=1,this._amount=this._newAmount;const t=e.view.stage.renderView.techniques;t.precompile(w,new P);const s=new P;s.reduced=!0,t.precompile(w,s),t.precompile(g)}initialize(){this.addHandles([o((()=>this.view.environment.atmosphereEnabled),(e=>e?this._enable():this._disable()),a),o((()=>this.view.stage?.renderer.renderContext.bind.clouds.fadeFactor??1),(e=>this._fade(e)),a),o((()=>this.view.environment.weather.type),(e=>this._newAmount="rainy"===e?0:1),a),o((()=>this.view.stage.renderer?.fullResolutionAtmosphere),(e=>this._hazeConfiguration.reduced=!e),a)])}_fade(e){e>=1?(this._amount=this._newAmount,this._oldAmount=this._newAmount):this._amount=e<=0?this._oldAmount:t(this._oldAmount,this._newAmount,e)}destroy(){this._vao=i(this._vao)}render(e){const s=e.find((({name:e})=>e===d.TRANSPARENT_ENVIRONMENT));if(!this.bindParameters.mainDepth)return s;const r=this.renderingContext;this._vao??=j(r,v.Pos2Tex);const i=this.techniques.get(w,this._hazeConfiguration);if(!i.compiled)return s;const o=s.getAttachment(C);if(this._update(),!this._hazeConfiguration.reduced)return s.detachDepth(),r.bindFramebuffer(s.fbo),r.bindTechnique(i,this.bindParameters,this._passParameters),this._renderCommon(r),s.attachDepth(o),s;const a=this.techniques.get(g);if(!a.compiled)return s;const n=r.getViewport(),m=this.camera,c=h(m.eye)-u.radius;let p;const f=u.atmosphereHeight;if(c<f){const e=Math.min(1,Math.max(0,c/f));p=t(.4,.5,e)}else{const e=Math.min(1,Math.max(0,(c-f)/(15*f)));p=t(.5,1,e)}const _=this.renderingContext.parameters.maxTextureSize,b=A(Math.round(p*m.fullViewport[2]),_),P=A(Math.round(p*m.fullViewport[3]),_);r.setViewport(0,0,b,P);const T=this.fboCache.acquire(b,P,"haze",l.RGBA8UNORM);return r.bindFramebuffer(T.fbo),r.clearFramebuffer([0,0,0,1],!0,!0),r.bindTechnique(i,this.bindParameters,this._passParameters),this._renderCommon(r),r.setViewport(n.x,n.y,n.width,n.height),this._compositingPassParameters.color=T.getTexture(),s.detachDepth(),r.bindFramebuffer(s.fbo),r.bindTechnique(a,this.bindParameters,this._compositingPassParameters),r.screen.draw(),s.attachDepth(o),T.release(),s}_renderCommon(e){null!=this._vao&&(e.bindVAO(this._vao),e.drawArrays(T.TRIANGLE_STRIP,0,4))}_update(){const e=this.bindParameters.camera,i=c(e.eye),o=Math.sqrt(i),a=i-this._passParameters.radii[1]*this._passParameters.radii[1],n=s((o-this._passParameters.radii[0])/u.atmosphereHeight,0,1);p(this._passParameters.heightParameters,o,i,a,n);const h=this.view.basemapTerrain?.getLowerBoundRadius()??0;m(this._passParameters.radii,h,h+u.atmosphereHeight),this._passParameters.hazeStrength=t(t(.6,1,r(9500,10500,o-u.radius)),1,this._amount)}};x=e([n("esri.views.3d.webgl-engine.effects.haze.Haze")],x);export{x as Haze};
