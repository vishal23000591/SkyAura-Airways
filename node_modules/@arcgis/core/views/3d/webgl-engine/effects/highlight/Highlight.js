/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../core/has.js";import{releaseMaybe as t,disposeMaybe as r}from"../../../../../core/maybe.js";import{watch as i,initial as s}from"../../../../../core/reactiveUtils.js";import{property as o}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as h}from"../../../../../core/accessorSupport/decorators/subclass.js";import{set as n}from"../../../../../core/libs/gl-matrix-2/math/vec2.js";import{InternalRenderCategory as l}from"../../../webgl.js";import a from"../../../webgl/RenderNode.js";import{ColorFormat as g}from"../../core/FBOCacheFormats.js";import{HighlightApplyTechnique as c}from"./HighlightApplyTechnique.js";import{HighlightBlurTechnique as u}from"./HighlightBlurTechnique.js";import{HighlightDownsampleTechnique as m}from"./HighlightDownsampleTechnique.js";import{HighlightPassParameters as p}from"./HighlightPassParameters.js";import{HighlightToSingleTechnique as d}from"./HighlightToSingleTechnique.js";import{RenderRequestType as f}from"../../lib/basicInterfaces.js";import{Default3D as T}from"../../lib/DefaultVertexAttributeLocations.js";import{NoVertex as b}from"../../lib/DefaultVertexBufferLayouts.js";import{VertexArrayObject as w}from"../../lib/VertexArrayObject.js";import{H as x}from"../../../../../chunks/HighlightBlur.glsl.js";import{H as C,g as v}from"../../../../../chunks/HighlightDownsample.glsl.js";import{BufferObject as _}from"../../../../webgl/BufferObject.js";import{PixelFormat as j,TextureSamplingMode as O,FramebufferBit as R,Usage as H,PrimitiveType as P,DataType as q,TextureType as D}from"../../../../webgl/enums.js";import{Texture as I}from"../../../../webgl/Texture.js";import{TextureDescriptor as U}from"../../../../webgl/TextureDescriptor.js";let y=class extends a{constructor(){super(...arguments),this.produces=l.HIGHLIGHTS,this.consumes={required:[l.HIGHLIGHTS,"highlights"]},this._downsampleDrawParameters=new C,this._passParameters=new p,this._highlightBlurDrawParameters=new x,this._grid=new A}initialize(){this.addHandles([i((()=>this._updateOptionsTexture()),(()=>{}),s)])}destroy(){this._grid.coverage=t(this._grid.coverage),this._grid.vao=r(this._grid.vao),this._passParameters.highlightOptionsTexture=t(this._passParameters.highlightOptionsTexture)}_updateOptionsTexture(){if(null==this._passParameters.highlightOptionsTexture){const e=new U(16,2);e.internalFormat=j.RGBA,e.samplingMode=O.NEAREST,this._passParameters.highlightOptionsTexture=new I(this.renderingContext,e,null)}this._passParameters.highlightOptionsTexture.setData(E(this.view.state.highlights)),this.requestRender(f.UPDATE)}precompile(){this.techniques.precompile(m),this.techniques.precompile(d),this.techniques.precompile(u),this.techniques.precompile(c)}render(e){const t=e.find((({name:e})=>e===l.HIGHLIGHTS)),{techniques:r,bindParameters:i,_passParameters:s,renderingContext:o}=this;if(!i.decorations)return t;const h=r.get(m);if(!h.compiled)return this.requestRender(f.UPDATE),t;const n=e.find((({name:e})=>"highlights"===e)).getTexture();s.highlightTexture=n;const a=()=>{this._gridUpdateResources(n);const e=this._gridComputeCoverage(h,n,i),{horizontalCellCount:t,verticalCellCount:r}=e;return s.horizontalCellCount=t,s.verticalCellCount=r,s.coverageTexture=e.coverage?.getTexture(),e},g=e=>{const t=e.verticalCellCount*e.horizontalCellCount;o.bindVAO(e.vao),o.drawElementsInstanced(P.TRIANGLES,6,q.UNSIGNED_BYTE,0,t)},{camera:c}=i,u=()=>{o.bindFramebuffer(t.fbo),o.setViewport4fv(c.fullViewport)};return this._renderHighlightPostprocess(n,a,g,u),s.highlightTexture=null,s.coverageTexture=null,t}_renderHighlightPostprocess(e,t,r,i){const{fboCache:s,techniques:o,bindParameters:h,_passParameters:l,renderingContext:a}=this,m=o.get(d),p=o.get(u),T=o.get(c);if(!T.compiled||!p.compiled||!m.compiled)return void this.requestRender(f.UPDATE);l.highlightTexture=e;const b=t(),{width:w,height:x}=e.descriptor;l.highlightTexture=e;const{camera:C}=h,{fullWidth:v,fullHeight:_,pixelRatio:j}=C,O=Math.ceil(v/j),H=Math.ceil(_/j),{_highlightBlurDrawParameters:P}=this,q=this.view.stage.renderView.renderer,{highlights:D}=h;for(let c=0;c<D.length;++c){const{name:e}=D[c];if(!q.hasHighlight(e))continue;l.highlightLevel=c,a.setClearColor(0,0,0,0);const t=s.acquire(w,x,"single highlight",g.RG8UNORM);a.bindFramebuffer(t.fbo),a.setViewport(0,0,w,x),a.clear(R.COLOR),a.bindTechnique(m,h,l),r(b),P.blurInput=t.getTexture(),n(P.blurSize,1/O,0);const o=s.acquire(O,H,"single highlight blur h",g.RG8UNORM);a.unbindTexture(o.fbo?.colorTexture),a.bindFramebuffer(o.fbo),a.setViewport(0,0,O,H),a.clear(R.COLOR),a.bindTechnique(p,h,l,P),r(b),t.release(),n(P.blurSize,0,1/H),l.highlightBlurTexture=o.getTexture(),i(),a.bindTechnique(T,h,l,P),r(b),o.release()}}_gridUpdateResources(e){const t=this._grid,{width:r,height:i}=e.descriptor;if(t.horizontalCellCount=Math.ceil(r/v),t.verticalCellCount=Math.ceil(i/v),t.vao)return;const s=this.renderingContext,o=_.createIndex(s,H.STATIC_DRAW,L);t.vao=new w(s,T,new Map([["geometry",b]]),new Map([["geometry",_.createVertex(s,H.STATIC_DRAW)]]),o)}_gridComputeCoverage(e,t,r){const i=this.renderingContext,s=this._grid,o=t.descriptor,h=Math.ceil(o.width/v),n=Math.ceil(o.height/v);this._downsampleDrawParameters.input=t;const{highlights:l}=r;s.coverage?.release();const a=this.fboCache.acquire(h,n,"highlight coverage",l.length>B?g.RG8UINT:g.R8UINT);return s.coverage=a,i.bindFramebuffer(a.fbo),i.bindTechnique(e,r,this._passParameters,this._downsampleDrawParameters),i.setViewport(0,0,h,n),i.screen.draw(),s}get test(){}};e([o()],y.prototype,"produces",void 0),e([o()],y.prototype,"consumes",void 0),y=e([h("esri.views.3d.webgl-engine.effects.highlight.Highlight")],y);class A{constructor(){this.coverage=null,this.vao=null,this.verticalCellCount=0,this.horizontalCellCount=0,this.viewportWidth=0,this.viewportHeight=0}}function E(e){const t=new Uint8Array(128);let r=0;for(const i of e){const e=4*r,s=4*r+64;++r;const{color:o}=i,h=i.haloColor??o;t[e+0]=o.r,t[e+1]=o.g,t[e+2]=o.b,t[e+3]=i.fillOpacity*o.a*255,t[s+0]=h.r,t[s+1]=h.g,t[s+2]=h.b,t[s+3]=i.haloOpacity*h.a*255}return t}let S=0;function G(e){let t=0;for(const i of e){const{name:e}=i;t+=e.length;const{color:r,fillOpacity:s,haloColor:o,haloOpacity:h}=i;t+=r.r+r.g+r.b+r.a+s,t+=o?o.r+o.g+o.b+o.a+h:0}const r=e.at(0);if(r){const{shadowOpacity:e,shadowDifference:i,shadowColor:s}=r;t+=e+i+s.r+s.g+s.b+s.a}return S+++(t>=0?0:1)}const L=new Uint8Array([0,1,2,2,1,3]);function M(e,t,r,i,s,o=0){const{highlights:h}=i,l=h.length>1?t.acquire(r.width,r.height,"highlight mix",h.length>B?g.RG8UINT:g.R8UINT):null,{gl:a}=e;if(l){const t=e.getBoundFramebufferObject();e.bindFramebuffer(l.fbo),a.clearBufferuiv(a.COLOR,0,[0,0,0,0]),e.bindFramebuffer(t)}const c=l?.getTexture();i.highlightMixTexture=c,n(i.highlightMixOrigin,o,0),h.forEach(((t,h)=>{if(h>0){const t=I.TEXTURE_UNIT_FOR_UPDATES;e.bindTexture(c,t),e.setActiveTexture(t),a.copyTexSubImage2D(D.TEXTURE_2D,0,0,0,o,0,r.width,r.height),e.bindTexture(null,t)}e.clear(R.DEPTH),i.highlightLevel=h,s()})),i.highlightLevel=null,i.highlightMixTexture=null,l?.release()}const B=4;export{y as Highlight,B as maxHighlightsPerChannel,M as renderHighlightBuffer,G as trackHighlightOptions};
