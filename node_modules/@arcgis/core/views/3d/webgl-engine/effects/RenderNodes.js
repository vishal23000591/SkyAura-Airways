/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import r from"../../../../core/PooledArray.js";import{isManagedFBO as o}from"../../webgl/utils.js";import{defaultWebGLFBO as t}from"../core/FBOCache.js";import{hasFeatureFlagWebGLDebug as s}from"../../../webgl/checkWebGLError.js";class n{constructor(e){this._context=e,this._nodes=new r}destroy(){this._nodes.forEach((e=>e.destroy())),this._nodes.clear()}add(e){this._nodes.push(e),s&&console.log(`Registered render nodes: ${this._nodes.map((({declaredClass:e})=>e)).join(", ")}`)}remove(e){this._nodes.remove(e),s&&console.log(`Registered render nodes: ${this._nodes.map((({declaredClass:e})=>e)).join(", ")}`)}produces(e){return this._nodes.some((({produces:r})=>r===e))}require(e,...r){const o=this._nodes,t=r=>o.reduce(((o,{consumes:t,produces:s})=>o+(!t.required.includes(e)||null!=r&&s!==r?0:1)),0);return 0===r.length?t():r.reduce(((e,r)=>e+t(r)),0)}optional(e,...r){const o=this._nodes,t=r=>o.reduce(((o,{consumes:t,produces:s})=>o+(!t.optional?.includes(e)||null!=r&&s!==r?0:1)),0);return 0===r.length?t():r.reduce(((e,r)=>e+t(r)),0)}updateAnimation(e){return this._nodes.reduce(((r,o)=>o.updateAnimation(e)||r),!1)}precompile(...e){++this._context.techniques.precompiling;for(const r of e)this._nodes.forEach((e=>{e.produces===r&&e.precompile()}));--this._context.techniques.precompiling}render(e,r,s=()=>{}){return this._render(e,r,s)??(o(e)?e:t)}produce(e,r,o=()=>{}){return this._render(e,r,o)}_render(r,o,t=()=>{}){const s="string"==typeof r?r:r.name,n=this._nodes.filter((({produces:e})=>e===s));if(0===n.length)return;let i="string"==typeof r?null:r;return n.some((r=>{const n=i?[i]:[],c=null==i;for(const e of r.consumes.required){if(e===s){if(c)return!1;continue}const r=o.get(e);if(r)n.push(r);else if("emissive"!==e||!o.get(s)?.hasAttachment(e))return t?.(n),!1}if(r.consumes.optional)for(const e of r.consumes.optional){if(e===s)continue;const r=o.get(e);r&&n.push(r)}try{const t=r.doRender(n);t&&t!==i&&(s!==t.name&&(e.getLogger(r).errorOnce(`RenderNode produced ${t.name}, expected ${s}`),t.setName(s)),i?.release(),i=t,o.set(s,i))}catch(d){e.getLogger(r).errorOnce(d)}return t?.(n),c&&null!=i})),this._context.rctx.enforceState(),i}requireGeometryDepth(){return this._nodes.some((e=>"disabled"!==e.produces&&e.requireGeometryDepth))}get test(){return{nodes:this._nodes}}}export{n as RenderNodes};
