/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{ReadDepth as o}from"./output/ReadDepth.glsl.js";import{BlendColorsPremultiplied as e}from"./util/BlendColorsPremultiplied.glsl.js";import{CameraSpace as l}from"./util/CameraSpace.glsl.js";import{Float3PassUniform as t}from"../shaderModules/Float3PassUniform.js";import{FloatPassUniform as r}from"../shaderModules/FloatPassUniform.js";import{glsl as a}from"../shaderModules/glsl.js";import{Texture2DBindUniform as n}from"../shaderModules/Texture2DBindUniform.js";import{Texture2DPassUniform as i}from"../shaderModules/Texture2DPassUniform.js";function p(p,d){const s=p.fragment;s.include(o),p.include(l),s.include(e),s.uniforms.add(new r("globalAlpha",(o=>o.globalAlpha)),new t("glowColor",(o=>o.glowColor)),new r("glowWidth",((o,e)=>o.glowWidth*e.camera.pixelRatio)),new r("glowFalloff",(o=>o.glowFalloff)),new t("innerColor",(o=>o.innerColor)),new r("innerWidth",((o,e)=>o.innerWidth*e.camera.pixelRatio)),new n("depthMap",(o=>o.depth?.attachment)),new i("normalMap",(o=>o.normals))),s.code.add(a`vec4 premultipliedColor(vec3 rgb, float alpha) {
return vec4(rgb * alpha, alpha);
}`),s.code.add(a`vec4 laserlineProfile(float dist) {
if (dist > glowWidth) {
return vec4(0.0);
}
float innerAlpha = (1.0 - smoothstep(0.0, innerWidth, dist));
float glowAlpha = pow(max(0.0, 1.0 - dist / glowWidth), glowFalloff);
return blendColorsPremultiplied(
premultipliedColor(innerColor, innerAlpha),
premultipliedColor(glowColor, glowAlpha)
);
}`),s.code.add(a`bool laserlineReconstructFromDepth(out vec3 pos, out vec3 normal, out float angleCutoffAdjust, out float depthDiscontinuityAlpha) {
float depth = depthFromTexture(depthMap, uv);
if (depth == 1.0) {
return false;
}
float linearDepth = linearizeDepth(depth);
pos = reconstructPosition(gl_FragCoord.xy, linearDepth);
float minStep = 6e-8;
float depthStep = clamp(depth + minStep, 0.0, 1.0);
float linearDepthStep = linearizeDepth(depthStep);
float depthError = abs(linearDepthStep - linearDepth);
vec3 normalReconstructed = normalize(cross(dFdx(pos), dFdy(pos)));
vec3 normalFromTexture = normalize(texture(normalMap, uv).xyz * 2.0 - 1.0);
float blendFactor = smoothstep(0.15, 0.2, depthError);
normal = normalize(mix(normalReconstructed, normalFromTexture, blendFactor));
angleCutoffAdjust = mix(0.0, 0.004, blendFactor);
float ddepth = fwidth(linearDepth);
depthDiscontinuityAlpha = 1.0 - smoothstep(0.0, 0.01, -ddepth / linearDepth);
return true;
}`),d.contrastControlEnabled?s.uniforms.add(new i("frameColor",((o,e)=>o.colors)),new r("globalAlphaContrastBoost",(o=>o.globalAlphaContrastBoost))).code.add(a`float rgbToLuminance(vec3 color) {
return dot(vec3(0.2126, 0.7152, 0.0722), color);
}
vec4 laserlineOutput(vec4 color) {
float backgroundLuminance = rgbToLuminance(texture(frameColor, uv).rgb);
float alpha = clamp(globalAlpha * max(backgroundLuminance * globalAlphaContrastBoost, 1.0), 0.0, 1.0);
return color * alpha;
}`):s.code.add(a`vec4 laserlineOutput(vec4 color) {
return color * globalAlpha;
}`)}export{p as Laserline};
