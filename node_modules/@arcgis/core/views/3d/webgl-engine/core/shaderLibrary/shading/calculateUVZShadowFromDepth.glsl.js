/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{invert as e,translate as r}from"../../../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as t}from"../../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{ReadDepth as a}from"../output/ReadDepth.glsl.js";import{calculateUVZShadowPass as o,calculateUVZShadowDraw as i}from"./calculateUVZShadow.glsl.js";import{CameraSpace as l}from"../util/CameraSpace.glsl.js";import{glsl as c}from"../../shaderModules/glsl.js";import{Matrix4BindUniform as n}from"../../shaderModules/Matrix4BindUniform.js";function p(e){e.include(o),s(e)}function d(e){e.include(i),s(e)}function s(t){t.fragment.include(a),t.include(l),t.fragment.uniforms.add(new n("inverseViewMatrix",(({camera:t})=>e(u,r(u,t.viewMatrix,t.center))))).code.add(c`vec3 calculateUVZShadowAndPixelPosFromDepth(
in vec2 _uv,
ivec2 shadowMapSize,
in sampler2D _depthMap,
out vec4 currentPixelPos
) {
float depth = depthFromTexture(_depthMap, _uv);
if (depth >= 1.0 || depth <= 0.0) {
return invalidShadowmapUVZ;
}
float currentPixelDepth = linearizeDepth(depth);
currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;
float linearDepth = -currentPixelDepth;
return calculateUVZShadow(worldSpacePos.xyz, linearDepth, shadowMapSize);
}
vec3 calculateUVZShadowFromDepth(
in vec2 _uv,
ivec2 shadowMapSize,
in sampler2D _depthMap
) {
vec4 currentPixelPos;
return calculateUVZShadowAndPixelPosFromDepth(_uv, shadowMapSize, _depthMap, currentPixelPos);
}`)}const u=t();export{d as calculateUVZShadowFromDepthDraw,p as calculateUVZShadowFromDepthPass};
