/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{clamp as e,deg2rad as t}from"../../../../core/mathUtils.js";import{fromMat4 as i}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as r}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as a}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as n,rotate as o}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{fromValues as l,create as c}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{i as f,t as u,n as p,d as h,g as m,c as d,l as g,j as O,f as S,a as T,o as b,e as v}from"../../../../chunks/vec32.js";import{create as A,fromValues as E}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromArray as R,create as I,freeze as x}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isMat4 as F}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as P}from"../../../../geometry/support/aaBoundingRect.js";import{BufferViewVec4u8 as _,BufferViewVec3f as C,BufferViewFloat as y,BufferViewVec2f as D,BufferViewVec4f as L}from"../../../../geometry/support/buffer/BufferView.js";import{evaluateModelTransformScale as N}from"../../layers/support/FastSymbolUpdates.js";import{debugFlags as j}from"../../support/debugFlags.js";import{newLayout as U}from"../../support/buffer/InterleavedLayout.js";import{isColorEmissionHighlightOrOID as z,isColorOrColorEmission as M}from"../core/shaderLibrary/ShaderOutput.js";import{HUDVerticalPixelOffset as w}from"../core/shaderLibrary/hud/HUD.glsl.js";import{olidEnabled as B}from"../effects/geometry/olidUtils.js";import{GLTextureMaterialBindParameters as V,GLTextureMaterial as X}from"../lib/GLTextureMaterial.js";import{Material as q,RenderOccludedFlag as G}from"../lib/Material.js";import{RenderSlot as H}from"../lib/RenderSlot.js";import{applyScaleFactor as W,applyPrecomputedScaleFactor as Y,precomputeScaleFactor as Z}from"../lib/screenSizePerspectiveUtils.js";import{assert as k}from"../lib/Util.js";import{VertexAttribute as J}from"../lib/VertexAttribute.js";import{ScaleInfo as K}from"./ScaleInfo.js";import{writePosition as Q,writeNormal as $,writeColor as ee,writeBufferFloat as te,writeBufferVec4 as ie,writeBufferVec4Zeros as se,writeOlidColor as re}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as ae}from"./internal/MaterialUtil.js";import{c as ne,f as oe}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechnique as le}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as ce}from"../shaders/HUDMaterialTechniqueConfiguration.js";import{alphaCutoff as fe}from"../../../../webscene/support/AlphaCutoff.js";class ue extends q{constructor(e,t){super(e,Me),this.produces=new Map([[H.HUD_MATERIAL,e=>z(e)&&!this.parameters.drawAsLabel],[H.LABEL_MATERIAL,e=>z(e)&&this.parameters.drawAsLabel],[H.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[H.DRAPED_MATERIAL,e=>this.parameters.draped&&z(e)]]),this._visible=!0,this._configuration=new ce(t)}getConfiguration(e,t){const i=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=i,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===H.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=!i&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||t.slot===H.OCCLUSION_PIXELS,M(e)&&(this._configuration.debugDrawLabelBorder=!!j.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,s,a,n,o){const{options:{selectionMode:l,hud:c,excludeLabels:S},point:T,camera:b}=s,{parameters:v}=this;if(!l||!c||S&&v.isLabel||!e.visible||!T||!b)return;const E=e.attributes.get(J.FEATUREATTRIBUTE),I=null==E?null:R(E.data,ye),{scaleX:x,scaleY:F}=Xe(I,v,b.pixelRatio);i(Ie,t),e.attributes.has(J.FEATUREATTRIBUTE)&&de(Ie);const P=e.attributes.get(J.POSITION),_=e.attributes.get(J.SIZE),C=e.attributes.get(J.NORMAL),y=e.attributes.get(J.ROTATION),D=e.attributes.get(J.CENTEROFFSETANDDISTANCE);k(P.size>=3);const L=ne(v),N="screen"===this.parameters.centerOffsetUnits;for(let i=0;i<P.data.length/P.size;i++){const e=i*P.size;f(Se,P.data[e],P.data[e+1],P.data[e+2]),u(Se,Se,t),u(Se,Se,b.viewMatrix);const a=i*D.size;if(f(_e,D.data[a],D.data[a+1],D.data[a+2]),!N&&(Se[0]+=_e[0],Se[1]+=_e[1],0!==_e[2])){const e=_e[2];p(_e,Se),h(Se,Se,m(_e,_e,e))}const n=i*C.size;if(f(Te,C.data[n],C.data[n+1],C.data[n+2]),me(Te,Ie,b,De),qe(this.parameters,Se,De,b,Oe),b.applyProjection(Se,be),be[0]>-1){N&&(_e[0]||_e[1])&&(be[0]+=_e[0]*b.pixelRatio,0!==_e[1]&&(be[1]+=W(_e[1],Oe.factorAlignment)*b.pixelRatio),b.unapplyProjection(be,Se)),be[0]+=this.parameters.screenOffset[0]*b.pixelRatio,be[1]+=this.parameters.screenOffset[1]*b.pixelRatio,be[0]=Math.floor(be[0]),be[1]=Math.floor(be[1]);const e=i*_.size;je[0]=_.data[e],je[1]=_.data[e+1],Y(je,Oe.factor,je);const t=Le*b.pixelRatio;let a=0;if(v.textureIsSignedDistanceField){a=Math.min(v.outlineSize,.5*je[0])*b.pixelRatio/2}je[0]*=x,je[1]*=F;const n=i*y.size,l=v.rotation+y.data[n];if(ge(T,be[0],be[1],je,t,a,l,v,L)){const e=s.ray;if(u(Ae,Se,r(Fe,b.viewMatrix)),be[0]=T[0],be[1]=T[1],b.unprojectFromRenderScreen(be,Se)){const t=A();d(t,e.direction);const i=1/g(t);m(t,t,i);o(O(e.origin,Se)*i,t,-1,Ae)}}}}}intersectDraped(e,t,i,s,r){const a=e.attributes.get(J.POSITION),n=e.attributes.get(J.SIZE),o=e.attributes.get(J.ROTATION),l=this.parameters,c=ne(l),f=e.attributes.get(J.FEATUREATTRIBUTE),u=null==f?null:R(f.data,ye),{scaleX:p,scaleY:h}=Xe(u,l,e.screenToWorldRatio),m=Ne*e.screenToWorldRatio;for(let d=0;d<a.data.length/a.size;d++){const t=d*a.size,f=a.data[t],u=a.data[t+1],g=d*n.size;je[0]=n.data[g],je[1]=n.data[g+1];let O=0;if(l.textureIsSignedDistanceField){O=Math.min(l.outlineSize,.5*je[0])*e.screenToWorldRatio/2}je[0]*=p,je[1]*=h;const S=d*o.size,T=l.rotation+o.data[S];ge(i,f,u,je,m,O,T,l,c)&&s(r.distance,r.normal,-1)}}createBufferWriter(){return new Ve}applyShaderOffsetsView(e,t,i,s,r,a,n){const o=me(t,i,r,De);return this._applyVerticalGroundOffsetView(e,o,r,n),qe(this.parameters,n,o,r,a),this._applyPolygonOffsetView(n,o,s[3],r,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,t,i,s,r){return this._applyCenterOffsetNDC(e,t,i,s),null!=r&&d(r,s),this._applyPolygonOffsetNDC(s,t,i,s),s}_applyPolygonOffsetView(t,i,s,r,a){const n=r.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=n);const l=n*o;if(this.parameters.shaderPolygonOffset<=0)return d(a,t);const c=e(Math.abs(i.cosAngle),.01,1),f=1-Math.sqrt(1-c*c)/c/r.viewport[2];return m(a,t,l>0?f:1/f),a}_applyVerticalGroundOffsetView(e,t,i,s){const r=g(e),a=i.aboveGround?1:-1,n=i.computeRenderPixelSizeAtDist(r)*w,o=m(Se,t.normal,a*n);return S(s,e,o),s}_applyCenterOffsetView(e,t,i){const s="screen"!==this.parameters.centerOffsetUnits;return i!==e&&d(i,e),s&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(p(Te,i),T(i,i,m(Te,Te,t[2])))),i}_applyCenterOffsetNDC(e,t,i,s){const r="screen"!==this.parameters.centerOffsetUnits;return s!==e&&d(s,e),r||(s[0]+=t[0]/i.fullWidth*2,s[1]+=t[1]/i.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,i,s){const r=this.parameters.shaderPolygonOffset;if(e!==s&&d(s,e),r){const e=i.aboveGround?1:-1,a=e*Math.sign(t[3]);s[2]-=(a||e)*r}return s}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:i}=this.parameters,s=e[3]>=fe||t>=fe&&i[3]>=fe;return this._visible&&s}createGLMaterial(e){return new pe(e)}calculateRelativeScreenBounds(e,t,i=P()){return he(this.parameters,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class pe extends X{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(le,e)}}function he(e,t,i,s){s[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*i,s[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*i}function me(e,t,s,r){return F(t)&&(t=i(xe,t)),b(r.normal,e,t),u(r.normal,r.normal,s.viewInverseTransposeMatrix),r.cosAngle=v(ve,ze),r}function de(e){const t=e[0],i=e[1],s=e[2],r=e[3],a=e[4],n=e[5],o=e[6],l=e[7],c=e[8],f=1/Math.sqrt(t*t+i*i+s*s),u=1/Math.sqrt(r*r+a*a+n*n),p=1/Math.sqrt(o*o+l*l+c*c);return e[0]=t*f,e[1]=i*f,e[2]=s*f,e[3]=r*u,e[4]=a*u,e[5]=n*u,e[6]=o*p,e[7]=l*p,e[8]=c*p,e}function ge(e,i,s,r,a,l,c,f,u){let p=i-a-r[0]*u[0],h=p+r[0]+2*a,m=s-a-r[1]*u[1],d=m+r[1]+2*a;const g=f.distanceFieldBoundingBox;return f.textureIsSignedDistanceField&&null!=g&&(p+=r[0]*g[0],m+=r[1]*g[1],h-=r[0]*(1-g[2]),d-=r[1]*(1-g[3]),p-=l,h+=l,m-=l,d+=l),n(Re,i,s),o(Ee,e,Re,t(c)),Ee[0]>p&&Ee[0]<h&&Ee[1]>m&&Ee[1]<d}const Oe=new K,Se=A(),Te=A(),be=I(),ve=A(),Ae=A(),Ee=c(),Re=c(),Ie=s(),xe=s(),Fe=a(),Pe=I(),_e=A(),Ce=A(),ye=I(),De={normal:ve,cosAngle:0},Le=1,Ne=2,je=l(0,0),Ue=6,ze=E(0,0,1);class Me extends V{constructor(){super(...arguments),this.renderOccluded=G.Occlude,this.isDecoration=!1,this.color=x(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=x(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=I(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}}const we=U().vec3f(J.POSITION).vec3f(J.NORMAL).vec2i16(J.UVI).vec4u8(J.COLOR).vec2f(J.SIZE).f32(J.ROTATION).vec4f(J.CENTEROFFSETANDDISTANCE).vec4f(J.FEATUREATTRIBUTE),Be=we.clone().vec4u8(J.OLIDCOLOR);class Ve{constructor(){this.vertexBufferLayout=B()?Be:we}elementCount(e){return e.get(J.POSITION).indices.length*Ue}write(e,t,i,s,r,a){const{position:n,normal:o,uvi:l,color:c,size:f,rotation:u,centerOffsetAndDistance:p,featureAttribute:h}=r;Q(i.get(J.POSITION),e,n,a,Ue),$(i.get(J.NORMAL),t,o,a,Ue);const m=i.get(J.UVI)?.data;let d=0,g=0,O=-1-oe,S=-1-oe;m&&m.length>=4&&(d=m[0],g=m[1],O=-1-m[2],S=-1-m[3]);let T=i.get(J.POSITION).indices.length,b=a;for(let E=0;E<T;++E)l.set(b,0,d),l.set(b,1,g),b++,l.set(b,0,O),l.set(b,1,g),b++,l.set(b,0,O),l.set(b,1,S),b++,l.set(b,0,O),l.set(b,1,S),b++,l.set(b,0,d),l.set(b,1,S),b++,l.set(b,0,d),l.set(b,1,g),b++;ee(i.get(J.COLOR),4,c,a,Ue);const{data:v,indices:A}=i.get(J.SIZE);T=A.length,b=a;for(let E=0;E<T;++E){const e=v[2*A[E]],t=v[2*A[E]+1];for(let i=0;i<Ue;++i)f.set(b,0,e),f.set(b,1,t),b++}if(te(i.get(J.ROTATION),u,a,Ue),i.get(J.CENTEROFFSETANDDISTANCE)?ie(i.get(J.CENTEROFFSETANDDISTANCE),p,a,Ue):se(p,a,T*Ue),i.get(J.FEATUREATTRIBUTE)?ie(i.get(J.FEATUREATTRIBUTE),h,a,Ue):se(h,a,T*Ue),null!=s){const e=i.get(J.POSITION)?.indices;if(e){const t=e.length,i=r.getField(J.OLIDCOLOR,_);re(s,i,t,a,Ue)}}return{numVerticesPerItem:Ue,numItems:T}}intersect(e,t,i,s,a,n,o){const{options:{selectionMode:l,hud:c,excludeLabels:T},point:b,camera:v}=s;if(!l||!c||T&&t.isLabel||!b)return;const E=this.vertexBufferLayout.createView(e),R=E.getField(J.POSITION,C),I=E.getField(J.NORMAL,C),x=E.getField(J.ROTATION,y),F=E.getField(J.SIZE,D),P=E.getField(J.FEATUREATTRIBUTE,L),_=E.getField(J.CENTEROFFSETANDDISTANCE,L),N="screen"===t.centerOffsetUnits,j=ne(t);if(null==R||null==I||null==x||null==F||null==_||null==v)return;const U=null==P?null:P.getVec(0,ye),{scaleX:z,scaleY:M}=Xe(U,t,v.pixelRatio),w=R.count/Ue;for(let C=0;C<w;C++){const e=C*Ue;if(R.getVec(e,Se),null!=i&&S(Se,Se,i),u(Se,Se,v.viewMatrix),_.getVec(e,Pe),f(_e,Pe[0],Pe[1],Pe[2]),!N&&(Se[0]+=_e[0],Se[1]+=_e[1],0!==_e[2])){const e=_e[2];p(_e,Se),h(Se,Se,m(_e,_e,e))}if(I.getVec(e,Te),me(Te,Ie,v,De),qe(t,Se,De,v,Oe),v.applyProjection(Se,be),be[0]>-1){N&&(_e[0]||_e[1])&&(be[0]+=_e[0]*v.pixelRatio,0!==_e[1]&&(be[1]+=W(_e[1],Oe.factorAlignment)*v.pixelRatio),v.unapplyProjection(be,Se)),be[0]+=t.screenOffset[0]*v.pixelRatio,be[1]+=t.screenOffset[1]*v.pixelRatio,be[0]=Math.floor(be[0]),be[1]=Math.floor(be[1]),F.getVec(e,je),Y(je,Oe.factor,je);const i=Le*v.pixelRatio;let a=0;if(t.textureIsSignedDistanceField){a=Math.min(t.outlineSize,.5*je[0])*v.pixelRatio/2}je[0]*=z,je[1]*=M;const n=x.get(e),l=t.rotation+n;if(ge(b,be[0],be[1],je,i,a,l,t,j)){const e=s.ray;if(u(Ae,Se,r(Fe,v.viewMatrix)),be[0]=b[0],be[1]=b[1],v.unprojectFromRenderScreen(be,Se)){const t=A();d(t,e.direction);const i=1/g(t);m(t,t,i);o(O(e.origin,Se)*i,t,C,Ae)}}}}}}function Xe(e,t,i){return null==e||null==t.vvSize?{scaleX:i,scaleY:i}:(N(Ce,t,e),{scaleX:Ce[0]*i,scaleY:Ce[1]*i})}function qe(e,t,i,s,r){if(!e.verticalOffset?.screenLength){if(e.screenSizePerspective||e.screenSizePerspectiveAlignment){Ge(e,r,g(t),i.cosAngle)}else r.factor.scale=1,r.factorAlignment.scale=1;return t}const a=g(t),n=e.screenSizePerspectiveAlignment??e.screenSizePerspective,o=ae(s,a,e.verticalOffset,i.cosAngle,n);return Ge(e,r,a,i.cosAngle),m(i.normal,i.normal,o),S(t,t,i.normal)}function Ge(e,t,i,s){null!=e.screenSizePerspective?Z(s,i,e.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minScaleFactor=0),null!=e.screenSizePerspectiveAlignment?Z(s,i,e.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minScaleFactor=t.factor.minScaleFactor)}export{ue as HUDMaterial,Me as Parameters};
