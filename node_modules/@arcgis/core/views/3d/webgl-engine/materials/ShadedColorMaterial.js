/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{n as e,i as t,g as r,f as i}from"../../../../chunks/vec32.js";import{fromValues as s,create as a}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromValues as n}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{center as o,scale as c}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec3f as h}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as p}from"../../support/buffer/InterleavedLayout.js";import{isColorOrOID as l,ShaderOutput as u,isColorOrColorEmission as f}from"../core/shaderLibrary/ShaderOutput.js";import{CullFaceOptions as m}from"../lib/basicInterfaces.js";import d from"../lib/GLMaterial.js";import{Material as g,MaterialParameters as S}from"../lib/Material.js";import{intersectTriangleGeometry as b}from"../lib/RayIntersections.js";import{RenderSlot as T}from"../lib/RenderSlot.js";import{assert as E}from"../lib/Util.js";import{VertexAttribute as _}from"../lib/VertexAttribute.js";import{writeDefaultAttributes as A,writePosition as j}from"./internal/bufferWriterUtils.js";import{vertexAttributeLocations as F,ShadedColorMaterialTechnique as w}from"../shaders/ShadedColorMaterialTechnique.js";import{ShadedColorMaterialTechniqueConfiguration as v}from"../shaders/ShadedColorMaterialTechniqueConfiguration.js";import{alphaCutoff as x}from"../../../../webscene/support/AlphaCutoff.js";class z extends g{constructor(e){super(e,M),this._configuration=new v,this.vertexAttributeLocations=F,this.supportsEdges=!0,this._pp0=s(0,0,1),this._pp1=s(0,0,0),this.produces=new Map([[T.OPAQUE_MATERIAL,e=>e===u.Highlight||l(e)&&!this.parameters.transparent],[T.TRANSPARENT_MATERIAL,e=>l(e)&&this.parameters.transparent&&this.parameters.writeDepth],[T.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>l(e)&&this.parameters.transparent&&!this.parameters.writeDepth]])}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.screenSizeEnabled=this.parameters.screenSizeEnabled,this._configuration.shadingEnabled=this.parameters.shadingEnabled,this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest&&f(e),this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}get visible(){return this.parameters.color[3]>=x}intersect(e,t,r,i,s,a){this._intersect(e,r,i,s,a)}intersectDraped(e,t,r,i){return this._pp0[0]=this._pp1[0]=r[0],this._pp0[1]=this._pp1[1]=r[1],this._intersect(e,t,this._pp0,this._pp1,i)}_intersect(e,s,a,n,h){if(this.parameters.screenSizeEnabled){const p=e.attributes.get(_.OFFSET),l={applyToVertex:(e,a,n,o)=>{const c=t(I,p.data[3*o],p.data[3*o+1],p.data[3*o+2]),h=t(L,e,a,n);return r(c,c,this.parameters.screenSizeScale*(s.camera?.computeScreenPixelSizeAt(c)??1)),i(h,h,c),[h[0],h[1],h[2]]},applyToAabb:e=>{const t=o(e,I);return c(e,this.parameters.screenSizeScale*(s.camera?.computeScreenPixelSizeAt(t)??1))}};b(e,s,a,n,l,h)}else b(e,s,a,n,void 0,h)}createGLMaterial(e){return new O(e)}createBufferWriter(){return new P(this.parameters.screenSizeEnabled)}}class O extends d{beginSlot(e){return this.getTechnique(w,e)}}class M extends S{constructor(){super(...arguments),this.color=n(1,1,1,1),this.shadingTint=n(0,0,0,.25),this.shadingDirection=e(a(),[.5,-.5,-.5]),this.screenSizeScale=14,this.forceTransparentMode=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=m.None,this.screenSizeEnabled=!1,this.shadingEnabled=!0}get transparent(){return this.color[3]<1||this.forceTransparentMode}}class P{constructor(e){this.screenSizeEnabled=e;const t=p().vec3f(_.POSITION).vec3f(_.NORMAL);this.screenSizeEnabled&&t.vec3f(_.OFFSET),this.vertexBufferLayout=t}elementCount(e){return e.get(_.POSITION).indices.length}write(e,t,r,i,s,a){const n=A(r,i,this.vertexBufferLayout,e,t,s,a);if(this.screenSizeEnabled){if(!r.has(_.OFFSET))throw new Error(`${_.OFFSET} vertex attribute required for screenSizeEnabled ShadedColorMaterial`);{const e=r.get(_.OFFSET);E(3===e.size);const i=s.getField(_.OFFSET,h);if(!i)throw new Error("unable to acquire view for "+_.OFFSET);j(e,t,i,a)}}return n}}const I=a(),L=a();export{M as Parameters,z as ShadedColorMaterial};
