/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{removeUnordered as t,filterInPlace as r}from"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import{nextHighestPowerOfTwo as i}from"../../../../../core/mathUtils.js";import{disposeMaybe as s}from"../../../../../core/maybe.js";import{NestedMap as o}from"../../../../../core/NestedMap.js";import a from"../../../../../core/PooledArray.js";import{addMany as n}from"../../../../../core/SetUtils.js";import{property as l}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/Logger.js";import{subclass as h}from"../../../../../core/accessorSupport/decorators/subclass.js";import{copy as u,invert as f,transpose as c}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as d}from"../../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{glLayout as m}from"../../../support/buffer/glUtil.js";import{ShaderOutput as g}from"../../core/shaderLibrary/ShaderOutput.js";import{SyncRenderPlugin as p}from"../../effects/RenderPlugin.js";import{GLMaterials as y}from"../../lib/GLMaterials.js";import{DirtyState as _}from"../../lib/ModelDirtyTypes.js";import{RenderSlot as b}from"../../lib/RenderSlot.js";import{assert as w}from"../../lib/Util.js";import{DrawParameters as v}from"../DrawParameters.js";import{BufferRange as C,mergeAdjacentRanges as O}from"./BufferRange.js";import{Instance as A}from"./Instance.js";import{PerBufferData as E,hasVao as B}from"./PerBufferData.js";import{PerOriginData as M}from"./PerOriginData.js";import{defaultHighlightName as x}from"../../../../support/HighlightDefaults.js";let D=class extends p{get _hasHighlights(){return this._highlightNames.size>0}hasHighlight(e){return this._highlightNames.has(e)}constructor(e){super(e),this._dataByOrigin=new Map,this._drawParameters=new v,this._highlightNames=new Set,this.drapedPriority=0,this._produces=new Map,this._hasOccludees=!1}destroy(){this._glMaterials=s(this._glMaterials),this._dataByOrigin.forEach((e=>e.dispose())),this._dataByOrigin.clear(),this._vaoCache=null}initialize(){this._updateProduces()}_updateProduces(){this.material.produces.forEach(((e,t)=>{this._produces.set(t,(t=>!(0===this._dataByOrigin.size||!(t!==g.Highlight&&t!==g.ShadowHighlight||this._hasHighlights))&&e(t)))}))}initializeRenderContext(e){F??=e.renderContext.rctx.isAssumedMetalDriver,this._glMaterials=new y(this.material,e.materials),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=e.renderContext.rctx.getVaoCache(this.material.vertexAttributeLocations,m(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get produces(){return this._produces}get hasOccludees(){return this._hasOccludees}get hasEmissions(){return this.material.hasEmissions}get isDecoration(){return this.material.parameters.isDecoration}get renderOccludedFlags(){return this.material.renderOccludedFlags}get numGeometries(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.instances.size),0))),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.vao.cachedMemory),0))),e}forEachGeometry(e){this._dataByOrigin.forEach((t=>t.buffers.forEach((t=>t.instances.forEach((({geometry:t})=>e(t)))))))}modify(e,t){this._applyUpdates(e,t),this._applyAddsAndRemoves(e),this._updateDrawCommands()}get canCompact(){for(const e of this._dataByOrigin.values())if(e.buffers.some((e=>e.holes.length>1)))return!0;return!1}compact(e){if(!this.canCompact)return!1;let t=!1;for(const r of this._dataByOrigin.values()){const i=new Array;for(let t=0;t<r.buffers.length&&!e.done;){const s=r.buffers[t];s.holes.length<=1?++t:(s.instances.forEach((({geometry:e})=>i.push(e))),this._vaoCache.deleteVao(s.vao),r.buffers[t]=r.buffers[r.buffers.length-1],--r.buffers.length,e.madeProgress())}if(i.length>0){for(r.buffers.forEach((e=>this._applyAdds(e,i)));i.length>0;)r.buffers.push(this._applyAndRebuild(new E,i,null));t=!0}}return t}updateHighlights(e){this.highlightOrderMap=e,this._highlightNames.clear(),this._dataByOrigin.forEach((t=>{t.buffers.forEach((t=>{t.updateHighlights(e),t.highlightNames.forEach((e=>this._highlightNames.add(e)))}))})),this._updateProduces()}_applyUpdates(e,t){const r=this._bufferWriter;if(null==r)return void e.clearUpdates();const i=r.vertexBufferLayout.stride/4;for(const s of e.updates){if(t.done)return;const{renderGeometry:o,updateType:a}=s;e.pending.updates.removeUnordered(s),t.madeProgress();const n=this._dataByOrigin.get(o.localOrigin.id),l=n?.findBuffer(o.id);if(null==l)return;const h=l.instances.get(o.id);if(a&(_.GEOMETRY|_.TRANSFORMATION)){const e=U(r.elementCount(h.geometry.geometry.attributes)*i),t=r.vertexBufferLayout.createView(e.buffer);this._writeGeometry(o,t,0),l.vao.vertexBuffers.get("geometry").setSubData(e,h.from*i,0,h.numElements*i)}a&(_.HIGHLIGHT|_.OCCLUDEE|_.VISIBILITY)&&(l.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new o;for(const i of e){const e=i.localOrigin;if(null==e)continue;let t=r.get(e.id,null);null==t&&(t=new H(e.vec3),r.set(e.id,null,t)),t.changes.push(i)}for(const i of t){const e=i.localOrigin;if(null==e)continue;const t=this._dataByOrigin.get(e.id),s=t?.findBuffer(i.id);if(null==s)continue;let o=r.get(e.id,s);null==o&&(o=new H(e.vec3),r.set(e.id,s,o)),o.changes.push(i)}return r}_applyAddsAndRemoves(e){const{_bufferWriter:r,_dataByOrigin:i,_vaoCache:s}=this;if(null==r||null==s)return void e.clearAddsAndRemoves();const o=r.vertexBufferLayout.stride/4,a=this._computeDeltas(e.adds,e.removes);a.forEach(((e,n)=>{const l=e.get(null),h=l?.changes??[];a.delete(n,null);let u=i.get(n);if(e.forEach(((e,l)=>{if(a.delete(n,l),null==l&&w(!1,"No VAO for removed geometries"),l.instances.size===e.changes.length)return s.deleteVao(l.vao),t(u.buffers,l),void(0===u.buffers.length&&0===h.length&&i.delete(n));const f=l.numElements,c=l.vao.getByteLength("geometry")/4,d=h.reduce(((e,t)=>e+r.elementCount(t.geometry.attributes)),0),m=e.changes.reduce(((e,t)=>e+r.elementCount(t.geometry.attributes)),0),g=Math.min((f+d-m)*o,W),p=g>c;g>N&&g<c/2?(e.changes.forEach((({id:e})=>l.deleteInstance(e))),l.instances.forEach((({geometry:e})=>h.push(e))),this._vaoCache.deleteVao(l.vao),t(u.buffers,l)):p?this._applyAndRebuild(l,h,e):this._applyRemoves(l,e)})),h.length>0)for(null==u&&(u=new M(l.origin),i.set(n,u)),u.buffers.forEach((e=>this._applyAdds(e,h)));h.length>0;)u.buffers.push(this._applyAndRebuild(new E,h,null))})),e.clearAddsAndRemoves()}_updateDrawCommands(){this._highlightNames.clear(),this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.buffers.forEach((e=>{e.updateIfDrawCommandsDirty(this.highlightOrderMap,this._bufferWriter.vertexBufferLayout.stride),e.hasHighlights&&n(this._highlightNames,e.highlightNames),this._hasOccludees=this._hasOccludees||e.hasOccludees}))}))}_applyAndRebuild(e,t,r){if(r)for(const d of r.changes)e.deleteInstance(d.id);const i=this._bufferWriter,s=i.vertexBufferLayout.stride,o=s/4,a=Math.floor(W/o);let n=e.numElements;for(;t.length>0;){const r=t.pop(),s=i.elementCount(r.geometry.attributes);if(n+s>a&&n>0){t.push(r);break}n+=s;const o=new A(r,0,0,this.highlightOrderMap);w(null==e.instances.get(r.id)),e.addInstance(r.id,o)}const l=n*o,h=U(l),u=i.vertexBufferLayout.createView(h.buffer);let f=0;e.resetInstanceSummary(),e.instances.forEach(((t,r)=>{this._writeGeometry(t.geometry,u,f);const s=f;f+=i.elementCount(t.geometry.geometry.attributes),e.updateInstance(r,s,f),e.updateDrawState(t)})),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(V(l)),e.vao.vertexBuffers.get("geometry").setSubData(h,0,0,f*o),e.holes.clear();const c=e.holes.pushNew();return c.from=f,c.to=Math.floor(e.vao.getByteLength("geometry")/s),e.updateDrawCommands(this.highlightOrderMap,s),e}_applyRemoves(e,t){if(0===t.changes.length||null==this._bufferWriter)return;let r=1/0,i=-1/0;for(const a of t.changes){const t=a.id,s=e.instances.get(t);if(!s)continue;e.deleteInstance(t),F&&(r=Math.min(r,s.from),i=Math.max(i,s.to));const o=S.back();if(o){if(o.to===s.from){o.to=s.to;continue}if(o.from===s.to){o.from=s.from;continue}}const n=S.pushNew();n.from=s.from,n.to=s.to}O(S);const s=this._bufferWriter.vertexBufferLayout.stride/4,o=e.vao.vertexBuffers.get("geometry");if(F){const t=(i-r)*s,a=U(t),n=this._bufferWriter.vertexBufferLayout.createView(a.buffer);a.fill(0,0,t),e.instances.forEach((e=>{if(!(e.from>=r&&e.to<=i))return;const t=e.from-r;this._writeGeometry(e.geometry,n,t)})),o.setSubData(a,r*s,0,t)}else{const e=S.reduce(((e,t)=>Math.max(e,t.numElements)),0)*s,t=U(e);t.fill(0,0,e),S.forAll((e=>o.setSubData(t,e.from*s,0,e.numElements*s)))}e.holes.pushArray(S.data,S.length),S.forAll(((e,t)=>S.data[t]=null)),S.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(0===t.length||null==this._bufferWriter)return;if(!B(e))return void this._applyAndRebuild(e,t,null);const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,o=e.numElements,a=t.reduce(((e,t)=>e+i.elementCount(t.geometry.attributes)),0),n=Math.min((o+a)*s,W),l=4*n;if(e.vao.getByteLength("geometry")<V(W-N)&&l>e.vao.getByteLength("geometry"))return void this._applyAndRebuild(e,t,null);O(e.holes);const h=new Array;let u=1/0,f=-1/0;for(const r of t){const t=i.elementCount(r.geometry.attributes),s=R(e.holes,t);h.push(s),F&&null!=s&&(u=Math.min(s,u),f=Math.max(s+t,f))}const c=e.vao.vertexBuffers.get("geometry");let d=0,m=0,g=0;const p=U(F?(f-u)*s:n),y=i.vertexBufferLayout.createView(p.buffer);if(t.forEach(((t,r)=>{const o=h[r];if(null==o)return;const a=i.elementCount(t.geometry.attributes);if(!F){if(!(g===o)){const e=g-m;e>0&&c.setSubData(p,m*s,0,e*s),m=o,d=0}this._writeGeometry(t,y,d),d+=a,g=o+a}const n=new A(t,o,o+a,this.highlightOrderMap);w(null==e.instances.get(t.id)),e.addInstance(t.id,n),e.drawCommandsDirty=!0})),F){const t=(f-u)*s;p.fill(0,0,t),e.instances.forEach((e=>{if(!(e.from>=u&&e.to<=f))return;const t=e.from-u;this._writeGeometry(e.geometry,y,t)})),m=u,g=f}const _=g-m;_>0&&c.setSubData(p,m*s,0,_*s),r(t,((e,t)=>null==h[t]))}_writeGeometry(e,t,r){null!=this._bufferWriter&&(u(L,e.transformation),L[12]-=e.localOrigin.vec3[0],L[13]-=e.localOrigin.vec3[1],L[14]-=e.localOrigin.vec3[2],f(j,L),c(j,j),this._bufferWriter.write(L,j,e.geometry.attributes,e.geometry.objectAndLayerIdColor,t,r))}updateAnimation(e){return this.material.update(e)}acquireTechniques(e){if(!this.material.shouldRender(e))return null;const{output:t,bind:r}=e,i=this.material.produces.get(r.slot);if(!i?.(t))return null;const{highlight:s,slot:o}=r,a=t===g.ShadowHighlight,n=t===g.Highlight,l=n||a,h=s?.name;if(l&&(0===this._highlightNames.size||n&&h&&!this._highlightNames.has(h)))return null;const u=e=>n&&!!h&&!e.has(h),f=t===g.ShadowExcludeHighlight,c=!(l||f);for(const{buffers:d}of this._dataByOrigin.values())for(const i of d){if(u(i.highlightNames))continue;const s=a?i.drawCommandsHighlights.get(x):l?h?i.drawCommandsHighlights.get(h):i.drawCommandsHighlights.size>0:((f&&i.needsMultipleCommands()?i.drawCommandsShadowHighlightRest:i.drawCommandsDefault)||null)?.length??!1,n=c&&i.drawCommandsOccludees||null;if(s||n?.length){const i=this._glMaterials.load(e.rctx,o,t),s=i?.beginSlot(r);if(s)return s}}return null}render(e,t){const{output:r,bind:i}=e,{slot:s,highlight:o}=i,n=r===g.Highlight,l=o?.name??"";if(n&&!o)return;const h=r===g.ShadowHighlight,u=n||h,f=r===g.ShadowExcludeHighlight,c=!(u||f),d=s===b.OCCLUDER_MATERIAL||s===b.TRANSPARENT_OCCLUDER_MATERIAL?s:null,{rctx:m}=e;m.runAppleAmdDriverHelper();const p=m.bindTechnique(t,i,this.material.parameters);for(const g of this._dataByOrigin.values())for(const e of g.buffers){if(n&&(!e.hasHighlights||!e.drawCommandsHighlights.has(l)))continue;if(h&&(!e.hasHighlights||!e.drawCommandsHighlights.has(x)))continue;const r=()=>{const t=[],r=e.drawCommandsHighlights.get(x)??new a;return r&&t.push(r),t},s=u&&!h?e.drawCommandsHighlights.get(l)??null:null,o=h?r():u?s?[s]:z:f&&e.needsMultipleCommands()?[e.drawCommandsShadowHighlightRest]:[e.drawCommandsDefault],y=o.some((e=>e.length>0)),_=c&&e.drawCommandsOccludees||null;if(y||_?.length){if(this._drawParameters.origin=g.origin,p.bindDraw(i,this.material.parameters,this._drawParameters),t.ensureAttributeLocations(e.vao),m.bindVAO(e.vao),y)for(const e of o)m.setPipelineState(t.getPipeline(!1,d)),e.forAll((e=>m.drawArrays(t.primitiveType,e.first,e.count)));_?.length&&(m.setPipelineState(t.getPipeline(!0,d)),_.forAll((e=>m.drawArrays(t.primitiveType,e.first,e.count))))}}}static prune(){G=new Float32Array(N)}get test(){}};e([l({constructOnly:!0})],D.prototype,"material",void 0),e([l({})],D.prototype,"highlightOrderMap",void 0),D=e([h("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],D);class H{constructor(e){this.origin=e,this.changes=new Array}}function R(e,t){const r=e.find((e=>e.numElements>=t));if(null==r)return null;const i=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),i}const L=d(),j=d(),S=new a({allocator:e=>e||new C,deallocator:null}),N=65536,I=4*N,P=1024,T=16777216,W=T/4;let G=new Float32Array(N);function U(e){return G.length<e&&(G=new Float32Array(e)),G}function V(e){const t=4*e;return t<=P?P:t<I?i(t):Math.max(Math.min(Math.ceil(1.5*t/I)*I,T),t)}const z=[];let F;export{D as MergedRenderer,V as sizeForVao};
