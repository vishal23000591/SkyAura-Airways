/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{i as t,n as e,d as r,h as s,j as o,t as i}from"../../../../chunks/vec32.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromValues as a}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{newLayout as c}from"../../support/buffer/InterleavedLayout.js";import{isColorOrColorEmission as u}from"../core/shaderLibrary/ShaderOutput.js";import l from"../lib/GLMaterial.js";import{Material as f,MaterialParameters as p}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as m}from"../lib/VertexAttribute.js";import{vertexAttributeLocations as g,MeasurementArrowTechnique as d}from"../shaders/MeasurementArrowTechnique.js";import{MeasurementArrowTechniqueConfiguration as O}from"../shaders/MeasurementArrowTechniqueConfiguration.js";import{alphaCutoff as v}from"../../../../webscene/support/AlphaCutoff.js";class A extends f{constructor(t){super(t,C),this._configuration=new O,this.vertexAttributeLocations=g,this.intersectDraped=void 0,this.produces=new Map([[h.OPAQUE_MATERIAL,t=>!this._transparent&&u(t)],[h.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,t=>this._transparent&&u(t)]])}getConfiguration(t,e){return super.getConfiguration(t,e,this._configuration),this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this._transparent,this._configuration.oitPass=e.oitPass,this._configuration}get visible(){const{outlineColor:t,stripeEvenColor:e,stripeOddColor:r}=this.parameters;return t[3]>=v||e[3]>=v||r[3]>=v}intersect(){}createGLMaterial(t){return new b(t)}createBufferWriter(){return new E}get _transparent(){const{parameters:t}=this;return t.outlineColor[3]<1||t.stripeEvenColor[3]<1||t.stripeOddColor[3]<1}}class b extends l{beginSlot(t){return this.getTechnique(d,t)}}class C extends p{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=a(1,.5,0,1),this.stripeEvenColor=a(1,1,1,1),this.stripeOddColor=a(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const T=c().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).f32(m.LENGTH),_=n(),j=n(),L=n(),M=n(),w=n();class E{constructor(){this.vertexBufferLayout=T}elementCount(t){return 2*(t.get(m.POSITION).indices.length/2+1)}write(n,a,c,u,l,f){const{data:p,indices:h}=c.get(m.POSITION),g=c.get(m.NORMAL).data,d=p.length/3;h&&h.length!==2*(d-1)&&console.warn("MeasurementArrowMaterial does not support indices");const O=_,v=j,A=L,b=M,C=w,T=l.position,E=l.normal,I=l.uv0;let x=0;for(let m=0;m<d;++m){const c=3*m;if(t(O,p[c],p[c+1],p[c+2]),m<d-1){const o=3*(m+1);t(v,p[o],p[o+1],p[o+2]),t(C,g[o],g[o+1],g[o+2]),e(C,C),r(A,v,O),e(A,A),s(b,C,A),e(b,b)}const u=o(O,v);n&&a&&(i(O,O,n),i(v,v,n),i(b,b,a));const l=f+2*m,h=l+1;T.setVec(l,O),T.setVec(h,O),E.setVec(l,b),E.setVec(h,b),I.set(l,0,x),I.set(l,1,-1),I.set(h,0,x),I.set(h,1,1),m<d-1&&(x+=u)}const N=l.length;for(let t=0;t<2*d;++t)N.set(f+t,x);return null}}export{A as MeasurementArrowMaterial,C as Parameters};
