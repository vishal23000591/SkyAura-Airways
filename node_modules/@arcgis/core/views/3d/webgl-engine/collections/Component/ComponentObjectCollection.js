/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../../core/Logger.js";import{getOrCreateMapValue as t}from"../../../../../core/MapUtils.js";import o from"../../../../../core/PooledArray.js";import{isTypedArray as i}from"../../../../../core/typedArrayUtil.js";import{s as n}from"../../../../../chunks/vec32.js";import{clone as r}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as s}from"../../../../../geometry/support/aaBoundingBox.js";import{compactIndices as a}from"../../../../../geometry/support/Indices.js";import{c as l}from"../../../../../chunks/vec3.js";import{c}from"../../../../../chunks/vec33.js";import{ViewingMode as m}from"../../../../ViewingMode.js";import{ColorMixModeEnum as f,encodeSymbolColor as h}from"../../../layers/support/symbolColorUtils.js";import{computeOffsetObb as p}from"../../../support/orientedBoundingBox.js";import{glLayout as g}from"../../../support/buffer/glUtil.js";import{newLayout as d}from"../../../support/buffer/InterleavedLayout.js";import{ComponentData as u}from"./ComponentData.js";import{ComponentObject as b}from"./ComponentObject.js";import{IntersectionGeometry as v}from"./IntersectionGeometry.js";import{Renderable as y}from"./Renderable.js";import{RenderGeometry as _}from"./RenderGeometry.js";import{RenderSubmitSystem as C}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as M}from"./SourceGeometry.js";import{UniformComponentParameters as j}from"./UniformComponentParameters.js";import{ComponentParametersVarying as w,ComponentParametersUniform as x,ComponentParameterSummary as O,ComponentMaterial as D}from"./Material/ComponentMaterial.js";import{vertexAttributeLocations as A}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as R}from"./Material/shader/ComponentData.glsl.js";import{olidEnabled as S}from"../../effects/geometry/olidUtils.js";import{getVisibility as E,updatePickabilityWithCount as I}from"../../lib/ComponentUtils.js";import{assert as H}from"../../lib/Util.js";import{VertexAttribute as V}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as U}from"../../lib/verticalOffsetUtils.js";import{BufferManager as B}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as P}from"../../../../webgl/BufferObject.js";import{Usage as N,PrimitiveType as T}from"../../../../webgl/enums.js";import{VertexArrayObject as L}from"../../../../webgl/VertexArrayObject.js";const k=()=>e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class G{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._activeHighlightOptions=new Map,this._visible=new o,this._hidden=new o,this._renderSubmit=new C(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new B(e.rctx,2+(S()?1:0))}destroy(){H(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._visible.forAll((e=>e.destroy())),this._visible.clear(),this._hidden.forAll((e=>e.destroy())),this._hidden.clear()}createObject(e){const t=e.geometry,o=new u(this._componentBufferManager,a(t.componentOffsets)),i=this._createRenderable(e,o),n=new v(this._viewingMode,t.positionData,o),r=new b(e.transform,e.toMapSpace,e.obb.clone(),o,i,n);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(t?(this._hidden.removeUnordered(o),this._visible.push(o)):(this._visible.removeUnordered(o),this._hidden.push(o)),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=n(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.componentData.visibility.reset(t),o.componentData.markVisibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.componentData.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.componentData.visibility.componentCount;return{visible:o,invisible:t.componentData.count-o}}setComponentData(e,t){const o=e,{renderable:i,componentData:n}=o,r=i.material,s=n.materialDataBuffer,a=n.materialDataIndices,l=new j,c=s.textureBuffer,m=new Uint8Array(4),g=new Uint32Array(m.buffer);let d=0,u=0,b=0,v=n.verticalOffsets,y=1/0,_=-1/0,C=!1,M=!1,D=0;for(let p=0;p<n.count;p++){t(p,l),d+=+(l.externalColor[3]<1),u+=+(l.externalColorMixMode===f.Replace&&1===l.externalColor[3]),b+=+l.castShadows,h(l.externalColor,l.externalColorMixMode,m),m[2]=254&m[2]|+l.castShadows,c.setData(a[p],0,m[0],m[1],m[2],m[3]),C||=p>0&&D!==g[0],D=g[0],M||=0!==l.elevationOffset,M&&null==v&&(v=new Array(p).fill(0)),null!=v&&(v[p]=l.elevationOffset),y=Math.min(y,l.elevationOffset),_=Math.max(_,l.elevationOffset),R(l.elevationOffset,m),c.setData(a[p],1,m[0],m[1],m[2],m[3]);const e=l.objectAndLayerIdColor;null!=e&&c.setData(a[p],2,e[0],e[1],e[2],e[3]),l.pickable!==E(n.pickability,p)&&I(n,p,l.pickable)}n.verticalOffsets=M?v:null,o.offsetObb=M?p(o.obb,y,_,this._viewingMode,o.offsetObb??o.obb.clone()):null,C||M||S()?(r.componentParameters=new w,r.componentParameters.castShadows=W(b,n.count),r.componentParameters.transparent=W(d,n.count),r.componentParameters.opaqueOverride=W(u,n.count),r.componentParameters.texture=c,c.updateTexture()):(r.componentParameters=new x,r.componentParameters.castShadows=l.castShadows?O.All:O.None,r.componentParameters.externalColor=l.externalColor,r.componentParameters.externalColorMixMode=l.externalColorMixMode),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,o,i=!1){e.intersectionGeometry.getComponentAabb(t,o);const n=e,r=n.componentData.verticalOffsets;if(i||null==r)return o;const s=r[t];if(this._viewingMode===m.Local||0===s)return o[2]+=s,o[5]+=s,o;const a=U(s);return a.localOrigin=n.transform.position,a.applyToAabb(o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}expandRangeWithComponentObjectElevationRange(e,t,o,i){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||i.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const n=e,r=n.componentData,s=r.count,a=r.verticalOffsets,l=n.intersectionGeometry,c=this._viewingMode===m.Local,f=l.getComponentAabbs(),h=z;let p=1/0,g=-1/0;for(let m=0;m<s;m++){const e=6*m,r=a?.[m]??0;let s=1/0,l=-1/0;if(c)s=f[e+2]+r+t,l=f[e+5]+r+t;else{if(h[0]=f[e],h[1]=f[e+1],h[2]=f[e+2],h[3]=f[e+3],h[4]=f[e+4],h[5]=f[e+5],0!==r){const e=U(r);e.localOrigin=n.transform.position,e.applyToAabb(h)}const s=Math.max(Math.abs(h[3]),Math.abs(h[0])),a=Math.max(Math.abs(h[4]),Math.abs(h[1])),l=t+h[5]+o;i.expandElevationRangeValues(t+h[2],Math.sqrt(s*s+a*a+l*l)-o)}i.expandElevationRangeValues(s,l),p=Math.min(p,s),g=Math.max(g,l)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=p,this._elevationRangeCacheMax=g}intersect(e,t,o,i,n,r,s){const a=e,{transform:l,componentData:c,intersectionGeometry:m}=a;return null!=n&&(n.localOrigin=l.position),m.intersect(t,o,i,n,c.verticalOffsets,l,r,s)}addEdges(e,t,o,i,n){const r=e,{indices:s,positions:a}=r.intersectionGeometry,l=r.componentData.offsets;return t.addComponentObject(r,a,s,l,o,i,n)}async extractEdgeInformation(e,t,o){const i=e,n=i.componentData.visibility;if(n.allInvisible()){const{extractComponentsEdgeLocationsLayout:e}=await import("../../lib/edgeRendering/edgeProcessing.js");return{buffer:e.createBuffer(0),origin:[0,0,0]}}const{indices:s,positions:a}=i.intersectionGeometry,m=i.componentData.offsets,{EdgeInputBufferLayout:f}=await import("../../lib/edgeRendering/bufferLayouts.js"),h=f.createBuffer(a.length/3);c(h.position.typedBuffer,a,h.position.typedBufferStride,3),l(h.position,h.position,i.transform.rotationScale),this._setComponentIndices(h.componentIndex,s,m);const p=h.count,g=this._computeVisibilityIndices(s,n,m,p);return{origin:r(i.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:g,indicesLength:g.length,skipDeduplicate:!0,data:h,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let i=0;for(let n=0;n<o.length-1;n++){const r=o[n],s=o[n+1];for(let o=r;o<s;o++){const n=t?t[o]:o;e.set(n,i)}i++}}_computeVisibilityIndices(e,t,o,n){if(e&&t.allVisible())return e;let r=0;t.forEachComponentRange(((e,t)=>(r+=o[t]-o[e],!0)));const s=i(e)?2===e?.BYTES_PER_ELEMENT||n<=65536?new Uint16Array(r):new Uint32Array(r):new Array(r);let a=0;return t.forEachComponentRange(((t,i)=>{const n=o[t],r=o[i];for(let o=n;o<r;o++)s[a++]=e?e[o]:o;return!0})),s}addComponentHighlight(e,o,i){const n=e.componentData,r=t(n.componentHighlights,i,(()=>new Uint32Array(n.count+1)));{const e=this._activeHighlightOptions.get(i)??0;this._activeHighlightOptions.set(i,e+1)}0===r[o]++&&(n.markHighlightsDirty(),this._notifyDirty()),r[n.count]++}removeComponentHighlight(e,t,o){const{componentData:i}=e,n=i.componentHighlights.get(o);if(void 0===n)return void k().warn("Removing non-existing highlight.");const r=n[t];if(0===r)return void k().warn("Removing non-existing highlight.");this._removeActiveHighlight(o);const s=n[i.count];if(r>1)return n[t]=r-1,void(n[i.count]=s-1);n[t]=0,1===s?i.componentHighlights.delete(o):n[i.count]=s-1,i.markHighlightsDirty(),this._notifyDirty()}_removeActiveHighlight(e,t=1){const o=this._activeHighlightOptions.get(e);if(void 0===o)k().warn("Removing non-existing highlight.");else{const i=o-t;i<0&&k().warn("Removing non-existing highlight."),i<=0?this._activeHighlightOptions.delete(e):this._activeHighlightOptions.set(e,i)}}clearHighlights(e){const{componentData:t}=e,{componentHighlights:o}=t;if(o.size>0){for(const e of o)this._removeActiveHighlight(e[0],e[1][t.count]);o.clear(),t.markHighlightsDirty(),this._notifyDirty()}}hasHighlight(e){return this._activeHighlightOptions.has(e)}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const o=this._renderManager.rctx,i=e.geometry,n=i.vertices.layoutParameters,r=P.createVertex(o,N.STATIC_DRAW,i.vertices.data),s=i.indices?P.createIndex(o,N.STATIC_DRAW,i.indices):null,a=g(M(n)),l=new Uint16Array(i.vertices.count);for(let g=0;g<t.count;g++){const e=t.offsets[g],o=t.offsets[g+1],n=t.materialDataIndices[g];if(null!=i.indices)for(let t=e;t<o;t++){l[i.indices[t]]=n}else for(let t=e;t<o;t++)l[t]=n}const c=P.createVertex(o,N.STATIC_DRAW,l.buffer),m=new D(e.transform,e.toMapSpace),f=new L(o,A,new Map([["data",a],["componentIndices",q]]),new Map([["data",r],["componentIndices",c]]),s),h=new _(f,T.TRIANGLES,n,null!=s),p={cameraDepthSquared:.5,gpuMemoryEstimate:r.usedMemory+c.usedMemory+(null!=s?s.usedMemory:0)};return new y(m,h,p)}_notifyDirty(){this._renderManager.notifyDirty()}}const q=g(d().u16(V.COMPONENTINDEX));function W(e,t){return e===t?O.All:0===e?O.None:O.Some}const z=s();export{G as ComponentObjectCollection};
