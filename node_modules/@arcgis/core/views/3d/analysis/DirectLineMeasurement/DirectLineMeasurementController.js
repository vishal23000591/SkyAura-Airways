/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import e from"../../../../core/Accessor.js";import i from"../../../../core/Logger.js";import{toUnit as o}from"../../../../core/quantityUtils.js";import{watch as n,syncAndInitial as r}from"../../../../core/reactiveUtils.js";import{adaptiveLengthUnit as s,adaptiveVerticalLengthUnit as a}from"../../../../core/unitUtils.js";import{property as l}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/RandomLCG.js";import{subclass as c}from"../../../../core/accessorSupport/decorators/subclass.js";import{MeasurementMode as u}from"../interfaces.js";import{applyProjectionAndElevationAlignment as p,logFailedGeometryProjectionError as d}from"../support/projectionUtils.js";import{euclideanDistanceBetweenPoints as m}from"../../../support/euclideanLengthMeasurementUtils.js";let v=class extends e{constructor(t){super(t)}initialize(){this.addHandles([n((()=>({viewData:this.viewData,startPoint:this.analysis.startPoint})),(({viewData:t,startPoint:e})=>{t.elevationAlignedStartPoint=this._applyProjectionAndElevationAlignment(e)}),r),n((()=>({viewData:this.viewData,endPoint:this.analysis.endPoint})),(({viewData:t,endPoint:e})=>{t.elevationAlignedEndPoint=this._applyProjectionAndElevationAlignment(e)}),r),n((()=>({result:this._computedResult,viewData:this.viewData})),(({result:t,viewData:e})=>{e.result=t}),r)])}_applyProjectionAndElevationAlignment(t){if(null==t)return t;const{spatialReference:e,elevationProvider:o}=this.view,n=p(t,e,o);return n??(d(this.analysis,t.spatialReference,i.getLogger(this)),null)}get _computedResult(){const{elevationAlignedStartPoint:t,elevationAlignedEndPoint:e,measurementMode:i,unit:n}=this.viewData;if(null==t||null==e)return null;const r=m(t,e),l=this.geodesicLengthMeasurementUtils.geodesicDistanceBetweenPoints(t,e);if(null==r)return null;let c,p;switch(i){case u.Auto:p=null!=l?"geodesic":"euclidean",c=l??r.horizontal;break;case u.Geodesic:if(null==l)return null;p="geodesic",c=l;break;case u.Euclidean:p="euclidean",c=r.horizontal}let d=r.direct,v=r.vertical;const h=s(d.value,d.unit,n),g=s(c.value,c.unit,n),y=a(v.value,v.unit,n);return d=o(d,h),c=o(c,g),v=o(v,y),{mode:p,directDistance:d,horizontalDistance:c,verticalDistance:v}}};t([l({constructOnly:!0})],v.prototype,"view",void 0),t([l({constructOnly:!0})],v.prototype,"analysis",void 0),t([l({constructOnly:!0})],v.prototype,"viewData",void 0),t([l({constructOnly:!0})],v.prototype,"geodesicLengthMeasurementUtils",void 0),t([l()],v.prototype,"_computedResult",null),v=t([c("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")],v);export{v as DirectLineMeasurementController};
