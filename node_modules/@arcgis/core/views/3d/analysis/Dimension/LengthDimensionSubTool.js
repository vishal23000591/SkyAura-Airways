/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import e from"../../../../Color.js";import{LengthDimensionMeasureType as i}from"../../../../analysis/dimensionUtils.js";import a from"../../../../analysis/LengthDimension.js";import n from"../../../../core/Accessor.js";import s from"../../../../core/Handles.js";import{destroyHandle as o,handlesGroup as r}from"../../../../core/handleUtils.js";import"../../../../core/has.js";import{equals as p}from"../../../../core/lang.js";import{mapCollection as l}from"../../../../core/mapCollectionUtils.js";import{releaseMaybe as u,destroyMaybe as d}from"../../../../core/maybe.js";import{memoize as c}from"../../../../core/memoize.js";import{ignoreAbortErrors as m}from"../../../../core/promiseUtils.js";import{watch as h,initial as g,sync as f,syncAndInitial as _,when as M}from"../../../../core/reactiveUtils.js";import{property as v}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/Logger.js";import{subclass as y}from"../../../../core/accessorSupport/decorators/subclass.js";import{create as C}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{UpdatingHandles as S}from"../../../../core/support/UpdatingHandles.js";import w from"../../../../geometry/Point.js";import{clonePoint as b}from"../../../../layers/graphics/hydratedFeatures.js";import{reapplyConstraint as P,LengthDimensionConstraint as O,applyConstraint as D,computeConstraint as H,constraintDependencies as j}from"./lengthDimensionConstraintUtils.js";import{LengthDimensionManipulators as T,LengthDimensionPointManipulator as x,pointManipulatorHandles as G,createOffsetManipulator as z,offsetManipulatorHandles as U,LineOfSightOrientationManipulator as V,headingManipulatorHandles as I,rotationManipulatorHandles as A,createMeasureTypeManipulator as R,measureTypeManipulatorHandles as k,updateOffsetManipulatorTransform as E,updateHeadingManipulatorTransform as L,updateRotationManipulatorTransform as F,updateMeasureTypeManipulatorTransform as q,unfocusedOffsetWidth as B,focusedOffsetWidth as N}from"./lengthDimensionManipulatorUtils.js";import{isValidComputation as J,arePointsVerticallyAligned as K,computationToGeometryDependencies as Q,computeGeometryFromDimension as W}from"./lengthDimensionUtils.js";import{disabledPointColor as X,pointRadius as Y,getTransparentAccentColor as Z,getContrastColor as $,initialOffsetPx as tt}from"./settings.js";import{getRotateHeadingTexture as et}from"../images/Factory.js";import{SnappingVisualizer3D as it}from"../../interactive/SnappingVisualizer3D.js";import{LineVisualElement as at}from"../../interactive/visualElements/LineVisualElement.js";import{VerticesVisualElement as nt}from"../../interactive/visualElements/VerticesVisualElement.js";import{RenderOccludedFlag as st}from"../../webgl-engine/lib/Material.js";import{ImageMaterial as ot}from"../../webgl-engine/materials/ImageMaterial.js";import{createStipplePatternSimple as rt}from"../../webgl-engine/materials/lineStippleUtils.js";import{RibbonLineMaterial as pt}from"../../webgl-engine/materials/RibbonLineMaterial.js";import{createCoordinateHelper as lt}from"../../../interactive/coordinateHelper.js";import{EditGeometry as ut}from"../../../interactive/editGeometry/EditGeometry.js";import{EditGeometryOperations as dt}from"../../../interactive/editGeometry/EditGeometryOperations.js";import{SnappingContext as ct}from"../../../interactive/snapping/SnappingContext.js";import{createSnapDragEventPipelineStep as mt}from"../../../interactive/snapping/SnappingDragPipelineStep.js";import{acquire as ht}from"../../../interactive/snapping/SnappingManagerPool.js";import{SnappingOperation as gt}from"../../../interactive/snapping/SnappingOperation.js";import{setupSnappingToggleHandles as ft}from"../../../interactive/snapping/snappingUtils.js";let _t=class extends n{constructor(t){super(t),this._stagedDimension=null,this._computationManipulators=new Map,this._computationHandles=new s,this._updatingHandles=new S,this._getSnappingContext=c((t=>new ct({elevationInfo:{mode:"absolute-height",offset:0},pointer:t,editGeometryOperations:new dt(new ut("point",lt(!0,!1,this.view.spatialReference)),this.view.state.viewingMode),visualizer:new it})));const{view:i}=t;this._snappingManagerResult=ht(i),this.addHandles(this._snappingManagerResult),this._unfocusedOffsetManipulatorMaterial=this._createOffsetManipulatorMaterial(),this._focusedOffsetManipulatorMaterial=this._createOffsetManipulatorMaterial(),this._thinOffsetManipulatorMaterial=this._createOffsetManipulatorMaterial(),this._thinOffsetManipulatorMaterial.setParameters({stipplePattern:rt(2)}),this._constraintSnappingIndicator=new at({view:i,attached:!0,width:1,renderOccluded:st.OccludeAndTransparent,stipplePattern:rt(5),isDecoration:!0});const a=e.toUnitRGBA(X);this._stagedStartIndicator=new nt({view:i,attached:!1,elevationInfo:{mode:"absolute-height",offset:0},spatialReference:t.view.renderCoordsHelper.spatialReference,color:a,size:2*Y,outlineSize:0,renderOccluded:st.OccludeAndTransparent,isDecoration:!0})}initialize(){const{view:t}=this;this._snappingOperation=new gt({view:t});const i=Z(t.effectiveTheme),a=$(t.effectiveTheme),n=!t.stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;this._textureHandle=et(t.stage.textures,{accentColor:i,contrastColor:a,preMultiplyAlpha:n}),this._orientationManipulatorMaterial=new ot({draped:!1,texture:this._textureHandle.texture,writeDepth:!1,renderOccluded:st.Opaque,isDecoration:!0});const s=l((()=>this.analysisViewData.computations),(({computation:t})=>this._createManipulators(t)));this.addHandles([h((()=>({accentColor:Z(t.effectiveTheme),contrastColor:$(t.effectiveTheme)})),(({accentColor:i,contrastColor:a})=>{const s=this._textureHandle;this._textureHandle=et(t.stage.textures,{accentColor:i,contrastColor:a,preMultiplyAlpha:n}),this._orientationManipulatorMaterial.setParameters({texture:this._textureHandle.texture}),s?.release();const o=e.toUnitRGBA(i);this._unfocusedOffsetManipulatorMaterial.setParameters({color:o}),this._focusedOffsetManipulatorMaterial.setParameters({color:o}),this._thinOffsetManipulatorMaterial.setParameters({color:o}),this._constraintSnappingIndicator.color=o}),g),o(s),h((()=>({stagedPoint:this._snappingOperation.stagedPoint,stagedComputation:this._stagedComputation})),(({stagedPoint:t,stagedComputation:e})=>{if(null==e||null==t)return;const i=b(t,new w);this._applyPointUpdate(e,{endPoint:i})}),f),h((()=>({stagedDimension:this._stagedDimension,selectedComputation:this.analysisViewData.selectedComputation,firstGrabbedManipulator:this.firstGrabbedManipulator})),((t,e)=>{const{stagedDimension:i,selectedComputation:a,firstGrabbedManipulator:n}=t;if(i===e?.stagedDimension&&n===e?.firstGrabbedManipulator){for(const s of[a,e?.selectedComputation])if(null!=s){const e=this._computationManipulators.get(s);null!=e&&this._updateManipulators(s,e,t)}}else for(const[s,o]of this._computationManipulators)this._updateManipulators(s,o,t)}),_),h((()=>this.analysis.style.lineSize),(t=>this._updateManipulatorStyle(t)),g),h((()=>this.view.state.camera),(()=>{null!=this._stagedComputation&&this._updateStagedDimensionOffset(this._stagedComputation)})),h((()=>{const t=this._stagedComputation;if(!t)return null;const e=t.elevationAlignedStartPoint,i=C();return null!=e&&this.view.renderCoordsHelper.toRenderCoords(e,i)?i:null}),(t=>{null!=t?(this._stagedStartIndicator.vertices=[t],this._stagedStartIndicator.attached=!0):this._stagedStartIndicator.attached=!1}))]),this.addHandles(this._constraintHandles),this.addHandles(this._snappingIndicatorHandles),ft(this,(()=>{const t=this._activeComputation,e=this._stagedComputation;if(null==t||null!=e){const t=this.view.inputManager.latestPointerType??"mouse",e=this._getSnappingContext(t);this._updatingHandles.addPromise(m(this._snappingOperation.snapAgainNearPreviousMapPoint(this._snappingManager,e)))}if(null!=t){const{start:e,end:i}=this._computationManipulators.get(t);if(e.grabbing||i.grabbing){const i=e.grabbing?"start":"end",a=this._computeConstraint(t);P(t,i,{constraint:a,view:this.view})}}}))}destroy(){this._textureHandle=u(this._textureHandle),this._snappingOperation=d(this._snappingOperation),this._computationHandles.destroy(),this._constraintSnappingIndicator.destroy(),this._stagedStartIndicator.destroy(),this._orientationManipulatorMaterial.dispose()}get updating(){return this._updatingHandles.updating||this._snappingManager.updating}get firstGrabbedManipulator(){return this.parentTool.firstGrabbedManipulator}get hasGrabbedManipulators(){return this.parentTool.hasGrabbedManipulators}get snappingOptions(){return this._snappingManager.options}get _snappingManager(){return this._snappingManagerResult.snappingManager}get _activeComputation(){if(null!=this._stagedComputation)return this._stagedComputation;const{selectedComputation:t}=this.analysisViewData;return this.hasGrabbedManipulators&&null!=t?t:null}get _stagedComputation(){const t=this._stagedDimension,e=this.analysisViewData.computations.at(-1)?.computation;return null==t||null==e||e.dimension!==t?null:e}get _constraintHandles(){return[M((()=>this.analysisViewData.selectedComputation),(t=>{t.previousConstraint=this._computeConstraint(t)}),{..._,equals:p}),h((()=>{const t=this._activeComputation;if(null==t)return null;const{measureType:e,orientation:i}=t.dimension;return{measureType:e,orientation:i,computation:t}}),((t,e)=>{if(null!=t&&null==e){const{measureType:e,orientation:a,computation:n}=t;switch(n.previousConstraint){case O.Horizontal:n.preConstraintProperties={measureType:i.Horizontal,orientation:0};break;case O.Vertical:n.preConstraintProperties={measureType:i.Vertical,orientation:0};break;case O.Direct:n.preConstraintProperties={measureType:i.Direct,orientation:a};break;default:n.preConstraintProperties={measureType:e,orientation:a}}}null==t&&null!=e&&(e.computation.preConstraintProperties=null)}),f)]}get _snappingIndicatorHandles(){const t="snapping-indicator-event-handles";return[h((()=>({stagedComputation:this._stagedComputation,activeComputation:this._activeComputation})),(({stagedComputation:e,activeComputation:i})=>{const a=this._constraintSnappingIndicator;if(this.removeHandles(t),null!=i)if(i===e)a.attached=!0;else{const{start:e,end:n}=this._computationManipulators.get(i),s=()=>{a.attached=e.grabbing||n.grabbing};s(),this.addHandles([e.events.on("grab-changed",s),n.events.on("grab-changed",s)],t)}else a.attached=!1})),h((()=>{const t=this._activeComputation;return null!=t?{geometry:t.geometry,constraint:t.previousConstraint}:{}}),(({geometry:t,constraint:e})=>{const i=this._constraintSnappingIndicator;null!=t&&null!=e&&e!==O.Direct?(i.visible=!0,i.setGeometryFromSegment(t.directSegment)):i.visible=!1}))]}removeStaged(){return null!=this._stagedDimension&&(this.analysis.dimensions.remove(this._stagedDimension),this._stagedDimension=null,!0)}onDeactivate(){this.removeStaged(),this._resetSnappingState()}onClick(t){const{_stagedDimension:e}=this;if(null==e){const e=this._onUnstagedClick(t);return this.analysis.dimensions.add(e),null}return this._onStagedClick(t),e}onPointerMove({mapPoint:t,pointerType:e}){if("touch"===e)return;const i=this._getSnappingContext(e);this._updatingHandles.addPromise(m(this._snappingOperation.snap({point:t},this._snappingManager,i)))}onManipulatorSelectionChanged(){if(null!=this.analysisViewData.selectedComputation){this._computationManipulators.get(this.analysisViewData.selectedComputation).offset.selected||(this.analysisViewData.selectedDimension=null)}}_onUnstagedClick({mapPoint:t,pointerType:e}){let n=t;if("mouse"===e){const i=this._getSnappingContext(e);n=this._snappingManager.update({point:t,context:i})}const s=new a({startPoint:b(n,new w),endPoint:null,measureType:i.Horizontal});return this._stagedDimension=s,this._resetSnappingState(),s}_onStagedClick({mapPoint:t,pointerType:e}){const i=this._stagedComputation;if(null==i)return;let a=t;if("mouse"===e){const i=this._getSnappingContext(e);a=this._snappingManager.update({point:t,context:i})}const n=b(a,new w);this._applyPointUpdate(i,{endPoint:n}),this._stagedDimension=null,this._resetSnappingState()}_resetSnappingState(){this._snappingManager.doneSnapping(),this._snappingOperation.abort(),this._snappingOperation.stagedPoint=null}_createManipulators(t){const e=this._setupPointManipulator(t,{isStart:!0}),a=this._setupPointManipulator(t,{isStart:!1}),n=this._setupOffsetManipulator(t),s=this._setupHeadingManipulator(t),o=this._setupRotationManipulator(t),p=this._setupMeasureTypeManipulator(t,i.Direct),l=this._setupMeasureTypeManipulator(t,i.Horizontal),u=this._setupMeasureTypeManipulator(t,i.Vertical),d=new T({start:e,end:a,offset:n,heading:s,rotation:o,direct:p,horizontal:l,vertical:u});this._setupComputationToManipulatorsSync(t,d),this._computationManipulators.set(t,d),this.manipulators.addMany(d.values());const c=r(d.values().map((t=>t.events.on("focus-changed",(()=>{d.values().some((t=>t.focused))&&this._resetSnappingState()})))));return{manipulators:d,remove:()=>{c.remove(),this._computationHandles.remove(t),this._computationManipulators.delete(t);for(const t of d.values())this.manipulators.remove(t)}}}_setupComputationToManipulatorsSync(t,e){this._computationHandles.add([h((()=>t.geometry),(()=>this._updateManipulators(t,e)),{..._,equals:p})],t)}_setupPointManipulator(t,e){const{view:i}=this,{dimension:a}=t,n=new x(i,{metadata:a}),s=G(n,{isStart:e.isStart,createSnappingPipelineStep:t=>mt({snappingContext:this._getSnappingContext(t),snappingManager:this._snappingManager,updatingHandles:this._updatingHandles}),dimension:a,onUpdate:e=>this._applyPointUpdate(t,e),view:i});return this._computationHandles.add(s,t),n}_setupOffsetManipulator(t){const{view:e}=this,i=z(e,{lineSizePt:this.analysis.style.lineSize,unfocusedMaterial:this._unfocusedOffsetManipulatorMaterial,focusedMaterial:this._focusedOffsetManipulatorMaterial,metadata:t.dimension}),a=U(i,{computation:t,view:e});return this._computationHandles.add(a,t),i}_setupHeadingManipulator(t){const{view:e}=this,i=new V(e,{lineSizePt:this.analysis.style.lineSize,material:this._orientationManipulatorMaterial,metadata:t.dimension}),a=I(i,{computation:t,view:e});return this._computationHandles.add(a,t),i}_setupRotationManipulator(t){const{view:e}=this,i=new V(e,{lineSizePt:this.analysis.style.lineSize,material:this._orientationManipulatorMaterial,metadata:t.dimension}),a=A(i,{computation:t,view:e});return this._computationHandles.add(a,t),i}_setupMeasureTypeManipulator(t,e){const{view:i}=this,a=R(i,{lineSizePt:this.analysis.style.lineSize,unfocusedMaterial:this._unfocusedOffsetManipulatorMaterial,focusedMaterial:this._focusedOffsetManipulatorMaterial,thinOffsetManipulatorMaterial:this._thinOffsetManipulatorMaterial,metadata:t.dimension}),n=k(a,{computation:t,manipulatorMeasureType:e,view:i});return this._computationHandles.add(n,t),a}_updateManipulators(t,e,a={stagedDimension:this._stagedDimension,selectedComputation:this.analysisViewData.selectedComputation,firstGrabbedManipulator:this.firstGrabbedManipulator}){const{stagedDimension:n,selectedComputation:s,firstGrabbedManipulator:o}=a,{start:r,end:p,offset:l,heading:u,rotation:d}=e,c=s===t,m=J(t),{dimension:h}=t;for(const i of e.values()){const t=m&&null==n&&(null==o||i===o);i===l?(i.available=t,i.selected=c):i.available=t&&c}if(!m)return;null!=this._computeConstraint(t)?e.forEachMeasureTypeManipulator((t=>t.available=!1)):e.manipulatorForMeasureType(h.measureType).available=!1;for(const _ of[u,d])h.measureType===i.Direct&&0!==h.offset||(_.available=!1);K(t)?d.available=!1:u.available=!1;const{geometry:g}=t;r.renderLocation=g.directSegment.startRenderSpace,p.renderLocation=g.directSegment.endRenderSpace;const{renderCoordsHelper:f}=this.view;E(l,g,f),u.available&&L(u,t,f),d.available&&F(d,t,f),e.forEachMeasureTypeManipulator(((e,i)=>{e.available&&q(e,t,i,f)}))}_updateManipulatorStyle(t){const e=B(t),i=N(t),a={lineSizePt:t,material:this._orientationManipulatorMaterial};for(const{offset:n,heading:s,rotation:o}of this._computationManipulators.values())n.radius=i/2,s.update(a),o.update(a);this._unfocusedOffsetManipulatorMaterial.setParameters({width:e}),this._focusedOffsetManipulatorMaterial.setParameters({width:i})}_applyPointUpdate(t,e){const{view:i}=this,a=Q(t);"startPoint"in e&&(a.elevationAlignedStartPoint=e.startPoint),"endPoint"in e&&(a.elevationAlignedEndPoint=e.endPoint);const n=W(a,i.renderCoordsHelper);if(null==n)return;const s=this._computeConstraint({...a,geometry:n});D(t,e,{...a,constraint:s,unconstrainedGeometry:n,view:i}),t===this._stagedComputation&&this._updateStagedDimensionOffset(t)}_updateStagedDimensionOffset(t){if(null==t.geometry)return;t.geometry.directSegment.eval(.5,Mt);const{state:e,renderCoordsHelper:i}=this.view,a=e.camera.computeScreenPixelSizeAt(Mt);t.dimension.offset=tt*a*i.unitInMeters}_computeConstraint(t){return H(j(t,this._snappingManager.options),this.view)}_createOffsetManipulatorMaterial(){return new pt({width:1,renderOccluded:st.OccludeAndTransparent,writeDepth:!1,hasPolygonOffset:!0,isDecoration:!0})}get test(){}};t([v({constructOnly:!0})],_t.prototype,"analysis",void 0),t([v({constructOnly:!0})],_t.prototype,"analysisViewData",void 0),t([v({constructOnly:!0})],_t.prototype,"manipulators",void 0),t([v({constructOnly:!0})],_t.prototype,"parentTool",void 0),t([v({constructOnly:!0,nonNullable:!0})],_t.prototype,"view",void 0),t([v({readOnly:!0})],_t.prototype,"updating",null),t([v()],_t.prototype,"firstGrabbedManipulator",null),t([v()],_t.prototype,"hasGrabbedManipulators",null),t([v()],_t.prototype,"snappingOptions",null),t([v()],_t.prototype,"_stagedDimension",void 0),t([v()],_t.prototype,"_activeComputation",null),t([v()],_t.prototype,"_stagedComputation",null),_t=t([y("esri.views.3d.analysis.Dimension.LengthDimensionSubTool")],_t);const Mt=C();export{_t as LengthDimensionSubTool};
