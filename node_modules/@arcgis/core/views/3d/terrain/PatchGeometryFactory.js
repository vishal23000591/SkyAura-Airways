/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{clamp as e,isPowerOfTwo as t}from"../../../core/mathUtils.js";import{maxUint16 as n}from"../../../core/typedArrayUtil.js";import{empty as o}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as r}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as s}from"./ElevationData.js";import{PatchType as i}from"./interfaces.js";import{NeighborIndex as a}from"./NeighborIndex.js";import{PatchGeometryLUT as c}from"./PatchGeometryLUT.js";import{zeroToFour as l,neighborTileIfLoadedOrSelf as u}from"./PatchRenderData.js";import{internalAssert as d,enableTerrainInternalChecks as f,neighborEdgeIndices as m,almostEquals as g}from"./terrainUtils.js";import{isCornerNeighbor as h}from"./Tile.js";import{compareTilesByLij as p}from"./tileUtils.js";import{compressNormal as x}from"../webgl-engine/lib/Normals.js";const M=65536;function S(e,t){const{tile:n,geometry:r,geometryState:s}=e,{extentInRadians:a,surface:c}=n,{isWebMercator:l,renderer:u}=c,{numVerticesPerSide:d,wireframe:f}=s,m=d-1,g=(d-2)**2,h=l&&(t===i.HAS_SOUTH_POLE||t===i.HAS_BOTH_POLES),p=l&&(t===i.HAS_NORTH_POLE||t===i.HAS_BOTH_POLES),x=((h?1:0)+(p?1:0))*he*d,M=fe(s),S=g+x+4*M,V=u.tileGeometryCache.acquire(S);r.numVerticesPerSide=d,r.vertexAttributes=V,r.maxEdgeVertexCount=M;const{boundingBox:B}=r;o(B);const I=O(e);se.update(m,a,I),v(e),r.poleVerticesStartIndex=g;const L=y(e,h,p);r.edgeVerticesStartIndex=g+x,X(e),b(e),W(r,L,f),e.intersectionData=null}function y(e,t,o){const{tile:r,localOrigin:s,geometry:i}=e,{extent:a,ellipsoid:c}=r,{boundingBox:l,numVerticesPerSide:u,vertexAttributes:d,poleVerticesStartIndex:f}=i,m=u-1,g=s[0],h=s[1],p=s[2],M=c.radius,S=a[1],y=a[3],v=[];let V=f;const B=(e,t)=>{const o=t*u;de(-g,-h,e*M-p,l),v.push(new oe(1===e,o,1===e?0:2,V,he));const r=A(-1===e?S:y,M),s=e*Math.PI/2-r,i=.99*(1===e?1:-1),a=M+0,{position:c,uv0:f}=d,{typedBuffer:B,typedBufferStride:I}=d.normalCompressed;for(let u=1;u<=he;++u){const e=r+s*(u/he),t=Math.cos(e),o=Math.sin(e);for(let r=0;r<=m;r++){const e=r/m,s=se.sinLonLUT[r],u=se.cosLonLUT[r]*t,d=s*t,M=o,S=u*a-g,y=d*a-h,v=M*a-p;de(S,y,v,l),c.setValues(V,S,y,v),f.setValues(V,Math.round(e*n),Math.round(i*n)),x(B,V,u,d,M,I),++V}}};return t&&B(-1,0),o&&B(1,m),v}function v(e){const{tile:t}=e;if(!t.intersectsClippingArea)return;const{geometry:o,geometryState:r,localOrigin:i}=e,{numVerticesPerSide:a,samplerData:c}=r,l=a-2,u=a-1,{vertexAttributes:d,boundingBox:f}=o,{position:m,uv0:g}=d,{typedBuffer:h,typedBufferStride:p}=d.normalCompressed,{extent:M}=t,S=M[0],y=M[2],v=M[1],V=M[3],B=t.ellipsoid.radius,I=i[0],b=i[1],L=i[2],C=m.typedBuffer,A=m.typedBufferStride,P=1/u;let E=0;if(1<=l){const e=P,t=v*(1-e)+V*e,o=se.sinLatLUT[1],r=se.cosLatLUT[1];for(let i=1;i<=l;i++){const a=i*P,l=S*(1-a)+y*a,u=se.sinLonLUT[i],d=se.cosLonLUT[i],m=B+s(l,t,c),h=m*d*r-I,p=m*u*r-b,x=m*o-L;de(h,p,x,f);const M=(i-1)*A;C[M]=h,C[M+1]=p,C[M+2]=x,g.setValues(i-1,Math.round(a*n),Math.round(e*n))}}for(let O=1;O<=l;O++){const e=O*P,t=v*(1-e)+V*e,o=se.sinLatLUT[O],r=se.cosLatLUT[O],i=O+1,a=i*P,d=v*(1-a)+V*a,m=se.sinLatLUT[i],M=se.cosLatLUT[i],T=se.sinLonLUT[0],D=se.cosLonLUT[0],R=B+s(S,t,c);let U=D*r*R-I,N=T*r*R-b,w=o*R-L;const j=E*A;let F=C[j],H=C[j+1],q=C[j+2];for(let V=1;V<=l;V++){const e=V*P,i=S*(1-e)+y*e,T=se.sinLonLUT[V],D=se.cosLonLUT[V];let R=0,j=0,_=0;if(V<l){const e=(E+1)*A;R=C[e],j=C[e+1],_=C[e+2]}else{const e=se.sinLonLUT[u],n=se.cosLonLUT[u],i=B+s(y,t,c);R=n*r*i-I,j=e*r*i-b,_=o*i-L}const W=U,k=N,z=w;U=F,N=H,w=q,F=R,H=j,q=_;const G=R-W,J=j-k,K=_-z;let Q=0,X=0,Y=0;if(O>1){const e=(E-l)*A;Q=C[e],X=C[e+1],Y=C[e+2]}else{const e=se.sinLatLUT[0],t=se.cosLatLUT[0],n=B+s(i,v,c);Q=D*t*n-I,X=T*t*n-b,Y=e*n-L}const Z=B+s(i,d,c),$=D*M*Z-I,ee=T*M*Z-b,te=m*Z-L;if(O<l){const t=E+l,o=t*A;C[o]=$,C[o+1]=ee,C[o+2]=te,de($,ee,te,f),g.setValues(t,Math.round(e*n),Math.round(a*n))}const ne=Q-$,oe=X-ee,re=Y-te;let ie=D*r,ae=T*r,ce=o;ce*ce<.999&&(ie=K*oe-J*re,ae=G*re-K*ne,ce=J*ne-G*oe);const le=1/Math.sqrt(ie*ie+ae*ae+ce*ce);x(h,E,ie*le,ae*le,ce*le,p),++E}}}function V(e){e.tile.intersectsClippingArea&&(b(e),te(e),e.intersectionData=null)}function B(e){e.tile.intersectsClippingArea&&(Y(e),b(e),te(e),ne(e),e.intersectionData=null)}function I(e){e.tile.intersectsClippingArea&&(C(e),L(e,!0),te(e),e.intersectionData=null)}function b(e){e.tile.intersectsClippingArea&&(C(e),L(e))}function L(e,o=!1){const{geometry:r,geometryState:i,tile:a,localOrigin:c}=e,{level:l,extent:h,extentInRadians:x,ellipsoid:M}=a,S=M.radius,y=x[0],v=x[2],V=x[1],B=x[3],{samplerData:I}=i,b=h[0],L=h[2],C=h[1],A=h[3],P=O(e),{boundingBox:E,vertexAttributes:T}=r,D=c[0],R=c[1],U=c[2],{position:N,uv0:w}=T,j=N.typedBuffer,F=N.typedBufferStride;for(let O=0;O<4;++O){const c=1===O||3===O,x=i.edgeResolutions[O];d(t(x));const M=x+1,T=u(a,i.edgePeerNeighbors[O]);if(ce(a,T,O)){Z(e,O,T);continue}const N=null!=T;d(!N||T.level===a.level),d(!N||p(a,T)<=0);const H=T?.renderData,q=H?.geometryState;if(f){const e=a.surface;if(!T&&e&&!e.updatingRootTiles){const t=m[O],n=a.findNeighborTile(t,(e=>e.loaded||e.leaf||e.level===a.level));n?n.intersectsClippingArea&&(d(!n.loaded),d(!n.leaf),d(n.level===l)):d(null==e?.rootTiles||!a.shouldHaveNeighbor(t))}}const _=1===O?h[2]:h[0],W=T?.extent,k=W&&c?1===O?W[0]:W[2]:_,z=0===O?h[3]:h[1],G=1===O?1:0,J=0===O?1:0,K=1===O?v:y,Q=0===O?B:V,X=Math.sin(K),Y=Math.cos(K),$=Math.sin(Q),ee=Math.cos(Q),te=q?.samplerData,ne=N?(e,t,n)=>.5*(s(e,t,I)+s(n,t,te)):(e,t,n)=>s(e,t,I),oe=r.outerEdgesOffsetAndLength[2*O+0],re=o&&M>3?M-3:1,se=null!=I&&I.some((e=>null!=e)),ie=null!=te&&te.some((e=>null!=e)),ae=se||ie,le=1/x,ue=oe;d(!W||g(W[2]-W[0],h[2]-h[0]));(()=>{const e=1===O?-1:3===O?1:0,t=0===O?-1:2===O?1:0,o=(h[2]-h[0])*le,i=e*o,a=t*o,l=c?e*((v-y)*le):0,u=c?0:t*le,d=J,f=c?K+l:K,m=c?Math.sin(f):X,g=c?Math.cos(f):Y,p=c?K-l:K,x=c?Math.sin(p):X,V=c?Math.cos(p):Y,B=c?Q:P(d+u),T=c?$:Math.sin(B),H=c?ee:Math.cos(B),q=c?Q:P(d-u),W=c?$:Math.sin(q),Z=c?ee:Math.cos(q);let oe=0,se=0,ie=0;{const e=0*le,t=c?_:b*(1-e)+L*e,n=c?k:t,o=c?C*(1-e)+A*e:z,r=c?K:y*(1-e)+v*e,s=c?X:Math.sin(r),i=c?Y:Math.cos(r),a=c?P(e):Q,l=c?Math.sin(a):$,u=c?Math.cos(a):ee,d=S+ne(t,o,n);oe=i*u*d,se=s*u*d,ie=l*d}let ce=0,fe=0,me=0;{const e=1*le,t=c?_:b*(1-e)+L*e,n=c?k:t,o=c?C*(1-e)+A*e:z,r=c?K:y*(1-e)+v*e,s=c?X:Math.sin(r),i=c?Y:Math.cos(r),a=c?P(e):Q,l=c?Math.sin(a):$,u=c?Math.cos(a):ee,d=S+ne(t,o,n);ce=i*u*d,fe=s*u*d,me=l*d}for(let h=1;h<M-1;h+=re){let e=0,t=0,o=0;{const n=(h+1)*le,r=c?_:b*(1-n)+L*n,s=c?k:r,i=c?C*(1-n)+A*n:z,a=c?K:y*(1-n)+v*n,l=c?X:Math.sin(a),u=c?Y:Math.cos(a),d=c?P(n):Q,f=c?Math.sin(d):$,m=c?Math.cos(d):ee,g=S+ne(r,i,s);e=u*m*g,t=l*m*g,o=f*g}const l=e,u=t,d=o,f=ce,p=fe,M=me;ce=l,fe=u,me=d;{const e=ue+h,t=e*F,o=f-D,r=p-R,s=M-U;j[t]=o,j[t+1]=r,j[t+2]=s,de(o,r,s,E);const i=h*le,a=c?G:i,l=c?i:J;w.setValues(e,Math.round(a*n),Math.round(l*n))}const B=oe,q=se,re=ie;oe=f,se=p,ie=M;const ge=f,he=p,pe=M,xe=1/Math.sqrt(ge*ge+he*he+pe*pe),Me=pe*xe;let Se=0,ye=0,ve=0;if(ae&&Me*Me<.999){let e=0,t=0,n=0;{const o=0===O?-1:1;e=o*(l-B),t=o*(u-q),n=o*(d-re)}{const o=h*le,r=c?_:b*(1-o)+L*o,l=c?k:r,u=c?C*(1-o)+A*o:z,d=c?K:y*(1-o)+v*o,f=c?X:Math.sin(d),p=c?Y:Math.cos(d),M=c?P(o):Q,B=c?Math.sin(M):$,E=c?Math.cos(M):ee;let D=ge,R=he,U=pe;if(N){const e=S+s(l-i,u-a,te),t=c?E:Z;D=(c?V:p)*t*e,R=(c?x:f)*t*e,U=(c?B:W)*e}{const o=S+s(r+i,u+a,I),l=c?E:H,d=(c?g:p)*l*o,h=(c?m:f)*l*o,x=(c?B:T)*o;N||(D=2*ge-d,R=2*he-h,U=2*pe-x);const M=3===O?-1:1,y=M*(D-d),v=M*(R-h),V=M*(U-x);Se=n*v-t*V,ye=e*V-n*y,ve=t*y-e*v;const b=1/Math.sqrt(Se*Se+ye*ye+ve*ve);Se*=b,ye*=b,ve*=b}}}else Se=ge*xe,ye=he*xe,ve=pe*xe;r.setEdgeNormalFromValues(O,h,Se,ye,ve)}})()}}function C(e){$(e)}function A(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function P(e,t,n,o){return A(e*(1-o)+t*o,n)}function E(e,t,n){return e*(1-n)+t*n}function O(e){const{tile:t}=e;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>P(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>E(n[1],n[3],e)}function T(e,t){const{tile:n,geometryState:r,geometry:s}=e,{extent:i,surface:a}=n,{wireframe:c}=r,l=i[0],u=i[1],d=i[2]-l,f=i[3]-u,{numVerticesPerSide:m,clippingArea:g}=r,h=null!=g?Math.max(0,(g[0]-l)/d):0,p=null!=g?Math.max(0,(g[1]-u)/f):0,x=null!=g?Math.min(1,(g[2]-l)/d):1,M=null!=g?Math.min(1,(g[3]-u)/f):1,S=(m-2)**2,y=fe(r),v=S+4*y,V=a.renderer.tileGeometryCache.acquire(v),{boundingBox:B}=s;o(B),s.numVerticesPerSide=m,s.vertexAttributes=V,s.maxEdgeVertexCount=y,s.minu=h,s.minv=p,s.maxu=x,s.maxv=M,D(e),s.edgeVerticesStartIndex=S,X(e),w(e),W(s,[],c),e.intersectionData=null}function D(t){const o=t.tile;if(!o.intersectsClippingArea)return;const{geometry:r,geometryState:i,localOrigin:a}=t,{samplerData:c,clippingArea:l,numVerticesPerSide:u}=i,{surface:d,extent:f,ellipsoid:m}=o,{isWebMercatorOnPlateCarree:g}=d,h=null!=l?l:ie,p=f[0],M=f[1],S=f[2],y=f[3],v=Math.max(p,h[0]),V=Math.min(S,h[2]),B=Math.max(M,h[1]),I=Math.min(y,h[3]),b=m.radius,L=o.horizontalScale,C=u-1,A=u-2,{minu:P,minv:E,maxu:O,maxv:T,boundingBox:D,vertexAttributes:R}=r,{position:U,uv0:N}=R,{typedBuffer:w,typedBufferStride:j}=R.normalCompressed,F=a[0],H=a[1],q=a[2],_=U.typedBuffer,W=U.typedBufferStride;let k=0;const z=e(M,B,I),G=g?(Math.PI/2-2*Math.atan(Math.exp(-z/b)))*b:z*L,J=1/C,K=e(M*(1-J)+y*J,B,I);let Q=G,X=g?(Math.PI/2-2*Math.atan(Math.exp(-K/b)))*b:K*L;for(let Y=1;Y<=A;Y++){const t=Y/C,o=e(M*(1-t)+y*t,B,I),r=e(t,E,T),i=X,a=(Y-1)/C,l=e(M*(1-a)+y*a,B,I),u=Q,d=(Y+1)/C,f=e(M*(1-d)+y*d,B,I),m=g?(Math.PI/2-2*Math.atan(Math.exp(-f/b)))*b:f*L,h=e(d,E,T);Q=X,X=m;const R=e(p,v,V);let U=R*L,z=s(R,o,c);const G=1/C,J=e(G,P,O),K=e(p*(1-J)+S*J,v,V);let Z=J,$=K,ee=K*L,te=s(K,o,c);if(1===Y){const t=ee-F,o=Q-H,s=te-q,i=0*W;_[i]=t,_[i+1]=o,_[i+2]=s,de(t,o,s,D);const a=e(G,P,O);N.setValues(k,Math.round(a*n),Math.round(r*n))}for(let g=1;g<=A;g++){const t=ee,a=te,d=(g+1)/C,M=e(d,P,O),y=e(p*(1-d)+S*d,v,V),B=$;$=y;{const e=k+1,t=e*W;if(1===Y||g===A){const a=y*L,l=s(y,o,c);if(1===Y&&g<A){const o=a-F,s=i-H,c=l-q;_[t]=o,_[t+1]=s,_[t+2]=c,de(o,s,c,D),N.setValues(e,Math.round(M*n),Math.round(r*n))}ee=a,te=l}else ee=_[t]+F,te=_[t+2]+q}const I=ee,b=te,E=U,T=z;U=t,z=a;const R=(k-A)*W,G=1===Y?s(B,l,c):_[R+2]+q,J=s(B,f,c);if(Y<A){const e=k+A,o=e*W,r=t-F,s=m-H,i=J-q;_[o]=r,_[o+1]=s,_[o+2]=i,de(r,s,i,D);const a=Z;Z=M,N.setValues(e,Math.round(a*n),Math.round(h*n))}{const e=I-E,t=u-m,n=t*(b-T),o=e*(G-J),r=-t*e,s=n*n+o*o+r*r;if(0===s)x(w,k,0,0,1,j);else{const e=1/Math.sqrt(s);x(w,k,n*e,o*e,r*e,j)}}++k}}}function R(e,t){e.tile.intersectsClippingArea&&(F(e),j(e,!0),te(e),e.intersectionData=null)}function U(e,t){e.tile.intersectsClippingArea&&(Y(e),w(e),te(e),ne(e),e.intersectionData=null)}function N(e,t){e.tile.intersectsClippingArea&&(w(e),te(e),e.intersectionData=null)}function w(e,t){e.tile.intersectsClippingArea&&(F(e),j(e,!1))}function j(n,o){const{geometry:r,geometryState:i,localOrigin:a}=n,c=n.tile,{surface:l,extent:g}=c,{clippingArea:h,samplerData:x}=i,M=null!=h?h:ie,S=g[0],y=g[2],v=g[1],V=g[3],B=[V>M[3],y>M[2],v<M[1],S<M[0]],I=c.horizontalScale,b=_(l.isWebMercatorOnPlateCarree,c.ellipsoid.radius,I),{minu:L,minv:C,maxu:A,maxv:P,boundingBox:E}=r,O=Math.max(S,M[0]),T=Math.min(y,M[2]),D=Math.max(v,M[1]),R=Math.min(V,M[3]),U=a[0],N=a[1],w=a[2];for(let j=0;j<4;++j){const a=1===j||3===j,g=i.edgeResolutions[j];d(t(g));const h=g+1,M=B[j],F=u(c,i.edgePeerNeighbors[j]);if(!M&&ce(c,F,j)){Z(n,j,F);continue}const H=null!=F&&!M,q=F?.renderData,_=q?.geometryState;if(f&&(d(!H||F.level===c.level),d(!H||p(c,F)<=0),c&&!F&&!l.updatingRootTiles)){const e=m[j],t=c.findNeighborTile(e,(e=>e.loaded||e.leaf||e.level===c.level));l.updatingRootTiles||(t?t.intersectsClippingArea&&(d(!t.loaded),d(!t.leaf),d(t.level===c.level)):d(null==l?.rootTiles||!c.shouldHaveNeighbor(e)))}const W=e(1===j?y:S,O,T),k=e(0===j?V:v,D,R),z=_?.samplerData,G=o&&h>3?h-3:1,J=e(1===j?1:0,L,A),K=e(0===j?1:0,C,P),Q=H?(e,t)=>.5*(s(e,t,z)+s(e,t,x)):(e,t)=>s(e,t,x),X=(y-S)/g,Y=a?1===j?X:-X:0,$=a?0:0===j?X:-X,ee=-Y,te=-$;let ne=0,oe=0,re=0;{const t=0/g,n=a?W:e(S*(1-t)+y*t,O,T),o=a?e(v*(1-t)+V*t,D,R):k,r=Q(n,o);ne=n*I,oe=b(o),re=r}let se=0,ie=0,ae=0;{const t=1/g,n=a?W:e(S*(1-t)+y*t,O,T),o=a?e(v*(1-t)+V*t,D,R):k,r=Q(n,o);se=n*I,ie=b(o),ae=r}for(let t=1;t<h-1;t+=G){const n=t/g,o=se,i=ie,c=ae;{const s=a?J:e(n,L,A),l=a?e(n,C,P):K,u=o-U,d=i-N,f=c-w;de(o,d,f,E),r.setEdgeVertexFromValuesRawPositionUV(j,t,u,d,f,s,l)}{const n=(t+1)/g,o=a?W:e(S*(1-n)+y*n,O,T),r=a?e(v*(1-n)+V*n,D,R):k,s=Q(o,r);se=o*I,ie=b(r),ae=s}const l=se,u=ae,d=ne,f=oe,m=re;ne=o,oe=i,re=c;let h=0,p=0,M=0;if(a){const t=ie-i,r=u-c,a=f-i,l=m-c,d=e(v*(1-n)+V*n,D,R),g=W+ee,S=g*I-o,y=s(g,d,x)-c,B=3===j?-1:1;if(h=B*(-a+t)*y,p=B*S*(-l+r),M=-B*S*(-a+t),H){const e=W+Y,n=e*I-o;h=(-a+t)*(y-(s(e,d,z)-c)),p=(S-n)*(-l+r),M=-(S-n)*(-a+t)}}else{const t=l-o,r=u-c,a=d-o,f=m-c,g=e(S*(1-n)+y*n,O,T),v=k+te,V=s(g,v,x)-c,B=b(v)-i,I=2===j?-1:1;if(h=I*B*(-f+r),p=I*(-a+t)*V,M=-I*B*(-a+t),H){const e=g,n=k+$,o=b(n)-i;h=(-B+o)*(-f+r),p=(-a+t)*(-V+(s(e,n,z)-c)),M=-(-B+o)*(-a+t)}}const B=1/Math.sqrt(h*h+p*p+M*M);r.setEdgeNormalFromValues(j,t,h*B,p*B,M*B)}}}function F(e,t){$(e)}function H(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function q(e,t){return e*t}function _(e,t,n){return e?e=>H(e,t):e=>q(e,n)}function W(e,t,n){const{numVerticesPerSide:o,vertexAttributes:r,maxEdgeVertexCount:s}=e,i=o-1,a=r.count,c=2*(o-3)*(o-3),u=4*(i+s-3),d=l.reduce(((t,n)=>t+(i+e.getEdgeCount(n)-3)),0),f=t.reduce(((e,t)=>e+i*(2*(t.latitudeResolution-1)+1)),0),m=3*(n?2:1),g=(c+u+f)*m,h=a>=M?new Uint32Array(g):new Uint16Array(g);for(let l=0;l<g;++l)h[l]=0;e.indices=h,e.indexCount=(c+d+f)*m,e.poleIndicesStartIndex=c*m,e.edgeIndicesStartIndex=(c+f)*m,n?(J(e),K(e,t),Q(e)):(k(e),z(e,t),G(e))}function k(e){const{numVerticesPerSide:t,indices:n,vertexAttributes:o}=e,{position:r}=o,{typedBuffer:s,typedBufferStride:i}=r,a=t-2,c=t-3,l=0,u=t-3;let d=0;for(let f=0;f<c;++f){const e=f*a;for(let t=l;t<u;++t){const o=e+t,r=o+1,c=r+a,l=c-1;me(o,r,c,l,i,s)?(n[d]=o,n[d+1]=r,n[d+2]=c,n[d+3]=c,n[d+4]=l,n[d+5]=o):(n[d]=o,n[d+1]=r,n[d+2]=l,n[d+3]=l,n[d+4]=r,n[d+5]=c),d+=6}}}function z(e,t){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:r}=e,s=n-1;let i=r;for(const a of t){const t=a.isNorth?1:2,r=a.isNorth?2:1,c=a.isNorth?3:4,l=a.isNorth?4:3;let u=e.getEdgeVertexIndex(a.connectedOuterEdgeOffset,0),d=1;for(let e=0;e<a.latitudeResolution;++e){const f=0===e?a.rowOffset:u+n;for(let n=0;n<s;n++){const s=f+n;o[i]=u,o[i+t]=u+1,o[i+r]=s,e<a.latitudeResolution-1?(o[i+c]=u+1,o[i+l]=s+1,o[i+5]=s,i+=6):i+=3,u+=d}u=f,d=1}}}function G(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,r=n-1,s=r-2;let i=o;for(let a=0;a<4;++a){const n=ue[a];let o=0,c=0;const l=e.getEdgeCount(a),u=n.count;d(u===r-1);const f=1===a||2===a,m=f?1:2,g=f?2:1,h=e.getEdgeFirstVertexIndex(a),p=1,x=n.vertex0Index,M=n.stride;for(;o<l-1||c<u-1;){const e=x+c*M,n=h+o*p,a=o<l-1,d=c<u-1,f=a&&(!d||(a?0+r*(o+.5)/(l-1):0)<=(d?1+s*(c+.5)/(u-1):0));f?++o:++c;const S=f?n+p:e+M;t[i]=e,t[i+m]=n,t[i+g]=S,i+=3}}e.indexCount=i}function J(e){const{indices:t,numVerticesPerSide:n,vertexAttributes:o}=e,{position:r}=o,{typedBuffer:s,typedBufferStride:i}=r,a=n-2;let c=0;for(let l=0;l<n-3;++l){const e=l*a;for(let o=0;o<n-3;++o){const n=l*a+o,r=n+1,u=r+a,d=u-1,f=e+o,m=f+1,g=m+a;me(f,m,g,g-1,i,s)?(ge(t,c,n,r,u),c+=6,ge(t,c,u,d,n)):(ge(t,c,n,r,d),c+=6,ge(t,c,d,u,r)),c+=6}}}function K(e,t){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:r}=e,s=o-1;let i=r;for(const a of t){const t=a.connectedOuterEdgeOffset;let r=e.getEdgeVertexIndex(t,0),c=1;for(let e=0;e<a.latitudeResolution;++e){const t=0===e?a.rowOffset:r+o;for(let o=0;o<s;o++)ge(n,i,r,r+1,t+o),i+=6,e<a.latitudeResolution-1&&(ge(n,i,r+1,t+o+1,t+o),i+=6),r+=c;r=t,c=1}}}function Q(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,r=n-1,s=r-2;let i=o;for(let a=0;a<4;++a){const n=ue[a];let o=0,c=0;const l=e.getEdgeCount(a),u=n.count;d(u===r-1);const f=1===a||2===a,m=f?1:3,g=f?3:1,h=e.getEdgeFirstVertexIndex(a),p=1,x=n.vertex0Index,M=n.stride;for(;o<l-1||c<u-1;){const e=x+c*M,n=h+o*p,a=o<l-1,d=c<u-1,f=a&&(!d||(a?0+r*(o+.5)/(l-1):0)<=(d?1+s*(c+.5)/(u-1):0));f?++o:++c;const S=f?n+p:e+M;t[i]=e,t[i+m]=n,t[i+m+1]=n,t[i+g]=S,t[i+g+1]=S,t[i+5]=e,i+=6}}e.indexCount=i}function X(e){const{geometry:t,geometryState:n}=e,{edgeResolutions:o}=n,{numVerticesPerSide:r,edgeVerticesStartIndex:s}=t,i=r-2;let a=s;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?i-1:0)*i+(1===c?i-1:0),n=(e?0:1)*i+(e?1:0),o=ue[c];o.vertex0Index=t,o.stride=n,o.count=i}{const e=o[c]+1;t.outerEdgesOffsetAndLength[2*c+0]=a,t.outerEdgesOffsetAndLength[2*c+1]=e,a+=e}}}function Y(e){X(e),e.geometryState.wireframe?Q(e.geometry):G(e.geometry)}function Z(o,r,s){const{geometryState:i,geometry:a,tile:c,localOrigin:l}=o,u=1===r||3===r,f=i.edgeResolutions[r];d(t(f));const m=f+1,{boundingBox:g,minu:h,minv:p,maxu:x,maxv:M,vertexAttributes:S}=a,y=e(1===r?1:0,h,x),v=e(0===r?1:0,p,M),V=s.renderData,B=V.geometryState,I=V.geometry,b=(r+2)%4,L=I.getEdgeCount(b),C=c.getNeighborEdgeStartVertexIndex(r,s)*f,A=f*2**(c.level-s.level);d(B.edgeResolutions[b]===A),d(L-1===A);const P=V.localOrigin[0]-l[0],E=V.localOrigin[1]-l[1],O=V.localOrigin[2]-l[2],T=a.getEdgeFirstVertexIndex(r),{position:D,uv0:R}=S,U=D.typedBuffer,N=D.typedBufferStride,w=S.normalCompressed,j=w.typedBuffer,F=w.typedBufferStride,H=I.vertexAttributes,q=I.getEdgeFirstVertexIndex(b),_=H.position.typedBuffer,W=H.position.typedBufferStride,k=H.normalCompressed.typedBuffer,z=H.normalCompressed.typedBufferStride;for(let t=1;t<m-1;++t){const o=T+t,r=q+(C+t),s=o*N,i=r*W,a=_[i]+P,c=_[i+1]+E,l=_[i+2]+O;U[s]=a,U[s+1]=c,U[s+2]=l,de(a,c,l,g);const d=o*F,m=r*z;j[d]=k[m],j[d+1]=k[m+1];const S=t/f,V=u?y:e(S,h,x),B=u?e(S,p,M):v;R.setValues(o,Math.round(V*n),Math.round(B*n))}}function $(t){const{geometry:o,geometryState:r,localOrigin:i}=t,{clippingArea:a,samplerData:c}=r,{minu:l,minv:u,maxu:f,maxv:m,boundingBox:g,vertexAttributes:h}=o,x=t.tile,{surface:M,ellipsoid:S,extent:y,extentInRadians:v,horizontalScale:V}=x,B="local"===M.view?.viewingMode,I=S.radius;let b=0,L=0,C=0;const A=(e,t,n)=>{const o=v[0===t?1:3],r=v[0===e?0:2],s=Math.cos(o),i=Math.sin(o),a=Math.sin(r),c=Math.cos(r),l=I+n;b=c*s*l,L=a*s*l,C=i*l},P=B?(()=>{const t=a,n=null!=t&&(y[3]>t[3]||y[2]>t[2]||y[1]<t[1]||y[0]<t[0]),o=_(M.isWebMercatorOnPlateCarree,I,V);return(r,s,i)=>{const a=0===r?y[0]:y[2],c=0===s?y[1]:y[3],l=n?e(a,t[0],t[2]):a,u=n?e(c,t[1],t[3]):c,d=i;b=l*V,L=o(u),C=d}})():A;let E=0,T=0,D=0,R=0,U=0,N=0,w=0,j=0,F=0;const H=B&&M.isWebMercatorOnPlateCarree,q=(e,t,n,o,r)=>{let s=0,i=0,a=0;if(B){const e=t*V,r=H?(Math.PI/2-2*Math.atan(Math.exp(-n/I)))*I:n*V;s=e-b,i=r-L,a=o-C}else{const r=O(e),c=e.tile,l=c.extent,u=c.extentInRadians,d=(t-l[0])/(l[2]-l[0]),f=(n-l[1])/(l[3]-l[1]),m=u[0]*(1-d)+u[2]*d,g=r(f),h=Math.cos(g),p=Math.sin(g),x=Math.sin(m),M=Math.cos(m),S=I+o;s=M*h*S-b,i=x*h*S-L,a=p*S-C}switch(r){case 0:w+=s,j+=i,F+=a;break;case 1:R-=s,U-=i,N-=a;break;case 2:w-=s,j-=i,F-=a;break;case 3:R+=s,U+=i,N+=a}},W=a??ie,k=y[0],z=y[2],G=y[1],J=y[3],K=[J>W[3],z>W[2],G<W[1],k<W[0]],Q=Math.max(k,W[0]),X=Math.min(z,W[2]),Y=Math.max(G,W[1]),Z=Math.min(J,W[3]),$=e=>Math.max(W[0],Math.min(W[2],e)),te=e=>Math.max(W[1],Math.min(W[3],e)),ne=e=>{const t=r.cornerNeighborCornerTiles;E=0,T=0,D=1,R=0,U=0,N=0,w=0,j=0,F=0;let n=1/0;for(let r=0;r<4;++r){const o=t[4*e+r];n=Math.min(n,o?.level??1/0)}for(let r=0;r<4;++r){const o=t[4*e+r];ae[r]=o?.level===n?o:null}let o=1,i=0;for(let r=0;r<4;++r){const e=ae[r];e&&(o=Math.max(o,e?.renderData.geometryState.numVerticesPerSide),i=e.extent[2]-e.extent[0])}const a=i,c=o;d(c>1);const l=a/c;for(let r=0;r<4;++r){const e=ae[(r+3)%4],t=ae[r%4];if(!e&&!t)continue;const n=0===r?1:1===r?2:2===r?3:0,o=0===r?2:1===r?3:2===r?0:1;if(e&&t){const i=re[r][0]*l,a=re[r][1]*l,c=e.extent,u=$(c[0===n||1===n?2:0]+i),d=te(c[0===n||3===n?3:1]+a),f=t.extent,m=$(f[0===o||1===o?2:0]+i),g=te(f[0===o||3===o?3:1]+a),h=e.renderData,p=t.renderData,x=s(u,d,h.geometryState.samplerData),M=s(m,g,p.geometryState.samplerData);q(h,u,d,.5*(x+M),r)}else{const i=e??t,a=e?n:o,c=i.extent,u=re[r],d=$(c[0===a||1===a?2:0]+u[0]*l),f=te(c[0===a||3===a?3:1]+u[1]*l),m=i.renderData,g=s(d,f,m.geometryState.samplerData);q(m,d,f,g,r)}}if(!B){const e=Math.sqrt(b*b+L*L+C*C);E=b/e,T=L/e,D=C/e}if(B||D*D<.999){const e=Math.sqrt(R*R+U*U+N*N);R/=e,U/=e,N/=e;const t=Math.sqrt(w*w+j*j+F*F);w/=t,j/=t,F/=t,E=N*j-U*F,T=R*F-N*w,D=U*w-R*j;const n=1/Math.sqrt(E*E+T*T+D*D);E*=n,T*=n,D*=n}},oe=r.cornerNeighborCornerTiles;for(let O=0;O<4;++O){const t=O,a=(O+1)%4,M=0===O||1===O?1:0,S=0===O||3===O?1:0,y=e(M,l,f),v=e(S,u,m),V=o.getEdgeFirstVertexIndex(t),B=o.getEdgeCount(t),I=0===O||3===O?B-1:0,A=o.getEdgeFirstVertexIndex(a),R=o.getEdgeCount(a),U=0===O||1===O?R-1:0;let N=-1;for(let e=0;e<4;++e){const t=oe[4*O+e],n=oe[4*O+N];t&&(-1===N||p(n,t)>0)&&(N=e)}const w=N,j=oe[4*O+w];if(j!==x){const e=x.level-j.level,t=2**e,o=[j.lij[0]+e,j.lij[1]*t,j.lij[2]*t],s=[o[1]+t===x.lij[1],0===O&&(1===w||0===w&&j!==oe[4*O+3])||1===O&&(0===w||1===w&&j!==oe[4*O+2]),o[1]===x.lij[1]+1,2===O&&(3===w||2===w&&j!==oe[4*O+1])||3===O&&(2===w||3===w&&j!==oe[4*O+0])],a=s.reduce(((e,t)=>e+(t?1:0)),0);d(1===a||2===a);let c=-1,l=-1;const u=j.renderData;if(1===a){const e=s.findIndex((e=>e));d(0<=e&&e<=3),c=(e+2)%4;const t=r.edgeResolutions[e];l=x.getNeighborEdgeStartVertexIndex(e,j)*t+t*(0===e&&0===O||1===e&&0===O||2===e&&1===O||3===e&&3===O?1:0)}else{d(s[1]||s[3]),c=s[1]?3:1;const e=u.geometryState.edgeResolutions[c];l=0===O||3===O?0:e}const f=u.geometry;{const e=V+I,t=A+U,o=f.getEdgeFirstVertexIndex(c)+l,r=f.vertexAttributes,s=u.localOrigin,a=r.position,d=a.typedBuffer,m=o*a.typedBufferStride,p=d[m]+s[0]-i[0],x=d[m+1]+s[1]-i[1],M=d[m+2]+s[2]-i[2];de(p,x,M,g);const S=h.position,B=S.typedBuffer,b=e*S.typedBufferStride;B[b]=p,B[b+1]=x,B[b+2]=M;const L=t*S.typedBufferStride;B[L]=p,B[L+1]=x,B[L+2]=M;const C=h.uv0;C.setValues(e,Math.round(y*n),Math.round(v*n)),C.setValues(t,Math.round(y*n),Math.round(v*n));{const n=r.normalCompressed.typedBuffer,s=o*r.normalCompressed.typedBufferStride,i=h.normalCompressed,a=i.typedBuffer;{const t=e*i.typedBufferStride;a[t]=n[s],a[t+1]=n[s+1]}{const e=t*i.typedBufferStride;a[e]=n[s],a[e+1]=n[s+1]}}}}else{const n=K[t],r=K[a];let l;if(n||r){const t=e(k*(1-M)+z*M,Q,X),n=e(G*(1-S)+J*S,Y,Z);l=s(t,n,c)}else l=ee(oe,O);P(M,S,l),ne(O);const u=b-i[0],d=L-i[1],f=C-i[2];de(u,d,f,g),o.setEdgeVertexFromValuesRawPositionUVNormal(t,I,u,d,f,y,v,E,T,D),o.setEdgeVertexFromValuesRawPositionUVNormal(a,U,u,d,f,y,v,E,T,D)}}for(let e=0;e<4;++e)ae[e]=null}function ee(e,t){const n=4*t,o=l.reduce(((t,o)=>Math.min(t,e[n+o]?.level??1/0)),1/0);f&&(d(!e[n+0]||!e[n+2]||h(e[n+0],e[n+2],a.SOUTH_WEST)),d(!e[n+1]||!e[n+3]||h(e[n+1],e[n+3],a.NORTH_WEST)));let r=0,i=0;for(let a=0;a<4;++a){const t=e[n+a];if(t&&t.level===o){const e=0===a||1===a,n=0===a||3===a,o=t.extent,c=o[e?0:2],l=o[n?1:3],u=t.renderData?.geometryState?.samplerData;i+=s(c,l,u),r++}}const c=r?i/r:0;return d(null!=c),c}function te(e){const{vao:t,geometry:n}=e,{vertexAttributes:o,edgeVerticesStartIndex:r}=n,s=o.position.typedBuffer;t.vertexBuffers.get("geometry").setSubData(s,r,r,s.length)}function ne(e){const{vao:t,geometry:n}=e,{indices:o,indexCount:r,edgeIndicesStartIndex:s}=n;t.indexBuffer.setSubData(o,s,s,r)}class oe{constructor(e,t,n,o,r){this.isNorth=e,this.connectedRowOffset=t,this.connectedOuterEdgeOffset=n,this.rowOffset=o,this.latitudeResolution=r}}const re=[[0,1],[1,0],[0,-1],[-1,0]],se=new c,ie=r(-1/0,-1/0,1/0,1/0),ae=[null,null,null,null];function ce(e,t,n){if(!t)return!1;const o=p(e,t);return o>0||0===o&&n>=2}class le{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(e){return d(0<=e&&e<this.count),this.vertex0Index+this.stride*e}}const ue=[new le,new le,new le,new le];function de(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function fe(e){const{edgeResolutions:t,numVerticesPerSide:n}=e,o=1+Math.max(...t);return Math.max(n,o)}function me(e,t,n,o,r,s){const i=e*r,a=s[i],c=s[i+1],l=s[i+2],u=t*r,d=s[u],f=s[u+1],m=s[u+2],g=n*r,h=s[g],p=s[g+1],x=s[g+2],M=o*r,S=s[M],y=s[M+1],v=s[M+2];return(d-S)*(d-S)+(f-y)*(f-y)+(m-v)*(m-v)>(a-h)*(a-h)+(c-p)*(c-p)+(l-x)*(l-x)}function ge(e,t,n,o,r){e[t]=n,e[t+1]=o,e[t+2]=o,e[t+3]=r,e[t+4]=r,e[t+5]=n}const he=6;export{T as createPlanarGlobePatch,S as createSphericalGlobePatch,I as updateCornerSpherical,R as updateCornersPlanar,U as updateEdgeElevationsAndResolutionsPlanar,B as updateEdgeElevationsAndResolutionsSpherical,N as updateEdgesAndCornersPlanar,V as updateEdgesAndCornersSpherical};
