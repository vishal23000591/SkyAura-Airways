/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import t from"../../../../Color.js";import"../../../../core/has.js";import e from"../../../../core/Error.js";import{clone as r}from"../../../../core/lang.js";import{getMetersPerVerticalUnitForSR as o}from"../../../../core/unitUtils.js";import{e as s}from"../../../../chunks/earcut.js";import{normalFromMat4 as i}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as a,invertOrIdentity as l}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as c}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{i as m,t as p,a as h,h as g,n as d,c as u,d as f}from"../../../../chunks/vec32.js";import{fromArray as y,create as b}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{ZEROS as _}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{computeTranslationToOriginAndRotation as x}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{create as S,fromBuffer as j,intersectsClippingArea as P}from"../../../../geometry/support/aaBoundingBox.js";import{newDoubleArray as w}from"../../../../geometry/support/DoubleArray.js";import{newIndexArray as O,getZeroIndexArray as C}from"../../../../geometry/support/Indices.js";import{t as E}from"../../../../chunks/vec3.js";import{makeVertexCandidate as v,makeEdgeCandidate as I}from"../../../../layers/graphics/data/SnappingCandidate.js";import{getDriverAxisSizeValue as A}from"../../../../renderers/support/renderingInfoUtils.js";import{EmissiveSourceMode as M}from"../../../../symbols/support/materialUtils.js";import{ViewingMode as L}from"../../../ViewingMode.js";import{needsElevationUpdates3D as B,SampleElevationInfo as z}from"./elevationAlignmentUtils.js";import{Object3DEdgeState as R,Graphics3DObject3DGraphicLayer as U}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as D}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as G,computeCentroid as V}from"./graphicUtils.js";import{ApplyRendererDiffResult as T}from"./interfaces.js";import{geometryAsPolygon as N}from"./polygonUtils.js";import{createMaterial as F}from"../support/edgeUtils.js";import{debugFlags as k}from"../../support/debugFlags.js";import{SamplePosition as H}from"../../support/ElevationProvider.js";import{geometryToRenderInfo as W}from"../../support/renderInfoUtils/polygon.js";import{NormalType as q}from"../../webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{Attribute as Z}from"../../webgl-engine/lib/Attribute.js";import{CullFaceOptions as J}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as K}from"../../webgl-engine/lib/Geometry.js";import{isGeometryWithMapPositions as Q}from"../../webgl-engine/lib/GeometryWithMapPositions.js";import{compressNormals as X,compressNormal as Y}from"../../webgl-engine/lib/Normals.js";import{Object3D as $}from"../../webgl-engine/lib/Object3D.js";import{VertexAttribute as tt}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as et}from"../../webgl-engine/materials/DefaultMaterial.js";import{GeometryType as rt}from"../../webgl-engine/lib/IntersectableGeometry.js";const ot=["polygon","extent"];class st extends D{constructor(t,e,r,o){super(t,e,r,o,xt(e)),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=G(this._getSymbolSize());if(t)throw new e("graphics3dextrudesymbollayer:invalid-size",t)}const t=this.symbolLayer,r=t?.material,o=r?.color,s=this._getCombinedOpacityAndColor(o),i=y(s),n=s[3],a=this.needsDrivenTransparentPass,l=r?.emissive,c={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:i,ambient:i,opacity:n,drivenOpacity:a,hasVertexColors:!0,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:t.castShadows,emissiveStrength:l?.strength??0,emissiveSource:M.Color,offsetTransparentBackfaces:!0,normalType:q.Compressed},m=new et(c,this._context);m.setParameters({cullFace:m.transparent?J.None:J.Back});const p=new et({...c,cullFace:J.Back},this._context);this._materials[Mt.Main]=m,this._materials[Mt.Bottom]=p}destroy(){super.destroy(),this._materials.length=0}createGraphics3DGraphic(t){const e=t.graphic;if(!this._validateGeometry(e.geometry,ot,this.symbolLayer.type))return null;const r=this._getVertexOpacityAndColor(t.renderingInfo,this._getFallbackOpacityAndColor(),255),o=this.setGraphicElevationContext(e);return this._createAs3DShape(e,t.renderingInfo,r,o,e.uid)}layerOpacityChanged(t,e){const r=this.symbolLayer?.material?.color,o=this._getCombinedOpacity(r);this._materials[Mt.Main]?.setParameters({opacity:o}),this._materials[Mt.Bottom]?.setParameters({opacity:o});const s=this._getLayerOpacity();t?.forEach((t=>e(t)?.layerOpacityChanged(s,this._context.isAsync)))}layerElevationInfoChanged(t,e){return this.updateGraphics3DGraphicElevationInfo(t,e,B)}slicePlaneEnabledChanged(t,e){return this._materials[Mt.Main]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),this._materials[Mt.Bottom]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),t?.forEach((t=>{const r=e(t);null!=r&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){const t={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0};return this._materials[Mt.Main]?.setParameters(t),this._materials[Mt.Bottom]?.setParameters(t),!0}_getExtrusionSize(t){let e;return e=t.size&&this._drivenProperties.size?A(t.size,2)??0:this._getSymbolSize(),e/=this._context.renderCoordsHelper.unitInMeters,e}applyRendererDiff(t,e){return this._drivenPropertiesChanged(e)?T.RecreateSymbol:T.RecreateGraphics}async queryForSnapping(t,e,s,i){const n=this._getExtrusionSize(s)*this._context.renderCoordsHelper.unitInMeters/o(e),{objectId:a,target:l}=t,c=r(l);switch(c.z=(c.z??0)+n,t.type){case"edge":{const{start:e,end:o}=t,s=r(e),i=r(o);return s.z=(s.z??0)+n,i.z=(i.z??0)+n,[I(a,c,1/0,s,i)]}case"vertex":return[v(a,c,1/0),I(a,l,1/0,l,c)];default:return[]}}_getSymbolSize(){return this.symbolLayer.size??1}_createAs3DShape(t,e,r,o,l){const m=N(t.geometry);if(null==m)return null;if(0===m.rings.length||!m.rings.some((t=>t.length>0)))return this._logGeometryValidationWarnings(m.rings,"rings","ExtrudeSymbol3DLayer"),null;const p=W(m,this._context.elevationProvider,this._context.renderCoordsHelper,o);this._logGeometryCreationWarnings(p,m.rings,"rings","ExtrudeSymbol3DLayer");const h=V(m);if(null==h)return null;const g=new Array,d=new Array,u=S(),f=c(),y=b(),_=this._context.renderCoordsHelper.viewingMode===L.Global;_||this._context.renderCoordsHelper.worldUpAtPosition(null,y),x(m.spatialReference,[h.x,h.y,0],f,this._context.renderCoordsHelper.spatialReference);const C=c();a(C,f);const v=n();i(v,C);const{polygons:I,mapPositions:A,position:M}=p,z=new Map,D=this._materials[Mt.Main];for(const i of I){const t=i.count;if(this._context.clippingExtent&&(j(i.mapPositions,u),!P(u,this._context.clippingExtent)))continue;const o=s(i.mapPositions,i.holeIndices,3);if(0===o.length)continue;const n=o.length,a=6*t,c=O(a+n),m=O(n),p=w(3*a),h=w(3*a),b=w(3*a),x=w(a);nt(M,A,o,i,p,b,h,x,c,m,this._getExtrusionSize(e),y,_),E(p,p,C);const S=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:l,layerViewUid:this._context.layerViewUid}),v=new Lt(p,b,X(h),x),I=it(D,c,c.length-m.length,v,r,S),L=t,B=t,R=2*i.count,U=new Bt(L,B,R,n/3);_t(I,U,f),z.set(I,U),g.push(I,it(this._materials[Mt.Bottom],m,0,v,r,S)),d.push(v.heights)}if(0===g.length)return null;const G=new $({geometries:g,layerViewUid:this._context.layerViewUid,graphicUid:l,isElevationSource:!0});G.transformation=f;const T=F(this.symbolLayer,{opacity:this._getLayerOpacity()}),k=T?new R(this._materials[Mt.Main],T,this._context.slicePlaneEnabled):null,H=new U(this,G,null,((t,e,r,o,s)=>bt(t,e,r,o,s,d,z)),o,k);return H.alignedSampledElevation=p.sampledElevation,H.needsElevationUpdates=B(o.mode),H}_getFallbackOpacityAndColor(){const e=this.symbolLayer?.material?.color;return t.toUnitRGBA(e)??_}}function it(t,e,r,o,s,i){const n=C(e.length),a=[[tt.POSITION,new Z(o.positions,e,3,!0)],[tt.NORMALCOMPRESSED,new Z(o.normals,e,2,!0)],[tt.COLOR,new Z(s,n,4,!0)]];return new K(t,a,o.elevation,rt.Mesh,i,r)}function nt(t,e,r,o,s,i,n,a,l,c,m,p,h){const g=r.length/3;let d=2*o.count;at(t,e,o.index,o.count,r,0,g,s,i,n,a,l,c,d,m,p,h);let u=0,f=2*o.count;d=0;const y=o.pathLengths[0];mt(s,i,a,n,u,y,o.count,f,l,d,m),f+=4*y,d+=2*y,u+=y;for(let b=1;b<o.pathLengths.length;++b){const t=o.pathLengths[b];mt(s,i,a,n,u,t,o.count,f,l,d,m),f+=4*t,d+=2*t,u+=t}}function at(t,e,r,o,s,i,n,a,l,c,m,p,h,g,f,y,b){u(jt,y),l??=[],c??=[],m??=[];const _=f>0?1:-1;let x=3*r,S=0,j=3*S,P=o,w=3*P;for(let u=0;u<o;++u){const r=t[x],o=t[x+1],s=t[x+2];b&&(jt[0]=r,jt[1]=o,jt[2]=s,d(jt,jt)),a[j+0]=r,a[j+1]=o,a[j+2]=s;const i=e[x+0],n=e[x+1],p=e[x+2];l[j+0]=i,l[j+1]=n,l[j+2]=p,c[j+0]=-_*jt[0],c[j+1]=-_*jt[1],c[j+2]=-_*jt[2],m[S]=0,a[w+0]=r+f*jt[0],a[w+1]=o+f*jt[1],a[w+2]=s+f*jt[2],l[w+0]=i,l[w+1]=n,l[w+2]=p,m[P]=f,j+=3,w+=3,x+=3,S+=1,P+=1}x=3*i,j=0,w=3*g;const O=f<0?Ot:wt,C=f<0?wt:Ot;for(let d=0;d<n;++d)h[j]=s[x+O[0]],h[j+1]=s[x+O[1]],h[j+2]=s[x+O[2]],p[w]=s[x+C[0]]+o,p[w+1]=s[x+C[1]]+o,p[w+2]=s[x+C[2]]+o,j+=3,w+=3,x+=3}function lt(t,e,r,o,s,i,n){o[i]=o[n],n*=3,t[i*=3]=t[n],t[i+1]=t[n+1],t[i+2]=t[n+2],e[i]=e[n],e[i+1]=e[n+1],e[i+2]=e[n+2],r[i]=s[0],r[i+1]=s[1],r[i+2]=s[2]}const ct=b();function mt(t,e,r,o,s,i,n,a,l,c,m){e??=[],r??=[],o??=[];let p=s,h=s+1,g=s+n,d=s+n+1,u=a,f=a+1,y=a+2*i,b=a+2*i+1;m<0&&(p=s+n+1,d=s);let _=3*c;for(let x=0;x<i;++x)x===i-1&&(h=s,m>0?d=s+n:p=s+n),ft(t,p,h,g,ct),lt(t,e,o,r,ct,u,p),lt(t,e,o,r,ct,f,h),lt(t,e,o,r,ct,y,g),lt(t,e,o,r,ct,b,d),l[_]=u,l[_+1]=y,l[_+2]=b,l[_+3]=u,l[_+4]=b,l[_+5]=f,_+=6,p++,h++,g++,d++,u+=2,f+=2,y+=2,b+=2}const pt=b(),ht=b(),gt=b(),dt=b(),ut=b();function ft(t,e,r,o,s){e*=3,r*=3,o*=3,m(pt,t[e++],t[e++],t[e++]),m(ht,t[r++],t[r++],t[r++]),m(gt,t[o++],t[o++],t[o++]),f(dt,ht,pt),f(ut,gt,pt),g(s,ut,dt),d(s,s)}const yt=b();function bt(t,e,r,o,s,i,n){const a=t.stageObject,h=a.geometries,g=h.length,d="absolute-height"!==e.mode;let u=0;const f=a.transformation,y=l(c(),f);for(let l=0;l<g;l+=2){const t=h[l];if(!Q(t))continue;const e=t.getMutableAttribute(tt.POSITION).data,c=i[l/2],g=new H(t.mapPositions),b=e.length/3;let _=!1,x=0;{let t=0;for(let i=0;i<b;i++){yt[0]=e[t],yt[1]=e[t+1],yt[2]=e[t+2],o(g,Pt),d&&(x+=Pt.sampledElevation),k.TESTS_DISABLE_OPTIMIZATIONS?(m(St,g.array[g.offset],g.array[g.offset+1],Pt.z+c[t/3]),null!=r&&s.toRenderCoords(St,r,St),p(St,St,y)):(m(St,e[t],e[t+1],e[t+2]),p(St,St,f),s.setAltitude(St,Pt.z+c[t/3]),p(St,St,y)),e[t]=St[0],e[t+1]=St[1],e[t+2]=St[2];const i=Ct/s.unitInMeters;(Math.abs(yt[0]-e[t])>=i||Math.abs(yt[1]-e[t+1])>=i||Math.abs(yt[2]-e[t+2])>=i)&&(_=!0),g.offset+=3,t+=3}}if(_){const e=n.get(t);e&&_t(t,e,f),a.geometryVertexAttributeUpdated(h[l],tt.NORMALCOMPRESSED),t.invalidateBoundingInfo(),a.geometryVertexAttributeUpdated(h[l],tt.POSITION),h[l+1].invalidateBoundingInfo(),a.geometryVertexAttributeUpdated(h[l+1],tt.POSITION)}u+=x/b}return u/g}function _t(t,e,r){const o=t.getMutableAttribute(tt.POSITION),s=t.getMutableAttribute(tt.NORMALCOMPRESSED).data,{topVertexStart:i,topVertexCount:n,topFaceStart:a,topFaceCount:l}=e,c=o.data,u=n,f=t.attributes.get(tt.POSITION).indices,y=a+l,b=i+n,_=w(3*u);for(let m=0;m<u;++m){const t=3*m;_[t+0]=0,_[t+1]=0,_[t+2]=0}const x=Et,S=vt,j=It,P=At,O=jt;for(let w=a;w<y;++w){const t=3*w;for(let e=0;e<3;++e){const o=f[t+e];P[e]=o;const s=3*o;m(St,c[s+0],c[s+1],c[s+2]),p(x[e],St,r)}h(S,x[1],x[0]),h(j,x[2],x[0]),g(O,S,j),d(O,O);for(let e=0;e<3;++e){const t=3*(P[e]-i);_[t+0]+=O[0],_[t+1]+=O[1],_[t+2]+=O[2]}}for(let m=i;m<b;++m){const t=3*(m-i),e=_[t+0],r=_[t+1],o=_[t+2],n=Math.sqrt(e*e+r*r+o*o);Y(s,m,e/n,r/n,o/n)}}function xt(t){return 1===(t.material?.color?.a??1)}const St=b(),jt=b(),Pt=new z,wt=[0,2,1],Ot=[0,1,2],Ct=.01,Et=[b(),b(),b()],vt=b(),It=b(),At=[0,0,0];var Mt;!function(t){t[t.Main=0]="Main",t[t.Bottom=1]="Bottom"}(Mt||(Mt={}));class Lt{constructor(t,e,r,o){this.positions=t,this.elevation=e,this.normals=r,this.heights=o}}class Bt{constructor(t,e,r,o){this.topVertexStart=t,this.topVertexCount=e,this.topFaceStart=r,this.topFaceCount=o}}export{st as Graphics3DExtrudeSymbolLayer,nt as extrudePolygon};
