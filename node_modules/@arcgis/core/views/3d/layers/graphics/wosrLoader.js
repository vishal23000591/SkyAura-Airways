/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{result as t}from"../../../../core/asyncUtils.js";import r from"../../../../core/Error.js";import n from"../../../../core/Logger.js";import{estimateNestedObjectMemory as s}from"../../../../core/memoryEstimations.js";import{NestedMap as o}from"../../../../core/NestedMap.js";import{throwIfAbortError as a}from"../../../../core/promiseUtils.js";import{Version as i}from"../../../../core/Version.js";import{fromArray as l}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{empty as u,expandWithVec3 as c}from"../../../../geometry/support/aaBoundingBox.js";import{getContinuousIndexArray as m}from"../../../../geometry/support/Indices.js";import{requestImage as p}from"../../../../support/requestImageUtils.js";import{Attribute as f}from"../../webgl-engine/lib/Attribute.js";import{CullFaceOptions as d,AlphaDiscardMode as g}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as y}from"../../webgl-engine/lib/Geometry.js";import{Texture as w}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as b}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as x}from"../../webgl-engine/materials/DefaultMaterial.js";import{TextureWrapMode as h}from"../../../webgl/enums.js";const v=()=>n.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class j{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}async function A(e,t){const r=await I(e,t),n=await T(r.textureDefinitions??{},t);let o=0;for(const s in n)if(n.hasOwnProperty(s)){const e=n[s];o+=e?.image?e.image.width*e.image.height*4:0}return new j(r,n,o+s(r))}async function I(r,n){const s=n?.streamDataRequester;if(s)return P(r,s,n);const o=await t(e(r,n));if(!0===o.ok)return o.value.data;a(o.error),M(o.error)}async function P(e,r,n){const s=await t(r.request(e,"json",n));if(!0===s.ok)return s.value;a(s.error),M(s.error.details.url)}function M(e){throw new r("",`Request for object resource failed: ${e}`)}function E(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(v().warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(v().warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(v().warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(v().warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else v().warn("Indexed geometries must specify faces"),n=!1;break}default:v().warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(v().warn("Geometry requires material"),n=!1);const s=e.params.vertexAttributes;for(const o in s){s[o].values||(v().warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function U(e,t){const r=new Array,n=new Array,s=new Array,a=new o,u=e.resource,c=i.parse(u.version||"1.0","wosr");R.validate(c);const p=u.model.name,g=u.model.geometries,h=u.materialDefinitions??{},v=e.textures;let j=0;const A=new Map;for(let o=0;o<g.length;o++){const e=g[o];if(!E(e))continue;const i=q(e),u=e.params.vertexAttributes,c=[],p=t=>{if("PerAttributeArray"===e.params.topology)return null;const r=e.params.faces;for(const e in r)if(e===t)return r[e].values;return null},I=u[b.POSITION],P=I.values.length/I.valuesPerElement;for(const t in u){const e=u[t],r=e.values,n=p(t)??m(P);c.push([t,new f(r,n,e.valuesPerElement,!0)])}const M=i.texture,U=v&&v[M];if(U&&!A.has(M)){const{image:e,parameters:t}=U,r=new w(e,t);n.push(r),A.set(M,r)}const O=A.get(M),T=O?O.id:void 0,R=i.material;let B=a.get(R,M);if(null==B){const e=h[R.slice(R.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=U?k(U.alphaChannelUsage):void 0,n={ambient:l(e.diffuse),diffuse:l(e.diffuse),opacity:1-(e.transparency||0),textureAlphaMode:r,textureAlphaCutoff:.33,textureId:T,doubleSided:!0,cullFace:d.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:U?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(n,t.materialParameters),B=new x(n,t),a.set(R,M,B)}s.push(B);const C=new y(B,c);j+=c.find((e=>e[0]===b.POSITION))?.[1]?.indices.length??0,r.push(C)}return{engineResources:[{name:p,stageResources:{textures:n,materials:s,geometries:r},pivotOffset:u.model.pivotOffset,numberOfVertices:j,lodThreshold:null}],referenceBoundingBox:O(r)}}function O(e){const t=u();return e.forEach((e=>{const r=e.boundingInfo;null!=r&&(c(t,r.bbMin),c(t,r.bbMax))})),t}async function T(e,t){const r=new Array;for(const o in e){const n=e[o],s=n.images[0].data;if(!s){v().warn("Externally referenced texture data is not yet supported");continue}const a=n.encoding+";base64,"+s,i="/textureDefinitions/"+o,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",u={noUnpackFlip:!0,wrap:{s:h.REPEAT,t:h.REPEAT},preMultiplyAlpha:k(l)!==g.Opaque},c=t?.disableTextures?Promise.resolve(null):p(a,t);r.push(c.then((e=>({refId:i,image:e,parameters:u,alphaChannelUsage:l}))))}const n=await Promise.all(r),s={};for(const o of n)s[o.refId]=o;return s}function k(e){switch(e){case"mask":return g.Mask;case"maskAndTransparency":return g.MaskBlend;case"none":return g.Opaque;default:return g.Blend}}function q(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const R=new i(1,2,"wosr");export{j as LoaderResultWOSR,T as createTextureResources,A as load,U as processLoadResult};
