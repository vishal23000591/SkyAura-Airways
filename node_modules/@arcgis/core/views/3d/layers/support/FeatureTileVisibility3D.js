/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{n as t,c as r,a as n,e,b as s,i as o,F as i,h as u,f as c,g as f,H as a}from"../../../../chunks/vec32.js";import{create as h,fromValues as l,freeze as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as d}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBuffer as _}from"../../../../geometry/projection/projectBuffer.js";import{projectVec3Array as g}from"../../../../geometry/projection/projectVec3Array.js";import{PlaneIndex as b}from"../../../../geometry/support/frustum.js";import{fromValues as F,signedDistance as M}from"../../../../geometry/support/plane.js";import{ViewingMode as R}from"../../../ViewingMode.js";import{Frustum as S}from"../../state/Frustum.js";class j{constructor(t,r){this._renderCoordsHelper=t,this.opaqueGround=r,this._cache=new Map,this._cameraForward=h(),this._cameraEye=h(),this._cameraFovY=55*Math.PI/180,this._frustumBoundingSphereCenter=h(),this._frustumBoundingSphereRadius=0,this._frustum=new S(t),this._renderSR=t.spatialReference;const n=d(this._renderSR);this._renderSREllipsoidRadius=p(n).radius}setup(n){this._aboveGround=n.aboveGround,this._frustum.update(n),t(this._cameraForward,n.viewForward),r(this._cameraEye,n.eye),this._cameraFovY=n.fovY,this._updateFrustumBoundingSphere()}done(){this._cache.clear()}compute(t){if(this._cache.has(t.id))return this._cache.get(t.id);const r=this._isVisibleInFrustum(t);return this._cache.set(t.id,r),r}_isVisibleInFrustum(t){return this._renderCoordsHelper.viewingMode===R.Local?this._isTileVisibleInFrustumLocal(t):this._isTileVisibleInFrustumGlobal(t)}_updateFrustumBoundingSphere(){const r=this._frustum,o=r.origin,i=W;t(i,r.direction);const u=r.points,c=z;n(c,u[4],o);const f=.5*e(c,c)/e(i,c),a=this._frustumBoundingSphereCenter;s(a,o,i,f);const h=1+f;this._frustumBoundingSphereRadius=h}_isTileVisibleInFrustumLocal(t){const r=t.spatialReference,u=t.extent,c=this._renderSR;if(C[0]=u[0],C[1]=u[1],C[2]=0,C[3]=u[2],C[4]=u[3],C[5]=0,!_(C,r,0,C,c,0))return!1;o(P[0],C[0],C[1],0),o(P[1],C[3],C[1],0),o(P[2],C[3],C[4],0),o(P[3],C[0],C[4],0),o(k,.5*(C[0]+C[3]),.5*(C[1]+C[4]),.5*(C[2]+C[5]));const f=jt,a=.5*i(P[0],P[2]),h=this._frustum,l=this._frustumBoundingSphereRadius,m=this._frustumBoundingSphereCenter,p=J;n(p,m,k);const d=e(f,p),g=D;s(g,k,f,d);if(i(g,m)>a+l)return!1;const b=this._cameraForward,F=e(b,jt),M=this._cameraFovY,R=this._cameraEye;if(Math.abs(F)<Math.abs(Math.cos(.5*M))){let t=!0;const r=o(vt,b[0],b[1],0),n=e(R,r);for(let s=0;s<4;++s){const o=P[s];if(e(o,r)-n>0){t=!1;break}}if(t)return!1}{const t=P[0],r=P[2];if(t[0]<=R[0]&&R[0]<=r[0]&&t[1]<=R[1]&&R[1]<=r[1])return!0}const S=E,j=this.opaqueGround&&this._aboveGround,v=this.opaqueGround&&!this._aboveGround,G=Math.min(v?Ft:1/0,d+l),B=Math.max(j?-430:-1/0,d-l);for(let n=0;n<4;++n)s(S[n],P[n],f,G),s(S[n+4],P[n],f,B);if(I(h.planes,S,8))return!1;if(T(h.planes,S,8))return!0;for(let n=0;n<4;++n){const t=S[n],r=S[n+4];if(Gt(h.planes,t,r))return!0;const e=S[(n+1)%4];if(Gt(h.planes,t,e))return!0;const s=S[4+(n+1)%4];if(Gt(h.planes,r,s))return!0}if(wt[0][3]=+P[0][0],wt[1][3]=-P[2][0],wt[2][3]=+P[0][1],wt[3][3]=-P[2][1],wt[4][3]=+B,wt[5][3]=-G,T(wt,h.points))return!0;if(T(wt,h.points))return!0;for(let n=0;n<4;++n){const t=R,r=h.points[n+4];if(Bt(wt,t,r))return!0;const e=h.points[4+(n+1)%4];if(Bt(wt,r,e))return!0}return!1}_isTileVisibleInFrustumGlobal(r){if(r.level<V)return!0;const l=r.spatialReference,m=r.extent,p=this.opaqueGround&&this._aboveGround,d=this.opaqueGround&&!this._aboveGround,_=P,b=.5*(m[0]+m[2]);if(o(_[0],m[0],m[1],0),o(_[1],m[2],m[1],0),o(_[2],m[2],m[3],0),o(_[3],m[0],m[3],0),o(_[4],b,m[1],0),o(_[5],b,m[3],0),!g(_,l,0,_,this._renderSR,0,6))return!1;const F=_[0][2]>0,R=_[3][2]<0,S=F||R,j=this._renderSREllipsoidRadius;if(S){const t=L;v(t,It,_[0]);const r=Y;if(v(r,It,_[1]),F){const n=H,e=_[4],s=O;v(s,e,It),v(n,s,e);const o=_[0];u(o,t,n),B(o,j);const i=_[1];u(i,r,n),B(i,j)}else if(R){const n=H,e=_[5],s=O;v(s,e,It),v(n,e,s);const o=_[3];u(o,n,t),B(o,j);const i=_[2];u(i,n,r),B(i,j)}}const y=k,w=n(Z,_[3],_[0]);t(w,w);const T=c($,_[0],_[3]);f(T,T,.5);const q=-e(T,w),E=c(tt,_[0],_[1]);f(E,E,.5);const C=c(rt,_[2],_[3]);f(C,C,.5);const W=n(nt,C,E);t(W,W);const z=-(q+e(w,E))/e(w,W);s(y,E,W,z),B(y,j);const D=this._frustumBoundingSphereRadius,J=this._frustumBoundingSphereCenter,ut=this._frustum,dt=ut.planes,_t=A;t(_t,y);const gt=e(_[0],_t)/a(_[0]),jt=ut.origin,vt=ut.points;let Gt=!1;if(p){{Gt=!0;const r=t(Mt,jt);for(let s=0;s<4;++s){const o=vt[4+s],i=n(h(),o,jt);t(i,i);const c=u(h(),r,i);t(c,c);const f=u(h(),i,c);t(f,f);if(e(jt,f)>j){Gt=!1;break}}}if(Gt){if(e(jt,_t)<j*gt-Ft)return!1}const r=t(Mt,ut.origin);if(e(r,_t)<0)return!1;{const r=t(Rt,ut.direction);if(e(r,_t)>St)return!1}}const Bt=Math.sqrt(1-gt*gt);if(Bt>.9)return!0;let yt=!1;const wt=e(_t,J),Tt=a(J);if(Tt<=D&&!dt.some((t=>M(t,K)>0))){if(!p)return!0;yt=!0}const Vt=wt/Tt;if(!yt&&wt<=0){if(-wt>D)return!1}const qt=D/Tt;if(Math.sqrt(1-Vt*Vt)*Math.sqrt(1-qt*qt)-qt*Vt>Bt)return!1;if(!Gt){if(_.some((t=>ut.intersectsPoint(t))))return!0;if(ut.intersectsPoint(y))return!0}const xt=N;n(xt,J,K);const Et=e(xt,_t),Ct=U;f(Ct,_t,Et);const Pt=i(Ct,J),kt=l.isWGS84,Ht=r.lij,Lt=kt&&Ht[2]===2**Ht[0]-1,Yt=kt&&0===Ht[2],Ot=Yt?lt:Lt?at:ct,At=Yt?mt:Lt?ht:ft;if(!yt){const t=_,r=pt,n=et,e=st,s=K;for(const o of Ot){const i=t[o];if(G(n,t[(o+1)%4],i),G(e,s,i),v(r,e,n),x(r,vt,1))return!1}}let Ut=null;if(!p&&Et<1.01*D){const t=2.5*D;if(Pt>gt*t+D)return!1;const r=X,n=t/gt;for(let e=0;e<4;++e)f(r[e],_[e],n/j);o(r[4],0,0,0),Ut=r}else{const t=(d?j+Ft:Et+D)/gt,r=p?j-Ft:(Et-D)/gt,n=Q;for(let e=0;e<4;++e){const s=_[e];f(n[e],s,r/j),f(n[e+4],s,t/j)}Ut=n}if(I(dt,Ut,Ut.length))return!1;const Wt=ut.lines,zt=ot,Dt=it;for(const e of Wt){t(Dt,e.direction);for(const r of At){const e=Ut[r];if(t(zt,e),bt(Dt,zt,Ut,vt))return!1;const s=(r+1)%4;if(p){const r=Ut[s];if(n(zt,r,e),t(zt,zt),bt(Dt,zt,Ut,vt))return!1}if(d){const e=Ut[4+r],o=Ut[4+s];if(n(zt,o,e),t(zt,zt),bt(Dt,zt,Ut,vt))return!1}}}return!0}}function v(r,n,e){return u(r,n,e),t(r,r),r}function G(r,e,s){return n(r,e,s),t(r,r),r}function B(t,r){return f(t,t,r/a(t)),t}const y=[b.LEFT,b.RIGHT,b.BOTTOM,b.TOP,b.FAR];function w(t,r,n){for(let e=0;e<n;++e)if(M(t,r[e])<=0)return!1;return!0}function I(t,r,n){for(const e of y)if(w(t[e],r,n))return!0;return!1}function T(t,r,n=r.length){for(let e=0;e<n;++e){const n=r[e];let s=!0;for(const r of t){if(M(r,n)>0){s=!1;break}}if(s)return!0}return!1}const V=2,q=4;function x(t,r,n){for(const s of r)if(e(s,t)<n)return!1;return!0}const E=[h(),h(),h(),h(),h(),h(),h(),h()],C=[0,0,0,0,0,0],P=[h(),h(),h(),h(),h(),h()],k=h(),H=h(),L=h(),Y=h(),O=h(),A=h(),U=h(),W=h(),z=h(),D=h(),J=h(),K=m(0,0,0),N=h(),Q=[h(),h(),h(),h(),h(),h(),h(),h()],X=[h(),h(),h(),h(),h()],Z=h(),$=h(),tt=h(),rt=h(),nt=h(),et=h(),st=h(),ot=h(),it=h(),ut=h(),ct=[0,1,2,3],ft=[0,1,2,3],at=[0,1,3],ht=[0,1,3],lt=[1,2,3],mt=[1,2,3],pt=h();function dt(t,r,n){let s=1/0,o=-1/0;for(const i of n){const t=e(r,i);s=Math.min(s,t),o=Math.max(o,t)}t[0]=s,t[1]=o}function _t(t,r,n,s){let o=1/0,i=-1/0;for(const u of s){const s=e(n,u);if(o=Math.min(o,s),i=Math.max(i,s),o<=r&&i>=t)return!1}return!0}const gt=[0,0];function bt(t,r,n,e){const s=n.length,o=e.length;if(0===s||0===o)return!0;const i=ut;v(i,t,r);const u=o<s,c=u?n:e,f=gt;return dt(f,i,u?e:n),_t(f[0],f[1],i,c)}const Ft=430,Mt=h(),Rt=h(),St=Math.cos(.25*Math.PI),jt=l(0,0,1),vt=h();function Gt(t,r,n){const e={t0:0,t1:1};for(const s of y){if(!yt(t[s],r,n,e))return!1}return e.t0<e.t1}function Bt(t,r,n){const e={t0:0,t1:1};for(const s of t){if(!yt(s,r,n,e))return!1}return e.t0<e.t1}function yt(t,r,n,e){let{t0:s,t1:o}=e;const i=M(t,r),u=M(t,n);if(i>=0&&u>=0)return!1;if(i<0&&u>=0){const t=-i/(u-i);if(t<s)return!1;t<o&&(o=t)}else if(i>=0&&u<0){const t=i/(i-u);if(t>o)return!1;t>s&&(s=t)}return e.t0=s,e.t1=o,!0}const wt=[F(-1,0,0,1),F(1,0,0,-1),F(0,-1,0,1),F(0,1,0,-1),F(0,0,-1,1),F(0,0,1,-1)],It=m(0,0,1);export{j as FeatureTileVisibility3D,T as isAnyVertexInPolyhedron,I as isConvexHullOutsideOfFrustum,q as maxLODLevelDelta,V as minTileLOD};
