/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{fromMat4 as t}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as o}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{identity as i,copy as n,set as s,multiply as r,scale as l,translate as a,rotateZ as f,rotateX as c,rotateY as u}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{i as d,c as m}from"../../../../chunks/vec32.js";import{ones as z,zeros as v,create as h}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{c as S}from"../../../../chunks/vec42.js";import{ones as y}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{meterIn as b}from"../../../../renderers/support/lengthUtils.js";import{isString as x,isStringOrNull as g,isNumber as C}from"../../../../support/guards.js";import{debugFlags as k}from"../../support/debugFlags.js";import{olidEnabled as D}from"../../webgl-engine/effects/geometry/olidUtils.js";import{NoParameters as w}from"../../../webgl/NoParameters.js";var U,j;!function(e){e[e.Undefined=0]="Undefined",e[e.DefinedSize=1]="DefinedSize",e[e.DefinedScale=2]="DefinedScale"}(U||(U={})),function(e){e[e.Undefined=0]="Undefined",e[e.DefinedAngle=1]="DefinedAngle"}(j||(j={}));class V{constructor(e){this.field=e}}class M extends V{constructor(e){super(e),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[U.Undefined,U.Undefined,U.Undefined],this.fallback=[0,0,0]}}class I extends V{constructor(e){super(e),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0],this.fallback=[0,0,0,0]}}class A extends V{constructor(e,t=0){super(e),this.fallback=t,this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}}class N extends V{constructor(e){super(e),this.offset=[0,0,0],this.factor=[1,1,1],this.type=[0,0,0]}}class P{}function T(e){return null!=e}function F(e,t){e&&e.push(t)}function R(e,t,o,i=p()){const n=e||0,s=t||0,r=o||0;return 0!==n&&f(i,i,-n/180*Math.PI),0!==s&&c(i,i,s/180*Math.PI),0!==r&&u(i,i,r/180*Math.PI),i}function E(e,t,o,i,n){const s=e.minSize,r=e.maxSize;if(e.useSymbolValue){const e=i.symbolSize[o];return t.minSize[o]=e,t.maxSize[o]=e,t.offset[o]=t.minSize[o],t.factor[o]=0,t.type[o]=U.DefinedSize,!0}if(T(e.field))return T(e.stops)?2===e.stops.length&&C(e.stops[0].size)&&C(e.stops[1].size)?(_(e.stops[0].size,e.stops[1].size,e.stops[0].value,e.stops[1].value,t,o),t.type[o]=U.DefinedSize,!0):(F(n,"Could not convert size info: stops only supported with 2 elements"),!1):C(s)&&C(r)&&T(e.minDataValue)&&T(e.maxDataValue)?(_(s,r,e.minDataValue,e.maxDataValue,t,o),t.type[o]=U.DefinedSize,!0):"unknown"===e.valueUnit?(F(n,"Could not convert size info: proportional size not supported"),!1):null!=b[e.valueUnit]?(t.minSize[o]=-1/0,t.maxSize[o]=1/0,t.offset[o]=0,t.factor[o]=1/b[e.valueUnit],t.type[o]=U.DefinedSize,!0):(F(n,"Could not convert size info: scale-dependent size not supported"),!1);if(!T(e.field)){if(e.stops?.[0]&&C(e.stops[0].size))return t.minSize[o]=e.stops[0].size,t.maxSize[o]=e.stops[0].size,t.offset[o]=t.minSize[o],t.factor[o]=0,t.type[o]=U.DefinedSize,!0;if(C(s))return t.minSize[o]=s,t.maxSize[o]=s,t.offset[o]=s,t.factor[o]=0,t.type[o]=U.DefinedSize,!0}return F(n,"Could not convert size info: unsupported variant of sizeInfo"),!1}function _(e,t,o,i,n,s){const r=Math.abs(i-o)>0?(t-e)/(i-o):0;n.minSize[s]=r>0?e:t,n.maxSize[s]=r>0?t:e,n.offset[s]=e-o*r,n.factor[s]=r}function q(e,t,o,i){if(e.normalizationField||e.valueRepresentation)return F(i,"Could not convert size info: unsupported property"),null;if(!g(e.field))return F(i,"Could not convert size info: field is not a string"),null;if(t.size){if(e.field)if(t.size.field){if(e.field!==t.size.field)return F(i,"Could not convert size info: multiple fields in use"),null}else t.size.field=e.field}else t.size=new M(e.field),m(t.size.fallback,o.fallbackSize);let n;switch(e.axis){case"width":return n=E(e,t.size,0,o,i),n?t:null;case"height":return n=E(e,t.size,2,o,i),n?t:null;case"depth":return n=E(e,t.size,1,o,i),n?t:null;case"width-and-depth":return n=E(e,t.size,0,o,i),n&&E(e,t.size,1,o,i),n?t:null;case null:case void 0:case"all":return n=E(e,t.size,0,o,i),n=n&&E(e,t.size,1,o,i),n=n&&E(e,t.size,2,o,i),n?t:null;default:return F(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}function $(e,t,o){for(let n=0;n<3;++n){let o=t.unitInMeters;e.type[n]===U.DefinedSize&&(o*=t.modelSize[n],e.type[n]=U.DefinedScale),e.minSize[n]=e.minSize[n]/o,e.maxSize[n]=e.maxSize[n]/o,e.offset[n]=e.offset[n]/o,e.factor[n]=e.factor[n]/o}let i;if(e.type[0]!==U.Undefined)i=0;else if(e.type[1]!==U.Undefined)i=1;else{if(e.type[2]===U.Undefined)return F(o,"No size axis contains a valid size or scale"),!1;i=2}for(let n=0;n<3;++n)e.type[n]===U.Undefined&&(e.minSize[n]=e.minSize[i],e.maxSize[n]=e.maxSize[i],e.offset[n]=e.offset[i],e.factor[n]=e.factor[i],e.type[n]=e.type[i]);return!0}function B(e,t,o){e[4*t]=o.r/255,e[4*t+1]=o.g/255,e[4*t+2]=o.b/255,e[4*t+3]=o.a}function L(e,t,o,i){if(e.normalizationField)return F(i,"Could not convert color info: unsupported property"),null;if(x(e.field)){if(!e.stops)return F(i,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return F(i,"Could not convert color info: too many color stops"),null;t.color=new I(e.field);const n=e.stops;for(let e=0;e<8;++e){const o=n[Math.min(e,n.length-1)];t.color.values[e]=o.value,B(t.color.colors,e,o.color)}S(t.color.fallback,o.fallbackColor)}}else{if(!(e.stops&&e.stops.length>=0))return F(i,"Could not convert color info: no field and no colors/stops"),null;{const i=e.stops&&e.stops.length>=0&&e.stops[0].color;t.color=new I(null);for(let e=0;e<8;e++)t.color.values[e]=1/0,B(t.color.colors,e,i);S(t.color.fallback,o.fallbackColor)}}return t}function O(e,t,o,i){if(e.normalizationField)return F(i,"Could not convert opacity info: unsupported property"),null;if(x(e.field)){if(!e.stops)return F(i,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return F(i,"Could not convert opacity info: too many opacity stops"),null;t.opacity=new A(e.field,o.fallbackColor[3]);const n=e.stops;for(let e=0;e<8;++e){const o=n[Math.min(e,n.length-1)];t.opacity.values[e]=o.value,t.opacity.opacityValues[e]=o.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return F(i,"Could not convert opacity info: no field and no opacities/stops"),null;{const i=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;t.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0],fallback:o.fallbackColor[3]};for(let e=0;e<8;e++)t.opacity.values[e]=1/0,t.opacity.opacityValues[e]=i}}return t}function G(e,t,o){const i=2===o&&"arithmetic"===e.rotationType;t.offset[o]=i?90:0,t.factor[o]=i?-1:1,t.type[o]=1}function H(e,t,o){if(!x(e.field))return F(o,"Could not convert rotation info: field is not a string"),null;if(t.rotation){if(e.field)if(t.rotation.field){if(e.field!==t.rotation.field)return F(o,"Could not convert rotation info: multiple fields in use"),null}else t.rotation.field=e.field}else t.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return G(e,t.rotation,0),t;case"roll":return G(e,t.rotation,1),t;case null:case void 0:case"heading":return G(e,t.rotation,2),t;default:return F(o,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}class J{constructor({supports:e,modelSize:t,symbolSize:o,unitInMeters:i,anchor:n,scale:s,rotation:r,fallbackColor:l,fallbackSize:a}){this.supports=e,this.modelSize=t??z(),this.symbolSize=o??z(),this.unitInMeters=i??1,this.anchor=n??v(),this.scale=s??z(),this.rotation=r??v(),this.fallbackColor=l??y(),this.fallbackSize=a??z()}}function K(e,t,o){if(!e)return null;const i=e.reduce(((e,i)=>{if(!e)return e;if(i.valueExpression)return F(o,"Could not convert visual variables: arcade expressions not supported"),null;switch(i.type){case"size":return t.supports.size?q(i,e,t,o):e;case"color":return t.supports.color?L(i,e,t,o):e;case"opacity":return t.supports.opacity?O(i,e,t,o):null;case"rotation":return t.supports.rotation?H(i,e,o):e;default:return null}}),new P);return!(e.length>0&&i)||i.size||i.color||i.opacity||i.rotation?i?.size&&!$(i.size,t,o)?null:i:null}class Q{constructor(e,t,o){this.visualVariables=e,this.materialParameters=t,this.requiresShaderTransformation=o}}function W(e,t){if(!e)return null;if(D())return null;if(k.TESTS_DISABLE_FAST_UPDATES)return null;const o=K(e.visualVariables,t);return o?new Q(o,ee(o,t),!!o.size):null}function X(e,t,o){if(!t||!e)return!1;const i=e.visualVariables,n=K(t.visualVariables,o);return!!n&&(!!(Y(i.size,n.size,"size")&&Y(i.color,n.color,"color")&&Y(i.rotation,n.rotation,"rotation")&&Y(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=ee(n,o),e.requiresShaderTransformation=!!n.size,!0))}function Y(e,t,o){if(!!e!=!!t)return!1;if(e&&e.field!==t?.field)return!1;if(e&&"rotation"===o){const o=e,i=t;for(let e=0;e<3;e++)if(o.type[e]!==i.type[e]||o.offset[e]!==i.offset[e]||o.factor[e]!==i.factor[e])return!1}return!0}class Z extends w{constructor(e){super(),this.vvSize=e?.size??null,this.vvColor=e?.color??null,this.vvOpacity=e?.opacity??null}}function ee(e,n){const s=new Z(e);return s.vvSize&&(s.vvSymbolAnchor=n.anchor,i(re),R(n.rotation[2],n.rotation[0],n.rotation[1],re),s.vvSymbolRotationMatrix=s.vvSymbolRotationMatrix||o(),t(s.vvSymbolRotationMatrix,re)),s}function te(e,t,o){if(!e.vvSize)return o;n(ne,o);const i=e.vvSymbolRotationMatrix;return s(re,i[0],i[1],i[2],0,i[3],i[4],i[5],0,i[6],i[7],i[8],0,0,0,0,1),r(ne,ne,re),oe(se,e,t),l(ne,ne,se),a(ne,ne,e.vvSymbolAnchor),ne}function oe(t,o,i){if(!o.vvSize)return d(t,1,1,1),t;if(Number.isNaN(i[0]))return m(t,o.vvSize.fallback);for(let n=0;n<3;++n){const s=o.vvSize.offset[n]+i[0]*o.vvSize.factor[n];t[n]=e(s,o.vvSize.minSize[n],o.vvSize.maxSize[n])}return t}function ie(e,t){const o=null==e?0:t.attributes[e];return"number"==typeof o&&isFinite(o)?o:NaN}const ne=p(),se=h(),re=p();export{J as ConvertOptions,I as FastColorInfo,A as FastOpacityInfo,N as FastRotationInfo,j as FastRotationType,M as FastSizeInfo,U as FastSizeType,Q as FastSymbolUpdatesState,P as FastVisualVariables,Z as VisualVariablesParameters,K as convertVisualVariables,te as evaluateModelTransform,oe as evaluateModelTransformScale,ie as getAttributeValue,ee as getMaterialParameters,W as initFastSymbolUpdatesState,X as updateFastSymbolUpdatesState};
