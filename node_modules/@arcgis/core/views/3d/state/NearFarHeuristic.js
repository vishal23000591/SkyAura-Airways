/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{acosClamped as e,lerp as t,clamp as i}from"../../../core/mathUtils.js";import{getMetersPerUnitForSR as r}from"../../../core/unitUtils.js";import{l as s,n,g as a,e as o,d as m}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as l}from"../../../geometry/ellipsoidUtils.js";import c from"../../../geometry/Extent.js";import{create as f,fromValues as x}from"../../../geometry/support/ray.js";import{b as p,c as u,i as M}from"../../../chunks/sphere.js";import{ViewingMode as d}from"../../ViewingMode.js";import{computeInnerAltitudeFade as _}from"../environment/atmosphereUtils.js";import{DepthRange as y}from"../webgl-engine/lib/DepthRange.js";function v(e,t,i){return e===d.Global?new E(t,i):new g(t,i)}class g{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=l(t),this._unitInMeters=r(t,this._referenceEllipsoid.metersPerDegree)}compute(e,r,s,a){const{eye:h,center:l}=e;let f=h[2]*this._unitInMeters;const x=f,p=f-a,u=this._elevationProvider?.visibleElevationBounds;u&&(f=p>=0?x-this._unitInMeters*u.min:this._unitInMeters*u.max-x),r??=new c({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0});const M={x:r.xmax-r.xmin,y:r.ymax-r.ymin,z:4*Math.max(r.xmax-r.xmin,r.ymax-r.ymin)},d=Math.max(M.x,M.y,M.z);m(B,l,h),q[0]=B[0]>0?r.xmax:r.xmin,q[1]=B[1]>0?r.ymax:r.ymin,q[2]=B[2]>0?d/2:-d/2,m(q,q,h),n(B,B);const _=1.1*o(q,B)*this._unitInMeters,y=Math.sqrt(f*(f+2*this._referenceEllipsoid.radius)),v=Math.max(r.xmax-r.xmin,r.ymax-r.ymin),g=v*z*this._unitInMeters,E=v*k*this._unitInMeters,b=i((f-E)/(g-E),0,1)**3,I=Math.min(t(y,_,b),y)*Math.max(Math.log(Math.abs(p)),1);return j(Math.min(I,Math.max(34064e4,d))/this._unitInMeters,w,this._unitInMeters,D)}}class E{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=l(t)}compute(r,h,l,c){const{eye:f}=r,u=s(f),d=u-this._referenceEllipsoid.radius,v=this._referenceEllipsoid.radius+Math.min(0,c),g=Math.abs(d-c),E=Math.max(g,Math.abs(d)),z=this._elevationProvider?.visibleElevationBounds.max??0,k=_(E),H=Math.sqrt(E*(E+2*v)),R=u+this._referenceEllipsoid.radius,V=1.2*t(H,R,k),Y=(Math.log(E)-b)/(I-b);j(V,i(w-Y*(w-P),P,w),1,D);const A=this._referenceEllipsoid.radius+z,C=this._referenceEllipsoid.radius+this._referenceEllipsoid.atmosphereHeight,J=Math.max(A,C),K=u-J;if(k>0&&K>U){const i=n(q,a(q,r.eye,-1)),h=n(B,r.viewForward),c=e(o(i,h)),f=.5*r.fovY,u=Math.cos(f);let d=y.infinite.near;if(c<=f)d=K*u;else{const e=n(q,r.viewUp),t=Math.tan(f),i=a(q,e,t),o=n(q,m(q,h,i)),l=x(r.eye,o,G),c=p(F,J);if(M(c,l,q)){const e=m(q,q,r.eye);d=s(e)*u}}const _=.99*Math.min(l.near,d);if(_<y.infinite.near&&_>D.near){const e=t(D.near,_,k);D.near=e}}return D}}function j(e,t,i,r){const s=U/i,n=e/t;return n>s?(r.far=e,r.near=n):(r.near=s,r.far=r.near*t),r}const b=7.983,I=16.994,w=2e4,P=100,U=2,z=.001,k=1e-4,q=h(),B=h(),D={near:0,far:0},F=u(),G=f();export{v as createNearFarHeuristic,U as minNearDistanceInMeters};
