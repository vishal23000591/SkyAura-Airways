/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{clamp as i}from"../../../../core/mathUtils.js";import{createScreenPointArray as r}from"../../../../core/screenUtils.js";import"../../../../core/Logger.js";import"../../../../core/has.js";import"../../../../core/RandomLCG.js";import"../../../../core/Error.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{copy as e,distance as a}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{n as o,d as h,l as c,e as m,g as p,f as l}from"../../../../chunks/vec32.js";import{create as _}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as u}from"../../../../geometry/ellipsoidUtils.js";import{create as P,fromPoints as C}from"../../../../geometry/support/axisAngle.js";import{c as d,a as y}from"../../../../chunks/sphere.js";import{pixelDistanceToInteractionFactor as f,applyAll as g}from"../../camera/constraintUtils.js";import{ConstraintOptions as v}from"../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as R}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as j}from"../../camera/constraintUtils/InteractionType.js";import{applySurfaceCollisionConstraint as k}from"../../camera/constraintUtils/surfaceCollision.js";import{InteractiveController as w}from"./InteractiveController.js";import{NavigationMode as D,normalizeCoordinate as A,pickPointAndInitSphere as b,excludeTerrain as M,SpherePickPointFallback as O,navigationMode as U,distanceClampValues as x,pivotDistanceModifier as z,screenPixelArea as H,sphereOrPlanePointFromScreenPoint as L,applyRotation as I}from"../utils/navigationUtils.js";import{fromScreenAtEye as S}from"../../support/geometryUtils/ray.js";let B=class extends w{constructor(){super(...arguments),this._pickPoint=_(),this._tmpP0=n(),this._panAxisAngle=P(),this._tmpRayDir=_(),this._tmpRayDirPick=_(),this._targetOnSphere=_(),this._navMode=D.Horizontal,this._tmpRay={origin:_(),direction:_()},this.dragBeginPoint=r(),this._normalizedAnchorPoint=n(),this._constraintOptions=new v(R.ALL_EXCEPT_COLLISION,j.ZOOM,0,this.startCamera),this._sphere=d(),this._hasPickPoint=!1}get _intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.running)return;e(this.dragBeginPoint,t),A(this.startCamera,t,this._normalizedAnchorPoint);const r=u(this.view.spatialReference),s=b(this._intersectionHelper,this.startCamera,t,r.radius,O.Ellipsoid,this.view.basemapTerrain.invisible?M:{});if(this._navMode=U(this.startCamera,t,this.view.renderCoordsHelper,this.view.viewingMode),this._navMode===D.Horizontal)this._hasPickPoint=!!s.scenePickPoint,this._pickPoint=s.scenePickPoint??this._pickPoint,this._sphere=s.sphere;else{let r;S(this.startCamera,t,this._tmpRay),o(this._tmpRay.direction,this._tmpRay.direction),null!=s.scenePickPoint&&(h(this._tmpRayDirPick,this.startCamera.eye,s.scenePickPoint),r=c(this._tmpRayDirPick));const e=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(this.startCamera.eye,T);let a=i(Math.min(z,1/Math.abs(m(T,this._tmpRay.direction)))*e,x[0],x[1]);const n=this.view.stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,H);a=null!=n?n:a,a=null!=r?Math.min(a,r):a,this._hasPickPoint=!0,p(this._tmpRay.direction,this._tmpRay.direction,a),l(this._pickPoint,this._tmpRay.origin,this._tmpRay.direction)}}update(t){if(this.running){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this._navMode===D.Horizontal){h(this._tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const i=c(this._tmpRayDir);A(this.currentCamera,t,this._tmpP0);const r=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let s=i*2**r;const e=this.view.state.constraints.minimumPoiDistance;if(r<0&&s<e&&(s=e),Math.abs(i-s)<1e-6)return;if(this._hasPickPoint&&s<i){const t=1-(1-s/i)*(1-this._sphere[3]/c(this.currentCamera.center));this.currentCamera.center=p(E,this.currentCamera.center,t)}p(this._tmpRayDir,this._tmpRayDir,-s/i),this.currentCamera.eye=l(E,this.currentCamera.center,this._tmpRayDir),this._constraintOptions.interactionFactor=f(a(this.dragBeginPoint,t)),g(this.view,this.currentCamera,this._constraintOptions),this._hasPickPoint&&(L(this._sphere,this.currentCamera,this.dragBeginPoint,this._targetOnSphere),C(this._pickPoint,this._targetOnSphere,this._panAxisAngle),I(this.currentCamera,y(this._sphere),this._panAxisAngle))}else{const i=c(this._tmpRay.direction);A(this.currentCamera,t,this._tmpP0);const r=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let s=i*2**r;const e=this.view.state.constraints.minimumPoiDistance;if(r<0&&s<e&&(s=e),Math.abs(i-s)<1e-6)return;p(this._tmpRayDir,this._tmpRay.direction,1-s/i),this.currentCamera.eye=l(E,this.currentCamera.eye,this._tmpRayDir),this.currentCamera.center=l(E,this.currentCamera.center,this._tmpRayDir)}k(this.view,this.currentCamera),this.commitCamera()}}finish(){this.running&&this.finishController()}};B=t([s("esri.views.3d.state.controllers.ZoomControllerGlobal")],B);const E=_(),T=_();export{B as ZoomControllerGlobal};
