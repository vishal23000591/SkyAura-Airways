/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../request.js";import s from"../../../core/Accessor.js";import{removeUnordered as r}from"../../../core/arrayUtils.js";import o from"../../../core/Error.js";import"../../../core/has.js";import{clone as a}from"../../../core/lang.js";import{removeMaybe as n,abortMaybe as i,destroyMaybe as u}from"../../../core/maybe.js";import{createResolver as l,onAbort as h,createAbortError as c,throwIfAborted as d,isAbortError as p}from"../../../core/promiseUtils.js";import{property as m}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/Logger.js";import{subclass as _}from"../../../core/accessorSupport/decorators/subclass.js";import{AsyncWorkerQueue as g,BaseTask as f}from"./AsyncWorkerQueue.js";import{ImageWithType as k}from"./ImageWithType.js";import{isImageWithType as L}from"../terrain/TerrainData.js";import{assert as D}from"../webgl-engine/lib/Util.js";import{TaskPriority as y}from"../../support/Scheduler.js";let b=class extends s{constructor(){super(...arguments),this._tasks=new Map,this._onLoadQueue=new Array,this._doneQueue=new Array,this.updating=!1}setup(e,t,s){this._loadQueue=new g(((e,t)=>this._startLoading(e,t)),((e,t)=>this._doneLoadingCB(e,t)),e,t),s&&(this._frameTask=s.registerTask(y.STREAM_DATA_LOADER,this))}destroy(){this._frameTask=n(this._frameTask),this._tasks.forEach((e=>i(e.abortController))),this._loadQueue=u(this._loadQueue),this._onLoadQueue=null,this._doneQueue=null,this._tasks=null}hasDownloadSlots(e){return this._loadQueue.hasQuota(e)}request(e,t,s,r={}){const o=l();o.__signal=null!=r?r.signal:null;const a=this._createOrUpdateTask(e,t,s,r,o);return h(r,(()=>this._cancelRequest(a,o))),o.promise}_createTask(e,t,s,r,o,a){const n=new O(e,t,s,r,o);return this._updateTask(n,a),this._tasks.set(o,n),1===this._tasks.size&&this._set("updating",!0),this._loadQueue.push(n),n}_cancelRequest(e,t){r(e.resolvers,t),t.reject(c()),0===e.resolvers.length&&(e.status===Q.DOWNLOADING&&(e.status=Q.CANCELLED,this._loadQueue.cancel(e),e.abortController?.abort(),e.request=null,e.abortController=null),e.status=Q.CANCELLED,this._tasks.delete(e.key),0===this._tasks.size&&this._set("updating",!1))}_updateTask(e,t){e.resolvers.push(t)}_createOrUpdateTask(e,t,s,r,o){const a=E(r?.uid||e,t,s),n=this._tasks.get(a);return n?(this._updateTask(n,o),n):this._createTask(e,r,t,s,a,o)}_doneLoadingCB(e,t){this._loadQueue&&(D(e.status===Q.DOWNLOADING),e.status=Q.DOWNLOADED,this._frameTask?this._doneQueue.push({task:e,err:t}):this._doneLoading(e,t))}get running(){return this._doneQueue.length>0||this._onLoadQueue.length>0}runTask(e){for(;!e.done&&this._onLoadQueue.length>0;){const t=this._onLoadQueue.shift();d(t.task.abortController),t.task.abortController=null,t.callback(t.task),e.madeProgress()}for(;!e.done&&this._doneQueue.length>0;){const t=this._doneQueue.shift();t.task.status!==Q.DOWNLOADED&&(t.err=t.err||c()),this._doneLoading(t.task,t.err),e.madeProgress()}}_doneLoading(e,t){if(t&&!p(t)&&e.numRetries>0)return--e.numRetries,void this._loadQueue.push(e);let s=L(e.result)||e.result instanceof HTMLImageElement?0:e.resolvers.length;for(const r of e.resolvers)if(t)p(t)?r.reject(t):r.reject(new o("stream-data-loader:request-error",`Failed to request resource at '${e.url}'. ${t}`,{url:e.url,error:t}));else{--s;const t=s>0?a(e.result):e.result;r.resolve(t)}this._tasks.delete(e.key),0===this._tasks.size&&this._set("updating",!1)}_startLoading(e,s){if(e.status===Q.CANCELLED)return!1;let r,o;switch(e.startTime=performance.now(),e.status=Q.DOWNLOADING,e.docType){case"binary":o="array-buffer",r=0;break;case"image":o="image";break;case"image+type":o="array-buffer";break;default:o="json"}e.abortController=new AbortController;const a=e.abortController.signal;e.request=t(e.url,{...e.options,responseType:o,timeout:r,signal:a});const n=t=>{e.duration=performance.now()-e.startTime,e.size=t instanceof ArrayBuffer?t.byteLength:e.size||0,e.result=t,this._frameTask?this._onLoadQueue.push({callback:s,task:e}):(e.abortController=null,s(e))},i=t=>{e.status===Q.DOWNLOADING&&s(e,t)};return"image+type"!==e.docType?(e.request.then((e=>n(e.data)),i),!0):(e.request.then((s=>{const u=s.data,l=A(u);if(o="image",e.size=u.byteLength,"unknown"===l)return e.request=t(e.url,{responseType:o,timeout:r,signal:a}),void e.request.then((e=>n(e.data)),i);const h=new Blob([u],{type:l}),c=window.URL.createObjectURL(h);e.request=t(c,{responseType:o,timeout:r,signal:a}),e.request.then((e=>n(new k(e.data,l))),i).finally((()=>window.URL.revokeObjectURL(c)))}),i),!0)}get test(){}};e([m({readOnly:!0})],b.prototype,"updating",void 0),b=e([_("esri.views.3d.support.StreamDataLoader")],b);const T={numRetries:0};function A(e){if(e.byteLength<2)return"unknown";const t=new Uint8Array(e,0,e.byteLength);return 137===t[0]&&80===t[1]?"image/png":71===t[0]&&73===t[1]?"image/gif":66===t[0]&&77===t[1]?"image/bmp":255===t[0]&&216===t[1]?"image/jpeg":"unknown"}class O extends f{constructor(e,t,s,r,o){super(r),this.url=e,this.options=t,this.docType=s,this.key=o,this.result=null,this.status=Q.QUEUED,this.request=null,this.abortController=null,this.resolvers=new Array,this.startTime=0,this.numRetries=T.numRetries}}function E(e,t,s){return`${e}:${t}:${s}`}var Q;!function(e){e[e.QUEUED=1]="QUEUED",e[e.DOWNLOADING=2]="DOWNLOADING",e[e.DOWNLOADED=3]="DOWNLOADED",e[e.CANCELLED=4]="CANCELLED"}(Q||(Q={}));export{b as StreamDataLoader,Q as TaskStatus,T as test};
