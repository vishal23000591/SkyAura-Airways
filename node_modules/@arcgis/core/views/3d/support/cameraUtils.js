/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{rad2deg as r,deg2rad as i,asinClamped as o}from"../../../core/mathUtils.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{c,j as l,F as s,g as u,f,l as m}from"../../../chunks/vec32.js";import{create as p,clone as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../geometry/ellipsoidUtils.js";import y from"../../../geometry/Point.js";import{projectWithZConversion as g,project as v}from"../../../geometry/projectionUtils.js";import w from"../../../geometry/SpatialReference.js";import{projectPointToVectorAsync as R,projectPointToVector as T}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPointAsync as x,projectVectorToPoint as S}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as M}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as j}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as z}from"../camera/intersectionUtils.js";import{c as C}from"../../../chunks/cameraUtilsPlanar.js";import{c as A}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as U}from"./earthUtils.js";import{getElevationAtPoint as b}from"./ElevationProvider.js";import{isSpatialReferenceSupported as D}from"../../support/spatialReferenceSupport.js";const L=()=>n.getLogger("esri.views.3d.support.cameraUtils"),P=96*39.37,E=1,G=8,H=5,F=1,J={heading:0,tilt:0},O=p(),q=new t(-20037508.342788905,20037508.342788905),I=new t(-180,180);var k;function V(e){return e.spatialReference??w.WGS84}function X({state:e}){return e.isGlobal?A:C}function K(e,t,n,r,i){return X(e).headingTiltToDirectionUp(t,n,r,i)}function W(e,t){if(null==t)return null;const n=e.renderSpatialReference,r=X(e).headingTiltToDirectionUp,o=p();if(!T(t.position,o,n))return null;const a=r(o,t.heading,t.tilt);u(a.direction,a.direction,e.state.camera.distance),f(a.direction,a.direction,o);const c=z(e,o,a.direction,a.up);return c.fov=i(t.fov),c.row=t.layout.row,c.rows=t.layout.rows,c.column=t.layout.column,c.columns=t.layout.columns,c}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(k||(k={}));const Y=p();function N(t,n,i){const o=t.renderSpatialReference,a=le(t,n.eye,n.viewForward,n.up,J);let c=V(t);return M(n.eye,o,Y,c)||(c=w.WGS84,M(n.eye,o,Y,c)),null==i?i=new e(new y(Y,c),a.heading,a.tilt,r(n.fov)):(i.position.x=Y[0],i.position.y=Y[1],i.position.z=Y[2],i.position.spatialReference=c,i.heading=a.heading,i.tilt=a.tilt,i.fov=r(n.fov)),i.layout.row=n.row,i.layout.rows=n.rows,i.layout.column=n.column,i.layout.columns=n.columns,i}function Z(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;t/=r;return n.width/2/n.pixelRatio/(P/t)/Math.tan(n.fovX/2)}function B(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,i=t*Math.tan(n.fovX/2),o=n.width/2/n.pixelRatio;return P/(o/i)*r}function Q(e,t,n,r){const i=r.levelAtScale(t),o=_(le(e,n.eye,n.viewForward,n.up).tilt),a=Math.max(i-o,0);return r.scaleAtLevel(a)}function $(e,t,n){const r=n.levelAtScale(e),i=_(t);return n.scaleAtLevel(r+i)}function _(e){return 2*((e>90?180-e:e)/90)**2}function ee(e,t,n=0){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;const i=h(e.spatialReference).radius,o=e.state.viewingMode===j.Local?t.eye[2]:m(t.eye)-i;return Q(e,B(e,Math.abs(o-n)),t,r)}function te(e,t,n=0){const r=W(e,t);return r?ee(e,r,n):0}const ne=1,re=100;function ie(e,t,n,a,c){if(0===t)return 0;const s=l(n.eye,a),u=e.basemapTerrain?.tilingScheme;if(!u)return L().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),s;let f=s;const p=le(e,n.eye,n.viewForward,n.up),d=p.tilt>90;if(e.state.isLocal){const r=(Z(e,$(t,p.tilt,u))-Math.abs(n.eye[2]-c[2]))/Math.cos(i(p.tilt));return f=d?f-r:f+r,f}let y=1/0,g=0,v=pe(e,p.heading,p.tilt,a,s,k.ADJUST);if(!v)return f;const w=m(c);for(;y>ne&&g<re;){const c=m(v.eye),s=d?180-v.tilt:v.tilt,R=i(s),T=Math.sin(R)*c,x=Math.cos(R)*c,S=Z(e,$(t,v.tilt,u)),M=d?w-S:w+S,j=o(T/M),z=Math.cos(j)*M-x,C=l(v.eye,a);f=d?C-z:C+z,v=pe(e,p.heading,p.tilt,a,f,k.ADJUST);const A=Ee(e,v,r(n.fov));if(!v||!A)return f;const U=te(e,A,w-h(e.spatialReference).radius);y=Math.abs(t-U),++g}return f}async function oe(e,t,n,r,i,o){return ce(e,t,Z(e,n),r,i,o)}function ae(e,t,n,r,i,o){return Ee(e,pe(e,r.heading,r.tilt,t,n,i),r.fov,o)}async function ce(e,t,n,r,i,o){const c=await de(e,r.heading,r.tilt,t,n,i,o);return a(o),Ge(e,c,r.fov,o)}function le(e,t,n,r,i){return X(e).directionToHeadingTilt(t,n,r,i)}function se(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,O,e.spatialReference)&&e.elevationProvider&&(b(e.elevationProvider,O)??0)>O[2]-F)}async function ue(e,t,n){if(se(e,t))return!0;const{elevationProvider:r,spatialReference:i,renderCoordsHelper:o}=e;if(null==r||!o.fromRenderCoords(t,O,i))return!1;const[c,l,s]=O,u=await r.queryElevation(c,l,s,i,"ground",n)??0;return a(n),u>s-F}async function fe(e,t,n){const r=p();if(null==t)return c(r,e.state.camera.center);if(t instanceof y){const{renderSpatialReference:i,basemapTerrain:o,elevationProvider:c}=e,l=t.spatialReference;if(await R(t,r,i,0,{signal:n}),a(n),null==t.z&&null!=o&&null!=c){const i=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);a(n),null!=i&&e.renderCoordsHelper.setAltitude(r,i)}return r}return c(r,t)}function me(e,t){const n=p();if(null==t)return c(n,e.state.camera.center);if(t instanceof y){if(!T(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:i}=e;if(null==t.z&&null!=r&&null!=i){const r=b(i,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return c(n,t)}function pe(e,t,n,r,i,o){return he(e,t,n,r instanceof y?r:null,me(e,r),i,o)}async function de(e,t,n,r,i,o,c){const l=r instanceof y?r:null,s=await fe(e,r,c);return a(c),ye(e,t,n,l,s,i,o,c)}function he(e,t,n,r,i,o,a){if(null==i)return null;if(!r&&(r=new y({spatialReference:V(e)}),!S(i,e.renderSpatialReference,r)))return null;const c=ge(e,t,n,i,o,a);if(ve(e,n,a)&&se(e,c.eye)){const{tilt:a,mode:c}=we(e,n,i,o);return he(e,t,a,r,i,o,c)}return Re(c,i)}async function ye(e,t,n,r,i,o,c,l){r||(r=new y({spatialReference:V(e)}),await x(i,e.renderSpatialReference,r,{signal:l})||(r=null)),a(l);const s=ge(e,t,n,i,o,c);if(ve(e,n,c)&&await ue(e,s.eye,l)){a(l);const{tilt:c,mode:s}=we(e,n,i,o);return ye(e,t,c,r,i,o,s,l)}return Re(s,i)}function ge(e,t,n,r,i,o){const a=Ae(e,t,n,r,i=Math.max(i,e.state.constraints.minimumPoiDistance),o);return(0,X(e).eyeForCenterWithHeadingTilt)(r,i,a.heading,a.tilt)}function ve(e,t,n){const r=e.map.ground.navigationConstraint;return n===k.ADJUST&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function we(e,t,n,r){const i=Le(e,n,r,De(e,r,t,n));return{tilt:i,mode:t-i<1?k.LOCKED:k.ADJUST}}function Re(e,t){return{...e,center:d(t)}}function Te(e,t){const{state:n,spatialReference:r}=e,i=t.spatialReference;return n.isGlobal&&D(i,j.Global)||n.isLocal&&r.equals(i)}function xe(e,t){let n,r,i;if(e.state.isGlobal){const e=new y(t.xmin,t.ymin,t.spatialReference),o=new y(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?I:q;n=new y({x:a.center(e.x,o.x),y:(o.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=h(t.spatialReference),l=U(n,e,o);r=l.lon,i=l.lat,a.diff(e.x,o.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),i=Math.min(i,c.halfCircumference)}else{const o=e.renderSpatialReference??t.spatialReference;o.equals(t.spatialReference)||(t=v(t,o)),r=t.xmax-t.xmin,i=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new y({x:t.xmin+.5*r,y:t.ymin+.5*i,z:a,spatialReference:o})}const o=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),l=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*i*l,.5*o*s)/E}}async function Se(e,t,n,r,i,o){const c=Te(e,t)?t:await g(t,e.spatialReference,{signal:o});a(o);const{center:l,distance:s}=xe(e,c),u=await de(e,n,r,l,s,i,o);return a(o),Ge(e,u,e.camera.fov,o)}function Me(e,t,n,r,i,o){let a;try{a=Te(e,t)?t:v(t,e.spatialReference)}catch(u){return null}const{center:c,distance:l}=xe(e,a),s=pe(e,n,r,c,l,i);return null==s?null:Ee(e,s,e.camera.fov,o)}function je(e,t,n){const r=e.renderSpatialReference,i=new y({spatialReference:V(e)});if(!S(n,r,i))return null;const o=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=s(t.eye,n),l=2*c*o*E,u=2*c*a*E;return X(e).toExtent(e,i,l,u)}function ze(e,t){return X(e).toArea(e,t)}function Ce(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>G)return!0;const i=t,o=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return l(i,o)/(Math.tan(.5*e.state.camera.fov)*r)>H}function Ae(e,t,n,r,i,o){let a=0;return o===k.ADJUST&&Ce(e,r,i)?(t=0,a=be(e,i,n,r)):a=Pe(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=Le(e,r,i,a)}}const Ue=.7;function be(e,t,n,r){const i=Pe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);o.max=Math.min(o.max,.5*Math.PI);const a=o.min*(1-Ue)+o.max*Ue;return Math.min(i,a)}function De(e,t,n,r){let i=Pe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);return i=Math.min(i,.5*Math.PI),o.min*(1-Ue)+i*Ue}function Le(e,t,n,r){return X(e).lookAtTiltToEyeTilt(r,t,n)}function Pe(e,t,n,r){return X(e).eyeTiltToLookAtTilt(r,t,n)}function Ee(t,n,r,i){if(null==n)return null;const o=t.renderSpatialReference,a=new y({spatialReference:V(t)});return S(n.eye,o,a)?(i??=new e,i.position=a,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i):null}async function Ge(t,n,r,i){const o=t.renderSpatialReference,c=new y({spatialReference:V(t)});return await x(n.eye,o,c,{signal:i}),a(i),new e(c,n.heading,n.tilt,r)}function He(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);L().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Fe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);L().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{k as OrientationMode,Q as applyTiltAdjustToScale,le as directionToHeadingTilt,B as distanceToScale,W as externalToInternal,ce as fromCenterDistanceAsync,ae as fromCenterDistanceSync,oe as fromCenterScale,Se as fromExtentAsync,Me as fromExtentSync,de as getObserverForPointAtDistanceAsync,pe as getObserverForPointAtDistanceSync,V as getViewSR,K as headingTiltToDirectionUp,N as internalToExternal,$ as removeTiltAdjustFromScale,ne as scaleErrorThreshold,Z as scaleToDistance,He as scaleToZoom,ze as toArea,je as toExtent,ie as viewScaleToCameraDistance,Fe as zoomToScale};
