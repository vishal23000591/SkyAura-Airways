/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{hasNativeFloat16Array as e}from"../../../../geometry/support/float16.js";import{BufferViewVec2f16 as t,BufferViewVec2f as i,BufferViewVec2f64 as s,BufferViewVec3f16 as r,BufferViewVec3f as n,BufferViewVec3f64 as h,BufferViewVec4f16 as d,BufferViewVec4f as u,BufferViewVec4f64 as f,BufferViewMat3f as o,BufferViewMat3f64 as p,BufferViewMat4f as l,BufferViewMat4f64 as c,BufferViewVec4u8 as a,BufferViewFloat16 as _,BufferViewFloat as F,BufferViewFloat64 as y,BufferViewUint8 as m,BufferViewUint16 as g,BufferViewInt8 as b,BufferViewVec2i8 as w,BufferViewVec2i16 as v,BufferViewVec2u8 as E,BufferViewVec2u16 as M,BufferViewVec4u16 as T,BufferViewUint32 as A,BufferViewVec3u8 as B,BufferViewVec3u16 as U,BufferViewVec2u32 as j,BufferViewVec3u32 as C,BufferViewVec4u32 as L,BufferViewVec3i8 as x,BufferViewVec4i8 as z,BufferViewInt16 as $,BufferViewVec3i16 as V,BufferViewVec4i16 as k,BufferViewInt32 as q,BufferViewVec2i32 as D,BufferViewVec3i32 as G,BufferViewVec4i32 as H}from"../../../../geometry/support/buffer/BufferView.js";import{elementTypeSize as I}from"../../../../geometry/support/buffer/types.js";import{assert as J}from"../../webgl-engine/lib/Util.js";class K{constructor(e,t){this.layout=e,this.buffer="number"==typeof t?new ArrayBuffer(t*e.stride):t;for(const i of e.fields.keys()){const t=e.fields.get(i);this[i]=new t.constructor(this.buffer,t.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(e,t){const i=this[e];return i&&i.elementCount===t.ElementCount&&i.elementType===t.ElementType?i:null}slice(e,t){return new K(this.layout,this.buffer.slice(e*this.stride,t*this.stride))}copyFrom(e,t=0,i=0,s=e.count){const r=this.stride;if(r%4==0){const n=new Uint32Array(e.buffer,t*r,s*r/4);new Uint32Array(this.buffer,i*r,s*r/4).set(n)}else{const n=new Uint8Array(e.buffer,t*r,s*r);new Uint8Array(this.buffer,i*r,s*r).set(n)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class N{constructor(e){this._stride=0,this._fields=new Map,e&&(this._stride=e.stride,e.fields.forEach((e=>this._fields.set(e[0],{...e[1],constructor:S(e[1].constructor)}))))}freeze(){return this}vec2f16(s,r){return this._appendField(s,e?t:i,r),this}vec2f(e,t){return this._appendField(e,i,t),this}vec2f64(e,t){return this._appendField(e,s,t),this}vec3f16(t,i){return this._appendField(t,e?r:n,i),this}vec3f(e,t){return this._appendField(e,n,t),this}vec3f64(e,t){return this._appendField(e,h,t),this}vec4f16(t,i){return this._appendField(t,e?d:u,i),this}vec4f(e,t){return this._appendField(e,u,t),this}vec4f64(e,t){return this._appendField(e,f,t),this}mat3f(e,t){return this._appendField(e,o,t),this}mat3f64(e,t){return this._appendField(e,p,t),this}mat4f(e,t){return this._appendField(e,l,t),this}mat4f64(e,t){return this._appendField(e,c,t),this}vec4u8(e,t){return this._appendField(e,a,t),this}f16(t,i){return this._appendField(t,e?_:F,i),this}f32(e,t){return this._appendField(e,F,t),this}f64(e,t){return this._appendField(e,y,t),this}u8(e,t){return this._appendField(e,m,t),this}u16(e,t){return this._appendField(e,g,t),this}i8(e,t){return this._appendField(e,b,t),this}vec2i8(e,t){return this._appendField(e,w,t),this}vec2i16(e,t){return this._appendField(e,v,t),this}vec2u8(e,t){return this._appendField(e,E,t),this}vec2u16(e,t){return this._appendField(e,M,t),this}vec4u16(e,t){return this._appendField(e,T,t),this}u32(e,t){return this._appendField(e,A,t),this}_appendField(e,t,i){this._fields.has(e)&&J(!1,`${e} already added to vertex buffer layout`);const s=t.ElementCount*I(t.ElementType),r=this._stride;this._fields.set(e,{constructor:t,size:s,offset:r,optional:i}),this._alignFields()}_alignFields(){let e=0,t=1;this._fields.forEach((i=>{const s=I(i.constructor.ElementType);e=Math.floor((e+s-1)/s)*s,i.offset=e,e+=i.size,t=Math.max(t,s)})),e=Math.floor((e+t-1)/t)*t,this._stride=e}createBuffer(e){return new K(this,e)}createView(e){return new K(this,e)}clone(){const e=new N;return e._stride=this._stride,e._fields=new Map,this._fields.forEach(((t,i)=>e._fields.set(i,t))),e.BufferType=this.BufferType,e}get stride(){return this._stride}get fields(){return this._fields}}function O(){return new N}class P{constructor(e){this.fields=new Array,e.fields.forEach(((e,t)=>{const i={...e,constructor:R(e.constructor)};this.fields.push([t,i])})),this.stride=e.stride}}const Q=[F,i,n,u,o,l,y,s,h,f,p,c,m,E,B,a,g,M,U,T,A,j,C,L,b,w,x,z,$,v,V,k,q,D,G,H];function R(e){return`${e.ElementType}_${e.ElementCount}`}function S(e){return W.get(e)}const W=new Map;Q.forEach((e=>W.set(R(e),e)));export{K as InterleavedBuffer,N as InterleavedLayout,P as PackedLayout,O as newLayout};
