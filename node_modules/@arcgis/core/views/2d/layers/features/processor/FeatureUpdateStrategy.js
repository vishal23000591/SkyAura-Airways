/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import has from"../../../../../core/has.js";import{AProcessorStrategy as e,ASendState as t}from"./AProcessorStrategy.js";import{FeatureTileUpdateMessage as s,FeatureTileAppendMessage as r}from"../sources/FeatureSourceMessage.js";import{OverrideChunk as o}from"../sources/strategies/chunks/Overrides.js";import{createArcadeEvaluationOptions as a}from"../support/arcadeUtils.js";import{FeatureSetReaderJSON as n}from"../support/FeatureSetReaderJSON.js";class d extends t{}class i extends e{constructor(e,t,s,r){super(e,t,r),this._arcadeContextInfo=s,this.handledChunks=new Set,this.handledChunksForIdCreation=new Set,this.handledChunksForAttributeData=new Set,this._streamLayerDeferredObjectIdsToRemove=[]}destroy(){super.destroy();for(const e of this._source.chunks())this._cleanupChunkIds(e)}invalidateAttributeData(e){this.handledChunksForAttributeData.clear(),this._arcadeContextInfo=e,null!=this._evalOptions&&(this._evalOptions=a(this._evalOptions.$view.scale,e))}onSubscribe(e){super.onSubscribe(e),this._evalOptions=e.tile.createArcadeEvaluationOptions(this._arcadeContextInfo)}createState(e){return new d(e)}get aggregateQueryEngine(){return null}displayMap(e,t,s){const r=new Map(e.map((e=>[t(e),e]))),o=[];for(const a of this._source.chunks()){const e=a.reader.getCursor();for(;e.next();){const t=e.getObjectId(),a=e.getDisplayId(),n=r.get(t);if(null!=n){const e=s(a,n,t);o.push(e),r.delete(t)}}}return o}getDisplayFeatures(e){const t=new Set(e),s=new Set,r=[];for(const o of this._source.chunks()){const e=o.reader.getCursor();for(;e.next();){const o=e.getObjectId(),a=e.getDisplayId();t.has(a)&&!s.has(o)&&(r.push({...e.readLegacyFeatureWorldSpace(),displayId:a}),s.add(o))}}return{features:r,aggregates:[],tracks:[]}}async*applyOverrideUpdate(e){const t=[];for(const s of e.modified){const e=this._attributeStore.createDisplayIdForObjectId(s.objectId);s.displayId=e,t.push(e)}const r=n.fromOptimizedFeatures(e.modified,this._source.metadata).getCursor();for(;r.next();)this._attributeStore.setAttributeData(r.getDisplayId(),r,this._evalOptions,this._sqlOptions);const a=[];for(const s of e.removed){const e=this._attributeStore.getDisplayIdForObjectId(s);null!=e&&a.push(e)}has("esri-2d-update-debug")&&console.debug("FeatureUpdateStrategy.applyLocalEdit",{message:e,modifiedDisplayIds:t,removedDisplayIds:a});const d=o.fromFeatures(e.modified,this._source.metadata);this.handledChunks.add(d.chunkId),this.handledChunksForAttributeData.add(d.chunkId),this.handledChunksForIdCreation.add(d.chunkId);for(const o of this._sendStates.values())o.handledChunks.add(d.chunkId),yield new s(o.subscription,null,t,!1,d.queryInfo);for(const o of this._sendStates.values()){const e=d.getTileReader(o.subscription.tile);yield new s(o.subscription,e,a,!1,d.queryInfo)}for(const s of e.removed)this._attributeStore.releaseDisplayIdForObjectId(s)}async*updateChunks(){if(this._source.chunks().length){await this._updateAttributeData();for(const e of this._sendStates.values())yield*this._update(e)}}removeChunks(e){for(const t of e)this.handledChunks.delete(t.chunkId),this.handledChunksForAttributeData.delete(t.chunkId),this._cleanupChunkIds(t)}afterUpdateChunks(){for(const e of this._streamLayerDeferredObjectIdsToRemove)this._attributeStore.releaseDisplayIdForObjectId(e);this._streamLayerDeferredObjectIdsToRemove=[]}_cleanupChunkIds(e){if(this.handledChunksForIdCreation.has(e.chunkId)){const t=e.reader.getCursor();for(;t.next();){const e=t.getObjectId();this._source.isStream?this._streamLayerDeferredObjectIdsToRemove.push(e):this._attributeStore.releaseDisplayIdForObjectId(e)}this.handledChunksForIdCreation.delete(e.chunkId)}}async _updateAttributeData(){for(const e of this._source.chunks()){const{chunkId:t,reader:s}=e;if(!this.handledChunksForIdCreation.has(t)){this.handledChunksForIdCreation.add(t);const e=s.getCursor();for(;e.next();){const t=this._attributeStore.createDisplayIdForObjectId(e.getObjectId());e.setDisplayId(t)}}}for(const e of this._source.chunks())if(!this.handledChunksForAttributeData.has(e.chunkId)){this.handledChunksForAttributeData.add(e.chunkId);const t=e.reader.getCursor();for(;t.next();){const e=t.getDisplayId();this._attributeStore.setAttributeData(e,t,this._evalOptions,this._sqlOptions)}}}*_update(e){const{subscription:t,handledChunks:s}=e;for(const o of this._source.chunks()){const{chunkId:a}=o;if(s.has(a))continue;s.add(a);const n=o.getTileReader(t.tile);n&&(yield new r(e.subscription,n,!1,o.end,o.queryInfo))}}}export{d as DefaultSendState,i as FeatureUpdateStrategy};
