/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{convertToFeature as e}from"../../../../../layers/graphics/featureConversionUtils.js";import{OptimizedFeature as t}from"../../../../../layers/graphics/OptimizedFeature.js";import s from"../../../../../layers/graphics/OptimizedGeometry.js";import i from"../../../../../layers/support/FieldsIndex.js";import{tileSize as r}from"../../../engine/webgl/definitions.js";import{ComputedAggregateField as n}from"../aggregation/ComputedAggregateField.js";import{GridCell as a}from"../aggregation/GridCell.js";import{pixelsPerMapUnit as l}from"../aggregation/GridSpatialIndex.js";import{AAggregateStrategy as o}from"./AAggregateStrategy.js";import{ASendState as d}from"./AProcessorStrategy.js";import{WithDisplayId as u}from"./support/WithDisplayId.js";import{FeatureTileAppendMessage as c}from"../sources/FeatureSourceMessage.js";import{ComputedAttributeStorage as h}from"../support/ComputedAttributeStorage.js";import p from"../support/FeatureFilterEvaluator.js";import{FeatureMetadata as f}from"../support/FeatureMetadata.js";import{FeatureSetReaderJSON as g}from"../support/FeatureSetReaderJSON.js";import _ from"../../../tiling/TileKey.js";const m=128;class y extends d{constructor(e){super(e),this.didSend=!1,this.done=!1}}class S{constructor(e,t,s,i,r){this._level=e,this._scale=t,this._indexOptions=s,this._clusterRadius=i,this._store=r,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const e of this._clusters.values())this._store.releaseDisplayIdForObjectId(e.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const e of this._clusters.values()){const s=e.inner.getCentroid(null),i=new t(s,e.inner.getAttributes(),null,e.inner.id,e.displayId);yield i}}clusters(){return this._clusters.values()}updateChunks(e,t){let s=!1;for(const a of e){const e=a.queryInfo;if("tileId"in e){if(new _(e.tileId).level!==this._level)continue}if(!this._handledChunks.has(a.normalizedChunkId)){this._handledChunks.add(a.normalizedChunkId),s=!0;a.getAggregateIndex({...this._indexOptions,scale:this._scale}).put(this._cells)}}const i={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},r=l(this._indexOptions.spatialReference,this._scale),n=this._indexOptions.cellSize;for(const{subscription:a}of t){const e=a.tile.bounds,t=Math.floor(e[0]*r/n),s=Math.floor(e[1]*r/n),l=Math.ceil(e[2]*r/n),o=Math.ceil(e[3]*r/n);i.xMin=Math.min(i.xMin,t),i.yMin=Math.min(i.yMin,s),i.xMax=Math.max(i.xMax,l),i.yMax=Math.max(i.yMax,o)}return null!=this._lastCellBounds&&i.xMin===this._lastCellBounds.xMin&&i.yMin===this._lastCellBounds.yMin&&i.yMin===this._lastCellBounds.yMin&&i.yMax===this._lastCellBounds.yMax||(s=!0,this._lastCellBounds=i),s&&this._clusterCells(i),s}async updateStatistics(e){let t=!1;for(const s of this._clusters.values())s.inner.count>1&&(t=this._updateAggregateStatistics(this._statistics,s.inner)||t);if(t){const t=Array.from(this._statistics.entries()).map((([e,t])=>({fieldName:e,minValue:t.minValue,maxValue:t.maxValue})));await e.container.updateStatistics(this._level,t)}}createAggregateFeatures(e,i){const n=e.subscription,a=[],l=n.tile.transform;for(const o of this._clusters.values()){let e=o.inner.getCentroidX(l);const i=o.inner.getCentroidY(l),d=n.tile.lod,u=d.wrap?d.worldSize[0]:null,c=1===o.inner.count?o.inner.firstObjectId:o.inner.id,h=o.displayId;if(null!=u)if(1===u){const n=new s([],[e,i]),l=new t(n,o.inner.getAttributes(),null,c,h);l.geometry.coords[0]-=r,a.push(l);const d=new s([],[e,i]),u=new t(d,o.inner.getAttributes(),null,c,h);u.geometry.coords[0]+=r,a.push(u)}else e>r+r/2?e-=u*r:e<-256&&(e+=u*r);if(e<r+m&&e>=-128&&i<r+m&&i>=-128){const r=new s([],[e,i]),n=new t(r,o.inner.getAttributes(),null,c,h);a.push(n)}}return g.fromOptimizedFeatures(a,i,n.tile.transform)}_clusterCells(e){let t=Array.from(this._cells.values());t=t.sort(((e,t)=>t.count-e.count));const s=[];for(const a of this._clusters.values())s.push(a.inner.id);this._clusters.clear();const i=this._clusterRadius*(1/l(this._indexOptions.spatialReference,this._scale)),r=1+this._clusterRadius/this._indexOptions.cellSize,n=new Set;for(const l of t){if(n.has(l.id))continue;if(l.gridX<e.xMin||l.gridX>e.xMax||l.gridY<e.yMin||l.gridY>e.yMax)continue;const t=this._store.createDisplayIdForObjectId(l.id),s=new u(l.clone(),t);n.add(l.id),this._clusters.set(l.id,s);const o=l.centroidXWorld,d=l.centroidYWorld;for(let e=l.gridY-r;e<=l.gridY+r;e++)for(let t=l.gridX-r;t<=l.gridX+r;t++){if(e===l.gridY&&t===l.gridX)continue;const r=this._cells.get(a.createId(t,e));if(!r||n.has(r.id))continue;const u=Math.abs(r.centroidXWorld-o),c=Math.abs(r.centroidYWorld-d);u<i&&c<i&&(s.inner.merge(r),n.add(r.id))}}for(const a of s)this._store.releaseDisplayIdForObjectId(a)}_updateAggregateStatistics(e,t){let s=!1;for(const i of t.statistics.values()){if("esriFieldTypeString"===i.field.type)continue;const t=i.value,r=i.field,n=e.get(r.name);if(n){const{minValue:e,maxValue:i}=n,r=Math.min(n.minValue,t),a=Math.max(n.maxValue,t);e===r&&i===a||(n.minValue=r,n.maxValue=a,s=!0)}else e.set(r.name,{minValue:t,maxValue:t}),s=!0}return s}}class x extends o{static async create(e,t,s,i,r,a,l){const o=new h({spatialReference:s}),d={type:"grid",fields:await Promise.all(t.fields.map((async e=>n.create(o,e)))),spatialReference:s,featureFilter:t.featureFilter?await p.create({geometryType:i.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:i.metadata.timeInfo,fieldsIndex:i.metadata.fieldsIndex,spatialReference:s,filterJSON:t.featureFilter}):null,cellSize:t.clusterRadius/4,arcadeContextInfo:a,sqlOptions:l};return new x(e,t.clusterRadius,d,t.fields,i,r,l)}constructor(e,t,s,r,n,a,l){super(n,a,s.spatialReference,s.fields,l),this._connection=e,this._clusterRadius=t,this._indexOptions=s,this._cellsPerScale=new Map,this._metadata=f.createFeature({geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:new i([...r,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}]).toJSON(),globalIdField:null,spatialReference:n.metadata.spatialReference,outSpatialReference:n.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const e of this._cellsPerScale.values())e.destroy();this._cellsPerScale.clear()}onSubscribe(e){super.onSubscribe(e),this._requiredLevel=e.tile.level,this._requiredScale=e.tile.scale}createState(e){return new y(e)}async*applyOverrideUpdate(e){for(const t of this._cellsPerScale.values())t.destroy();this._cellsPerScale.clear();for(const t of this._sendStates.values())t.done=!1}displayMap(e,t,s){const i=new Map(e.map((e=>[t(e),e]))),r=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const a of n.clusters()){const e=i.get(a.inner.id);if(null==e){if(1===a.inner.count){const{firstObjectId:e}=a.inner,t=e?i.get(e):null;if(null!=t){const n=s(a.displayId,t,e);r.push(n),i.delete(e)}}}else{const t=s(a.displayId,e,a.inner.id);r.push(t),i.delete(a.inner.id)}}return r}getDisplayFeatures(t){const s=new Set(t),i=new Set,r=[],n=[],a=this._getClusterState(this._requiredLevel,this._requiredScale);for(const l of a.aggregatesWorldSpace())if(s.has(l.displayId)&&!i.has(l.displayId)){const t=e(l,this._metadata.geometryType,!1,!1);if(i.add(l.displayId),1===t.attributes.cluster_count){r.push({...t,displayId:l.displayId});continue}n.push({...t,displayId:l.displayId})}return{features:r,aggregates:n,tracks:[]}}getFeatureObjectIdsForAggregate(e){const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const s of t.clusters())if(s.inner.id===e)return Array.from(s.inner.containedObjectIds);return[]}async*updateChunks(){const e=this._source.chunks();if(!e.length)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale),s=Array.from(this._sendStates.values()).filter((e=>e.subscription.tile.level===this._requiredLevel));if(t.updateChunks(e,s)||!this._source.updateTracking.updating)for(const n of s)n.subscription.tile.level===this._requiredLevel&&(n.didSend=!1,n.done=!1);const i=Array.from(this._sendStates.values()).filter((e=>e.done)).map((e=>e.subscription.tile.key)),r=new Set(i);for(const n of this._sendStates.values()){if(this._source.updateTracking.updating){if(i.some((e=>e.containsChild(n.subscription.tile.key))))continue;if(n.subscription.tile.key.getChildKeys().every((e=>r.has(e))))continue}n.didSend||n.subscription.tile.level!==this._requiredLevel||(n.didSend=!0,yield*this._update(n,t,this._source))}await t.updateStatistics(this._connection)}forEachAggregateWorldSpace(e){if(null==this._requiredLevel||null==this._requiredScale)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const s of t.aggregatesWorldSpace())e(s)}_getClusterState(e,t){if(null==e||null==t)throw new Error("InternalError: Level and scale must be defined");let s=this._cellsPerScale.get(t);return s||(s=new S(e,t,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(t,s)),s}async*_update(e,t,s){if(e.done)return;const i=t.createAggregateFeatures(e,this._metadata);this.events.emit("changed"),e.done=!s.updateTracking.updating;const r=i.getCursor(),n=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);for(;r.next();)this._attributeStore.setAttributeData(r.getDisplayId(),r,n,this._sqlOptions);const a=new c(e.subscription,i,!0,e.done,{});yield a}}export{y as ClusterState,x as ClusterStrategy};
