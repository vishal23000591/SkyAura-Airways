/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{destroyMaybe as e}from"../../../../core/maybe.js";import{notDeepEqual as t}from"../../../../core/object.js";import{throwIfNotAbortError as s,throwIfAborted as r,after as i}from"../../../../core/promiseUtils.js";import{diff as a}from"../../../../core/accessorSupport/diffUtils.js";import{ignoreConnectionErrors as o}from"../../../../core/workers/utils.js";import n from"../../../../geometry/SpatialReference.js";import{MultiTileMeshData as c}from"../../engine/webgl/mesh/MultiTileMeshData.js";import{FeatureMeshFactory as h}from"../../engine/webgl/mesh/factories/FeatureMeshFactory.js";import{ResourceProxy as u}from"../../engine/webgl/mesh/factories/ResourceProxy.js";import{MeshWriterRegistry as p}from"../../engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry.js";import{MatcherContext as g}from"../../engine/webgl/util/MatcherContext.js";import{ProcessorTileMessageQueue as y}from"./ProcessorTileMessageQueue.js";import{BinningStrategy as d}from"./processor/BinningStrategy.js";import{ClusterStrategy as _}from"./processor/ClusterStrategy.js";import{FeatureUpdateStrategy as l}from"./processor/FeatureUpdateStrategy.js";import{TrackStrategy as m}from"./processor/TrackStrategy.js";import{AttributeStore as f}from"./support/AttributeStore.js";import{ComputedAttributeStorage as b}from"./support/ComputedAttributeStorage.js";class w{constructor(e,t){this._connection=e,this._source=t,this._version=1,this._registry=new p,this._proxy=new u({fetch:(e,t)=>this._connection.layerView.fetch(e,t),fetchDictionary:(e,t)=>this._connection.layerView.fetchDictionary(e,t)}),this._attributeStore=new f({isLocal:!1,update:e=>o(this._connection.container.updateAttributeView(e))})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}get version(){return this._version}getDisplayFeatures(e){return this._strategy?this._strategy.getDisplayFeatures(e):{features:[],aggregates:[],tracks:[]}}getDisplayIds(e){const t={};return this._strategy?(this._strategy.displayMap(e,(e=>e),((e,s,r)=>{t[r]=e})),t):t}getFeatureObjectIdsForAggregate(e){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(e):[]}onSubscribe(e){this._strategy?.onSubscribe(e)}onUnsubscribe(e){this._strategy?.onUnsubscribe(e)}requiresInvalidation(){return this._strategy?.requiresInvalidation()??!1}async update(e,s,r,i,o){const c=e.processor,u=t(this._schema?.storage,c.storage),p=t(this._schema?.mesh.properties,c.mesh.properties),y=t(this._schema?.mesh.factory,c.mesh.factory),d=t(this._schema?.mesh.strategy,c.mesh.strategy),_=S(this._schema?.expressionProperties,c.expressionProperties),l=_.some((e=>this._attributeStore.hasArcadeDependency(e))),m=_.some((e=>this._factory?.hasArcadeDependency(e)??!1)),f=_.some((e=>this._strategy?.hasArcadeDependency(e)))||this._strategy?.isAggregate&&l,w=m||f,I=p||y||d;if(!(u||I||(m||l||f))&&!i)return!1;has("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:a(this._schema,c),schema:c}),this._schema=c;const x=n.fromJSON(this._source.service.outSpatialReference),v=new b({fields:this._source.metadata.fieldsIndex,spatialReference:x}),M={currentUser:c.mesh.properties.currentUser};if((u||I||l)&&(await this._attributeStore.update(c.storage,v,this._source.metadata,s),this._strategy?.invalidateAttributeData(j(c))),!i&&!I&&!w)return!1;(d||p||w)&&await this._updateStrategy(c.mesh.strategy,x,o,j(c),M),this._updateSortKey(v,"sortKey"in c.mesh.properties?c.mesh.properties.sortKey:null);const k="dictionary"===c.mesh.factory.symbology.type?c.mesh.factory.symbology.fieldMap:null,U=new g(v,this._proxy,r,this._registry,k);return(y||"dictionary"===c.mesh.factory.symbology.type)&&(this._factory=await h.create(U,c.mesh.factory)),this._version=s,!0}async applyOverrideUpdate(e){if(!this._strategy)return;const t=this._strategy.applyOverrideUpdate(e);for await(const r of t)try{await this._process(r)}catch(s){}}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(e){this._strategy?.removeChunks(e),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:e}){if(!this._strategy||!this._strategy.hasSubscribers)return void this._attributeStore.setHighlight(e.map((({objectId:e,highlightFlags:t})=>({objectId:e,highlightFlags:t,displayId:-1}))),e);const t=this._strategy.displayMap(e,(({objectId:e})=>e),((e,{highlightFlags:t},s)=>({objectId:s,displayId:e,highlightFlags:t})));this._attributeStore.setHighlight(t,e)}invalidate(){this._strategy&&this._strategy.invalidate()}async _doUpdateChunks(){if(!this._strategy)return;const e=this._strategy.updateChunks(),t=[],r=new Map;for await(const a of e){let e=r.get(a.id);null==e&&(e=new y({concurrency:16,process:e=>this._process(e)}),r.set(a.id,e));const i=e.push(a).catch((e=>s(e)));t.push(i)}try{await Promise.all(t)}catch(i){}has("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(e,t,s,r,i){switch(this._strategy?.destroy(),e.type){case"feature":this._strategy=new l(this._source,this._attributeStore,r,i);break;case"binning":this._strategy=await d.create(e,t,this._source,this._attributeStore,r,i);break;case"cluster":this._strategy=await _.create(this._connection,e,t,this._source,this._attributeStore,r,i);break;case"track":this._strategy=await m.create(e,t,this._source,this._attributeStore,r,i)}for(const a of s)this._strategy.onSubscribe(a)}async _updateSortKey(t,s){if(this._sortInfo=e(this._sortInfo?.computed),null!=s){const e=s.byRenderer?null:await t.createComputedField(s);this._sortInfo={...s,computed:e}}}async _process(e){const t=e.subscription;if(has("esri-2d-update-debug")){const s=t.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${e.end}] Processor._process`)}const s={currentUser:this._schema?.mesh.properties.currentUser};await this._fetchResources(e,s),r(t.signal);const i=await this._write(e,t.tile.createArcadeEvaluationOptions(j(this._schema)),s),a=t.tile.tileInfoView.getLODInfoAt(t.tile.key);r(t.signal);const{message:o,transferList:n}=i.serialize(a),c={objectIdMap:null,inner:e.createMessage(o,this._version,this._attributeStore.epoch)};if(this._schema?.mesh.properties.returnMeshObjectId){c.objectIdMap={};const t=e.reader?.getCursor();if(t)for(;t.next();)c.objectIdMap[t.getDisplayId()]=t.getObjectId()}if(r(t.signal),await this._connection.container.onMessage(c,{signal:t.signal,transferList:n}),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")){const s=t.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${e.end}] Processor._process.await`)}}async _fetchResources(e,t){await this._fetchMatcherResources(e),await this._fetchWriterResources(e,t)}async _fetchMatcherResources(e){if(e.reader)return this._factory.enqueueMatcherRequests(this._proxy,e.reader)}async _fetchWriterResources(e,t){if(!e.reader)return;const s=e.reader.getCursor(),r=e.subscription.tile.createArcadeEvaluationOptions(j(this._schema));for(;s.next();)this._factory.enqueueWriterRequests(this._proxy,s,r,t);await this._proxy.fetchEnqueuedResources()}async _write(e,t,s){const a=e.subscription.tile,o=e.reader?.getCursor(),n=o?.getSize()??0,h=a.tileInfoView.tileInfo.isWrappable,u=a.tileInfoView.tileInfo.spatialReference.isWGS84,p=new c(a.key,this._strategy.enablePixelBuffering,h,u,n);if(!o)return p;const g=a.createArcadeEvaluationOptions(j(this._schema));let y=0;for(;o.next();){++y%1e3||(await i(0),r(e.subscription));const n=this._getSortKeyValue(o,t);p.entityStart(o.getDisplayId(),n),this._factory.write(p,this._proxy,o,g,s,a.level),p.entityEnd()}return p}_getSortKeyValue(e,t){if(!this._sortInfo)return 0;const{computed:s,order:r,byRenderer:i}=this._sortInfo,a=i?this._factory.getSortKey(e,t):s?.read(e,t);return null==a||isNaN(a)?0:a*("asc"===r?-1:1)}}function S(e,t){const s=[];return e?.timeExtent?.start===t.timeExtent?.start&&e?.timeExtent?.end===t.timeExtent?.end||s.push("timeProperties"),s}function j(e){const{timeZone:t}=e?.mesh.properties??{},{timeExtent:s}=e?.expressionProperties??{};return{timeZone:t,timeExtent:s}}export{w as default};
