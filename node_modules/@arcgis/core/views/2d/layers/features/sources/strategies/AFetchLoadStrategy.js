/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../../../core/Error.js";import t from"../../../../../../core/Logger.js";import{QueueProcessor as r}from"../../../../../../core/QueueProcessor.js";import s from"../../../../../../rest/support/Query.js";import{ALoadStrategy as n}from"./ALoadStrategy.js";import{createQueryAdapter as o}from"./support/queryAdapters.js";import{FeatureSetReaderJSON as u}from"../../support/FeatureSetReaderJSON.js";class i extends n{constructor(e,t,s,n,u){super(s),this._serviceInfo=e,this._queryInfo=t,this._metadata=n,this._connection=u,this._queue=new r({concurrency:32,process:async e=>{const t={signal:e.options?.signal,query:e.query.customParameters,useRequestQueue:!0};return this._adapter.executeQuery(e.query.inner,t)}}),this._adapter=o(e,n)}unsafeSetQueryHistoricMoment(e){this._queryInfo.updateHistoricMoment(e)}async updateFields(t){this._queryInfo.updateFields(t);const r=Array.from(this._store.chunks()).map((async e=>{const t=s.fromJSON(e.queryInfo.queryJSON);if(t)try{return await this._tryUpdateFields(e.reader,t,{chunkId:e.chunkId}),null}catch(r){return r}})),n=(await Promise.all(r)).filter((e=>e));if(n.length)throw new e("featurelayer-query","Encountered errors when downloading fields",{errors:n})}async queryByObjectId(e){if(0===e.length)return u.empty(this._metadata);const t=this._queryInfo.createQuery({objectIds:e});return this._fetch(t,null,null)}async _fetch(e,t,r){const s=await this._enqueue(e,t);return await this._tryUpdateFields(s,e.inner,r),s}async _tryUpdateFields(r,s,n){const o=this._queryInfo.createPatchFieldsQuery(s,r,n);if(!o)return;const u=await this._enqueue(o,this._options);u.getSize()===r.getSize()?r.joinAttributes(u):t.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new e("featurelayer-query",`Failed to join features. Expected a count of ${r.getSize()} features, but got ${u.getSize()}`,{query:o.inner.toJSON(),debugInfo:n}))}async _enqueue(e,t){return this._connection.onEvent({type:"fetchStart"}),this._queue.push({query:e,options:t}).finally((()=>{this._connection.onEvent({type:"fetchEnd",done:0===this._queue.length})}))}}export{i as AFetchLoadStrategy};
