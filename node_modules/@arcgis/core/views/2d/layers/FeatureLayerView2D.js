/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../AggregateGraphic.js";import r from"../../../Graphic.js";import s from"../../../TrackGraphic.js";import{isSome as i}from"../../../core/arrayUtils.js";import a from"../../../core/Collection.js";import{neverReached as o}from"../../../core/compilerUtils.js";import n from"../../../core/Error.js";import{makeHandle as u,handlesGroup as l}from"../../../core/handleUtils.js";import has from"../../../core/has.js";import h from"../../../core/Logger.js";import{destroyMaybe as c}from"../../../core/maybe.js";import{notDeepEqual as p}from"../../../core/object.js";import{createAbortError as d,createResolver as y,ignoreAbortErrors as f,throwIfNotAbortError as g,isAbortError as m}from"../../../core/promiseUtils.js";import{watch as w}from"../../../core/reactiveUtils.js";import{sqlOr as v,sqlIn as _,sqlAnd as b}from"../../../core/sql.js";import{property as F}from"../../../core/accessorSupport/decorators/property.js";import{subclass as S}from"../../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as A}from"../../../core/support/UpdatingHandles.js";import j from"../../../geometry/Extent.js";import U from"../../../layers/effects/FeatureEffectView.js";import{convertFromFeature as I}from"../../../layers/graphics/featureConversionUtils.js";import x from"../../../layers/support/FeatureFilter.js";import{checkServiceCurrentUserSupport as E}from"../../../layers/support/featureLayerUtils.js";import{packFields as k}from"../../../layers/support/fieldUtils.js";import{getEffectiveLayerCapabilities as C}from"../../../layers/support/layerUtils.js";import{combineTimeExtent as V}from"../../../layers/support/timeSupport.js";import q from"../../../rest/support/AggregateFeatureSet.js";import R from"../../../rest/support/AttributeBinsFeatureSet.js";import O from"../../../rest/support/AttributeBinsQuery.js";import Q from"../../../rest/support/FeatureSet.js";import L from"../../../rest/support/Query.js";import{LayerView2DMixin as T}from"./LayerView2D.js";import{FeatureContainer as D}from"./features/FeatureContainer.js";import{createFeaturePipelineWorkerProxy as P}from"./features/FeaturePipelineWorkerProxy.js";import{FeatureSourceEventLog as W}from"./features/FeatureSourceEventLog.js";import{CatalogFootprintLayerAdapter as M}from"./features/layerAdapters/CatalogFootprintLayerAdapter.js";import{FeatureLayerAdapter as H}from"./features/layerAdapters/FeatureLayerAdapter.js";import{createFeatureIdInfo as N}from"./features/layerAdapters/featureServiceUtils.js";import{InMemoryLayerAdapter as J}from"./features/layerAdapters/InMemoryLayerAdapter.js";import{KnowledgeGraphSublayerAdapter as G}from"./features/layerAdapters/KnowledgeGraphSublayerAdapter.js";import{OGCFeatureLayerAdapter as $}from"./features/layerAdapters/OGCFeatureLayerAdapter.js";import{OrientedImageryLayerAdapter as B}from"./features/layerAdapters/OrientedImageryLayerAdapter.js";import{ParquetLayerAdapter as z}from"./features/layerAdapters/ParquetLayerAdapter.js";import{StreamLayerAdapter as Z}from"./features/layerAdapters/StreamLayerAdapter.js";import{SubtypeGroupLayerAdapter as K}from"./features/layerAdapters/SubtypeGroupLayerAdapter.js";import{createComplexSymbolInstances as X}from"./features/schema/processor/symbols/ComplexSymbolSchema.js";import{DebouncedFeatureOverride as Y}from"./support/DebouncedFeatureOverride.js";import{FeatureCommandQueue as ee}from"./support/FeatureCommandQueue.js";import{handleNoEngineError as te}from"./support/handleNoEngineError.js";import{toJSONGeometryType as re}from"./support/util.js";import{FeatureTileSubscriptionManager as se}from"../tiling/FeatureTileSubscriptionManager.js";import ie from"../../layers/FeatureLayerView.js";import ae from"../../layers/LayerView.js";import oe from"../../layers/RefreshableLayerView.js";import{defaultHighlightName as ne}from"../../support/HighlightDefaults.js";function ue(e,t){const r=new Set;return e&&e.forEach((e=>r.add(e))),t&&t.forEach((e=>r.add(e))),r.has("*")?["*"]:Array.from(r)}const le=4294967294;function he(e,t){return l(e.map((e=>w((()=>{const t=e();return t&&"object"==typeof t?"getTime"in t&&"function"==typeof t.getTime?t.getTime():JSON.stringify(t):t}),t))))}let ce=class extends(ie(oe(T(ae)))){constructor(){super(...arguments),this._commandsQueue=new ee({process:e=>{switch(e.type){case"override-batch":return this._doOverride(e);case"update":return this._doUpdate();case"highlight":return this._updateHighlights()}}}),this._visibilityOverrides=new Set,this._lastAvailableFields=[],this._lastTargetState=null,this.eventLog=new W,this._sourceRefreshVersion=1,this._displayRefreshVersion=1,this._pipelineUpdating=!1,this._editUpdatingHandles=new A,this._fields=null,this._sourceUpdating=!1,this.featureEffectView=new U}destroy(){this._workerProxy?.destroy(),this._workerAttached.reject(d()),this._commandsQueue.destroy()}initialize(){this._workerAttached=y(),f(this._workerAttached.promise),this.addResolvingPromise(this._initProxy()),this.featureEffectView.featureEffect=this.featureEffect,this.featureEffectView.endTransition()}async _initProxy(){const e=this.layer;if("isTable"in e&&e.isTable)throw new n("featurelayerview:table-not-supported","table feature layer can't be displayed",{layer:e});if(("feature"===e.type||"subtype-group"===e.type)&&!1===C(e)?.operations.supportsQuery)throw new n("featurelayerview:query-not-supported","layer view requires a layer with query capability",{layer:e});this._workerProxy&&this._workerProxy.destroy();const t=this._createClientOptions();this._workerProxy=await P(t)}async _attachProxy(){const e={service:await this.layerAdapter.createServiceOptions(this.view),tileInfoJSON:this.view?.featuresTilingScheme?.tileInfo?.toJSON()};let t=[];Array.isArray(e.service.source)&&(t=e.service.source);try{await this._workerProxy.pipeline.onAttach(e,{transferList:t}),this._workerAttached.resolve()}catch(r){this._workerAttached.reject(d()),g(r)}}async _detachProxy(){return this._workerProxy.pipeline.onDetach()}async getWorker(){return await this._workerAttached.promise,this._workerProxy}get dataUpdating(){return this._sourceUpdating||this._editUpdatingHandles.updating}get effectiveDisplayFilterClause(){const e=this.effectiveDisplayFilter?.where??null;return e&&this.hasHighlight?v(e,_(this.layer.objectIdField,this.highlightIds)):e}get hasAllFeatures(){return this.layer.visible&&!this.suspended&&this.eventLog.hasAllData&&this.eventLog.willQueryAllFeatures}get hasAllFeaturesInView(){const e=this.effectiveDisplayFilter?.where||null,t=!this.eventLog.willQueryAllFeatures&&null!=e&&"1=1"!==e;return this.layer.visible&&!this.suspended&&this.eventLog.hasAllData&&!t}get hasFullGeometries(){return this.layer.visible&&!this.suspended&&this.eventLog.hasAllData&&this.eventLog.willQueryFullResolutionGeometry}get labelingCollisionInfos(){const e=this.layerAdapter.getLabelingDeconflictionInfo(this.view),t=this.layer.geometryType,r=!this.suspended;return e.map((({vvEvaluators:e,deconflictionEnabled:s,labelingInfo:i})=>({labelingInfo:i,container:this.featureContainer,vvEvaluators:e,deconflictionEnabled:s,geometryType:t,visible:r})))}get layerAdapter(){switch(this.layer.type){case"feature":return"memory"===this.layer.source.type?new J(this.layer):new H(this.layer);case"geojson":case"csv":case"wfs":return new J(this.layer);case"parquet":return new z(this.layer);case"subtype-group":return new K(this.layer);case"ogc-feature":return new $(this.layer);case"stream":return new Z(this.layer);case"oriented-imagery":return new B(this.layer);case"knowledge-graph-sublayer":return new G(this.layer);case"catalog-footprint":return new M(this.layer);default:o(this.layer)}return null}get timeExtent(){return V(this.layerAdapter.timeOptions,this.view?.timeExtent,this._get("timeExtent"))}getDisplayStatistics(e,t){return this.featureContainer?.getDisplayStatistics(e,t)}async queryHeatmapStatistics(e){return(await this.getWorker()).pipeline.queryHeatmapStatistics(e)}highlight(e,t){let s;e instanceof r?s=[e.getObjectId()]:"number"==typeof e||"string"==typeof e?s=[e]:a.isCollection(e)&&e.length>0?s=e.map((e=>e?.getObjectId())).toArray():Array.isArray(e)&&e.length>0&&(s="number"==typeof e[0]||"string"==typeof e[0]?e:e.map((e=>e?.getObjectId())));const o=s?.filter(i);if(!o?.length)return u();const n=t?.name??ne;return this._addHighlights(o,n),u((()=>!this.destroyed&&this._removeHighlights(o,n)))}async hitTest(e,i){const a=await this.featureContainer.hitTest(i);if(0===a.length)return null;const o=await this.getWorker(),{features:n,aggregates:u,tracks:l}=await o.pipeline.getDisplayFeatures(a),h=this.featureContainer.getSortKeys(a),c=({displayId:e},{displayId:t})=>h.has(e)&&h.has(t)?h.get(e)-h.get(t):e-t;return n.sort(c).reverse(),u.sort(c).reverse(),[...u.map((r=>this._createGraphicHit(e,t.fromJSON(r)))),...l.map((t=>this._createGraphicHit(e,s.fromJSON(t)))),...n.map((t=>this._createGraphicHit(e,r.fromJSON(t))))]}async queryStatistics(){const e=await this.getWorker();return te(e.pipeline.queryStatistics(),{featureCount:0,ringCount:0,vertexCount:0})}async querySummaryStatistics(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e),i,r);return te(a,{})}async queryAggregateSummaryStatistics(e,t,r){const s={...t,scale:this.view.scale},i=(await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e),s,r);return te(i,{})}async queryUniqueValues(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.features.executeQueryForUniqueValues(this._cleanUpQuery(e),i,r);return te(a,{uniqueValueInfos:[]})}async queryAggregateUniqueValues(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e),i,r);return te(a,{uniqueValueInfos:[]})}async queryClassBreaks(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.features.executeQueryForClassBreaks(this._cleanUpQuery(e),i,r);return te(a,{classBreakInfos:[]})}async queryAggregateClassBreaks(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e),i,r);return te(a,{classBreakInfos:[]})}async queryHistogram(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.features.executeQueryForHistogram(this._cleanUpQuery(e),i,r);return te(a,{bins:[],maxValue:null,minValue:null,normalizationTotal:null})}async queryAggregateHistogram(e,t,r){const s=await this.getWorker(),i={...t,scale:this.view.scale},a=s.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e),i,r);return te(a,{bins:[],maxValue:null,minValue:null,normalizationTotal:null})}queryFeatures(e,t){return this.queryFeaturesJSON(e,t).then((e=>{const t=Q.fromJSON(e);return t.features.forEach((e=>this._setLayersForFeature(e))),t}))}async queryVisibleFeatures(e,t){const r=(await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e),t),s=await te(r,{features:[]}),i=Q.fromJSON(s);return i.features.forEach((e=>this._setLayersForFeature(e))),i}async queryAggregates(e,t){const r=(await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e),t),s=await te(r,{features:[]}),i=q.fromJSON(s);return i.features.forEach((e=>this._setLayersForFeature(e))),i}async queryAggregateIds(e,t){const r=(await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e),t);return te(r,[])}async queryAggregateCount(e,t){const r=(await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e),t);return te(r,0)}async queryAggregateJSON(e,t){const r=(await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e),t);return te(r,{features:[]})}async queryFeaturesJSON(e,t){const r=(await this.getWorker()).features.executeQuery(this._cleanUpQuery(e),t);return te(r,{features:[]})}async queryObjectIds(e,t){const r=(await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e),t);return te(r,[])}async queryFeatureCount(e,t){const r=(await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e),t);return te(r,0)}async queryExtent(e,t){const r=(await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e),t),s=await te(r,{count:0,extent:null});return{count:s.count,extent:j.fromJSON(s.extent)}}async queryAttributeBins(e,t){const r=(await this.getWorker()).features.executeAttributeBinsQuery(this._cleanUpAttributeBinsQuery(e),t),s=await te(r,{features:[]});return R.fromJSON(s)}async getSampleFeatures(e){return(await this.getWorker()).pipeline.getSampleFeatures(e)}setVisibility(e,t){t?this._visibilityOverrides.delete(e):this._visibilityOverrides.add(e),this._update()}update(e){if(!this.subscriptionManager)return;this.view.animation&&!this._lastTargetState&&(this._lastTargetState=e.state.clone()),!this.view.animation&&this._lastTargetState&&(this._lastTargetState=null);const t=this.subscriptionManager.update(e.targetState,this._lastTargetState),r=this.subscriptionManager.coverageSet;for(const s of this.featureContainer.tiles||[])s.isCoverage=r.has(s.id),s.neededForCoverage=t.has(s.id)||s.isCoverage;this.featureContainer.setVisibleTiles(t)}attach(){has("esri-2d-update-debug")&&console.debug("FeatureLayerView2D.attach"),f(this._updatingHandles.addPromise(this._workerAttached.promise)),f(this._attachProxy()),this.featureContainer=new D(this),this.container.addChild(this.featureContainer),this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`),this.subscriptionManager=new se({tileInfoView:this.view.featuresTilingScheme,updateSubscriptions:e=>{this.featureContainer.updateSubscriptions(e),f(this._updatingHandles.addPromise(this.getWorker().then((t=>t.pipeline.updateSubscriptions(e)))))},isDone:e=>this.featureContainer.isDone(e)}),this.requestUpdate(),this.addAttachHandles([he([()=>this._displayRefreshVersion,()=>this.layer.displayFilterInfo,()=>this.timeExtent,()=>this.clips,()=>this.filter,()=>this.effectiveDisplayFilterClause,()=>this.featureEffect,()=>this._sourceRefreshVersion,()=>this.view.timeZone,()=>this.view.timeExtent,...this.layerAdapter.getUpdateHashProperties(this.view)],(()=>this._update())),w((()=>this.updateSuspended),(e=>{e||(this.subscriptionManager.resume(),this.view.labelManager.requestUpdate())})),w((()=>this.visible),(e=>{this.view.labelManager.requestUpdate()}))]),this._update(),"stream"!==this.layer.type&&"parquet"!==this.layer.type&&"catalog-footprint"!==this.layer.type&&this.addAttachHandles(this.layer.on("edits",(e=>this._editUpdatingHandles.addPromise(this._edit(e)))))}detach(){has("esri-2d-update-debug")&&console.debug("FeatureLayerView2D.detach"),this._detachProxy(),this._fields=null,this.featureContainer.destroy(),this.featureContainer=null,this._commandsQueue.clear(),this.container.removeAllChildren(),this.subscriptionManager=c(this.subscriptionManager),this._workerProxy.pipeline.onDetach(),this._workerAttached=y(),f(this._workerAttached.promise),this._lastAvailableFields=[],this._lastSchema=null}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}addOverrides(e){return this._commandsQueue.push({type:"override",options:{...e,release:[]}})}removeOverrides(e){for(const r of e)if(null==r)throw new n("featurelayerview:bad-override","Tried to remove an override for an invalid objectId",{objectId:r});const t={added:[],updated:[],removed:[],release:e,isWeak:!1,historicMoment:null};return this._commandsQueue.push({type:"override",options:t})}isUpdating(){const e="renderer"in this.layer&&null!=this.layer.renderer,t=this._commandsQueue.updateTracking.updating,r=null!=this._updatingRequiredPromise,s=this.featureContainer.updatingHandles.updating,i=this.updateRequested||e&&(t||r)||s||this._pipelineUpdating||this.dataUpdating;if(has("esri-2d-log-updating")){console.log(`Updating FLV2D (${this.layer.id}): ${i}\n  -> updateRequested ${this.updateRequested}\n  -> hasRenderer ${e}\n  -> updatingRequiredFields ${r}\n  -> hasPendingCommand ${t}\n  -> dataUpdating ${this.dataUpdating}\n  -> processing ${this._pipelineUpdating}\n  -> updatingContainer ${s}\n`);for(const e of this.featureContainer.subscriptions())console.log(`    -> Tile[${e.id}] Done: ${e.done}`)}return i}_createClientOptions(){const e=this;return{get container(){return e.featureContainer},setUpdating:e=>{this._set("_pipelineUpdating",e.pipeline),this._set("_sourceUpdating",e.source)},emitEvent:e=>{this.emit(e.name,e.event)},get eventLog(){return e.eventLog},fetch:async t=>{if(has("esri-2d-stabilize-glyphs")){const r=[];for(const s of t)r.push(await e.view.stage.painter.textureManager.rasterizeItem(s));return r}return Promise.all(t.map((t=>e.view.stage.painter.textureManager.rasterizeItem(t))))},fetchDictionary:e=>Promise.all(e.map((e=>this._fetchDictionaryRequest(e))))}}async _fetchDictionaryRequest(e){try{if("subtype-group"===this.layer.type)throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");const t=this.layer.renderer;if(!t||"dictionary"!==t.type)throw new Error("InternalError: Expected layer to have a DictionaryRenderer");const r=this._lastSchema.processor.mesh.factory.symbology;if("dictionary"!==r.type)throw new Error("InternalError: Expected schema to be of type 'dictionary'");const s={cimAnalyzer:this.view.stage.cimAnalyzer,cimResourceManager:this.view.stage.painter.textureManager.resourceManager,store:this.featureContainer.instanceStore,scaleExpression:r.scaleExpression};this._fields||(this._fields=this.layer.fields.map((e=>e.toJSON())));const i=r.visualVariableUniforms,a=re(this.layer.geometryType),o=await t.getSymbolForControlString(e.controlString,a,!1);if(!o||!o.data)return{type:"dictionary-response",meshes:[]};return{type:"dictionary-response",meshes:await X({...o.data,hasTextStringTemplates:!0},{uniforms:i,path:"renderer",schemaOptions:s})}}catch(t){return{type:"dictionary-response",meshes:[]}}}_cleanUpQuery(e){const t=L.from(e)||this.createQuery();return t.outSpatialReference||(t.outSpatialReference=this.view.spatialReference),t.toJSON()}_cleanUpAttributeBinsQuery(e){const t=O.from(e);return t.outSpatialReference||(t.outSpatialReference=this.view.spatialReference),t.toJSON()}_cleanUpAggregateQuery(e){const t=L.from(e)||this.createAggregateQuery();t.outSpatialReference||(t.outSpatialReference=this.view.spatialReference);const r=t.objectIds??[];for(const s of t.aggregateIds??[])r.push(s);return t.objectIds=r,t.aggregateIds=[],t.toJSON()}async _update(){return this._commandsQueue.push({type:"update"})}_edit(e){return this.updateSuspended?(this.subscriptionManager.suspend(),Promise.resolve()):this._commandsQueue.push({type:"edit",event:e})}async doRefresh(e){this.attached&&(this.updateSuspended&&e||(e?this.incrementSourceRefreshVersion():this.incrementDisplayRefreshVersion()))}incrementSourceRefreshVersion(){this._sourceRefreshVersion=(this._sourceRefreshVersion+1)%le+1}incrementDisplayRefreshVersion(){this._displayRefreshVersion=(this._displayRefreshVersion+1)%le+1}async _resolveIdenifiers(e){const t=[],r=[];for(const a of e)null==a.objectId||-1===a.objectId?null==a.globalId?h.getLogger(this).warn("mapview-apply-edits","A feature identifier must contain either a GlobalId or ObjectId. Ignoring",{identifier:a}):r.push(a.globalId):t.push(a.objectId);const s="globalIdField"in this.layer&&this.layer.globalIdField,i=s&&this.availableFields.includes(s);if(r.length&&!i)return h.getLogger(this).error(new n("mapview-apply-edits",`Editing the specified service requires the layer's globalIdField, ${s} to be included the layer's outFields for updates to be reflected on the map`)),t;if(r.length){const e=await this._workerProxy.pipeline.getObjectIdsFromGlobalIds(r);for(const r of e)t.push(r)}return t}_resolveOverrides(e){const t=!1,r=!1,s=re(this.layer.geometryType),i=N(this.layer),a=[];for(const o of e.added){const e=I(o,s,t,r,i);if(null==e.objectId)throw new n("featurelayerview:bad-override","Feature does not have an objectId",{feature:o});a.push(e)}for(const o of e.updated){const e=I(o,s,t,r,i);if(null==e.objectId)throw new n("featurelayerview:bad-override","Feature does not have an objectId",{feature:o});a.push(e)}for(const o of e.removed)if(null==o)throw new n("featurelayerview:bad-override","Tried to remove an invalid objectId",{objectId:o});return{type:"override",updates:a,removed:e.removed,release:e.release,isWeak:e.isWeak??!1,historicMoment:e.historicMoment??null}}async _resolveEdit(e){const t=this.layer,r=e.historicMoment?.getTime()??null,s="layerId"in t&&e.editedFeatures?.find((e=>e.layerId===t.layerId));if(s&&this._canEditByFeature(s)){const{adds:e,deletes:t,updates:i}=s.editedFeatures,a=this.layer.objectIdField,o=i.map((e=>e.current)),n=t.map((e=>"attributes"in e?{objectId:a?e.attributes[a]:null}:e)),u=await this._resolveIdenifiers(n);return this._resolveOverrides({added:e,updated:o,removed:u,historicMoment:r,isWeak:!0,release:[]})}const[i,a,o]=await Promise.all([this._resolveIdenifiers(e.addedFeatures),this._resolveIdenifiers(e.updatedFeatures),this._resolveIdenifiers(e.deletedFeatures)]);return{type:"override-by-id",updates:[...i,...a],removed:o,historicMoment:r,isWeak:!0}}_canEditByFeature(e){const{adds:t,updates:r}=e.editedFeatures;return t.every((e=>this.view.spatialReference.equals(e.geometry?.spatialReference)))&&r.every((e=>this.view.spatialReference.equals(e.current.geometry?.spatialReference)))}async _doUpdate(){"featureReduction"in this.layer&&this.layer.featureReduction&&this.layer.featureReduction!==this._lastFeatureReduction&&(this.layer.featureReduction=this.layer.featureReduction?.clone(),this._lastFeatureReduction=this.layer.featureReduction);try{if(await Promise.allSettled([this._handleChange(),E(this.layer)]),this.destroyed||!this.layerAdapter?.hasRequiredSupport||!this.subscriptionManager)return;const e=this.featureContainer.instanceStore;this.featureContainer.attributeView.lockTextureUploads();const t=this._lastSchema?.processor.mesh.factory.symbology?.type;let r=!0;"subtype-group"!==this.layer.type&&"dictionary"===this.layer.renderer?.type&&"dictionary"===t&&(r=!1),e.updateStart(r);const s=this.featureEffect,i={store:e,cimAnalyzer:this.view.stage.cimAnalyzer,cimResourceManager:this.view.stage.painter.textureManager.resourceManager,scaleExpression:void 0},a=await this._createViewSchemaConfig(),o={source:this.layerAdapter.createSourceSchema(a,this._sourceRefreshVersion),processor:await this.layerAdapter.createProcessorSchema(i,a,this._displayRefreshVersion)},n=o.processor.mesh.factory.labels;n&&this.view.labelManager.setLabelSchemaStyles(n,this.featureContainer);const u=p(this._lastSchema?.source.mutable,o.source.mutable)||p(this._lastSchema?.processor,o.processor);if(!u)return this.featureContainer.requestRender(),this.featureContainer.attributeView.unlockTextureUploads(),e.updateEnd(r),void(this.featureEffectView.featureEffect=s);this._lastSchema=o,this._fields=null;const l=Math.round(performance.now());has("esri-2d-update-debug")&&console.debug(`Id[${this.layer.uid}] Version[${l}] FeatureLayerView2D._doUpdate`,{changes:u});const h=await this.getWorker();await h.pipeline.updateSchema(o,l),e.updateEnd(r),this.featureEffectView.featureEffect=s,this.featureEffectView.endTransition(),this.featureContainer.restartAllAnimations(),this.featureContainer.attributeView.unlockTextureUploads(),this.featureContainer.trySwapRenderState(),this.featureContainer.requestRender(),has("esri-2d-update-debug")&&console.debug(`Version[${l}] FeatureLayerView2D.updateEnd`),this.requestUpdate()}catch(e){has("esri-2d-update-debug")&&console.error("Encountered an error during update",e)}}async _doOverride(e){const t=await this.getWorker();try{for(const r of e.messages)switch(r.type){case"edit":{const e=new Y;e.add(await this._resolveEdit(r.event)),await t.pipeline.onOverride(e.toMessage());break}case"override":{const e=new Y;e.add(this._resolveOverrides(r.options)),await t.pipeline.onOverride(e.toMessage());break}}}catch(r){m(r),0}}_getEffectiveAvailableFields(e){const t=ue(this._lastAvailableFields,e);return this._lastAvailableFields=t,k(this.layer.fieldsIndex,t)}async _createViewSchemaConfig(){const e=this.requiresCurrentUser?await this.signedInUser:null,t=[pe(this.view,this.layerAdapter,this.timeExtent,this._visibilityOverrides,this.filter,this.effectiveDisplayFilterClause),this.featureEffect?.filter?.toJSON()??null];return{availableFields:this._getEffectiveAvailableFields(this.availableFields),displayFilterEnabled:this.displayFilterEnabled,filters:t,scale:this.view.scale,timeZone:this.view.timeZone,timeExtent:this.view.timeExtent,currentUser:e}}_processHighlight(){this._commandsQueue.push({type:"highlight"})}async _updateHighlights(){const e=this._getHighlights(),t=await this.getWorker();if(this.destroyed)return;const r=t.pipeline.updateHighlight({highlights:e}).catch((e=>{m(e)||h.getLogger(this).error(e)}));this._updatingHandles.addPromise(r)}_setLayersForFeature(e){e.layer=e.sourceLayer=this.layer,this.layerAdapter.setGraphicOrigin&&this.layerAdapter.setGraphicOrigin(e)}_createGraphicHit(e,t){return this._setLayersForFeature(t),null!=t.geometry&&(t.geometry.spatialReference=this.view.spatialReference),{type:"graphic",graphic:t,layer:this.layer,mapPoint:e}}};function pe(e,t,r,s,i,a){i&&(i=i.clone());const o=null!=i?i.timeExtent:null,n=null!=r&&null!=o?r.intersection(o):r||o;n&&(i??=new x,i.timeExtent=n),i=t.addFilters?.(i,e)??i,a&&(i??=new x,i.where=b(i.where,a));let u=i?.toJSON()??null;return s.size&&(u??=(new x).toJSON(),u.hiddenIds=Array.from(s)),u}e([F()],ce.prototype,"_commandsQueue",void 0),e([F()],ce.prototype,"_sourceRefreshVersion",void 0),e([F()],ce.prototype,"_displayRefreshVersion",void 0),e([F({readOnly:!0})],ce.prototype,"_pipelineUpdating",void 0),e([F()],ce.prototype,"_sourceUpdating",void 0),e([F({readOnly:!0})],ce.prototype,"dataUpdating",null),e([F({readOnly:!0})],ce.prototype,"effectiveDisplayFilterClause",null),e([F({readOnly:!0})],ce.prototype,"hasAllFeatures",null),e([F({readOnly:!0})],ce.prototype,"hasAllFeaturesInView",null),e([F({readOnly:!0})],ce.prototype,"hasFullGeometries",null),e([F()],ce.prototype,"featureEffectView",void 0),e([F()],ce.prototype,"labelingCollisionInfos",null),e([F()],ce.prototype,"layerAdapter",null),e([F({readOnly:!0})],ce.prototype,"timeExtent",null),e([F()],ce.prototype,"updating",void 0),ce=e([S("esri.views.2d.layers.FeatureLayerView2D")],ce);export{ce as default};
