/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{BucketType as t}from"../enums.js";import{isCircleOverlapingRect as e}from"../GeometryUtils.js";import{VTLSymbol as o}from"./core.js";function s(t,e,o,s){return r(t,e,o.level,o.col,s.key.level,s.key.col)}function l(t,e,o,s){return r(t,e,o.level,o.row,s.level,s.row)}function r(t,e,o,s,l,r){const i=o-l;if(i>=0)return(e>>i)+(s-(r<<i))*(t>>i);const n=-i;return e-(r-(s<<n))*(t>>n)<<n}class i{constructor(t,e,o){this._rows=Math.ceil(e/o),this._columns=Math.ceil(t/o),this._cellSize=o,this.cells=new Array(this._rows);for(let s=0;s<this._rows;s++){this.cells[s]=new Array(this._columns);for(let t=0;t<this._columns;t++)this.cells[s][t]=[]}}getCell(t,e){const o=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),s=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[o]&&this.cells[o][s]||null}getCellSpan(t,e,o,s){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(o/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function n(t,e,s,l,r,i,n){const c=e[l++];for(let a=0;a<c;a++){const c=new o(i,n);c.xTile=e[l++],c.yTile=e[l++],c.hash=e[l++],c.priority=e[l++],c.featureIndex=e[l++];const a=e[l++],h=c.colliders();for(let t=0;t<a;t++){const t=e[l++],o=e[l++],r=e[l++],i=e[l++],n=!!e[l++],c=e[l++],a=s[l++],u=s[l++],f=e[l++],m=e[l++];h.push({xTile:t,yTile:o,dxPixels:r,dyPixels:i,hard:n,partIndex:c,width:f,height:m,minLod:a,maxLod:u})}const u=t[l++];for(let e=0;e<u;e++)c.textVertexRanges.push([t[l++],t[l++]]);const f=t[l++];for(let e=0;e<f;e++)c.iconVertexRanges.push([t[l++],t[l++]]);r.push(c)}return l}function c(t,e,o){for(const[s,l]of t.symbols)a(t,e,o,l,s)}function a(e,o,s,l,r){const i=e.layerData.get(r);if(i.type===t.SYMBOL){for(const t of l){const o=t.uniqueSymbol;let l;if(t.selectedForRendering){const t=o.parts[0],r=t.startOpacity,i=t.targetOpacity;e.allSymbolsFadingOut=e.allSymbolsFadingOut&&0===i;const n=s?Math.floor(127*r)|i<<7:i?255:0;l=n<<24|n<<16|n<<8|n}else l=0;for(const[e,s]of t.iconVertexRanges)for(let t=e;t<e+s;t+=4)i.iconOpacity[t/4]=l;if(t.selectedForRendering){const t=o.parts[1],r=t.startOpacity,i=t.targetOpacity;e.allSymbolsFadingOut=e.allSymbolsFadingOut&&0===i;const n=s?Math.floor(127*r)|i<<7:i?255:0;l=n<<24|n<<16|n<<8|n}else l=0;for(const[e,s]of t.textVertexRanges)for(let t=e;t<e+s;t+=4)i.textOpacity[t/4]=l}i.lastOpacityUpdate=o,i.opacityChanged=!0}}function h(t,o,s,l){const r=t.colliders();let i,n,c,a;for(const h of r){if(t.uniqueSymbol?.show&&t.uniqueSymbol.parts[h.partIndex].show&&(i=h.xScreen-l[0]+h.dxScreen,n=h.yScreen-l[1]+h.dyScreen,c=i+h.width,a=n+h.height,e(s,o.x,o.y,i,n,c,a)))return!0}return!1}export{i as GridIndex,n as deserializeSymbols,h as isSearchCircleOverlapingSymbol,s as tileCoordChangeX,l as tileCoordChangeY,c as writeOpacityToBuffers};
