/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{clone as e}from"../../../../../core/lang.js";import{StyleLayerType as t,SymbolPlacement as r,RotationAlignment as a}from"./StyleDefinition.js";import{CircleStyleLayer as i,SymbolStyleLayer as s,LineStyleLayer as l,FillStyleLayer as n,BackgroundStyleLayer as y}from"./StyleLayer.js";class o{constructor(r,a=!0){if(this.backgroundBucketIds=[],this._uidToLayer=new Map,this._layerByName={},this._runningId=0,this._style=a?e(r):r,this._style.layers||(this._style.layers=[]),this.version=parseFloat(this._style.version),this.layers=this._style.layers.map(((e,t,r)=>this._create(e,t,r))).filter((e=>!!e)),this.layers)for(let e=0;e<this.layers.length;e++){const r=this.layers[e];this._layerByName[r.id]=r,this._uidToLayer.set(r.uid,r),r.type===t.BACKGROUND&&this.backgroundBucketIds.push(r.id)}this._identifyRefLayers()}getLayerStyleProperties(e,t){const i=this.getStyleLayerByUID(e),s=i?.getLayoutValue("symbol-placement",t)!==r.POINT;let l=i?.getLayoutValue("icon-rotation-alignment",t);l===a.AUTO&&(l=s?a.MAP:a.VIEWPORT);let n=i?.getLayoutValue("text-rotation-alignment",t);n===a.AUTO&&(n=s?a.MAP:a.VIEWPORT);const y=i?.getPaintValue("icon-translate",t),o=i?.getPaintValue("icon-translate-anchor",t),u=i?.getPaintValue("text-translate",t),c=i?.getPaintValue("text-translate-anchor",t);return{geometryType:null,iconAllowOverlap:i?.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:i?.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:i?.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:i?.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:l,textRotationAlignment:n,iconTranslateAnchor:o,iconTranslate:y,textTranslateAnchor:c,textTranslate:u}}isPainterDataDriven(e){const t=this._layerByName[e];return!!t&&t.isPainterDataDriven()}getStyleLayerId(e){return e>=this.layers.length?null:this.layers[e].id}getStyleLayerByUID(e){return this._uidToLayer.get(e)??null}getStyleLayerIndex(e){const t=this._layerByName[e];return t?this.layers.indexOf(t):-1}setStyleLayer(e,t){if(!e?.id)return;const r=this._style;null!=t&&t>=this.layers.length&&(t=this.layers.length-1);let a,i=!0;const s=this._layerByName[e.id];if(s){const l=this.layers.indexOf(s);t||(t=l),t===l?(i=!1,a=o._recreateLayer(e,s),this.layers[t]=a,r.layers[t]=e):(this.layers.splice(l,1),r.layers.splice(l,1),a=this._create(e,t,this.layers),this.layers.splice(t,0,a),r.layers.splice(t,0,e))}else a=this._create(e,t,this.layers),!t||t>=this.layers.length?(this.layers.push(a),r.layers.push(e)):(this.layers.splice(t,0,a),r.layers.splice(t,0,e));this._layerByName[e.id]=a,this._uidToLayer.set(a.uid,a),i&&this._recomputeZValues(),this._identifyRefLayers()}getStyleLayer(e){const t=this._layerByName[e];return t?{type:t.typeName,id:t.id,source:t.source,"source-layer":t.sourceLayer,minzoom:t.minzoom,maxzoom:t.maxzoom,filter:t.filter,layout:t.layout,paint:t.paint}:null}deleteStyleLayer(e){const t=this._layerByName[e];if(t){delete this._layerByName[e],this._uidToLayer.delete(t.uid);const r=this.layers.indexOf(t);this.layers.splice(r,1),this._style.layers.splice(r,1),this._recomputeZValues(),this._identifyRefLayers()}}getLayerById(e){return this._layerByName[e]}getLayoutProperties(e){const t=this._layerByName[e];return t?t.layout:null}getPaintProperties(e){const t=this._layerByName[e];return t?t.paint:null}setPaintProperties(e,t){const r=this._layerByName[e];if(!r)return;const a={type:r.typeName,id:r.id,source:r.source,"source-layer":r.sourceLayer,minzoom:r.minzoom,maxzoom:r.maxzoom,filter:r.filter,layout:r.layout,paint:t},i=o._recreateLayer(a,r),s=this.layers.indexOf(r);this.layers[s]=i,this._style.layers[s].paint=t,this._layerByName[r.id]=i,this._uidToLayer.set(r.uid,i)}setLayoutProperties(e,t){const r=this._layerByName[e];if(!r)return;const a={type:r.typeName,id:r.id,source:r.source,"source-layer":r.sourceLayer,minzoom:r.minzoom,maxzoom:r.maxzoom,filter:r.filter,layout:t,paint:r.paint},i=o._recreateLayer(a,r),s=this.layers.indexOf(r);this.layers[s]=i,this._style.layers[s].layout=t,this._layerByName[r.id]=i,this._uidToLayer.set(r.uid,i)}setStyleLayerVisibility(e,t){const r=this._layerByName[e];if(!r)return;const a=r.layout||{};a.visibility=t;const i={type:r.typeName,id:r.id,source:r.source,"source-layer":r.sourceLayer,minzoom:r.minzoom,maxzoom:r.maxzoom,filter:r.filter,layout:a,paint:r.paint},s=o._recreateLayer(i,r),l=this.layers.indexOf(r);this.layers[l]=s,this._style.layers[l].layout=a,this._layerByName[r.id]=s,this._uidToLayer.set(r.uid,s)}getStyleLayerVisibility(e){const t=this._layerByName[e];if(!t)return"none";const r=t.layout;return r?.visibility??"visible"}_recomputeZValues(){const e=this.layers,t=1/(e.length+1);for(let r=0;r<e.length;r++)e[r].z=1-(1+r)*t}_identifyRefLayers(){const e=[],r=[];let a=0;for(const i of this.layers){const s=i.layout;if(i.type===t.FILL){const t=i;let r=i.source+"|"+i.sourceLayer;r+="|"+(s?.visibility??""),r+="|"+i.minzoom,r+="|"+i.maxzoom,r+="|"+JSON.stringify(i.filter),(t.hasDataDrivenFill||t.hasDataDrivenOutline)&&(r+="|"+a),e.push({key:r,layer:i})}else if(i.type===t.LINE){const e=i,t=i.paint,l=null!=t&&(null!=t["line-pattern"]||null!=t["line-dasharray"]);let n=i.source+"|"+i.sourceLayer;n+="|"+(s?.visibility??""),n+="|"+i.minzoom,n+="|"+i.maxzoom,n+="|"+JSON.stringify(i.filter),n+="|"+(void 0!==s?s["line-cap"]:""),n+="|"+(void 0!==s?s["line-join"]:""),(e.hasDataDrivenLine||l)&&(n+="|"+a),r.push({key:n,layer:i})}++a}this._assignRefLayers(e),this._assignRefLayers(r)}_assignRefLayers(e){let r,a;e.sort(((e,t)=>e.key<t.key?-1:e.key>t.key?1:0));const i=e.length;for(let s=0;s<i;s++){const l=e[s];if(l.key===r)l.layer.refLayerId=a;else if(r=l.key,a=l.layer.id,l.layer.type===t.FILL){if(!l.layer.getPaintProperty("fill-outline-color"))for(let t=s+1;t<i;t++){const i=e[t];if(i.key!==r)break;if(i.layer.getPaintProperty("fill-outline-color")){e[s]=i,e[t]=l,a=i.layer.id;break}}}else if(l.layer.type===t.LINE){let t=l.layer;for(let n=s+1;n<i;n++){const i=e[n];if(i.key!==r)break;const y=i.layer;(t.canUseThinTessellation&&!y.canUseThinTessellation||!t.canUseThinTessellation&&(y.getPaintProperty("line-pattern")||y.getPaintProperty("line-dasharray")))&&(t=y,e[s]=i,e[n]=l,a=i.layer.id)}}}}_create(e,r,a){const o=1-(1+r)*(1/(a.length+1)),u=this._runningId++;switch(e.type){case"background":return new y(t.BACKGROUND,e,o,u);case"fill":return new n(t.FILL,e,o,u);case"line":return new l(t.LINE,e,o,u);case"symbol":return new s(t.SYMBOL,e,o,u);case"raster":return console.warn(`Unsupported vector tile raster layer ${e.id}`),null;case"circle":return new i(t.CIRCLE,e,o,u)}return null}static _recreateLayer(e,r){switch(e.type){case"background":return new y(t.BACKGROUND,e,r.z,r.uid);case"fill":return new n(t.FILL,e,r.z,r.uid);case"line":return new l(t.LINE,e,r.z,r.uid);case"symbol":return new s(t.SYMBOL,e,r.z,r.uid);case"raster":return console.warn(`Unsupported vector tile raster layer ${e.id}`),null;case"circle":return new i(t.CIRCLE,e,r.z,r.uid)}return null}}export{o as default};
