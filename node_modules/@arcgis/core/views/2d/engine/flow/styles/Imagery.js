/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{throwIfAborted as t}from"../../../../../core/promiseUtils.js";import{timeExtentsEqual as a,setUniforms as e}from"../utils.js";import{BufferObject as r}from"../../../../webgl/BufferObject.js";import{BlendFactor as s,PrimitiveType as o,Usage as i,PixelFormat as n,TextureWrapMode as m,DataType as l}from"../../../../webgl/enums.js";import{Texture as p}from"../../../../webgl/Texture.js";import{TextureDescriptor as c}from"../../../../webgl/TextureDescriptor.js";import{VertexArrayObject as h}from"../../../../webgl/VertexArrayObject.js";import{VertexElementDescriptor as _}from"../../../../webgl/VertexElementDescriptor.js";class f{constructor(t){this._params=t,this.animated=!1}isCompatible(t){if(!(t instanceof f))return!1;if(!a(this._params.timeExtent,t._params.timeExtent))return!1;let e=!0;return e=e&&this._params.loadImagery===t._params.loadImagery,e=e&&this._params.color.kind===t._params.color.kind,e=e&&this._params.opacity.kind===t._params.opacity.kind,e}async load(a,e){const{extent:r,size:s}=a;t(e);const o=await this._params.loadImagery(r,s[0],s[1],this._params.timeExtent,e);return new x(o,{color:this._params.color,opacity:this._params.opacity})}render(t,a,r){const{context:i}=t,{program:n}=r;i.setFaceCullingEnabled(!1),i.setBlendingEnabled(!0),i.setBlendFunction(s.ONE,s.ONE_MINUS_SRC_ALPHA),i.useProgram(n),n.setUniformMatrix3fv("u_dvsMat3",a.dvsMat3),i.bindTexture(r.texture,0),n.setUniform1i("u_texture",0),n.setUniform1f("u_Min",r.min),n.setUniform1f("u_Max",r.max),e(n,"color","vec4",this._params.color),e(n,"opacity","float",this._params.opacity),i.bindVAO(r.vertexArray),i.drawArrays(o.TRIANGLE_STRIP,0,4)}}const d=new Map;d.set("a_position",0),d.set("a_texcoord",1);const w=new Map([["geometry",[new _("a_position",2,l.UNSIGNED_SHORT,0,8),new _("a_texcoord",2,l.UNSIGNED_SHORT,4,8)]]]),u={vsPath:"raster/flow/imagery",fsPath:"raster/flow/imagery",attributes:d};class x{constructor(t,a){this._flowData=t,this._values=a}attach(t){const{context:a}=t,{width:e,height:s}=this._flowData,o=r.createVertex(a,i.STATIC_DRAW,new Uint16Array([0,0,0,1,e,0,1,1,0,s,0,0,e,s,1,0])),l=new Map([["geometry",o]]),_=new h(a,d,w,l),f=[];"ramp"===this._values.color.kind&&f.push("vvColor"),"ramp"===this._values.opacity.kind&&f.push("vvOpacity");const x=t.getProgram(u,f);let y=1e6,g=-1e6;for(let r=0;r<s;r++)for(let t=0;t<e;t++)if(0!==this._flowData.mask[r*e+t]){const a=this._flowData.data[2*(r*e+t)],s=this._flowData.data[2*(r*e+t)+1],o=Math.sqrt(a*a+s*s);y=Math.min(y,o),g=Math.max(g,o)}const A=new Uint8Array(4*e*s);for(let r=0;r<s;r++)for(let t=0;t<e;t++)if(0!==this._flowData.mask[r*e+t]){const a=this._flowData.data[2*(r*e+t)],s=this._flowData.data[2*(r*e+t)+1],o=(Math.sqrt(a*a+s*s)-y)/(g-y);A[4*(r*e+t)]=255*o,A[4*(r*e+t)+1]=0,A[4*(r*e+t)+2]=0,A[4*(r*e+t)+3]=255}else A[4*(r*e+t)]=0,A[4*(r*e+t)+1]=0,A[4*(r*e+t)+2]=0,A[4*(r*e+t)+3]=0;const b=new c;b.internalFormat=n.RGBA,b.wrapMode=m.CLAMP_TO_EDGE,b.flipped=!0,b.width=e,b.height=s;const v=new p(a,b,A);this.vertexArray=_,this.program=x,this.texture=v,this.min=y,this.max=g,this._flowData=null}detach(){this.vertexArray.dispose(),this.texture.dispose()}get ready(){return this.program.compiled}}export{f as Imagery,x as ImageryResources};
