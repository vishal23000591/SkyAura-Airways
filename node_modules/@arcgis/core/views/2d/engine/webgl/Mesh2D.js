/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import r from"../../../../core/Logger.js";import{e as t}from"../../../../chunks/earcut.js";import{set as o}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{convertFromNestedArray as s,convertFromPolygon as i}from"../../../../layers/graphics/featureConversionUtils.js";import c from"../../../../layers/graphics/OptimizedGeometry.js";import{i1616to32 as a}from"./number.js";import{BufferObject as f}from"../../../webgl/BufferObject.js";import{PrimitiveType as m,Usage as h}from"../../../webgl/enums.js";const l=(e,r,t,o)=>{let n=0;for(let s=1;s<t;s++){const t=e[2*(r+s-1)],o=e[2*(r+s-1)+1];n+=(e[2*(r+s)]-t)*(e[2*(r+s)+1]+o)}return o?n>0:n<0},u=({coords:e,lengths:r},o)=>{const n=[];for(let s=0,i=0;s<r.length;i+=r[s],s+=1){const c=i,a=[];for(;s<r.length-1&&l(e,i+r[s],r[s+1],o);s+=1,i+=r[s])a.push(i+r[s]-c);const f=e.slice(2*c,2*(i+r[s])),m=t(f,a,2);for(const e of m)n.push(e+c)}return n};class y{constructor(e,r,t,o=!1){this._cache={},this.vertices=e,this.indices=r,this.primitiveType=t,this.isMapSpace=o}static fromPath(e){const r=s(new c,e.path,!1,!1),t=r.coords,o=new Uint32Array(u(r,!0)),n=new Uint32Array(t.length/2);for(let s=0;s<n.length;s++)n[s]=a(Math.floor(t[2*s]),Math.floor(t[2*s+1]));return new y({geometry:n},o,m.TRIANGLES)}static fromGeometry(t,o){const n=o.geometry?.type;switch(n){case"polygon":return y.fromPolygon(t,o.geometry);case"extent":return y.fromMapExtent(t,o.geometry);default:return r.getLogger("esri.views.2d.engine.webgl.Mesh2D").error(new e("mapview-bad-type",`Unable to create a mesh from type ${n}`,o)),y.fromScreenExtent({xmin:0,ymin:0,xmax:1,ymax:1})}}static fromPolygon(e,r){const t=i(new c,r,!1,!1),s=t.coords,f=new Uint32Array(u(t,!1)),h=new Uint32Array(s.length/2),l=n(),x=n();for(let n=0;n<h.length;n++)o(l,s[2*n],s[2*n+1]),e.toScreen(x,l),h[n]=a(Math.floor(x[0]),Math.floor(x[1]));return new y({geometry:h},f,m.TRIANGLES,!0)}static fromScreenExtent({xmin:e,xmax:r,ymin:t,ymax:o}){const n={geometry:new Uint32Array([a(e,t),a(r,t),a(e,o),a(e,o),a(r,t),a(r,o)])},s=new Uint32Array([0,1,2,3,4,5]);return new y(n,s,m.TRIANGLES)}static fromMapExtent(e,r){const[t,o]=e.toScreen([0,0],[r.xmin,r.ymin]),[n,s]=e.toScreen([0,0],[r.xmax,r.ymax]),i={geometry:new Uint32Array([a(t,o),a(n,o),a(t,s),a(t,s),a(n,o),a(n,s)])},c=new Uint32Array([0,1,2,3,4,5]);return new y(i,c,m.TRIANGLES)}destroy(){null!=this._cache.indexBuffer&&this._cache.indexBuffer.dispose(),this._cache.vertexBuffers?.forEach((e=>e?.dispose())),this._cache.indexBuffer=this._cache.vertexBuffers=null}getIndexBuffer(e,r=h.STATIC_DRAW){return this._cache.indexBuffer??=f.createIndex(e,r,this.indices),this._cache.indexBuffer}getVertexBuffers(e,r=h.STATIC_DRAW){return this._cache.vertexBuffers??=new Map(Object.keys(this.vertices).reduce(((t,o)=>(t.push([o,f.createVertex(e,r,this.vertices[o])]),t)),new Array)),this._cache.vertexBuffers}}export{y as default};
