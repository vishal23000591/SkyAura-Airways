/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{GraphShaderModule as o,FragmentOutput as s,location as r,uniform as i,define as n,input as a,VertexInput as p,UniformGroup as l,FragmentInput as u}from"../../GraphShaderModule.js";import{Vec4 as d,texture2D as m,Float as c,Vec2 as y,Sampler2D as v}from"../../graph/glsl.js";import{getHeatmapCompressionFactor as x}from"./heatmapUtils.js";class g extends p{}t([r(0,y)],g.prototype,"position",void 0);class f extends u{}class h extends l{}t([i(v)],h.prototype,"texture",void 0),t([i(y)],h.prototype,"minAndInvRange",void 0),t([i(c)],h.prototype,"normalization",void 0);class w extends l{}t([i(v)],w.prototype,"texture",void 0);class b extends o{constructor(){super(...arguments),this.type="HeatmapResolveShader",this.usesHalfFloatPrecision=!1}vertex(t){return{glPosition:new d(t.position.multiply(2).subtract(1),1,1),uv:t.position}}fragment(t){const{accumulatedDensity:e,gradient:o}=this;let r=m(e.texture,t.uv).r.divide(new c(x(this.usesHalfFloatPrecision)));r=r.multiply(e.normalization),r=r.subtract(e.minAndInvRange.x).multiply(e.minAndInvRange.y);const i=m(o.texture,new y(r,.5)),n=new s;return n.fragColor=new d(i.rgb.multiply(i.a),i.a),n}}t([n],b.prototype,"usesHalfFloatPrecision",void 0),t([i(h)],b.prototype,"accumulatedDensity",void 0),t([i(w)],b.prototype,"gradient",void 0),t([e(0,a(g))],b.prototype,"vertex",null),t([e(0,a(f))],b.prototype,"fragment",null);export{h as AccumulatedDensity,w as Gradient,f as HeatmapResolveFragmentInput,b as HeatmapResolveShader,g as HeatmapResolveVertexInput};
