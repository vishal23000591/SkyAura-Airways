/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{GeometryCursor as e}from"../../../../../../../geometry/GeometryCursor.js";import{CIMEffectHelper as t}from"../../../../../../../symbols/cim/effects/CIMEffectHelper.js";import{loadGeometryEngine as r,getGeometryEngine as s}from"./loadGeometryEngine.js";import{MeshWriterVertexPack as a}from"./MeshWriterVertexPack.js";function i(e){if(!e)return!1;for(const t of e)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1}class c{constructor(e,t,r,s){this._instanceId=e,this._evaluator=t,this._enabledOptionalAttributes=r,this._viewParams=s,this._evaluator.evaluator=e=>this.vertexSpec.createComputedParams(e)}get _vertexPack(){if(!this._cachedVertexPack){const e=a.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||e.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=e}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(e){this._references=e}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){i(this.effectInfos)&&await r()}enqueueRequest(e,t,r){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(e,t,r)}write(e,t,r,s,a){this.ensurePacked(t,r,s);const i=this.evaluatedMeshParams.effects;if(!i||0===i.length)return void this._write(e,r,void 0,a);const c=this.getEffectCursor(e,r,i);if(!c)return;let n;for(;n=c.next();)n.invertY(),this._write(e,r,n,a)}ensurePacked(e,t,r){if(!this._evaluator.hasDynamicProperties)return;const s=this._evaluator.evaluateMeshParams(e,t,r);this._vertexPack.pack(s,this._viewParams)}hasArcadeDependency(e){return this._evaluator.hasArcadeDependency(e)}_writeVertex(e,t,r,s,a){const i=this.evaluatedMeshParams;this._vertexPack.writeVertex(e,t,r,s,i,a)}getEffectCursor(r,a,i){const c=a.readGeometryForDisplay()?.clone();if(!c)return;const n=e.fromOptimizedCIM(c,a.geometryType),o=s();n.invertY();const f=r.id||"";return t.executeEffects(i,n,f,o,this._preventEffectClipping)}}export{c as MeshWriter};
