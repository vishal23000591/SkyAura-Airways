/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{disposeMaybe as e}from"../../../../../../../../core/maybe.js";import{tileSize as t}from"../../../../definitions.js";import{Technique as r}from"../../Technique.js";import{createNewFBO as n,createProcessedTexture as s}from"./textureUtils.js";import{BlendFactor as o}from"../../../../../../../webgl/enums.js";import{createColormapTexture as a}from"../../../../../../../webgl/rasterUtils.js";class i extends r{shutdown(e){super.shutdown(e),this._fbo?.dispose(),this._fbo=void 0}render(r,i){const{rasterFunction:u}=r;if(!u)return;const{context:m}=r,p="indexedColormap"in u.parameters?a(m,u.parameters.indexedColormap):void 0,d="Reproject"===u.name,l=m.getBoundFramebufferObject(),c=m.getViewport();for(const a of i.bitmaps){const l=d?!(a.rasterTexture&&a.projected):!a.processed;if(!a.source||!l||a.suspended)continue;r.timeline.begin(this.name);const{painter:c}=r;c.setPipelineState({depth:!1,stencil:{test:!1,write:!1},color:{write:[!0,!0,!0,!0],blendMode:"custom",blendParameters:{srcRGB:o.ONE,dstRGB:o.ZERO,srcAlpha:o.ONE,dstAlpha:o.ZERO}}}),d||(a.processedTexture=e(a.processedTexture)),a.updateTexture(r);const[g,f]=a.getRasterTextureSize(d),h=g===t&&f===t,x=h?i.processorFbo:n(m,g,f);m.bindFramebuffer(x),m.setViewport(0,0,x.width,x.height),this._process(r,a,p);const w=s(r.context,g,f);if(x.copyToTexture(0,0,g,f,0,0,w),d)a.rasterTexture=w;else{const e=r.hasBranches?u.id:0;a.functionTextures[e]=w}h||x.dispose(),r.timeline.end(this.name)}p?.dispose(),m.bindFramebuffer(l),m.setViewport(c.x,c.y,c.width,c.height)}_getCommonConfig(e,t){const{rasterFunction:r,hasBranches:n}=e,{raster:s,rasters:o}=r.parameters,a=n?s?.id??o?.filter((e=>"Constant"!==e.name))?.[0]?.id??-1:0,i=t.functionTextures[a]??t.rasterTexture,u="Reproject"===r.name;return{texture:{texture:i,unit:0},srcImageSize:t.getRasterTextureSize(u)}}_getMultipleInputConfig(e,t){return t?.length?2===t.length?{twoRasterConfig:this._getTwoInputConfig(t,e)}:3===t.length?{threeRasterConfig:this._getThreeInputConfig(t,e)}:{}:{}}_getConstantCount(e){return e?.filter((e=>"Constant"===e.name)).length??0}_getTextures(e,t){return e.filter((e=>"Constant"!==e.name)).map((e=>null!=e.id&&"Identity"!==e.name?t.functionTextures[e.id]:t.rasterTexture))}_getTwoInputConfig(e,t){const r=this._getTextures(e,t),n=r[1]?{texture:r[1],unit:1}:void 0,s=e.findIndex((e=>"Constant"===e.name)),o=0===s?new Float32Array([0,1,0,1,0,0,0,0,0]):new Float32Array([1,0,0,0,1,0,0,0,0]);return{image1:n,image1Const:s>-1?e[s].parameters.value:0,imageSwap:o}}_getThreeInputConfig(e,t){const r=this._getTextures(e,t);let n=0,s=0,o=new Float32Array([1,0,0,0,1,0,0,0,1]);const a=r[1]?{texture:r[1],unit:1}:void 0,i=r[2]?{texture:r[2],unit:2}:void 0,u=[];if(e.forEach(((e,t)=>"Constant"===e.name&&u.push(t))),1===u.length)n=e[u[0]].parameters.value,o=0===u[0]?new Float32Array([0,1,0,0,0,1,1,0,0]):1===u[0]?new Float32Array([1,0,0,0,0,1,0,1,0]):new Float32Array([1,0,0,0,1,0,0,0,1]);else if(2===u.length){n=e[u[0]].parameters.value,s=e[u[1]].parameters.value;const t=e.findIndex((e=>"Constant"!==e.name));o=0===t?new Float32Array([1,0,0,0,1,0,0,0,1]):1===t?new Float32Array([0,1,0,1,0,0,0,0,1]):new Float32Array([0,0,1,1,0,0,0,1,0])}return{image1:a,image2:i,image1Const:n,image2Const:s,imageSwap:o}}}export{i as BaseRasterProcessorTechnique};
