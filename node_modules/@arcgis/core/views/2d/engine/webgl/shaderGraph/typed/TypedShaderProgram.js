/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import r from"../../../../../../core/Error.js";import e from"../../../../../../core/Logger.js";import{getDeepValue as t}from"../../../../../../core/object.js";import"../../../../../../core/has.js";import"../../../../../../core/RandomLCG.js";import"../../../../../webgl/checkWebGLError.js";import"../../../../../webgl/enums.js";import"../../../../../webgl/FramebufferObject.js";import{Program as o}from"../../../../../webgl/Program.js";import"../../../../../webgl/FBOAttachmentType.js";import"../../../../../webgl/Texture.js";import{createTexture as i}from"../../textureUtils.js";const s=()=>e.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function n(e,t,o){const i=t.length;if(i!==o){const n=new r("Invalid Uniform",`Invalid length, expected ${o} but got ${i}`,{uniformName:e,values:t});s().errorOnce(n)}}class a{constructor(r,e,t,o,i,s){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=r,this.fragmentShader=e,this._locations=t,this._locationInfo=o,this._uniformBindings=i,this._transformFeedbackBindings=s}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(r){this._uniforms=r}cleanupTemporaryTextures(){for(const r of this._temporaryTextures)r.dispose();this._temporaryTextures=[]}bind(r){const e=this._uniforms;if(!this._program){const e=new Map;for(const[r,o]of this._locations)e.set(r,o);const t=[];for(const r of this._transformFeedbackBindings??[]){const{index:e,propertyKey:o}=r;t[e]=`v_${o}`}this._program=new o(r,this.vertexShader,this.fragmentShader,e,new Map,t)}const s=this._program;r.useProgram(s);for(const o of this._uniformBindings){const{shaderModulePath:a,uniformName:f,uniformType:m,uniformArrayLength:c}=o,u=t(a,e);if(null==u){if("sampler2D"===m)continue;throw new Error(`Failed to find uniform value for ${a}`)}switch("array"===m||"array-2d"===m?o.uniformArrayElementType:m){case"sampler2D":{const{unit:e,texture:t}=u;if(s.setUniform1i(f,e),"type"in t)r.bindTexture(t,e);else{const o=i(r,t.descriptor,t.data);r.bindTexture(o,e)}break}case"int":if(!c){s.setUniform1i(f,u);break}n(o.uniformName,u,c),s.setUniform1iv(f,u);break;case"float":if(!c){s.setUniform1f(f,u);break}n(o.uniformName,u,c),s.setUniform1fv(f,u);break;case"vec2":if(!c){s.setUniform2f(f,u[0],u[1]);break}n(o.uniformName,u,c),s.setUniform2fv(f,u.flat());break;case"vec3":if(!c){s.setUniform3f(f,u[0],u[1],u[2]);break}n(o.uniformName,u,c),s.setUniform3fv(f,u.flat());break;case"vec4":if(!c){s.setUniform4f(f,u[0],u[1],u[2],u[3]);break}n(o.uniformName,u,c),s.setUniform4fv(f,u.flat());break;case"mat3":s.setUniformMatrix3fv(f,u);break;case"mat4":s.setUniformMatrix4fv(f,u);break;default:throw new Error(`Unable to set uniform for type ${m}`)}}}}export{a as TypedShaderProgram};
