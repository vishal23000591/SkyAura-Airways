/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{pt2px as e}from"../../../../../../../core/screenUtils.js";import{GeometryCursor as t}from"../../../../../../../geometry/GeometryCursor.js";import{maxTileCoordValue as i}from"../../../../../../../symbols/cim/constants.js";import{ExtremityPlacement as r}from"../../../../../../../symbols/cim/enums.js";import{CIMMarkerPlacementHelper as s}from"../../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{spritePadding as o}from"../../../definitions.js";import{AAnimatedMeshWriter as n}from"./AnimatedMeshWriter.js";import{angle as a,sizing as c,animationPointerAndBaseSizeAndReferenceSize as m,uv as l,offset as d,pos as p,bitset as h,id as u,lineLength as f,value1Position2Value2 as y,zoomRange as x}from"./attributes.js";import{createComputedAnimatedMeshParams as P}from"./ComputedAnimatedParams.js";import{getGeometryEngine as M}from"../mesh/loadGeometryEngine.js";import{c256ToRad as g}from"../shaders/constants.js";const w=64,b=64,v=2;class _ extends n{get vertexSpec(){return{createComputedParams:P,optionalAttributes:{zoomRange:x,value1Position2Value2:y,lineLength:f},attributes:{id:u,bitset:h,pos:p,offset:d.marker,uv:l.marker,animationPointerAndBaseSizeAndReferenceSize:m,sizing:c,angle:a}}}_write(e,t){const i=this.evaluatedMeshParams.sprite,{textureBinding:r}=i;e.recordStart(this.instanceId,this.attributeLayout,r);const s=t.getDisplayId();if(this.shift&&"esriGeometryPolyline"===t.geometryType)this._writeParticles(e,t);else if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(e,t);else if("esriGeometryPolygon"===t.geometryType){const i=t.readCentroidForDisplay();if(!i)return;const[r,o]=i.coords;this._writeQuad(e,s,r,o)}else if("esriGeometryPoint"===t.geometryType){const i=t.readXForDisplay(),r=t.readYForDisplay();this._writeQuad(e,s,i,r)}else{const i=t.readGeometryForDisplay();i&&i.forEachVertex(((t,i)=>{this._writeQuad(e,s,t,i)}))}e.recordEnd()}_writePlacedMarkers(r,o){const n=t.fromFeatureSetReaderCIM(o)?.clone();if(!n)return;const a=-1,c=s.getPlacement(n,a,this.evaluatedMeshParams.placement,e(1),r.id,M());if(!c)return;const m=o.getDisplayId();let l=c.next(),d=null;for(;null!=l;){const e=l.tx,t=-l.ty;if(Math.abs(e)>i||Math.abs(t)>i){l=c.next();continue}const s=-l.getAngle();r.recordBounds(e,t,w,b),this.shift?d&&this._writeQuad(r,m,d[0],d[1],void 0,s):this._writeQuad(r,m,e,t,void 0,s),d=[e,t],l=c.next()}}_writeParticles(e,t){const i=t.getDisplayId(),s=t.readGeometryForDisplay();if(!s)return;const o=[];s.forEachVertex(((e,t)=>{o.push([e,t])}));const n=j(o);let a=0;for(let r=1;r<o.length;r++){const e=o[r][0]-o[r-1][0],t=o[r][1]-o[r-1][1],i=Math.sqrt(e*e+t*t);a+=i}const c=t=>{for(const r of n){const{a:s,b:o}=r;this._writeQuad(e,i,s.position[0],s.position[1],[s.distance-t,o.position[0],o.position[1],o.distance-t],this.evaluatedMeshParams.angleToLine?Math.atan2(s.direction[1],s.direction[0]):0,a,!0)}},{placement:m}=this.evaluatedMeshParams;if(!m||"placementTemplate"in m||"CIMMarkerPlacementOnVertices"===m.type){let e;if(m&&"CIMMarkerPlacementOnVertices"!==m.type)e=m.placementTemplate;else{e=[0];for(const t of n){const{a:i,b:r}=t,s=i.position[0]-r.position[0],o=i.position[1]-r.position[1],n=Math.sqrt(s*s+o*o);e.push(n)}}let t=-1*a;for(;t<(1+v/2)*a;)for(const i of e)t+=i,c(t)}else"CIMMarkerPlacementAtExtremities"===m.type?m.extremityPlacement===r.JustBegin?c(1):m.extremityPlacement===r.JustEnd?(c(a-1),c(-1)):m.extremityPlacement===r.Both&&(c(1),c(a-1)):"CIMMarkerPlacementOnLine"===m.type&&c(a/2)}_writeQuad(e,t,i,r,s,n=0,a=0,c=!1){const m=this.evaluatedMeshParams.sprite,{rect:l}=m,d=l.x+o,p=l.y+o,h=l.x+l.width-o,u=l.y+l.height-o,f=e.vertexCount();c||e.recordBounds(i,r,w,w);const y={texXmin:d,texYmin:p,texXmax:h,texYmax:u,value1Position2Value2:s,angle:n/g,lineLength:a};for(let o=0;o<4;o++)this._writeVertex(e,t,i,r,y);e.indexEnsureSize(6),e.indexWrite(f),e.indexWrite(f+1),e.indexWrite(f+2),e.indexWrite(f+1),e.indexWrite(f+3),e.indexWrite(f+2)}}function j(e){const t=[];let i=0;for(let r=1;r<e.length;r++){const s=e[r-1],o=e[r],n=o[0]-s[0],a=o[1]-s[1],c=Math.sqrt(n*n+a*a),m=n/c,l=a/c;t.push({a:{position:s,distance:i,direction:[m,l]},b:{position:o,distance:i+c,direction:[m,l]}}),i+=c}return t}class C extends _{constructor(){super(...arguments),this.shift=!1}}class I extends _{constructor(){super(...arguments),this.shift=!0}}export{C as AnimatedMarkerMeshWriter,I as AnimatedMarkerShiftMeshWriter};
