/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{memoize as e}from"../../../../../../../core/MapUtils.js";import{pt2px as t}from"../../../../../../../core/screenUtils.js";import{numericHash as i}from"../../../../../../../core/string.js";import{fromRotation as r,translate as s}from"../../../../../../../core/libs/gl-matrix-2/math/mat2d.js";import{create as o}from"../../../../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{transformMat2d as n,set as a,sub as l,normalize as h,add as c,scale as m}from"../../../../../../../core/libs/gl-matrix-2/math/vec2.js";import{fromValues as u}from"../../../../../../../core/libs/gl-matrix-2/factories/vec2f32.js";import{create as d}from"../../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{GeometryCursor as f}from"../../../../../../../geometry/GeometryCursor.js";import{generalizeOptimizedGeometry as g,convertToGeometry as _}from"../../../../../../../layers/graphics/featureConversionUtils.js";import p from"../../../../../../../layers/graphics/OptimizedGeometry.js";import{tileSize as b,minMaxZoomPrecisionFactor as x}from"../../../definitions.js";import M from"../../../collisions/BoundingBox.js";import{LabelMetric as v}from"../../../collisions/LabelMetric.js";import{smoothPaths as y,pathDivide as P}from"../../../mesh/templates/segmentUtils.js";import{getMinMaxZoom as w,processColorInput as L}from"../fill/meshWriterUtils.js";import{TextMeshWriter as I,maxLabelZoom as B}from"../text/TextMeshWriter.js";const S=1,z=0,j=128;function A(e,t){return i(`${e}${t}`)}function D(e,t,r){return i(`${e}${t}${r}`)}function G(e,t,r,s){return i(`${e}${t}${r*2**(B-s)}`)}function Z(e,t,r,s,o){return i(`${e}${o}${t}${r*2**(B-s)}`)}const k=e((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class F extends I{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,r){if(this._zoomLevel=r||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const i=t.readXForDisplay(),r=t.readYForDisplay();this._writePoint(e,i,r,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const i=t.readCentroidForDisplay();if(!i)return;const[r,s]=i.coords;this._writePoint(e,r,s,0,t);break}case"esriGeometryMultipoint":{let i=0;const r=f.fromFeatureSetReader(t);if(r?.nextPath())for(;r.nextPoint();)this._writePoint(e,r.x,r.y,i++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return["center"===e?0:"right"===e?-1:1,"middle"===t?0:"bottom"===t?-1:1]}_createLineLabelMetric(e,t,i,r,s,o){const[n,a]=this._getMetricDir(),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0,c=this.evaluatedMeshParams.labelClassId;return new v(e,c,t,i,r,s,n,a,l,h,o)}_writePoint(e,t,i,r,s){if(t<0||t>b||i<0||i>b)return;const o=this._getShaping();if(!o)return;const n=s.getDisplayId(),a=this.evaluatedMeshParams.labelClassId,l=A(s.getObjectId(),r),h=D(s.getObjectId(),a,r),[c,m]=this._getMetricDir(),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0,f=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new v(n,a,l,h,t,i,c,m,u,d,f)),this._writeGlyphs(e,n,t,i,o,0,f,void 0,!1),e.metricBoxWrite(o.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:i,verticalAlignment:r}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping("middle");if(!o)return;const n=(e,t,i,r)=>this._placeSubdivGlyphs(e,t,i,r),a=(o.bounds.width+s)/(1<<S);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:o,zoomRange:w(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement="bottom"===r?"above":"top"===r?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,n,a):this._writeCenterAlong(t,n,a)}_writeAboveAndBelowAlong(e,t,i){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,o=s.bounds.halfHeight,n=e.readGeometryForDisplay();if(!n)return;const a=new p;g(a,n,!1,!1,"esriGeometryPolyline",1);const l=C(new p,a,o),h=C(new p,a,-o),c=_(h,"esriGeometryPolyline",!1,!1),m=_(l,"esriGeometryPolyline",!1,!1),u=y(m.paths,s.bounds.width),d=y(c.paths,s.bounds.width);this._current.offsetDirection="above";for(let f=0;f<u.length;f++)this._current.pathIndex=f,P(u[f],i,t,!!r);this._current.offsetDirection="below";for(let f=0;f<d.length;f++)this._current.pathIndex=f,P(d[f],i,t,!!r)}_writeCenterAlong(e,t,i){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,o=y(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let n=0;n<o.length;n++)this._current.pathIndex=n,P(o[n],i,t,!!r)}_placeSubdivGlyphs(e,t,i,r){const{allowOverrun:s,labelPosition:o,repeatLabelDistance:n}=this.evaluatedMeshParams,a=this._current.zoomRange[0],l=k(t),h=this._current.shaping.bounds.width/(1<<S),c=Math.sqrt(n||j)/(1<<S),m=Math.min(i,r-i),u=this._current.shaping.isMultiline?B:Math.log2(m/(c+h/2)),d=0===t?u:Math.min(l,u),f=Math.max(a,this._zoomLevel+S-d),g=this._zoomLevel-f,_=this._current.shaping.bounds.width/2*2**g,p=G(this._current.objId,this._current.pathIndex,t,this._zoomLevel),b=Z(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?0===t&&this._placeStraight(e,f,p,b):s&&g<0?this._placeStraightAlong(e,a,p,b):"parallel"===o?this._placeStraightAlong(e,f,p,b):"curved"===o&&this._placeCurved(e,f,_,p,b)}_placeStraight(e,t,i,r){const{out:s,id:o,shaping:n,referenceBounds:a}=this._current,{x:l,y:h}=e;s.metricStart(this._createLineLabelMetric(o,i,r,l,h)),s.metricBoxWrite(n.boundsT);const c=e.angle*(180/Math.PI)%360,m=(e.angle*(180/Math.PI)+180)%360,u={clipAngle:c,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,o,l,h,n,0,a,u,!1);const d={clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,o,l,h,n,0,a,d,!1),s.metricEnd()}_placeCurved(e,t,i,r,s){const{out:o,id:n}=this._current;o.metricStart(this._createLineLabelMetric(n,r,s,e.x,e.y));const a=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(a,t,1,l),this._placeBack(e,a,t,i,1,l),this._placeForward(e,a,t,i,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(a,t,0,h),this._placeBack(e,a,t,i,0,h),this._placeForward(e,a,t,i,0,h)),o.metricEnd()}_placeStraightAlong(e,i,n,a){const{out:l,id:h,shaping:c,zoomRange:m,referenceBounds:d}=this._current,{boxBorderLineColor:f,boxBackgroundColor:g}=this.evaluatedMeshParams,_=e.clone(),p=e.angle*(180/Math.PI)%360,b=(e.angle*(180/Math.PI)+180)%360,x=c.glyphs.length>0&&!(!f&&!g);if(l.metricStart(this._createLineLabelMetric(h,n,a,e.x,e.y)),x){const n=Math.max(i,m[0],0),a=Math.min(B,m[1]),f=r(o(),-e.angle),g={minZoom:n,maxZoom:a,clipAngle:p,mapAligned:!0,isLineLabel:!0},_=t(this.evaluatedMeshParams.offsetX),x=t(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=u(_,-1*x),[i,r]=c.shapeBackground(s(o(),f,t));l.recordStart(this.instanceId,this.attributeLayout,c.glyphs[0].textureBinding),this._writeTextBox(l,h,e.x,e.y,r,d,g),l.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=u(_,x),[i,r]=c.shapeBackground(s(o(),f,t));g.clipAngle=b,l.recordStart(this.instanceId,this.attributeLayout,c.glyphs[0].textureBinding),this._writeTextBox(l,h,e.x,e.y,r,d,g),l.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(_,i,1,p,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(_,i,0,b,!0),l.metricEnd()}_placeBack(e,t,i,r,s,o){const n=e.clone();let a=e.backwardLength+z;for(;n.prev()&&!(a>=r);)this._placeOnSegment(n,t,a,i,-1,s,o),a+=n.length+z}_placeForward(e,t,i,r,s,o){const n=e.clone();let a=e.remainingLength+z;for(;n.next()&&!(a>=r);)this._placeOnSegment(n,t,a,i,1,s,o),a+=n.length+z}_placeFirst(e,i,s,a,l=!1){const{out:h,id:c,shaping:m,zoomRange:d,referenceBounds:f}=this._current,g=m.glyphs,_=t(this.evaluatedMeshParams.offsetX),p=t(this.evaluatedMeshParams.offsetY),b=u(_,p),x=r(o(),-e.angle);n(b,b,x);for(const t of g){const r=t.x>m.bounds.x?s:1-s,o=r*e.remainingLength+(1-r)*e.backwardLength,n=Math.abs(t.x+t.width/2-m.bounds.x),u=Math.max(0,this._zoomLevel+Math.log2(n/(o+z))),g=Math.max(i,l?0:u);if(t.maxZoom=Math.min(d[1],B),t.angle=e.angle+(1-s)*Math.PI,t.minZoom=Math.max(d[0],g),this._writeLineGlyph(h,c,e.x,e.y,t,a,f,!0),(s||this._current.offsetDirection)&&this._isVisible(t.minZoom,t.maxZoom)){const e=new M(t.bounds.x+b[0],t.bounds.y+b[1],t.bounds.width,t.bounds.height);h.metricBoxWrite(e)}}}_placeOnSegment(e,i,s,a,l,h,c){const{out:m,id:d,shaping:f,referenceBounds:g}=this._current,_=f.glyphs,p=e.dx/e.length,b=e.dy/e.length,x={x:e.x+s*-l*p,y:e.y+s*-l*b},v=t(this.evaluatedMeshParams.offsetX),y=t(this.evaluatedMeshParams.offsetY),P=u(v,y),w=r(o(),-e.angle);n(P,P,w);for(const t of _){const i=t.x>f.bounds.x?h:1-h;if(!(i&&1===l||!i&&-1===l))continue;const r=Math.abs(t.x+t.width/2-f.bounds.x),o=Math.max(0,this._zoomLevel+Math.log2(r/s)-.1),n=Math.max(a,this._zoomLevel+Math.log2(r/(s+e.length+z)));if(0!==o&&(t.angle=e.angle+(1-h)*Math.PI,t.minZoom=n,t.maxZoom=o,this._writeLineGlyph(m,d,x.x,x.y,t,c,g,!0),(h||this._current.offsetDirection)&&this._isVisible(t.minZoom,t.maxZoom))){const e=new M(t.bounds.x+P[0],t.bounds.y+P[1],t.bounds.width,t.bounds.height);m.metricBoxWrite(e)}}}_writeLineGlyph(e,t,i,r,s,o,n,a){if(i<0||i>b||r<0||r>b)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:l,offsets:h}=s,{fontSize:c,haloSize:m,outlineSize:u}=this._textMeshTransformProps;this._writeQuad(e,t,i,r,{texcoords:l,offsets:h,fontSize:c,haloSize:m,outlineSize:u,color:L(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:n,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:o,mapAligned:a,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*x)/x}_isVisible(e,t){let i=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);i=this._packedZoom(i),r=this._packedZoom(r);const s=this._packedZoom(this._zoomLevel);return i<=s&&s<=r}}function C(e,t,i){const{coords:r,lengths:s}=t,o=d(),n=d(),u=d(),f=d(),g=d(),_=d(),p=2;let b=0;for(let d=0;d<s.length;d++){const t=s[d];for(let s=0;s<t;s++){const d=p*(s+b-1),x=p*(s+b),M=p*(s+b+1);s>0?a(o,r[d],r[d+1]):a(o,0,0),a(n,r[x],r[x+1]),s<t-1?a(u,r[M],r[M+1]):a(u,0,0),0===s?a(f,0,0):(l(f,n,o),h(f,f),a(f,f[1],-f[0])),s===t-1?a(g,0,0):(l(g,u,n),h(g,g),a(g,g[1],-g[0])),c(_,f,g),h(_,_);const v=_[0]*g[0]+_[1]*g[1];0!==v&&m(_,_,v),m(_,_,i),e.coords.push(n[0]+_[0],n[1]+_[1])}e.lengths.push(t),b+=t}return e}export{F as LabelMeshWriter,A as labelIdHash,D as labelMetricHash,G as lineLabelIdHash,Z as lineLabelMetricHash};
