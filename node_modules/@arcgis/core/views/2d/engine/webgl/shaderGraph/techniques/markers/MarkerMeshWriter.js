/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{pt2px as e}from"../../../../../../../core/screenUtils.js";import{identity as t,translate as r,rotate as o}from"../../../../../../../core/libs/gl-matrix-2/math/mat2d.js";import{create as s}from"../../../../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{transformMat2d as a}from"../../../../../../../core/libs/gl-matrix-2/math/vec2.js";import{GeometryCursor as i}from"../../../../../../../geometry/GeometryCursor.js";import{clipCursorToTileExtent as n}from"../../../../../../../symbols/cim/CIMEffects.js";import{maxTileCoordValue as c}from"../../../../../../../symbols/cim/constants.js";import{Alignment as m}from"../../../../../../../symbols/cim/enums.js";import{CIMMarkerPlacementHelper as l}from"../../../../../../../symbols/cim/placements/CIMMarkerPlacementHelper.js";import{minMaxZoomPrecisionFactor as u}from"../../../definitions.js";import{processColorInput as d,getMinMaxZoom as p,packByteSqrt as h,getBitMask as f}from"../fill/meshWriterUtils.js";import{ComputedMarkerParams as y}from"./ComputedMarkerParams.js";import{MarkerConstants as M}from"./markerConstants.js";import{getGeometryEngine as P}from"../mesh/loadGeometryEngine.js";import{MeshWriter as x}from"../mesh/MeshWriter.js";import{DataType as g}from"../../../../../../webgl/enums.js";const b=3.14159265359/180,k=128/Math.PI;function v(e,t){return e%=t,Math.abs(e>=0?e:e+t)}function S(e){return v(e*k,256)}function I(e,a,i,n,c=!1){const m=s(),l=c?1:-1;return t(m),(a||i)&&r(m,m,[a,-i]),n&&o(m,m,l*b*-n),m}const _={createComputedParams:e=>y.from(e),optionalAttributes:{zoomRange:{type:g.SHORT,count:2,packPrecisionFactor:u,pack:({scaleInfo:e},{tileInfo:t})=>p(e,t)}},attributes:{pos:{type:g.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:g.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:g.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:r,overrideOutlineColor:o,colorLocked:s})=>{let a=0;return e.sdf&&(a|=f(M.bitset.isSDF)),t===m.MAP&&(a|=f(M.bitset.isMapAligned)),r&&(a|=f(M.bitset.scaleSymbolsProportionally)),o&&(a|=f(M.bitset.overrideOutlineColor)),s&&(a|=f(M.bitset.colorLocked)),a}},offset:{type:g.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:r,anchorX:o,anchorY:s,offsetX:i,offsetY:n,rotateClockwise:c})=>{const m=I(0,i,n,-e,c),l=-(.5+o)*t,u=-(.5-s)*r,d=[l,u],p=[l+t,u],h=[l,u+r],f=[l+t,u+r];return a(d,d,m),a(p,p,m),a(h,h,m),a(f,f,m),[d,p,h,f]}}},textureUV:{type:g.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:r,texYmin:o})=>[[t,o],[e,o],[t,r],[e,r]]}},color:{type:g.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>d(e)},outlineColor:{type:g.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>d(e)},sizing:{type:g.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:r,referenceSize:o})=>{const s=Math.max(e,t);return[h(s,128),h(r,128),h(o,128),0]}},placementAngle:{type:g.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>S(e)},sdfDecodeCoeff:{type:g.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class E extends x{constructor(){super(...arguments),this.vertexSpec=_}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,t,r){const o=this.evaluatedMeshParams.sprite?.textureBinding,s=t.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,o);const a=this.evaluatedMeshParams.minPixelBuffer,i=Math.max(this.evaluatedMeshParams.computedWidth,a),m=Math.max(this.evaluatedMeshParams.computedHeight,a),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+l,p=-this.evaluatedMeshParams.offsetY+u;if(null!=this.evaluatedMeshParams.placement){let o=null;if(null!=r){const e=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(o=n(r,2*e,!1),null===o)return}this._writePlacedMarkers(e,t,o,i,m)}else if(r?.nextPath()){r.nextPoint();const t=r.x,o=r.y;e.recordBounds(t+d,o+p,i,m),this._writeQuad(e,s,t,o)}else if("esriGeometryPolygon"===t.geometryType){const r=t.readCentroidForDisplay();if(!r)return;const[o,a]=r.coords;e.recordBounds(o+d,a+p,i,m),this._writeQuad(e,s,o,a)}else if("esriGeometryPoint"===t.geometryType){const r=t.readXForDisplay(),o=t.readYForDisplay();e.recordBounds(r+d,o+p,i,m),this._writeQuad(e,s,r,o)}else{const r=t.readGeometryForDisplay();r?.forEachVertex(((t,r)=>{e.recordBounds(t+d,r+p,i,m),Math.abs(t)>c||Math.abs(r)>c||this._writeQuad(e,s,t,r)}))}e.recordEnd()}_writePlacedMarkers(t,r,o,s,a){const n=o??i.fromFeatureSetReaderCIM(r);if(!n)return;const m=-1,u=l.getPlacement(n,m,this.evaluatedMeshParams.placement,e(1),t.id,P());if(!u)return;const d=r.getDisplayId();let p=u.next();const h=this.evaluatedMeshParams.offsetX,f=-this.evaluatedMeshParams.offsetY;for(;null!=p;){const e=p.tx,r=-p.ty;if(Math.abs(e)>c||Math.abs(r)>c){p=u.next();continue}const o=-p.getAngle();t.recordBounds(e+h,r+f,s,a),this._writeQuad(t,d,e,r,o),p=u.next()}}_writeQuad(e,t,r,o,s){const a=e.vertexCount(),i=null==s?null:{placementAngle:s};this._writeVertex(e,t,r,o,i),e.indexWrite(a+0),e.indexWrite(a+1),e.indexWrite(a+2),e.indexWrite(a+1),e.indexWrite(a+3),e.indexWrite(a+2)}}export{E as MarkerMeshWriter,_ as MarkerVertexSpec};
