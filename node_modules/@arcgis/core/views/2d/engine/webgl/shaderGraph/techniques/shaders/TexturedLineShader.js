/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{pt2px as i}from"../../../../../../../core/screenUtils.js";import{dashSdfRasterizationScale as s,dashSdfDistanceNormalization as o}from"../../../../../../../symbols/cim/constants.js";import{location as a,uniform as r,input as l}from"../../GraphShaderModule.js";import{max as n,Float as p,fract as c,mix as m,Vec2 as u,texture2D as d,cond as y,equal as h,sqrt as f,pow as w,clamp as b,Vec4 as g,ifElse as x,greaterThan as v,dot as D}from"../../graph/glsl.js";import{BaseHittestVertexInput as S}from"./AFeatureShader.js";import{bitsetLineScaleDash as j,bitsetLineIsSdf as A,bitsetGenericConsiderAlphaOnly as z}from"./constants.js";import{LineShader as F,getLineVertexData as T,getLineAntialiasing as _,LineVertexInput as L,LineFragmentInput as I}from"./LineShader.js";import{MosaicInfo as C}from"./MosaicInfo.js";import{getBit as O,rgba2float as P}from"./utils.js";class W extends L{}t([a(9,p)],W.prototype,"accumulatedDistance",void 0),t([a(10,u)],W.prototype,"segmentDirection",void 0),t([a(11,p)],W.prototype,"offsetAlongLine",void 0),t([a(12,p)],W.prototype,"capType",void 0),t([a(13,g)],W.prototype,"tlbr",void 0);class R extends I{}class H extends F{constructor(){super(...arguments),this.type="TexturedLineShader"}_getDistanceRatio(t,e){const s=O(t.bitset,j);return s.multiply(n(e,new p(.25)).multiply(new p(2))).add(new p(1).subtract(s).multiply(i(1)))}_getSDFAlpha(t){const{halfWidth:e,normal:i,tlbr:a,patternSize:r,accumulatedDistance:l,offsetAlongLine:x,dashToPx:v,capType:D}=t,S=r.x.divide(s).multiply(v),j=c(l.add(x).divide(S)),A=m(a.xy,a.zw,new u(j,.5)),z=P(d(this.mosaicInfo.texture,A)).multiply(2).subtract(1).multiply(o).multiply(v),F=i.y.multiply(e),T=y([h(D,new p(1)),z.subtract(e)],[h(D,new p(2)),f(w(n(z,new p(0)),new p(2)).add(F.multiply(F))).subtract(e)],[!0,z]),_=b(new p(.25).subtract(T),new p(0),new p(1));return new g(_)}_getPatternColor(t){const{halfWidth:e,normal:i,color:s,accumulatedDistance:o,patternSize:a,sampleAlphaOnly:r,tlbr:l}=t,n=a.y.multiply(new p(2).multiply(e).divide(a.x)),y=c(o.divide(n)),h=new p(.5).multiply(i.y).add(new p(.5)),f=m(l.xy,l.zw,new u(h,y));let w=d(this.mosaicInfo.texture,f);return null!=this.visualVariableColor&&(w=x(v(r,new p(.5)),new g(s.a),s)),w}vertex(t,e){const{segmentDirection:i,tlbr:s,bitset:o}=t,a=T(this,t),r=t.accumulatedDistance.divide(this.view.displayZoomFactor).add(D(i,a.scaledOffset)),l=new u(s.z.subtract(s.x),s.w.subtract(s.y)),n=s.divide(this.mosaicInfo.size.xyxy),c=O(o,A),m=O(o,z),d=x(v(c,new p(.5)),this._getDistanceRatio(t,a.scaledHalfWidth),new p(1));return{...a,tlbr:n,patternSize:l,accumulatedDistance:r,isSDF:c,sampleAlphaOnly:m,dashToPx:d,offsetAlongLine:t.offsetAlongLine,capType:t.capType,...this.maybeRunHittest(t,e,a.halfWidth)}}fragment(t){const{color:e,opacity:i,isSDF:s}=t,o=_(t,this.antialiasingControls.blur),a=x(v(s,new p(.5)),this._getSDFAlpha(t),this._getPatternColor(t)),r=e.multiply(i).multiply(o).multiply(a);return this.getFragmentOutput(r,t)}}t([r(C)],H.prototype,"mosaicInfo",void 0),t([e(0,l(W)),e(1,l(S))],H.prototype,"vertex",null);export{R as TexturedLineFragmentInput,H as TexturedLineShader,W as TexturedLineVertexInput};
