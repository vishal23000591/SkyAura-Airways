/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import"../../../tiling/TileInfoView.js";import e from"../../../tiling/TileKey.js";import"../../../tiling/TileQueue.js";import"../../../tiling/TileStrategy.js";import{tileSize as t}from"../definitions.js";import{MeshData as s}from"./MeshData.js";const r=1,i=2,n=4,h=8,o=16,c=32,a=64,l=128;function f(e){switch(e){case r:case h:case c:return-1;case i:case a:return 0;case n:case o:case l:return 1}}function u(e){switch(e){case r:case i:case n:return-1;case h:case o:return 0;case c:case a:case l:return 1}}const _=r|h|c,d=n|o|l,m=r|i|n,p=c|a|l;class g{constructor(e,t,r,i,n=0){this.tileKey=e,this._bufferingEnabled=t,this._sizeHint=n,this._meshes={self:new s(this.id,this._sizeHint),neighbors:new Array},this._currentRecordOverlaps=0,this._currentEntityOverlaps=0;const h=i?1:0;this._copyBufferedDataIntoSelf=r&&this._bufferingEnabled&&e.level===h}get id(){return this.tileKey.id}vertexStart(){return this._meshes.self.vertexStart()??0}vertexCount(){return this._meshes.self.vertexCount()}indexCount(){return this._meshes.self.indexCount()}indexEnsureSize(e){this._meshes.self.indexEnsureSize(e)}entityStart(e,t=e){this._currentEntityOverlaps=0,this._meshes.self.entityStart(e,t)}entityRecordCount(){return this._meshes.self.entityRecordCount()}entityEnd(){if(this._meshes.self.entityEnd(),this._bufferingEnabled){if(this._copyBufferedDataIntoSelf)return;for(let e=0;e<8;e++){const t=1<<e;!!(this._currentEntityOverlaps&t)&&this._meshes.neighbors[e].entityEnd()}}}recordStart(e,t,s){this._currentRecordOverlaps=0,this._meshes.self.recordStart(e,t,s)}recordEnd(e=0){const t=this._meshes.self.recordEnd(this._currentRecordOverlaps);return t&&0!==this._currentRecordOverlaps?(this._copyIntoNeighbors(),this._currentEntityOverlaps|=this._currentRecordOverlaps,!0):t}recordBounds(e,t,s,r){this._bufferingEnabled&&this._addOverlap(e,t,s,r)}recordCount(){return this._meshes.self.recordCount()}metricStart(e){this._meshes.self.metricStart(e)}metricBoxWrite(e){this._meshes.self.metricBoxWrite(e)}metricEnd(){this._meshes.self.metricEnd()}vertexWrite(e){this._meshes.self.vertexWrite(e)}vertexWriteF32(e){this._meshes.self.vertexWriteF32(e)}vertexWriteRegion(e){this._meshes.self.vertexWriteRegion(e)}indexWrite(e){this._meshes.self.indexWrite(e)}serialize(t){const s={message:[],transferList:[]},r=this._meshes.self.serialize();return s.message.push({tileId:this.tileKey.id,...r.message}),s.transferList.push(...r.transferList),this._meshes.neighbors.forEach(((r,i)=>{const n=r.serialize(),h=1<<i,o=f(h),c=u(h),a=new e(this.tileKey).getNormalizedNeighbor(o,c,t);s.message.push({tileId:a.id,...n.message}),s.transferList.push(...n.transferList)})),s}_addOverlap(e,s,r,i){const n=Math.min(t/2,r),h=Math.min(t/2,i),o=255^((e<0+n?d:e>=t-n?_:d|_)|(s<0+h?p:s>=t-h?m:p|m));this._currentRecordOverlaps|=o}_copyIntoNeighbors(){for(let e=0;e<8;e++){const r=1<<e;if(!!(this._currentRecordOverlaps&r)){if(this._copyBufferedDataIntoSelf){const e=-f(r)*t,s=-u(r)*t;if(0!==s)continue;this._meshes.self.copyLast(e,s);continue}if(!this._meshes.neighbors[e]){const t=Math.floor(this._sizeHint/16);this._meshes.neighbors[e]=new s(r,t)}const i=this._meshes.neighbors[e],n=-f(r)*t,h=-u(r)*t;i.copyLastFrom(this._meshes.self,n,h)}}}}export{g as MultiTileMeshData};
