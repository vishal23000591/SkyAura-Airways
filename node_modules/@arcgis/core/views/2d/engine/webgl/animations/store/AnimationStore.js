/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{PixelFormat as t,PixelType as e,TextureWrapMode as s,TextureSamplingMode as r}from"../../../../../webgl/enums.js";import{Texture as o}from"../../../../../webgl/Texture.js";import{TextureDescriptor as i}from"../../../../../webgl/TextureDescriptor.js";import{ValidatedTextureDescriptor as n}from"../../../../../webgl/ValidatedTextureDescriptor.js";class h{constructor(){this._entries=new l,this._nodes=new Map,this._book=new a}add(t){let e=this._entries.get(t);if(!e){const s=this._book.add(t),r=new Object;e={location:s,references:0,handle:r};const o=this._entries.set(t,e);this._nodes.set(r,o)}return e.references++,e}remove(t){const e=this._nodes.get(t.handle);e&&e.payload&&(e.payload.references--,0===e.payload.references&&(this._book.remove(e.payload.location),this._entries.delete(e),this._nodes.delete(t.handle)))}getTexture(t,e){return this._book.getTexture(t,e)}destroy(){this._book.destroy()}}class u{constructor(t,e){this.parent=t,this.key=e,this.payload=null,this._children=new Map}get(t){return this._children.get(t)}ensure(t){let e=this._children.get(t);return e||(e=new u(this,t),this._children.set(t,e)),e}delete(t){this._children.delete(t)}}class l{constructor(){this._root=new u(null,NaN)}set(t,e){let s=this._root;for(const r of t)for(const t of r)s=s.ensure(t);return s.payload=e,s}delete(t){t.parent?.delete(t.key)}get(t){let e=this._root;for(const s of t)for(const t of s){const s=e.get(t);if(!s)return;e=s}return e.payload||void 0}}class a{constructor(){this._pages=[]}add(t){0===this._pages.length&&this._pages.push(new _);let e=this._pages.length-1,s=this._pages[e].add(t);if(s||(this._pages.push(new _),e=this._pages.length-1,s=this._pages[e].add(t)),!s)throw new Error("Data allocation failed.");return{...s,page:e}}remove(t){this._pages[t.page].remove(t)}getTexture(t,e){return this._pages[e].getTexture(t)}destroy(){}}class _{constructor(){this._cursor={row:0,column:0},this._columns=1024,this._rows=1024,this._data=new Float32Array(this._columns*this._rows*4),this._texture=null,this._textureCursor={row:0,column:0}}add(t){if(t.length>this._columns)throw new Error(`The maximum allocation size is ${this._columns} texels.`);const e={...this._cursor};if(e.column+=t.length,e.column>=this._columns&&(e.column=t.length,e.row++),e.row>=this._rows)return null;this._cursor=e;const s={...this._cursor};s.column-=t.length;let r=4*(s.row*this._columns+s.column);for(let o=0;o<t.length;o++)this._data[r++]=t[o][0],this._data[r++]=t[o][1],this._data[r++]=t[o][2],this._data[r++]=t[o][3];return s}remove(t){}getTexture(h){if(!this._texture){const u=new i(this._columns,this._rows);u.pixelFormat=t.RGBA,u.dataType=e.FLOAT,u.wrapMode=s.CLAMP_TO_EDGE,u.samplingMode=r.NEAREST,u.hasMipmap=!1;const l=new n(h,u);this._texture=new o(h,l)}if(this._cursor.row===this._textureCursor.row&&this._cursor.column===this._textureCursor.column)return this._texture;const u=this._textureCursor.row,l=this._cursor.row-u+1;return this._texture.updateData(0,0,u,this._columns,l,this._data,u),this._textureCursor.row=this._cursor.row,this._textureCursor.column=this._cursor.column,this._texture}destroy(){this._texture?.dispose()}}export{h as AnimationStore,l as PrefixMap};
