/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../../Color.js";import{getStartGroup as t,getRandomValue as o}from"../grouping.js";import{hydrate as i}from"./infos.js";import{instructions as n}from"./instructions.js";function s(e){return a(e.map((e=>l(e))).map((e=>i(e).simplify())))}function r(e){const t=[];return t.push(e.transform),t.push(e.fromColor),t.push(e.toColor),t.push(e.colorMix),t.push(e.toOpacity),t.push(e.opacityMix),e?.shift?t.push(e?.shift):t.push([1,1,1,1]),t}function a(e){const t=[],o=[];let i=0;for(const s of e){const r=[...s.encode(),...n.ret.encode()];t.push([i+e.length,0,0,0]),o.push(...r),i+=r.length}return[...t,...o]}async function c(e,t){const o=e;let i;if("number"==typeof o||"string"==typeof o||"boolean"==typeof o)i=o;else if(Array.isArray(o))i=await Promise.all(o.map((e=>c(e,t))));else if("object"==typeof o)if("valueExpressionInfo"in o){const{valueExpressionInfo:e}=o,{expression:n}=e;i={...o,computed:await t.createComputedField({expression:n})}}else{i={};for(const e in o)i[e]=await c(o[e],t)}return i}function l(i,n,s){function r(t){if(!("computed"in t))return t;let o=t.computed.readWithDefault(n,s,[255*t.defaultValue[0],255*t.defaultValue[1],255*t.defaultValue[2],t.defaultValue[3]]);if("string"==typeof o){const t=e.fromString(o);t&&(o=[t.r,t.g,t.b,t.a])}return o}const a=i;let c;if("number"==typeof a||"string"==typeof a||"boolean"==typeof a)c=a;else if(Array.isArray(a))c=a.map((e=>l(e,n,s)));else if("object"==typeof a)if("type"in a&&null!=a.type&&"Process"===a.type)switch(a.op){case"ArcadeColor":{const e=l(a.value,n,s);p(Array.isArray(e)&&4===e.length);c=[e[0]/255,e[1]/255,e[2]/255,e[3]]}break;case"Transparency":{const e=l(a.value,n,s);p("number"==typeof e),c=1-e/100}break;case"Divide":case"Multiply":case"Add":{const e=l(a.left,n,s);p("number"==typeof e);const t=l(a.right,n,s);switch(p("number"==typeof t),a.op){case"Divide":c=e/t;break;case"Multiply":c=e*t;break;case"Add":c=e+t}}break;case"Random":{const e=l(a.seed,n,s),i=l(a.min,n,s),r=l(a.max,n,s),f=n.getObjectId(),p=t(f||0);c=i+o(p,e)*(r-i)}break;case"Cond":{const e=l(a.condition,n,s),t=l(a.ifTrue,n,s),o=l(a.ifFalse,n,s);c=e?t:o}break;case"MatchWinding":{const e=l(a.sign,n,s);let t=l(a.angle,n,s);if(e>0)for(;t<0;)t+=2*Math.PI;else for(;t>0;)t-=2*Math.PI;c=t}}else if("computed"in a)c=r(a);else{c={};for(const e in a)c[e]=l(a[e],n,s)}return c}function*f(e){const t=e;if(Array.isArray(t))for(const o of t)yield*f(o);else if("object"==typeof t)if("type"in t&&null!=t.type&&"Process"===t.type)switch(t.op){case"ArcadeColor":case"Transparency":yield*f(t.value);break;case"Divide":case"Multiply":case"Add":yield*f(t.left),yield*f(t.right);break;case"Random":yield*f(t.seed),yield*f(t.min),yield*f(t.max);break;case"Cond":yield*f(t.condition),yield*f(t.ifTrue),yield*f(t.ifFalse);break;case"MatchWinding":yield*f(t.sign),yield*f(t.angle)}else if("computed"in t)yield t.computed;else for(const o in t)yield*f(t[o])}function p(e){if(!e)throw new Error("Assertion failed.")}export{p as assert,c as compileAnimationParam,r as createParamList,a as encodeParamList,s as fromJSON,f as getAnimationExpressions,l as resolveToAnimationInfo};
