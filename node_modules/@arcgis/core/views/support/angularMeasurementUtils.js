/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{cyclicalDegrees as e,Cyclical as t}from"../../core/Cyclical.js";import{convertRotationType as r,createAngle as i}from"../../core/quantityUtils.js";import{convertUnit as o}from"../../core/unitUtils.js";import{angle as n}from"../../core/libs/gl-matrix-2/math/vec2.js";import{create as a,UNIT_Y as s}from"../../core/libs/gl-matrix-2/factories/vec2f64.js";import{q as c,c as l,i as u}from"../../chunks/vec32.js";import{create as f}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as m}from"../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as g,inverseGeodeticSolver as p,InverseGeodeticSolverResult as v,directGeodeticSolver as d}from"../../geometry/support/geodesicUtils.js";import{equals as h}from"../../geometry/support/spatialReferenceUtils.js";var j;function R(e,t){if(null==e||null==t)return;const r=b(e,t);return null!=r?i(r,"radians","geographic"):void 0}!function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"}(j||(j={}));const b=(()=>{const e=f(),t=f();return(r,i)=>(u(e,r.x,r.y,r.z??0),u(t,i.x,i.y,i.z??0),y(e,t,r.spatialReference,i.spatialReference))})(),y=(()=>{const e=a(),t=f(),r=f();return(i,a,l,u)=>{if(c(i,a))return;const f=g(l),v=g(u);if(f&&v&&h(f,v)&&m(i,l,t,f)&&m(a,u,r,v)){const{azimuth:e}=p(V,t,r,f);return null!=e?o(e,"degrees","radians"):void 0}e[0]=a[0]-i[0],e[1]=a[1]-i[1];let d=n(s,e);return e[0]<0&&(d=k-d),d}})();function x(e,t,r,i=j.Absolute){if(t&&r)switch(i){case j.Absolute:return R(t,r);case j.Relative:return w(z(e,t,r),j.Relative);case j.RelativeBilateral:return w(z(e,t,r),j.RelativeBilateral)}}function z(e,t,r){if(!e||!t||!r)return;const o=b(e,t),n=b(t,r);return null!=o&&null!=n?i(n-o,"radians","geographic"):void 0}function w(e,t){if(null!=e)switch(t){case j.Absolute:return A(e);case j.Relative:{const t=T(e);let r=I.normalize(t,0,!0);return-180===r&&(r=180),i(r,"degrees","geographic")}case j.RelativeBilateral:{const t=T(e),r=Math.abs(I.normalize(t,0,!0));return i(r,"degrees","geographic")}}}function A(e){const t=T(e),r=C.normalize(t,0,!0);return i(r,"degrees","geographic")}function B(e,t,n){let a=o(e.value,e.unit,"degrees");return a=r(a,e.rotationType,n),a=o(a,"degrees",t),i(a,t,n)}const M=(()=>{const e=f();return(t,i,n,a,s,c="geodesic")=>{l(e,i);const f=T(s);if("geodesic"===c){const r=g(n);if(r&&m(e,n,e,r))return d(t,e,f,a,r),t[2]=i[2],!!m(t,r,t,n)}const p=r(f,"geographic","arithmetic"),v=o(p,"degrees","radians"),h=i[0]+a*Math.cos(v),j=i[1]+a*Math.sin(v),R=i[2];return u(t,h,j,R),!0}})();function T(e){if(null!=e)return r(q(e),e.rotationType,"geographic")}function U(e){if(null!=e)return r(q(e),e.rotationType,"arithmetic")}function q(e){return o(e.value,e.unit,"degrees")}const V=new v,k=2*Math.PI,C=e,I=new t(-180,180);export{j as DirectionMode,B as convertAngle,R as directionBetweenPoints,x as directionForVertices,U as getDegreesArithmetic,T as getDegreesGeographic,w as getNormalizedDirection,A as getNormalizedGeographicOrientation,M as pointFromDistanceAlongAzimuth,y as radiansGeographicBetweenVec};
