/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../Graphic.js";import i from"../../request.js";import{deprecatedFunction as r}from"../../core/deprecate.js";import s from"../../core/Error.js";import{clone as n}from"../../core/lang.js";import a from"../../core/Logger.js";import{watch as o}from"../../core/reactiveUtils.js";import{urlToObject as l}from"../../core/urlUtils.js";import{property as u}from"../../core/accessorSupport/decorators/property.js";import{Integer as p,ensureRange as m,ensureClass as c,ensureNumber as h}from"../../core/accessorSupport/ensureType.js";import{reader as d}from"../../core/accessorSupport/decorators/reader.js";import{subclass as f}from"../../core/accessorSupport/decorators/subclass.js";import{writer as y}from"../../core/accessorSupport/decorators/writer.js";import g from"../../geometry/Extent.js";import R from"../../geometry/Polygon.js";import I from"../../geometry/SpatialReference.js";import{srToRESTValue as v}from"../../geometry/support/spatialReferenceUtils.js";import{opacity as w,url as b}from"../support/commonProperties.js";import S from"../support/DimensionalDefinition.js";import{ExportImageServiceParameters as x}from"../support/ExportImageServiceParameters.js";import _ from"../support/Field.js";import F from"../support/FieldsIndex.js";import{createBitmap as D}from"../support/imageBitmapUtils.js";import{isSupportedRendererType as T}from"../support/imageryRendererUtils.js";import O from"../support/MosaicRule.js";import C from"../support/MultidimensionalSubset.js";import M from"../support/PixelBlock.js";import{interpolationKebab as P,noDataInterpretationKebab as N,pixelTypeKebabDict as q}from"../support/rasterEnums.js";import{getServicePixelValueField as j,getItemPixelValueField as A,getRawServicePixelValueField as E,getProcessedServicePixelValueField as V,getMagnitudeField as Q,getDirectionField as U,getMultidimensionalFields as J,getRasterAttributeTableFields as B,commonRasterFieldNames as L,addMultidimensionalFieldValues as z,rasterFieldPrefix as H}from"../support/rasterFieldUtils.js";import G from"../support/RasterFunction.js";import k from"../support/RasterInfo.js";import{intersectMultimensionalSubset as W,getEffectiveMultidimensionalDefinition as $,getSubsetVariablesFromMdInfo as X,getDefaultMultidimensionalDefinition as K}from"../support/rasterDatasets/multidimensionalUtils.js";import{decode as Y,getFormat as Z}from"../support/rasterFormats/RasterCodec.js";import{uvComponentToVector as ee}from"../support/rasterFunctions/vectorFieldUtils.js";import{getSupportedRendererTypes as te,matchPresetRenderer as ie,getDefaultBandCombination as re,createDefaultRenderer as se,normalizeRendererJSON as ne}from"../../renderers/support/rasterRendererHelper.js";import ae from"../../renderers/support/RasterSymbolizer.js";import{websceneRasterRendererTypes as oe,rasterRendererTypes as le,read as ue}from"../../renderers/support/rasterTypeUtils.js";import{calculateVolume as pe,computeAngles as me,computePixelSpaceLocations as ce,computeHistograms as he,computeStatisticsHistograms as de,measureHeight as fe,measureAreaAndPerimeter as ye,measureDistanceAndAngle as ge,measurePointOrCentroid as Re,measureLengthFromImage as Ie,measureAreaFromImage as ve,getImageSpatialReferenceQueryParameter as we,getSamples as be,identify as Se,imageToMap as xe,imageToMapMultiray as _e,mapToImage as Fe,findImages as De,getImageUrl as Te,queryBoundary as Oe,queryGPSInfo as Ce}from"../../rest/imageService.js";import{fetchServiceRasterInfo as Me,generateRasterInfo as Pe,patchServiceInfo as Ne}from"../../rest/imageService/fetchRasterInfo.js";import{getCatalogItemRasterInfo as qe}from"../../rest/imageService/getCatalogItemRasterInfo.js";import{executeForCount as je}from"../../rest/query/executeForCount.js";import{executeForIds as Ae}from"../../rest/query/executeForIds.js";import{executeQueryJSON as Ee}from"../../rest/query/executeQueryJSON.js";import Ve from"../../rest/support/FeatureSet.js";import Qe from"../../rest/support/ImageIdentifyParameters.js";import Ue from"../../rest/support/Query.js";const Je=new Set(["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"]),Be=m(h,{min:0,max:255});function Le(e){const t=JSON.stringify(e),i=t.includes('"rasterFunctionDefinition":{'),r=i?t.match(/"type":"(.*?FunctionArguments")/gi):t.match(/"rasterFunction":"(.*?")/gi),s=r?.map((e=>i?e.slice(8,-18):e.slice(18,-1)));return s?s.join("/"):null}const ze=m=>{let h=class extends m{constructor(){super(...arguments),this._functionRasterInfos={},this._serviceSupportsMosaicRule=null,this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType="polygon",this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set("exportImageServiceParameters",new x({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){const e=new Map;return!this.rasterFunctionInfos||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.length<1||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.forEach((t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,"_"),t.name)})),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every((e=>"number"==typeof e)))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,i){null!=e&&"lerc"!==this.format&&(t[i]=e)}writeCompressionTolerance(e,t,i){"lerc"===this.format&&null!=e&&(t[i]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?O.fromJSON(t):null}get fieldsIndex(){return this.fields?new F(this.fields):null}set format(e){e&&Je.has(e.toLowerCase())&&this._set("format",e.toLowerCase())}readFormat(e,t){return"esriImageServiceDataTypeVector-UV"===t.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===t.serviceDataType||null!=this.pixelFilter?"lerc":"jpgpng"}readMinScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}readMaxScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=O.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set("mosaicRule",t)}readMosaicRule(e,t){const i=e||t.mosaicRule;return i?O.fromJSON(i):this._isMosaicRuleSupported(t)?O.fromJSON(t):null}writeMosaicRule(e,t,i){const{mosaicRule:r}=this;this._isValidCustomizedMosaicRule(r)&&(t[i]=r.toJSON())}writeNoData(e,t,i){null!=e&&"number"==typeof e&&(t[i]=Be(e))}readObjectIdField(e,t){if(!e){const i=t.fields.find((e=>"esriFieldTypeOID"===e.type||"oid"===e.type));e=i?.name}return e}get parsedUrl(){return l(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?"mosaic-dataset":"raster-dataset"}get renderer(){const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const i=t?.find((({name:t})=>t===e));return i?.renderer.clone()}return this.internalRenderer}set renderer(e){this.activePresetRendererName=null,this.internalRenderer=e}set internalRenderer(e){this.loaded&&(e=this._configRenderer(e)),this._set("internalRenderer",e)}readRenderer(e,t,i){const r=t?.layerDefinition?.drawingInfo?.renderer,s=ue(r,i);return null==s?null:("vector-field"===s.type&&t.symbolTileSize&&!r.symbolTileSize&&(s.symbolTileSize=t.symbolTileSize),T(s)||a.getLogger(this).warn("ArcGISImageService","Imagery layer doesn't support given renderer type."),s)}writeRenderer(e,t,i){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),"vector-field"===e.type&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){const e=this.fields?.map((e=>e.clone()))??[];e.push(j()),"mosaic-dataset"===this.sourceType&&this.fields?.length&&e.push(A()),this.version>=10.4&&null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.some((({name:e})=>"none"===e.toLowerCase()))&&e.push(E()),null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.filter((({name:e})=>"none"!==e.toLowerCase())).forEach((({name:t})=>e.push(V(t))));const{rasterInfo:t}=this;if(this._isVectorDataSet()){const i=t?.multidimensionalInfo?.variables[0].unit?.trim(),r=Q(i),s=U();e.push(r,s)}if(t?.multidimensionalInfo&&"raster-dataset"===this.sourceType){const i=J(t.multidimensionalInfo);e.push(...i)}const i=t?.attributeTable;if(null!=i){const t=B(i);e.push(...t)}return e}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=G.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set("rasterFunction",t)}readRasterFunction(e,t){const i=t.rasterFunctionInfos;return t.renderingRule||i?.length&&"None"!==i[0].name?this._isRFTJson(t.renderingRule)?G.fromJSON({rasterFunctionDefinition:t.renderingRule}):G.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){const i=e||t.extent.spatialReference;return i?I.fromJSON(i):null}writePixelType(e,t,i){null!=this.serviceRasterInfo&&this.pixelType===this.serviceRasterInfo.pixelType||(t[i]=q.toJSON(e))}readVersion(e,t){let i=t.currentVersion;return i||(i=t.hasOwnProperty("fields")||t.hasOwnProperty("timeInfo")?10:9.3),i}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let i=e;const{renderer:r,symbolizer:s,pixelFilter:n}=this;if(!this._isPicture()&&r&&s&&!n){await this._updateSymbolizer(s,r);const{bandIds:n}=this;i=await this._symbolize({pixelData:e,bandIds:n,symbolizer:s},t)}return i}destroy(){this._shutdownJobHandler()}async calculateVolume(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsCalculateVolume)throw new s("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return e=n(e),this.mosaicRule&&null==e.mosaicRule&&(e.mosaicRule=this.mosaicRule),pe(this.url,e,this._getRequestOptions(t))}async computeAngles(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeAngles)throw new s("imagery-layer:compute-angles","this operation is not supported on the input image service");return me(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputePixelLocation)throw new s("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return ce(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeHistograms)throw new s("imagery-layer:compute-histograms","this operation is not supported on the input image service");return e=n(e),this._applyMosaicAndRenderingRules(e),he(this.url,e,this._getRequestOptions(t))}async computeStatisticsHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeStatisticsHistograms)throw new s("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");return e=n(e),this._applyMosaicAndRenderingRules(e),de(this.url,e,this._getRequestOptions(t))}async measureHeight(e,t){const i=await this._fetchCapabilities(t?.signal);if(!("base-and-top"===e.operationType?i.mensuration.supportsHeightFromBaseAndTop:"base-and-top-shadow"===e.operationType?i.mensuration.supportsHeightFromBaseAndTopShadow:i.mensuration.supportsHeightFromTopAndTopShadow))throw new s("imagery-layer:measure-height","this operation is not supported on the input image service");return e=n(e),this._applyMosaicRule(e),fe(this.url,e,this._getRequestOptions(t))}async measureAreaAndPerimeter(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsAreaAndPerimeter&&(!e.is3D||i.mensuration.supports3D)))throw new s("imagery-layer:measure-area-and-perimeter","this operation is not supported on the input image service");return e=n(e),this._applyMosaicRule(e),ye(this.url,e,this._getRequestOptions(t))}async measureDistanceAndAngle(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsDistanceAndAngle&&(!e.is3D||i.mensuration.supports3D)))throw new s("imagery-layer:measure-distance-and-angle","this operation is not supported on the input image service");return e=n(e),this._applyMosaicRule(e),ge(this.url,e,this._getRequestOptions(t))}async measurePointOrCentroid(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsPointOrCentroid&&(!e.is3D||i.mensuration.supports3D)))throw new s("imagery-layer:measure-point-or-centroid","this operation is not supported on the input image service");return e=n(e),this._applyMosaicRule(e),Re(this.url,e,this._getRequestOptions(t))}async measureLengthFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new s("imagery-layer:measure-length-from-image","this operation is not supported on the input image service");if("polyline"!==e.geometry.type)throw new s("imagery-layer:measure-length-from-image","this input geometry must be a polyline");return Ie(this.url,e,this._getRequestOptions(t))}async measureAreaFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new s("imagery-layer:measure-area-from-image","this operation is not supported on the input image service");if("polygon"!==e.geometry.type)throw new s("imagery-layer:measure-area-from-image","this input geometry must be a polygon");return ve(this.url,e,this._getRequestOptions(t))}getField(e){const{fieldsIndex:t}=this;return null!=t?t.get(e):void 0}getFieldDomain(e,t){const i=this.getField(e);return i?i.domain:null}fetchImage(e,t,i,n={}){if(r(a.getLogger(this),"`ImageryLayer.fetchImage` is deprecated in favor of 'ImageryLayer.fetchPixels'.",{replacement:"ImageryLayer.fetchPixels",version:"4.33",warnOnce:!0}),null==e||null==t||null==i)throw new s("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");return this.internalFetchImage(e,t,i,n)}async internalFetchImage(e,t,i,r={}){await this._updateCurrentRasterInfo();const s=this.getExportImageServiceParameters(e,t,i,r.timeExtent);if(null==s){if(r.requestAsImageElement&&this._canRequestImageElement(this.format)){const e=document.createElement("canvas");if(e.width=t,e.height=i,r.returnImageBitmap){return{imageBitmap:await D(e,`${ze(this.parsedUrl)}/exportImage`,r.signal)}}return{imageOrCanvasElement:e}}const{bandIds:s,rasterInfo:n}=this,a=(s?.length||n.bandCount)??0,o=t*i,l=n.pixelType,u=[];for(let e=0;e<a;e++)u.push(M.createEmptyBand(l,o));return{pixelData:{pixelBlock:new M({width:t,height:i,pixels:u,mask:new Uint8Array(o),pixelType:l}),extent:e}}}const n=!!r.requestAsImageElement&&!this.pixelFilter,a=n&&!!r.returnImageBitmap,o={imageServiceParameters:s,imageProps:{extent:e,width:t,height:i,format:this.format},requestAsImageElement:n,returnImageBitmap:a,signal:r.signal};return this._requestArrayBuffer(o)}async fetchPixels(e,t,i,r={}){await this._initJobHandler(),r.applyRendering&&await this._updateCurrentRasterInfo();const s=r.applyRendering?void 0:new x({layer:this,requestRawData:!0,interpolation:r.interpolation??"nearest",bandIds:r.bandIds??[]}),n=this.getExportImageServiceParameters(e,t,i,r.timeExtent,s);if(null==n)return{extent:e,pixelBlock:null};delete n.pixelType,delete n.bandIds,delete n.compressionQuality;const a={imageServiceParameters:n,imageProps:{extent:e,width:t,height:i,format:this.format},requestAsImageElement:!1,returnImageBitmap:!1,signal:r.signal},{pixelData:o}=await this._requestArrayBuffer(a);return o??{extent:e,pixelBlock:null}}fetchKeyProperties(e){return i(ze(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>e.data))}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new s("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):i(ze(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>Ve.fromJSON(e.data)))}getCatalogItemRasterInfo(e,t){const i={...t,query:this._getQueryParams()};return qe(ze(this.parsedUrl),e,i)}async getCatalogItemICSInfo(e,t){const{data:r}=await i(ze(this.parsedUrl)+"/"+e+"/info/ics",{query:this._getQueryParams(),...t}),s=r?.ics;if(!s)return;let n=null;try{n=(await i(ze(this.parsedUrl)+"/"+e+"/info",{query:this._getQueryParams(),...t})).data.extent}catch{}if(!n?.spatialReference)return{ics:s,icsToPixelTransform:null,icsExtent:null,northDirection:null};const a=this.version>=10.7?i(ze(this.parsedUrl)+"/"+e+"/info/icstopixel",{query:this._getQueryParams(),...t}).then((e=>e.data)).catch((()=>({}))):{},o=n.spatialReference,l={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[n]}),inSR:v(o),outSR:"0:"+e},u=i(ze(this.parsedUrl)+"/project",{query:this._getQueryParams(l),...t}).then((e=>e.data)).catch((()=>({}))),p=5,m=(n.xmin+n.xmax)/2,c=(n.ymax-n.ymin)/(p+1),h=n.ymin+c,d=[];for(let i=0;i<p;i++)d.push({x:m,y:h+c*i});const f={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:d}),inSR:v(o),outSR:"0:"+e},y=i(ze(this.parsedUrl)+"/project",{query:this._getQueryParams(f),...t}).then((e=>e.data)).catch((()=>({}))),R=await Promise.all([a,u,y]);let w=R[0].ipxf;if(null==w){const e=s.geodataXform?.xf_0;"topup"===e?.name?.toLowerCase()&&6===e?.coefficients?.length&&(w={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:e.coefficients,cellsizeRatio:0,type:"GeometricXform"}})}const b=g.fromJSON(R[1]?.geometries?.[0]);b&&(b.spatialReference=new I({wkid:0,imageCoordinateSystem:s}));const S=R[2].geometries?R[2].geometries.filter((e=>null!=e?.x&&null!=e.y&&"NaN"!==e.x&&"NaN"!==e.y)):[],x=S.length;if(x<3)return{ics:s,icsToPixelTransform:w,icsExtent:b,northDirection:null};let _=0,F=0,D=0,T=0;for(let i=0;i<x;i++)_+=S[i].x,F+=S[i].y,D+=S[i].x*S[i].x,T+=S[i].x*S[i].y;const O=(x*T-_*F)/(x*D-_*_);let C=0;const M=S[p-1].x>S[0].x,P=S[p-1].y>S[0].y;return O===1/0?C=P?90:270:0===O?C=M?0:180:O>0?C=M?180*Math.atan(O)/Math.PI:180*Math.atan(O)/Math.PI+180:O<0&&(C=P?180+180*Math.atan(O)/Math.PI:360+180*Math.atan(O)/Math.PI),{ics:s,icsToPixelTransform:w,icsExtent:b,northDirection:C}}async generateRasterInfo(e,t){e=c(G,e);const i={...t,query:this._getQueryParams()};if(!e||"none"===e.functionName?.toLowerCase()||this._isVectorFieldResampleFunction(e))return this.serviceRasterInfo??Me(ze(this.parsedUrl),this.sourceJSON,i);const r=Le(e);if(!r)throw new s("imagery-layer:generate-raster-info","the rendering rule is not supported");if(this._functionRasterInfos[r])return this._functionRasterInfos[r];const n=Pe(ze(this.parsedUrl),e,i);this._functionRasterInfos[r]=n;try{return await n}catch(a){throw this._functionRasterInfos[r]=null,a}}getExportImageServiceParameters(e,t,i,r,s){e=e.clone().shiftCentralMeridian();const n=we(e.spatialReference,ze(this.parsedUrl));s??=this.exportImageServiceParameters;const a=s.toJSON(),{bandIds:o,noData:l}=a;let{renderingRule:u}=a;const p=this.rasterFunction?.rasterFunctionDefinition,m=this.renderer?.type,c=!m||"raster-stretch"===m||"raster-colormap"===m||"unique-value"===m||"class-breaks"===m||"raster-shaded-relief"===m;if(o?.length&&this._hasRasterFunction(this.rasterFunction)&&!p&&c){const e={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:o}};if("Stretch"===u.rasterFunction)e.rasterFunctionArguments.Raster=u.rasterFunctionArguments.Raster,u.rasterFunctionArguments.Raster=e;else if("Colormap"===u.rasterFunction){const t=u.rasterFunctionArguments.Raster;"Stretch"===t?.rasterFunction?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,u.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=u,u=e;a.bandIds=void 0}else a.bandIds=o?.join(",");Array.isArray(l)&&l.length>0&&(a.noData=l.join(","));const h=this._processMultidimensionalIntersection(null,r,s.mosaicRule);if(h.isOutSide)return null;a.mosaicRule=null!=h.mosaicRule?JSON.stringify(h.mosaicRule):null,r=h.timeExtent,a.renderingRule=this._getRenderingRuleString(G.fromJSON(u));const d={};if(null!=r){const{start:e,end:t}=r.toJSON();e&&t&&e===t?d.time=""+e:null==e&&null==t||(d.time=`${e??"null"},${t??"null"}`)}return{bbox:e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:n,imageSR:n,size:t+","+i,...a,...d}}async getSamples(e,t){const i=await this._fetchCapabilities(t?.signal);if(!i?.operations.supportsGetSamples)throw new s("imagery-layer:get-samples","getSamples operation is not supported on the input image service");e=n(e);const{raster:r}=this;return r&&null==e.raster&&(e.raster=r),be(this.url,e,this._getRequestOptions(t))}async identify(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsIdentify)throw new s("imagery-layer:identify","identify operation is not supported on the input image service");e=n(e),this.version<10.91&&"extent"===e.geometry?.type&&(e.geometry=R.fromExtent(e.geometry));const i=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(i.isOutSide)throw new s("imagery-layer:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");e.timeExtent=i.timeExtent,e.mosaicRule=i.mosaicRule;const{raster:r,rasterFunction:a}=this;return a&&null==e.rasterFunction&&(e.rasterFunction=a),r&&null==e.raster&&(e.raster=r),Se(this.url,e,this._getRequestOptions(t))}async imageToMap(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMap)throw new s("imagery-layer:image-to-map","imageToMap operation is not supported on the input image service");return xe(ze(this.parsedUrl),e,this._getRequestOptions(t))}async imageToMapMultiray(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMapMultiray)throw new s("imagery-layer:image-to-map-multiray","imageToMapMultiray operation is not supported on the input image service");return _e(ze(this.parsedUrl),e,this._getRequestOptions(t))}async mapToImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMapToImage)throw new s("imagery-layer:map-to-image","mapToImage operation is not supported on the input image service");return Fe(ze(this.parsedUrl),e,this._getRequestOptions(t))}async findImages(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsFindImages)throw new s("imagery-layer:find-images","findImages operation is not supported on the input image service");return De(ze(this.parsedUrl),e,this._getRequestOptions(t))}async getImageUrl(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsGetImageUrl)throw new s("imagery-layer:get-image-url","getImageUrl operation is not supported on the input image service");return Te(ze(this.parsedUrl),e,this._getRequestOptions(t))}createQuery(){return new Ue({outFields:["*"],returnGeometry:!0,where:this.definitionExpression||"1=1"})}async queryBoundary(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryBoundary)throw new s("imagery-layer:query-boundary","queryBoundary operation is not supported on the input image service");return e=e??{outSpatialReference:this.spatialReference},Oe(ze(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasters(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),Ee(this.url,e,t)}async queryObjectIds(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),Ae(this.url,e,t)}async queryGPSInfo(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryGPSInfo)throw new s("imagery-layer:query-gps-info","queryGPSInfo operation is not supported on the input image service");return e=e??{where:"1=1"},Ce(ze(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasterCount(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),je(this.url,e,t)}async queryVisibleRasters(e,t){if(!e)throw new s("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const{pixelSize:i,returnDomainValues:r,returnTopmostRaster:n,showNoDataRecords:a}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let o=!1,l=null,u=null;const p=L.servicePixelValue.toLowerCase(),m=this._rasterFunctionNamesIndex;if(null!=e.outFields&&(o=e.outFields.some((e=>!e.toLowerCase().startsWith(p))),this.version>=10.4)){const t=e.outFields.filter((e=>e.toLowerCase().startsWith(p)&&e.length>p.length)).map((e=>{const t=e.slice(p.length+1);return[this._updateRenderingRulesFunctionName(t,m),t]}));l=t.map((e=>new G({functionName:e[0]}))),u=t.map((e=>e[1]));const{rasterFunction:i}=this;0===l.length?i?.functionName?(l.push(i),u.push(i.functionName)):l=null:i?.functionName&&!l.some((e=>e.functionName===i.functionName))&&(l.push(i),u.push(i.functionName))}const c=null==e.outSpatialReference||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:h}=this;let d=e.timeExtent||this.timeExtent;if(h){const{isOutside:t,intersection:i}=W(h,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(t)throw new s("imagery-layer:query-visible-rasters","the request cannot be fulfilled when falling outside of the multidimensional subset");null!=i?.timeExtent&&(d=i.timeExtent)}const f=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,d);let y=e.geometry;this.version<10.91&&"extent"===y?.type&&(y=R.fromExtent(y));const g=this._getQueryParams({geometry:y,timeExtent:d,mosaicRule:f,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:l,pixelSize:i,returnCatalogItems:o,returnGeometry:c,raster:this.raster,maxItemCount:n?1:null});delete g.f;const I=new Qe(g);try{await this._generateRasterInfo(this.rasterFunction);const i=await Se(this.url,I,{signal:t?.signal,query:{...this.customParameters}}),s=e.outFields,n=null!=i.value&&i.value.toLowerCase().includes("nodata"),l=o&&!c&&i?.catalogItems?.features.length&&(a||!n),p=this.multidimensionalInfo&&"raster-dataset"===this.sourceType?$({rasterInfo:this.rasterInfo,multidimensionalDefinition:f?.multidimensionalDefinition,timeExtent:d,multidimensionalSubset:this.multidimensionalSubset}):null;if(!l)return this._processVisibleRastersResponse(i,{returnDomainValues:r,templateRRFunctionNames:u,showNoDataRecords:a,templateFields:s,effectiveMultidimensionalDefinition:p});const m=this.objectIdField||"ObjectId",h=i.catalogItems?.features??[],y=h.map((e=>e.attributes?.[m])),g=new Ue({objectIds:y,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[m]}),R=await this.queryRasters(g);return R?.features?.length&&R.features.forEach((t=>{h.forEach((i=>{i.attributes[m]===t.attributes[m]&&t.geometry&&(i.geometry=t.geometry.clone(),null!=e.outSpatialReference&&(i.geometry.spatialReference=e.outSpatialReference))}))})),this._processVisibleRastersResponse(i,{returnDomainValues:r,templateRRFunctionNames:u,showNoDataRecords:a,templateFields:s,effectiveMultidimensionalDefinition:p})}catch{throw new s("imagery-layer:query-visible-rasters","encountered error when querying visible rasters")}}async fetchVariableStatisticsHistograms(e,t){const r=i(ze(this.parsedUrl)+"/statistics",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.statistics)),s=i(ze(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.histograms)),n=await Promise.all([r,s]);return n[0]&&n[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:n[0]||null,histograms:n[1]||null}}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo.multidimensionalInfo;return X(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const t=this.sourceJSON,i=null!=this.serviceRasterInfo?Promise.resolve(this.serviceRasterInfo):Me(ze(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then((e=>(this._set("serviceRasterInfo",e),this._set("multidimensionalInfo",e.multidimensionalInfo),Ne(e,t),e))),r=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,s=this._getRasterFunctionInfos();return Promise.all([i,r,s]).then((e=>{e[1]?this._set("rasterInfo",e[1]):this._set("rasterInfo",e[0]),e[2]&&this._set("rasterFunctionInfos",e[2]),this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set("internalRenderer",null),a.getLogger(this).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")),this._set("internalRenderer",this._configRenderer(this.renderer)),this.addHandles([o((()=>this.rasterFunction),(e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then((e=>{e&&(this.rasterInfo=e)}))}))]);const{serviceRasterInfo:t}=this;null!=t.multidimensionalInfo&&this._updateMultidimensionalDefinition(t)}))}_combineMosaicRuleWithTimeExtent(e,t){const i=this.timeInfo,{multidimensionalInfo:r}=this.serviceRasterInfo;if(null==e||null==r||null==t||null==i?.startField)return e;const{startField:s}=i,n=r.variables.some((e=>e.dimensions.some((e=>e.name===s))))?s:"StdTime";if(e=e.clone(),"mosaic-dataset"===this.sourceType)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter((e=>e.dimensionName!==n)),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];const a=e.multidimensionalDefinition.filter((e=>e.dimensionName===n)),o=null!=t.start?t.start.getTime():null,l=null!=t.end?t.end.getTime():null,u=null==o||null==l||o===l,p=u?[o||l]:[[o,l]],m=this.version>=10.8;if(a.length)a.forEach((e=>{e.dimensionName===n&&(m?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=u,e.values=p))}));else if(!m){const t=e.multidimensionalDefinition.filter((e=>null!=e.variableName&&null==e.dimensionName));t.length?t.forEach((e=>{e.dimensionName=n,e.isSlice=u,e.values=p})):e.multidimensionalDefinition.push(new S({variableName:"",dimensionName:n,isSlice:u,values:p}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return null==e?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter((e=>!(!e.variableName&&!e.dimensionName))),0===e.multidimensionalDefinition.length&&(e.multidimensionalDefinition=null)),"mosaic-dataset"!==this.sourceType&&null==e.multidimensionalDefinition?null:e)}async _prepareForQuery(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQuery)throw new s("imagery-layer:query-rasters","query operation is not supported on the input image service");return e=null!=e?c(Ue,e):this.createQuery(),t=this._getRequestOptions(t),this.raster&&(t.query={...t.query,raster:this.raster}),{query:e,requestOptions:t}}_isSupportedRenderer(e){const{rasterInfo:t,rasterFunction:i}=this;return"unique-value"===e.type&&this._hasRasterFunction(i)&&1===t?.bandCount&&["u8","s8"].includes(t.pixelType)||null!=t&&null!=e&&te(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let t=this.sourceJSON;if(!t){const{data:r,ssl:s}=await i(ze(this.parsedUrl),{query:this._getQueryParams(),signal:e});t=r,this.sourceJSON=t,s&&(this.url=this.url.replace(/^http:/i,"https:"))}if(t.capabilities?.toLowerCase().split(",").map((e=>e.trim())).indexOf("tilesonly")>-1)throw new s("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(t,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?"esriImageServiceSourceTypeMosaicDataset"===e.serviceSourceType:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;const t=this._isMosaicDataset(e),i=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||i}_isVectorFieldResampleFunction(e){if(null==e)return!1;const{functionName:t,functionArguments:i}=e,r="resample"===t?.toLowerCase(),s=i?.ResampleType||i?.resampleType;return r&&(7===s||10===s)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(e){const t=this._isPicture(),{rasterInfo:i}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){const t=this.mosaicRule?.multidimensionalDefinition?.[0].variableName,r=ie({variableName:t,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&i.bandCount>=3){const e=r?.bandIds??re(i);!e||3===i.bandCount&&0===e[0]&&1===e[1]&&2===e[2]||(this.bandIds=e)}e||(e=r?.renderer??se(i,{bandIds:this.bandIds,variableName:this.rasterFunction?null:t}));const s=ne(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=s,this.symbolizer.rasterInfo=i):this.symbolizer=new ae({rendererJSON:s,rasterInfo:i}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return null==e?e:{extent:e.extent&&e.extent.clone(),pixelBlock:null!=e.pixelBlock?e.pixelBlock.clone():null}}_getQueryParams(e){null!=e?.renderingRule&&"string"!=typeof e.renderingRule&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));const{raster:t,viewId:i}=this;return{raster:t,viewId:i,f:"json",...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,i){return this._rasterJobHandler?this._rasterJobHandler.decode({data:e,options:t}):Y(e,t,i)}async _getRasterFunctionInfos(e){const t=this.sourceJSON.rasterFunctionInfos;if(this.loaded)return t;if(t&&this.version>=10.3){if(1===t.length&&"none"===t[0].name.toLowerCase())return t;const r=await i(ze(this.parsedUrl)+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:e});return r.data?.rasterFunctionInfos}return null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes("png"))}async _requestArrayBuffer(e){const{imageProps:t,requestAsImageElement:r,returnImageBitmap:n,signal:a}=e;if(r&&this._canRequestImageElement(t.format)){const r=`${ze(this.parsedUrl)}/exportImage`,{data:s}=await i(r,{responseType:n?"blob":"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...e.imageServiceParameters}),signal:a});if(s instanceof Blob){return{imageBitmap:await D(s,r,a),params:t}}return{imageOrCanvasElement:s,params:t}}const o=this._initJobHandler(),l=i(ze(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...e.imageServiceParameters}),signal:a}),u=(await Promise.all([l,o]))[0].data,p=t.format||"jpgpng";let m=p;if("bsq"!==m&&"bip"!==m&&(m=Z(u)),!m)throw new s("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(u)));const c={signal:a},h="gif"===p||"bmp"===p||p.includes("png")&&("png"===m||"jpg"===m)?Y(u,{useCanvas:!0,...t},c):this._decodePixelBlock(u,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:p},c);return{pixelData:{pixelBlock:await h,extent:t.extent},params:t}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch((()=>null))}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=K(e,{multidimensionalSubset:this.multidimensionalSubset});if(null!=t&&t.length>0){this.mosaicRule=this.mosaicRule||new O;const e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&"none"!==this.rasterFunction.functionName?.toLowerCase()&&t.forEach((e=>e.variableName="")),t=t.filter((({variableName:e,dimensionName:t})=>e&&"*"!==e||t)),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,i){i=i||{};const r=e.value,{templateRRFunctionNames:s,showNoDataRecords:n,returnDomainValues:a,templateFields:o}=i,l=e.processedValues;let u=e.catalogItems?.features,p=e.properties?.Values?.map((e=>e.replaceAll(/ /gi,", ")))||[];const m=this.objectIdField||"ObjectId",c="string"==typeof r&&r.toLowerCase().includes("nodata"),h=[];if(r&&!u&&(!c||n)){const e={};e[m]=0;p=[r],u=[new t({geometry:this.fullExtent,attributes:e})],this.multidimensionalInfo&&"raster-dataset"===this.sourceType&&z(this.rasterFields,e,i.effectiveMultidimensionalDefinition)}if(!u)return[];this._updateResponseFieldNames(u,o),c&&!n&&(u=[]);const{itemPixelValue:d,servicePixelValue:f}=L,y=this.rasterFields.some((e=>e.name===d));for(let t=0;t<u.length;t++){const e=u[t];if(null!=r){const i=p[t],a=this.rasterFunction&&l&&l.length>0&&s&&s.length>0&&s.includes(this.rasterFunction.functionName)?l[s.indexOf(this.rasterFunction.functionName)]:r;if("nodata"===i.toLowerCase()&&!n)continue;y&&(e.attributes[d]=i),e.attributes[f]=a,this._updateFeatureWithMagDirValues(e,i);const o=this.fields&&this.fields.length>0;let u=this.rasterFunction&&null!=this.serviceRasterInfo.attributeTable?o?i:r:a;this.rasterFunction||(u=o?i:r),this._updateFeatureWithRasterAttributeTableValues(e,u)}if(e.sourceLayer=e.layer=this,a&&this._updateFeatureWithDomainValues(e),s&&l&&s.length===l.length)for(let t=0;t<s.length;t++){const i=`${L.servicePixelValue}.${s[t]}`;e.attributes[i]=l[t]}h.push(u[t])}return h}_processMultidimensionalIntersection(e,t,i){const{multidimensionalSubset:r}=this;if(!r)return{isOutSide:!1,timeExtent:t,mosaicRule:i=this._combineMosaicRuleWithTimeExtent(i,t)};if(r){const{isOutside:i,intersection:s}=W(r,{geometry:e,timeExtent:t});if(i)return{isOutSide:!0,timeExtent:null,mosaicRule:null};null!=s?.timeExtent&&(t=s.timeExtent)}if(i=this._combineMosaicRuleWithTimeExtent(i,t),i?.multidimensionalDefinition){const{isOutside:e}=W(r,{multidimensionalDefinition:i.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:i}}_updateFeatureWithRasterAttributeTableValues(e,t){const i=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(null==i)return;const{features:r,fields:s}=i,n=s.map((e=>e.name)).find((e=>"value"===e.toLowerCase()));if(!n)return;const a=r.filter((e=>e.attributes[n]===(null!=t?parseInt(t,10):null)));a&&a[0]&&s.forEach((t=>{const i=H+t.name;e.attributes[i]=a[0].attributes[t.name]}))}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;const i=t.split(/,\s*/).map((e=>parseFloat(e))),r=i.map((e=>[e])),s=i.map((e=>({minValue:e,maxValue:e,noDataValue:null}))),n=new M({height:1,width:1,pixelType:"f32",pixels:r,statistics:s});null!=this.pixelFilter&&this.pixelFilter({pixelBlock:n,extent:new g(0,0,0,0,this.spatialReference)});const a="esriImageServiceDataTypeVector-MagDir"===this.serviceDataType?[n.pixels[0][0],n.pixels[1][0]]:ee([n.pixels[0][0],n.pixels[1][0]]);e.attributes[L.magnitude]=a[0],e.attributes[L.direction]=a[1]}_updateFeatureWithDomainValues(e){const t=this.fields&&this.fields.filter((e=>e.domain&&"coded-value"===e.domain.type));null!=t&&t.forEach((t=>{const i=e.attributes[t.name];if(null!=i){const r=t.domain.codedValues.find((e=>e.code===i));r&&(e.attributes[t.name]=r.name)}}))}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;const i=this.fieldsIndex;null!=i&&e.forEach((e=>{if(e?.attributes)for(const r of t){const t=i.get(r)?.name;t&&t!==r&&(e.attributes[r]=e.attributes[t],delete e.attributes[t])}}))}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return null!=e?.functionName&&"none"!==e.functionName.toLowerCase()}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if("Raw"===e)return e.replace("Raw","None");const i=e.toLowerCase().replaceAll(/ /gi,"_");return t.has(i)?t.get(i):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty("functionType")}_isVectorDataSet(){return"esriImageServiceDataTypeVector-UV"===this.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===this.serviceDataType}_applyMosaicAndRenderingRules(e){const{raster:t,mosaicRule:i,rasterFunction:r}=this;r&&null==e.rasterFunction&&(e.rasterFunction=r),i&&null==e.mosaicRule&&(e.mosaicRule=i),t&&null==e.raster&&(e.raster=t)}async _updateCurrentRasterInfo(e){if(this.renderer||this.symbolizer){const t=await this._generateRasterInfo(this.rasterFunction,{signal:e});t&&(this.rasterInfo=t)}}_applyMosaicRule(e){const{raster:t,mosaicRule:i}=this;i&&null==e.mosaicRule&&(e.mosaicRule=i),t&&null==e.raster&&(e.raster=t)}_readCapabilities(e){const t=e.capabilities?e.capabilities.toLowerCase().split(",").map((e=>e.trim())):["image","catalog"],{currentVersion:i,maxRecordCount:r}=e,s=t.includes("image"),n="esriImageServiceDataTypeElevation"===e.serviceDataType,a=!(!e.spatialReference&&!e.extent?.spatialReference),o=t.includes("edit"),l=t.includes("mensuration")&&a,u=null==e.mensurationCapabilities?[]:e.mensurationCapabilities.toLowerCase().split(",").map((e=>e.trim())),p=l&&u.includes("basic"),m=this._isMosaicDataset(e)&&t.includes("catalog"),c=t.includes("download"),h=i>=10.7&&n||i>=11.4&&(n||l&&u.includes("3d")),d=m&&e.fields&&e.fields.length>0,f=d&&e.supportsAdvancedQueries?e.advancedQueryCapabilities:void 0;return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:s,supportsExportImage:s,supportsIdentify:s,supportsImageToMap:i>=11.2&&m,supportsImageToMapMultiray:i>=11.2&&m,supportsMapToImage:i>=11.2&&m,supportsFindImages:i>=11.2&&m,supportsGetImageUrl:i>=11.3&&c,supportsMeasure:l,supportsMeasureFromImage:i>=11.2,supportsDownload:c,supportsQuery:d,supportsGetSamples:i>=10.2&&s,supportsProject:i>=10.3&&s,supportsComputeStatisticsHistograms:i>=10.4&&s,supportsQueryBoundary:i>=10.6&&s,supportsCalculateVolume:h,supportsComputePixelLocation:i>=10.7&&m,supportsComputeAngles:i>=10.91,supportsQueryGPSInfo:i>=11.2&&m,supportsAdd:o,supportsDelete:o,supportsEditing:o,supportsUpdate:o,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:r,maxRecordCountFactor:void 0,maxUniqueIDCount:void 0,supportsStatistics:!!f?.supportsStatistics,supportsOrderBy:!!f?.supportsOrderBy,supportsDistinct:!!f?.supportsDistinct,supportsPagination:!!f?.supportsPagination,supportsPaginationOnAggregatedQueries:!!f?.supportsPaginationOnAggregatedQueries,supportsStandardizedQueriesOnly:!!f?.useStandardizedQueries,supportsPercentileStatistics:!!f?.supportsPercentileStatistics,supportsCentroid:!!f?.supportsReturningGeometryCentroid,supportsCurrentUser:!1,supportsDistance:!!f?.supportsQueryWithDistance,supportsExtent:!!f?.supportsReturningQueryExtent,supportsGeometryProperties:!!f?.supportsReturningGeometryProperties,supportsHavingClause:!!f?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsReturnMesh:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:f?.supportsSqlExpression??!!f,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!f?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0,supportsTrueCurve:!1},mensuration:{supportsDistanceAndAngle:p,supportsAreaAndPerimeter:p,supportsPointOrCentroid:p,supportsHeightFromBaseAndTop:l&&u.includes("base-top height"),supportsHeightFromBaseAndTopShadow:l&&u.includes("base-top shadow height"),supportsHeightFromTopAndTopShadow:l&&u.includes("top-top shadow height"),supports3D:l&&u.includes("3d")}}}};function ze(e){return e?.path??""}return e([u({clonable:!1})],h.prototype,"_functionRasterInfos",void 0),e([u({readOnly:!0})],h.prototype,"_serviceSupportsMosaicRule",void 0),e([d("_serviceSupportsMosaicRule",["currentVersion","fields"])],h.prototype,"readServiceSupportsMosaicRule",null),e([u({readOnly:!0})],h.prototype,"_rasterFunctionNamesIndex",null),e([u()],h.prototype,"adjustAspectRatio",void 0),e([u({type:[p],json:{write:!0}})],h.prototype,"bandIds",void 0),e([d("bandIds")],h.prototype,"readBandIds",null),e([u({readOnly:!0,json:{read:!1}})],h.prototype,"capabilities",void 0),e([d("service","capabilities",["capabilities","currentVersion","serviceDataType"])],h.prototype,"readCapabilities",null),e([u({type:Number})],h.prototype,"compressionQuality",void 0),e([y("compressionQuality")],h.prototype,"writeCompressionQuality",null),e([u({type:Number})],h.prototype,"compressionTolerance",void 0),e([y("compressionTolerance")],h.prototype,"writeCompressionTolerance",null),e([u({json:{read:{source:"copyrightText"}}})],h.prototype,"copyright",void 0),e([u({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],h.prototype,"defaultMosaicRule",void 0),e([d("defaultMosaicRule",["defaultMosaicMethod"])],h.prototype,"readDefaultMosaicRule",null),e([u({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],h.prototype,"definitionExpression",void 0),e([u({readOnly:!0,constructOnly:!0})],h.prototype,"exportImageServiceParameters",void 0),e([u()],h.prototype,"rasterInfo",void 0),e([u({readOnly:!0,type:[_]})],h.prototype,"fields",void 0),e([u({readOnly:!0})],h.prototype,"fieldsIndex",null),e([u({type:["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff","bip","bsq"],json:{write:!0}})],h.prototype,"format",null),e([d("service","format",["serviceDataType"])],h.prototype,"readFormat",null),e([u({type:g})],h.prototype,"fullExtent",void 0),e([u({readOnly:!0})],h.prototype,"hasMultidimensions",void 0),e([u({json:{read:{source:"maxImageHeight"}}})],h.prototype,"imageMaxHeight",void 0),e([u({json:{read:{source:"maxImageWidth"}}})],h.prototype,"imageMaxWidth",void 0),e([u({type:String,json:{type:P.jsonValues,read:P.read,write:P.write}})],h.prototype,"interpolation",void 0),e([u()],h.prototype,"minScale",void 0),e([d("service","minScale")],h.prototype,"readMinScale",null),e([u()],h.prototype,"maxScale",void 0),e([d("service","maxScale")],h.prototype,"readMaxScale",null),e([u({type:O})],h.prototype,"mosaicRule",null),e([d("mosaicRule",["mosaicRule","defaultMosaicMethod"])],h.prototype,"readMosaicRule",null),e([y("mosaicRule")],h.prototype,"writeMosaicRule",null),e([u()],h.prototype,"multidimensionalInfo",void 0),e([u({type:C,json:{write:!0}})],h.prototype,"multidimensionalSubset",void 0),e([u({json:{type:p}})],h.prototype,"noData",void 0),e([y("noData")],h.prototype,"writeNoData",null),e([u({type:String,json:{type:N.jsonValues,read:N.read,write:N.write}})],h.prototype,"noDataInterpretation",void 0),e([u({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],h.prototype,"objectIdField",void 0),e([d("objectIdField")],h.prototype,"readObjectIdField",null),e([u({readOnly:!0})],h.prototype,"geometryType",void 0),e([u({})],h.prototype,"typeIdField",void 0),e([u({})],h.prototype,"types",void 0),e([u({readOnly:!0})],h.prototype,"parsedUrl",null),e([u({type:Function})],h.prototype,"pixelFilter",void 0),e([u()],h.prototype,"raster",void 0),e([u({readOnly:!0})],h.prototype,"sourceType",void 0),e([d("sourceType",["serviceSourceType","fields"])],h.prototype,"readSourceType",null),e([u()],h.prototype,"viewId",void 0),e([u()],h.prototype,"renderer",null),e([u({types:le,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:oe,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],h.prototype,"internalRenderer",null),e([d("internalRenderer")],h.prototype,"readRenderer",null),e([y("internalRenderer")],h.prototype,"writeRenderer",null),e([u({clonable:!1})],h.prototype,"symbolizer",void 0),e([u(w)],h.prototype,"opacity",void 0),e([u({readOnly:!0})],h.prototype,"rasterFields",null),e([u({constructOnly:!0})],h.prototype,"rasterFunctionInfos",void 0),e([u({type:G,json:{name:"renderingRule"}})],h.prototype,"rasterFunction",null),e([d("rasterFunction",["renderingRule","rasterFunctionInfos"])],h.prototype,"readRasterFunction",null),e([u({readOnly:!0})],h.prototype,"serviceDataType",void 0),e([u({readOnly:!0,type:I})],h.prototype,"spatialReference",void 0),e([d("spatialReference",["spatialReference","extent"])],h.prototype,"readSpatialReference",null),e([u({type:q.apiValues,json:{read:q.read,type:q.jsonValues}})],h.prototype,"pixelType",void 0),e([y("pixelType")],h.prototype,"writePixelType",null),e([u({constructOnly:!0,type:k})],h.prototype,"serviceRasterInfo",void 0),e([u()],h.prototype,"sourceJSON",void 0),e([u(b)],h.prototype,"url",void 0),e([u({readOnly:!0})],h.prototype,"version",void 0),e([d("version",["currentVersion","fields","timeInfo"])],h.prototype,"readVersion",null),h=e([f("esri.layers.mixins.ArcGISImageService")],h),h};export{ze as ArcGISImageService};
