/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../request.js";import i from"../../core/Error.js";import r from"../../core/Logger.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import{Integer as n,ensureClass as o}from"../../core/accessorSupport/ensureType.js";import"../../core/has.js";import"../../core/RandomLCG.js";import{enumeration as a}from"../../core/accessorSupport/decorators/enumeration.js";import{reader as l}from"../../core/accessorSupport/decorators/reader.js";import{subclass as m}from"../../core/accessorSupport/decorators/subclass.js";import u from"../../geometry/Point.js";import p from"../../geometry/SpatialReference.js";import{getInfo as c}from"../../geometry/support/spatialReferenceUtils.js";import{sanitizeUrl as d}from"../support/arcgisLayerUrl.js";import{url as h}from"../support/commonProperties.js";import f from"../support/DimensionalDefinition.js";import y from"../support/MultidimensionalSubset.js";import{interpolationKebab as g}from"../support/rasterEnums.js";import b from"../support/RasterFunction.js";import R from"../support/TileInfo.js";import{isFunctionRaster as I}from"../support/rasterDatasets/datasetUtils.js";import x from"../support/rasterDatasets/FunctionRaster.js";import{getEffectiveMultidimensionalDefinition as S,getDefaultVariableInfo as v,isMultiSliceOrRangeDefinition as w,convertOleDateTimeToEpoch as F,getSubsetVariablesFromMdInfo as _,getDefaultMultidimensionalDefinition as j}from"../support/rasterDatasets/multidimensionalUtils.js";import{snapToRaster as D,clip as J}from"../support/rasterFunctions/clipUtils.js";import{create as N}from"../support/rasterFunctions/rasterFunctionHelper.js";import{load as T,projectExtent as O,projectPolygon as z}from"../support/rasterFunctions/rasterProjectionHelper.js";import{computeStatisticsHistograms as H}from"../support/rasterFunctions/stretchUtils.js";import{getVariableRasterInfo as P,getDefaultInterpolation as E,matchPresetRenderer as C,getDefaultBandCombination as M,getFunctionColorRamp as U,createDefaultRenderer as q,normalizeRendererJSON as L}from"../../renderers/support/rasterRendererHelper.js";import k from"../../renderers/support/RasterSymbolizer.js";import{websceneRasterRendererTypes as B,rasterRendererTypes as A,read as V}from"../../renderers/support/rasterTypeUtils.js";import $ from"../../rest/support/ImageHistogramParameters.js";import G from"../../rest/support/ImageSample.js";import W from"../../rest/support/ImageSampleParameters.js";import K from"../../rest/support/ImageSampleResult.js";const Q=1e3,X=X=>{let Y=class extends X{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=I(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",d(e,r.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const i=t?.find((({name:t})=>t===e));return i?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,i){const r=t?.layerDefinition?.drawingInfo?.renderer;return V(r,i)||void 0}async computeStatisticsHistograms(e,t){await this.load(t),e=o($,e).clone();const{serviceRasterInfo:r}=this;if(null==r)throw new i("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=e;if(null==s)throw new i("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let n=s;const{spatialReference:a}=r;if(!s.spatialReference.equals(a)){await T();const e="extent"===s.type?O(s,a):z(s,a);if(null==e)throw new i("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");n=e}const l=e.pixelSize??new u({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:a}),{extent:m,width:p,height:c}=D(r,n,l),d=await this.fetchPixels(m,p,c,{...t,interpolation:"nearest"});if(null==d.pixelBlock)throw new i("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const h=await J(d.pixelBlock,m,n),f=this._rasterJobHandler;return f?f.computeStatisticsHistograms({pixelBlock:h},t):H(h)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;const i=S({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:i,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:t,renderer:i}=this;if(!e||!t||!i)return;const{rasterInfo:r}=this.raster,s=v(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=s?.name,o=P(r,n);return this._updateSymbolizer(t,i,n,o)}async applyRenderer(e,t,i){const r=e?.pixelBlock;if(!(null!=r&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();const s=this.bandIds??[],{pixelBlock:n}=await this._symbolize({pixelData:e,simpleStretchParams:t,bandIds:s,symbolizer:this.symbolizer},i);return n}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t,i=!1){if(!this.loaded||null==t)return null;if(i&&e.equals(this.spatialReference))return this.tileInfo;const r=c(e);return R.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,i,r,s={}){if(Z(this),s.requestAsImageElement){const n=this.getTileUrl(e,i,r);return t(n,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then((e=>e.data))}const{serviceRasterInfo:n}=this;if(null!=n.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition){const t=s.tileInfo||n.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,i,r,t),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,i,r,s)}async fetchPixels(e,t,i,r={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),i=Math.round(i),this.raster.fetchPixels(e,t,i,r))}async getSamples(e,t){if(await this.load(),(e=o(W,e).clone()).interpolation&&"nearest"!==e.interpolation)throw new i("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const r=e.mosaicRule?.multidimensionalDefinition,s={...t,multidimensionalDefinition:r},n=(await this._getSampleLocations(e)).map((e=>this.identify(e,s).then((t=>(t.location=e,t))))),a=(await Promise.all(n)).flatMap(((e,t)=>this._convertRasterIdentifyResultToSample(e,t)));return new K({samples:a})}async identify(e,t={}){await this.load();const{raster:r,serviceRasterInfo:s}=this;if(null!=s?.multidimensionalInfo){if(!(s.hasMultidimensionalTranspose&&!(!w(t.multidimensionalDefinition)&&!t.transposedVariableName))&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null}}const n=this.multidimensionalSubset?.areaOfInterest;if(n&&!n.contains(e))throw new i("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const o=this.serviceRasterInfo?.storageInfo.isBsqTile&&this.bandIds?.length?this.bandIds:void 0;return r.identify(e,{...t,bandIds:o})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,i=t?.[0]?.variableName;return e.variables.some((e=>e.name===i&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date(F(e)).toISOString()}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo?.multidimensionalInfo;return _(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=j(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&I(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then((async()=>{if(!this._rasterJobHandler)return;Z(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,I(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{}))}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:t}=e;if("point"===t.type)return[t];const{spatialReference:i,type:r}=t;if("multipoint"===r)return t.points.map((e=>new u({x:e[0],y:e[1],spatialReference:i})));if("polyline"===r){let r=t;if(e.sampleCount||e.sampleDistance){const i=await import("../../geometry/operators/densifyOperator.js"),s=(await import("../../geometry/operators/lengthOperator.js")).execute(t,{unit:"meters"}),n=Math.min(e.sampleCount||100,Q);let o=e.sampleDistance;if(!o){o=s/(n+(2===r.paths[0].length?1:0))}r=i.execute(t,o,{unit:"meters"})}return r.paths.flatMap((e=>e.map((e=>new u({x:e[0],y:e[1],spatialReference:i})))))}const s=Math.min(e.sampleCount||100,Q),n="extent"===t.type,o=n?t:t.extent,a=Math.sqrt(o.width*o.height/s),l=o.height/a,m=o.width/a,{xmin:p,ymax:c}=o,d=[];for(let h=0;h<l;h++)for(let e=0;e<m;e++){const r=new u({x:p+(e+.5)*a,y:c-(h+.5)*a,spatialReference:i});(n||t.contains(r))&&d.push(r)}return d}_configDefaultInterpolation(){if(null==this.interpolation){Z(this);const{raster:e}=this,t=E(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){Z(this);const{rasterInfo:t}=this.raster,i=v(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=i?.name,n=C({variableName:s,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=n?.bandIds??M(t)),!this.renderer||"override"===e){const e=U(this.raster),i=n?.renderer??q(t,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:e}),r=t.statistics,o=r&&r.length>0?r[0]:null,a=o?.max??0,l=o?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===i.type&&(a>1e24||l<-1e24)&&(i.dynamicRangeAdjustment=!0,i.customStatistics=null,"none"===i.stretchType&&(i.stretchType="min-max")),this.renderer=i}const o=L({...this.renderer.toJSON(),variableName:s}),a=P(t,s);this.symbolizer?(this.symbolizer.rendererJSON=o,this.symbolizer.rasterInfo=a):this.symbolizer=new k({rendererJSON:o,rasterInfo:a});const l=this.symbolizer.bind();if(l.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=q(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,i=t.customStatistics?.length;!t.dynamicRangeAdjustment&&i&&e&&i!==e&&this._configDefaultRenderer("override")}}}else r.getLogger(this).warn("imagery-tile-mixin",l.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&I(this.raster)){const e=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&e&&this._set("rasterFunction",b.fromJSON(e)))}let e,t=this.raster,i=!1;I(t)?(e=t.primaryRasters.rasters,t=e[0],i=!0):e=[t];const{rasterFunction:r}=this;if(r){const i={raster:t};e.length>1&&e.forEach((e=>i[e.url]=e));const s=N(r.functionDefinition?.toJSON()??r.toJSON(),i),n=new x({rasterFunction:s});n.rasterJobHandler=this._rasterJobHandler,await n.open(),this.raster=n}else this.raster=t,await t.open();if(this._cachedRendererJson=void 0,!i&&!r)return;const{bandIds:s}=this,{bandCount:n}=this.raster.rasterInfo,o=s?.length?s.some((e=>e>=n)):n>=3;s&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,t){const{rasterInfo:i}=this.raster,r=i.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),s=(i.pixelSize.x+i.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new G({location:e.location,pixelValue:e.value,locationId:t,resolution:s})];const n=[];return e.dataSeries.forEach((({value:i,multidimensionalDefinition:r},o)=>{const a={Variables:r[0].variableName,Dimensions:r.flatMap((({dimensionName:e})=>e)).join(",")};for(const{dimensionName:e,values:t}of r){a[e]=Array.isArray(t[0])?t[0][0]:t[0];const i=t[t.length-1];a[`${e}_Max`]=Array.isArray(i)?i[i.length-1]:i}const l=new G({location:e.location,pixelValue:i,rasterId:o,locationId:t,resolution:s,attributes:a});n.push(l)})),n}};function Z(e){if(!e.raster||!e.serviceRasterInfo)throw new i("imagery-tile","no raster")}return e([s({clonable:!1})],Y.prototype,"_cachedRasterFunctionJson",void 0),e([s({clonable:!1})],Y.prototype,"_compatibleFullExtent",void 0),e([s({clonable:!1})],Y.prototype,"_isConstructedFromFunctionRaster",void 0),e([s({clonable:!1})],Y.prototype,"_rasterFunctionUpdatePromise",void 0),e([s({type:[n],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],Y.prototype,"bandIds",void 0),e([s({json:{origins:{service:{read:{source:"copyrightText"}}}}})],Y.prototype,"copyright",void 0),e([s({json:{read:!1}})],Y.prototype,"fullExtent",null),e([s({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),a(g)],Y.prototype,"interpolation",void 0),e([s()],Y.prototype,"ioConfig",void 0),e([s({type:[f],json:{write:!0}})],Y.prototype,"multidimensionalDefinition",null),e([s({type:y,json:{write:!0}})],Y.prototype,"multidimensionalSubset",void 0),e([s()],Y.prototype,"raster",void 0),e([s({type:b})],Y.prototype,"rasterFunction",null),e([s()],Y.prototype,"serviceRasterInfo",void 0),e([s()],Y.prototype,"sourceJSON",void 0),e([s({readOnly:!0,type:p,json:{read:!1}})],Y.prototype,"spatialReference",void 0),e([s({type:R})],Y.prototype,"tileInfo",void 0),e([s(h)],Y.prototype,"url",null),e([s()],Y.prototype,"renderer",null),e([s({types:A,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:B,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],Y.prototype,"internalRenderer",null),e([l("internalRenderer")],Y.prototype,"readRenderer",null),e([s({clonable:!1})],Y.prototype,"symbolizer",void 0),Y=e([m("esri.layers.mixins.ImageryTileMixin")],Y),Y};export{X as ImageryTileMixin};
