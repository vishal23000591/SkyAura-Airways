/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{createTask as t}from"../../../../core/asyncUtils.js";import{parseDate as i}from"../../../../core/date.js";import n from"../../../../core/Error.js";import r from"../../../../core/Logger.js";import{isAbortError as s}from"../../../../core/promiseUtils.js";import{urlToObject as o,getFilename as a}from"../../../../core/urlUtils.js";import{projectMany as l}from"../../../../geometry/projectionUtils.js";import m from"../../../../geometry/SpatialReference.js";import{jsonAdapter as c}from"../../../../geometry/geometryAdapters/json.js";import{equals as d,isWebMercator as u,wgs84 as f}from"../../../../geometry/support/spatialReferenceUtils.js";import{lngLatToXY as p}from"../../../../geometry/support/webMercatorUtils.js";import{OptimizedFeature as y}from"../../OptimizedFeature.js";import h from"../../OptimizedGeometry.js";import{executeQueryForSnapping as g}from"../../data/executeQueryForSnapping.js";import I from"../../data/FeatureStore.js";import{checkProjectionSupport as _}from"../../data/projectionSupport.js";import{QueryEngine as F}from"../../data/QueryEngine.js";import{parseRows as w,parseNumber as E,severSlicedString as j,readRows as T,inferDelimiterAndLocationInfo as x,extractFieldNamesAndAliasesFromRow as N,inferFields as S}from"../csv/csv.js";import{createDefaultAttributesFunction as q,createDrawingInfo as b}from"./clientSideDefaults.js";import C from"../../../support/FieldsIndex.js";import{getFieldDefaultValue as O}from"../../../support/fieldUtils.js";import{isNumber as v}from"../../../../support/guards.js";import{utc as D}from"../../../../time/constants.js";const k=b("esriGeometryPoint"),P=["csv"],R=[0,0];class V{constructor(e,t){this.x=e,this.y=t}}class A{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){this._queryEngine?.destroy(),this._queryEngine=null}async load(e,t={}){this._loadOptions=e;const[i]=await Promise.all([this._fetch(t.signal),this._checkProjection(e?.parsingOptions?.spatialReference)]),n=G(i,e);this._locationInfo=n.locationInfo,this._delimiter=n.delimiter,this._queryEngine=this._createQueryEngine(n);const r=await this._createFeatures(i);this._queryEngine.featureStore.addMany(r);const{fullExtent:s,timeExtent:o}=await this._queryEngine.fetchRecomputedExtents();if(n.layerDefinition.extent=s,o){const{start:e,end:t}=o;n.layerDefinition.timeInfo.timeExtent=[e,t]}return n}async applyEdits(){throw new n("csv-layer:editing-not-supported","applyEdits() is not supported on CSVLayer")}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){await this._waitSnapshotComplete();return(await this._queryEngine.executeQueryForIds(e,t.signal)).filter(v)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),g(this._queryEngine,e,t.signal)}async queryAttributeBins(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeAttributeBinsQuery(e,t.signal)}async refresh(e){this._loadOptions.customParameters=e,this._snapshotTask?.abort(),this._snapshotTask=t(this._snapshotFeatures),this._snapshotTask.promise.then((e=>{this._queryEngine.featureStore.clear(),e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),s(e)||r.getLogger("esri.layers.CSVLayer").error(new n("csv-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete();const{fullExtent:i,timeExtent:o}=await this._queryEngine.fetchRecomputedExtents();return{extent:i,timeExtent:o}}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:i,customParameters:r}=this._loadOptions;if(!i)throw new n("csv-layer:invalid-source","url not defined");const s=o(i);return(await e(s.path,{query:{...s.query,...r},responseType:"text",signal:t})).data}_createQueryEngine(e){const{objectIdField:t,fields:i,extent:n,timeInfo:r}=e.layerDefinition,s=new I({geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1}),o={type:"object-id",fieldName:t};return new F({fieldsIndex:C.fromLayerJSON({fields:i,dateFieldsTimeReference:{timeZoneIANA:D}}),geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1,timeInfo:r,featureIdInfo:o,spatialReference:n.spatialReference||{wkid:4326},featureStore:s})}async _createFeatures(e){const{latitudeFieldName:t,longitudeFieldName:n}=this._locationInfo,{objectIdField:r,fieldsIndex:s,spatialReference:o}=this._queryEngine;let a=[];const f=[],g=s.fields.filter((e=>e.name!==r)).map((e=>e.name));let I=0;const _={};for(const i of s.fields)if("esriFieldTypeOID"!==i.type&&"esriFieldTypeGlobalID"!==i.type){const e=O(i);void 0!==e&&(_[i.name]=e)}const F=w(e,g,this._delimiter,q(_,r));for(const l of F){const e=this._parseCoordinateValue(l[t]),o=this._parseCoordinateValue(l[n]);if(null!=o&&null!=e&&!isNaN(e)&&!isNaN(o)){l[t]=e,l[n]=o;for(const e in l)if(e!==t&&e!==n)if(s.isDateField(e))l[e]=i(l[e]);else if(s.isNumericField(e)){const t=E(l[e]);isNaN(t)?l[e]=null:l[e]=t}else null!=l[e]&&(l[e]=j(l[e]));l[r]=I,I++,a.push(new V(o,e)),f.push(l)}}if(!d({wkid:4326},o))if(u(o))for(const i of a)[i.x,i.y]=p(i.x,i.y,R);else a=l(c,a,m.WGS84,o,null,null);const T=[];for(let i=0;i<a.length;i++){const{x:e,y:t}=a[i],n=f[i];n[r]=i+1,T.push(new y(new h([],[e,t]),n,null,n[r]))}return T}_parseCoordinateValue(e){if(null==e||""===e)return null;let t=E(e);return(isNaN(t)||Math.abs(t)>181)&&(t=parseFloat(e)),t}async _checkProjection(e){try{await _(f,e)}catch{throw new n("csv-layer:projection-not-supported","Projection not supported")}}}function G(e,t){const i=t.parsingOptions||{},r={delimiter:i.delimiter,layerDefinition:null,locationInfo:{latitudeFieldName:i.latitudeField,longitudeFieldName:i.longitudeField}},s=r.layerDefinition={name:a(t.url,P)||"csv",dateFieldsTimeReference:{timeZoneIANA:D},drawingInfo:k,geometryType:"esriGeometryPoint",objectIdField:null,fields:[],timeInfo:i.timeInfo,extent:{xmin:Number.POSITIVE_INFINITY,ymin:Number.POSITIVE_INFINITY,xmax:Number.NEGATIVE_INFINITY,ymax:Number.NEGATIVE_INFINITY,spatialReference:i.spatialReference||{wkid:4326}}},o=T(e),l=o.next().value?.trim(),m=o.next().value?.trim();if(!l)throw new n("csv-layer:empty-csv","CSV is empty",{csv:e});const{delimiter:c,locationInfo:d}=x(l,m,i);if(!c)throw new n("csv-layer:invalid-delimiter","Unable to detect the delimiter from CSV",{firstLine:l,secondLine:m,parsingOptions:i});if(!d)throw new n("csv-layer:location-fields-not-found","Unable to identify latitude and longitude fields from the CSV file",{firstLine:l,secondLine:m,parsingOptions:i});r.locationInfo=d,r.delimiter=c;const{names:u,aliases:f}=N(l,c),p=S(e,r.delimiter,u,f,r.locationInfo);if(i.fields?.length){const e=new C(i.fields);for(const t of p){const i=e.get(t.name);i&&Object.assign(t,i)}}if(!p.some((e=>"esriFieldTypeOID"===e.type&&(s.objectIdField=e.name,!0)))){const e={name:"__OBJECTID",alias:"__OBJECTID",type:"esriFieldTypeOID",editable:!1,nullable:!1};s.objectIdField=e.name,p.unshift(e)}s.fields=p;const y=new C(s.fields);if(r.locationInfo&&(r.locationInfo.latitudeFieldName=y.get(r.locationInfo.latitudeFieldName).name,r.locationInfo.longitudeFieldName=y.get(r.locationInfo.longitudeFieldName).name),s.timeInfo){const e=s.timeInfo;if(e.startTimeField){const t=y.get(e.startTimeField);t?(e.startTimeField=t.name,t.type="esriFieldTypeDate"):e.startTimeField=null}if(e.endTimeField){const t=y.get(e.endTimeField);t?(e.endTimeField=t.name,t.type="esriFieldTypeDate"):e.endTimeField=null}if(e.trackIdField){const t=y.get(e.trackIdField);e.trackIdField=t?t.name:null}e.startTimeField||e.endTimeField||(s.timeInfo=null)}return r}export{A as default};
