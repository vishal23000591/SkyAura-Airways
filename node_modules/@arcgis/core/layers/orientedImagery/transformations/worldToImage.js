/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{rad2deg as t,deg2rad as a}from"../../../core/mathUtils.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{j as o,a as n}from"../../../chunks/vec32.js";import{webMercatorToGeographic as e}from"../../../geometry/support/webMercatorUtils.js";import{getWebMercatorScalingFactor as i,convertOrientationToPixelLocation as c,validatePointsToTransform as s,validateRotationMatrix as m}from"./utils.js";import{normalizeDegrees as f}from"../../../widgets/OrientedImageryViewer/components/imageNavigationUtils.js";function l(t,a){const{cameraLocation:r,pointsToTransform:o,scalingFactor:n}=h(t,a.cameraLocation,a.rotationMatrix),e=new Array;return p(o,e,{...a,cameraLocation:r,scalingFactor:n,...d(a)}),Array.isArray(t)?e:e[0]}function u(t,a,r){return l(t?a.map((t=>e(t))):a,r).map((t=>({...t,z:1})))}function p(t,a,o){const{affineTransformations:e,cameraLocation:i,focalLengthX:c,focalLengthY:s,principalOffsetPoint:m,radialDistortionCoefficients:f,rotationMatrix:l,scalingFactor:u,tangentialDistortionCoefficients:p}=o;for(const g of t){const t=r();n(t,g,i),t[0]=t[0]/u,t[1]=t[1]/u;const o=-c*((l[0]*t[0]+l[3]*t[1]+l[6]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),h=-s*((l[1]*t[0]+l[4]*t[1]+l[7]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),y=o*o+h*h;let L=0,A=0,d=0,w=0,T=0,b=0,j=0;f&&(L=f[0]??0,A=f[1]??0,d=f[2]??0),p&&(w=p[0],T=p[1]),m&&(b=m[0]??0,j=m[1]??0);const M=1+L*y+A*y*y+d*y*y*y;let N=o*M+w*(y+2*o**2)+2*T*o*h,F=h*M+T*(y+2*h**2)+2*w*o*h;N+=b,F+=j;const v=Number(e[0])+Number(e[1])*N+Number(e[2])*F,x=Number(e[3])+Number(e[4])*N+Number(e[5])*F;a.push({x:v,y:x})}}function g(a,r){const{cameraHeading:n,imageHeight:e,imageWidth:s}=r,{cameraLocation:m,pointsToTransform:l}=y(a,r.cameraLocation),u=new Array,p=i(m[1],r.cameraLocation.spatialReference);for(const i of l){const a=o([m[0],m[1],m[2]*p],[i[0],i[1],i[2]*p]),r=[(i[0]-m[0])/a,(i[1]-m[1])/a,(i[2]-m[2])*p/a],l=0!==r[0]&&0!==r[1]?f(t(Math.atan2(r[0],r[1]))-n):0,g=t(Math.acos(-r[2]));u.push(c(l,g,s,e))}return Array.isArray(a)?u:u[0]}function h(t,a,r){const o=Array.isArray(t)||"items"in t?t:[t];s(o,a),L(o,a),m(r);const n=i(a.y,a.spatialReference);return{pointsToTransform:o.map((t=>t.toArray())),scalingFactor:n,cameraLocation:a.toArray()}}function y(t,a){const r=Array.isArray(t)||"items"in t?t:[t];return s(r,a),L(r,a),{pointsToTransform:r.map((t=>t.toArray())),cameraLocation:a.toArray()}}function L(t,a){if(t.some((t=>!t.spatialReference.equals(a.spatialReference))))throw new Error("Input points and camera location must have the same spatial reference")}function A(t){return null!=t?.focalLength}function d(t){if(A(t))return{focalLengthX:t.focalLength,focalLengthY:t.focalLength};const{imageWidth:r,imageHeight:o,horizontalFieldOfView:n,verticalFieldOfView:e}=t;return{focalLengthX:r/(2*Math.tan(a(n)/2)),focalLengthY:o/(2*Math.tan(a(e)/2))}}export{l as worldToImage,g as worldToImagePanoramic,u as worldToImageWithLTPFlag};
