/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{isArrayLike as e}from"../../../core/arrayUtils.js";import{deg2rad as r}from"../../../core/mathUtils.js";import{clone as a,zeros as t}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{a as i}from"../../../chunks/vec32.js";import o from"../../../geometry/Point.js";import{isElevationSource as n}from"../core/ElevationSourceDefinitions.js";import{rectifyMapPointPanoramic as c,rectifyMapPoint as s}from"./rectifyMapPoint.js";import{getWebMercatorScalingFactor as f,hasAngles as l,convertPixelToHeadingPitch as m,isElevationSampler as p,reducerFn as y,validatePixelsToTransform as u,validateRotationMatrix as h,computeFarplaneVertices as d,computeHFOVAndVFOV as g,vecToPoint as w,or as v,isUpdateElevationWithElevationSource as x,scaleWithFactor as M,scaleAndAddWithFactor as A,computeNewReferenceCoordinates as P,projectiveTransform as j}from"./utils.js";import{worldToImage as R}from"./worldToImage.js";import{viewingLimit as V}from"../../../widgets/OrientedImageryViewer/constants.js";async function F(e,r,a){const{verticalFieldOfView:t,imageBoundaries:i,scalingFactor:o,farPlaneVertices:n,cameraLocation:c,pixelsToTransform:s,vecToPoint:f}=q(e,r),l=new Array;return await T(s,n,i,f,r,l,c,o,t,a),Array.isArray(e)?l:l[0]}async function T(e,r,a,t,i,o,n,c,f,l){let m=i.averageElevation;for(const y of e){const e=L(r,a,y,t,i);if(l&&v(p(l.elevationSample),x(l))){m=(await s(t(e),{x:y[0],y:y[1]},{...i,...l,farPlaneVertices:r.map(t)}))[2]}o.push(t(O(e,n,c,m,i.cameraPitch,f)))}}function O(e,r,o,n,c,s){let f=a(e);const l=Math.sqrt((e[2]-r[2])**2+(Math.sqrt((e[0]-r[0])**2+(e[1]-r[1])**2)/o)**2)*o,m=M(i(t(),e,r),1/l,1/o);if(b(e[2],n,c,s)){const e=Math.abs((r[2]-n)/-m[2])*o;f=A(r,m,e,o)}else f[2]=n;return f}function b(e,r,a,t){return e<r||a+t/2<V}function L(e,r,a,t,i){let o=null;const n=9;let c,s=0,f=e,l=r;for(;s<=n;){const e=S(a,l,f,i);if(c=e.error,o=e.transformedPoint,v(c<=1,s===n))break;f=P(f,c,a,r),l=E(f,t,i),s++}return o}function E(e,r,a){return R(e.map(r),a).map((({x:e,y:r})=>[e,r,1]))}function S(e,r,a,t){const{cameraLocation:i}=t,n=j(e,r,a),{x:c,y:s}=R(new o(n,i.spatialReference),t);return{transformedPoint:n,error:k(e,[c,s,1])}}function k(e,r){return Math.abs(e[0]-r[0])+Math.abs(e[1]-r[1])}function q(r,a){const t=e(r)||"items"in r?r:[r],{cameraLocation:i,rotationMatrix:n}=a;if(u(t,i),h(n),9!==n?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix");const c=f(i.y,i.spatialReference),s=d({...a,scalingFactor:c}),l=R(s.map((e=>new o(e,i.spatialReference))),a),{vfov:m}=g(a.horizontalFieldOfView,a.verticalFieldOfView,a.cameraRoll);return{cameraLocation:i.toArray(),imageBoundaries:l.map((({x:e,y:r})=>[e,r,1])),verticalFieldOfView:m,farPlaneVertices:s,scalingFactor:c,pixelsToTransform:t.map((e=>[e.x,e.y,1])),vecToPoint:w(i.spatialReference)}}async function B(e,a,t){const{cameraHeading:i,cameraLocation:s,farDistance:u,imageHeight:h,imageWidth:d,verticalFieldOfView:g}=a,w=f(s.y,s.spatialReference),v=u*w,x=new Array,[M,A,P]=s.toArray(),j=Array.isArray(e)?e:[e];for(const f of j){let e,j;if(l(f))e=f.heading,j=f.pitch;else{const r=m({x:f.x,y:f.y},d,h);e=r.heading,j=r.pitch}e=(e+i)%360;const R=[M+Math.sin(r(e))*Math.sin(r(j))*v,A+Math.cos(r(e))*Math.sin(r(j))*v,P+-Math.cos(r(j))*u];let V=a.averageElevation;if(t&&(n(t)||p(t.elevationSample))){V=(await c(new o(R,s.spatialReference),{heading:e,pitch:j},{...a,...t,farPlaneVertices:y(u,u).map((([e,r])=>new o([s.x+e,s.y+r],s.spatialReference)))}))[2]}x.push(new o(O(R,s.toArray(),w,V,j,g),s.spatialReference))}return Array.isArray(e)?x:x[0]}export{F as imageToWorld,B as imageToWorldPanoramic};
