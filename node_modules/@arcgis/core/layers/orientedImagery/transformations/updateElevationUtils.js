/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import t from"../../../core/Logger.js";import{isAbortError as r,waitTick as a}from"../../../core/promiseUtils.js";import o from"../../../geometry/Extent.js";import{projectWithZConversion as n}from"../../../geometry/projectionUtils.js";import{load as i,execute as s}from"../../../geometry/operators/projectOperator.js";import{fromExtent as c}from"../../../geometry/support/aaBoundingRect.js";import l from"../../ElevationLayer.js";import m from"../../ImageryLayer.js";import p from"../../ImageryTileLayer.js";import{getMetersPerUnitOfSR as u}from"../core/utils.js";import{TileElevationSampler as f}from"../../support/ElevationSampler.js";import{ElevationTile as y}from"../../support/ElevationTile.js";import{ElevationTileData as w}from"../../support/ElevationTileData.js";import g from"../../support/RasterFunction.js";import d from"../../support/TileInfo.js";import{TileKey as v}from"../../support/TileKey.js";import{identify as E}from"../../../rest/imageService.js";import I from"../../../rest/support/ImageIdentifyParameters.js";import{fetchArcGISServiceJSON as j}from"../../../support/requestPresets.js";import{logAndThrow as R}from"../../../widgets/OrientedImageryViewer/utils.js";async function h(t,r,a){if(!r.extent||!r.url)throw R("esri.layer.orientedImagery.transformations",new e("update-elevation:missing-property","both extent and url are required to create a sampler",r));const o=await L(r);if(!o)throw R("esri.layers.orientedImagery.transformations",new e("update-elevation:elevation-source","could not create a sampler using provided elevation source",r));return x(t,o,a)}async function x(e,t,r){await a(r);const o=C(t,r),n=Array.isArray(e)?e:[e];return await Promise.all(n.map(o))}var A;!function(e){e[e.DYNAMIC=0]="DYNAMIC",e[e.ELEVATION=1]="ELEVATION",e[e.IMAGE=2]="IMAGE"}(A||(A={}));const L=async(e,a)=>{let o;const{extent:n,rasterFunction:i,url:s,lod:c}=e;try{o=await T(s)}catch(l){if(r(l))return;t.getLogger("esri.layers.orientedImagery.transformations").error("updateElevationUsingElevationSource",l)}switch(o){case A.DYNAMIC:return await M(s,n,i,a);case A.ELEVATION:return await N(s,n,c,a);default:return}};async function N(e,a,o,n){const i=new l(e);let s;try{const{tileInfo:e}=await i.load(),t=(o&&e.lodAt(Math.min(e.lods.length-1,o))?.resolution)??"finest-contiguous";s=await i.createElevationSampler(a,{...n,demResolution:t})}catch(c){if(r(c))return;t.getLogger(i).error(c)}finally{i.destroy()}return s}async function M(e,t,r,a){const n=r?new g({functionName:r}):void 0,l=new m({url:e,rasterFunction:n,format:"lerc"});await l.load(a);const p=512,u=t.center,E=Math.max(t.width,t.height);let I=new o({xmin:u.x-E/2,ymin:u.y-E/2,xmax:u.x+E/2,ymax:u.y+E/2,spatialReference:t.spatialReference});l.spatialReference.equals(I.spatialReference)||(await i(),I=s(I,l.spatialReference));const j=await l.fetchPixels(I,p,p,a),R=d.create({scales:[E/p],size:p,spatialReference:I.spatialReference}),h=new v(null,0,0,0,c(I)),x=new w(j.pixelBlock.pixels[0],p,p,0),A=new y(h,x);return new f(A,R,void 0)}async function T(t,r){await a(r);const o=await j(t),{tileInfo:n,cacheType:i}=o;if(!o.hasOwnProperty("bandCount")||!o.hasOwnProperty("pixelSizeX"))throw new e("elevation-source:invalid-service-url",`ElevationSource URL expects an elevation 3D image service but given ${t}`);return n?"LERC"!==n?.format?.toUpperCase()||i&&"elevation"!==i.toLowerCase()?A.IMAGE:A.ELEVATION:A.DYNAMIC}function C(e,t){return async r=>{let a=r.clone();const o=r.spatialReference.equals(e.spatialReference)?a:await n(r,e.spatialReference,t),i=e.queryElevation(o);if(i){a=r.spatialReference.equals(e.spatialReference)?i.clone():await n(i,r.spatialReference,t)}return a.z=a.z??1,a}}async function O(e,t,r){return await a(r),e.map((e=>(e.z=t,e)))}async function z(e,a,o){const{url:n,rasterFunction:i}=a;let s;try{s=await T(n,o)}catch(c){r(c)||t.getLogger("esri.layers.orientedImagery.transformations").error(c)}switch(s){case A.ELEVATION:case A.DYNAMIC:{const t=await E(n,new I({geometry:e,rasterFunction:i?new g({functionName:i}):void 0}));if(t.value?.[0]){const r=e.clone();return r.z=+t.value[0],r}break}case A.IMAGE:{const t=new p(n,o);await t.load();const r=await t.identify(e,o);if(r.value?.[0]){const t=e.clone();return t.z=+r.value[0],t}break}}return e}function D(e,t){const{averageGroundElevation:r,spatialReference:a}=t,o=u(a);return e.map((e=>{const t=e.clone();return t.z=r*o/e.spatialReference.metersPerUnit,t}))}export{L as getElevationSampler,M as getElevationSamplerFromDynamicImageService,N as getElevationSamplerFromElevationLayer,D as updateUsingAverageGroundElevation,O as updateUsingConstant,x as updateUsingElevationSampler,h as updateUsingElevationSource,z as updateZfromService,T as validateElevationSourceURL};
