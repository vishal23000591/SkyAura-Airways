/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import t from"../../../core/Error.js";import{rad2deg as n,deg2rad as a}from"../../../core/mathUtils.js";import{create as i}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as e,fromValues as o}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{fromArray as r}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{zeros as c}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{multiply as s,transpose as l}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{invertOrIdentity as f,mul as u}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{a as h,f as m}from"../../../chunks/vec32.js";import{isSerializable as p}from"../../../core/support/jsonUtils.js";import M from"../../../geometry/Point.js";import{projectWithZConversion as v}from"../../../geometry/projectionUtils.js";import{earth as g}from"../../../geometry/support/Ellipsoid.js";import{isWebMercator as d}from"../../../geometry/support/spatialReferenceUtils.js";import{a as x}from"../../../chunks/vec3.js";import{isConstantElevation as w,ConstantElevation as y,isElevationSource as O}from"../core/ElevationSourceDefinitions.js";import{getMetersPerUnitOfSR as b}from"../core/utils.js";import{getElevationSampler as j}from"./updateElevationUtils.js";import{isNumber as E}from"../../../support/guards.js";import{defaultImageSphereSize as S}from"../../../widgets/PanoramicViewer/constants.js";function z(t,n,a){const[i,o,r,c]=n,[s,l,h,m]=a;F(i,o,r,c);const p=F(s,l,h,m),M=V(i,o,r,c),v=V(s,l,h,m),g=f(e(),M),d=u(e(),g,v),[x,w,y,O]=P(t,d);return[x/O,w/O,p?0:y/O]}function F(t,n,a,i){return 0===t[2]&&0===n[2]&&0===a[2]&&0===i[2]&&(t[2]=n[2]=a[2]=i[2]=1,!0)}function R(t){return 0===t?1:t}function P(t,n){const[a,i,e]=t,o=[0,0,0,0];return o[0]=a*n[0]+i*n[1]+e*n[2]+n[3],o[1]=a*n[4]+i*n[5]+e*n[6]+n[7],o[2]=a*n[8]+i*n[9]+e*n[10]+n[11],o[3]=R(a*n[12]+i*n[13]+e*n[14]+n[15]),o}function V(t,n,a,i){const c=H(r([...i,1]),f(new Array(16),o(t[0],n[0],a[0],0,t[1],n[1],a[1],0,t[2],n[2],a[2],0,1,1,1,1))),s=c[0],l=c[1],u=c[2],h=e();return h[0]=s*t[0],h[1]=l*n[0],h[2]=u*a[0],h[3]=0,h[4]=s*t[1],h[5]=l*n[1],h[6]=u*a[1],h[7]=0,h[8]=s*t[2],h[9]=l*n[2],h[10]=u*a[2],h[11]=0,h[12]=s,h[13]=l,h[14]=u,h[15]=1,h}function C(t,n,a,i,e=c()){return e[0]=t[0]+n[0]*a,e[1]=t[1]+n[1]*a,e[2]=t[2]+n[2]*(a/i),e}function D(t,n,a){const i=c();return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*(n/a),i}function L(t,n){const[a,i,e]=t,o=c();return o[0]=a*n[0]+i*n[3]+e*n[6],o[1]=a*n[1]+i*n[4]+e*n[7],o[2]=a*n[2]+i*n[5]+e*n[8],o}function H(t,n){const[a,i,e,o]=t,r=new Array(4);return r[0]=a*n[0]+i*n[1]+e*n[2]+o*n[3],r[1]=a*n[4]+i*n[5]+e*n[6]+o*n[7],r[2]=a*n[8]+i*n[9]+e*n[10]+o*n[11],r[3]=a*n[12]+i*n[13]+e*n[14]+o*n[15],r}function I(n,e,o,r=!0){if(!Number.isFinite(n))throw new t("InvalidRotationAngle","Please specify a valid angle for rotation");const c=o*(r?a(n):n),s=Math.cos(c),l=Math.sin(c),f=i();switch(e){case 0:f[4]=s,f[5]=-l,f[7]=l,f[8]=s;break;case 1:f[0]=s,f[2]=l,f[6]=-l,f[8]=s;break;case 2:f[0]=s,f[1]=-l,f[3]=l,f[4]=s;break;default:throw new t("InvalidRotationAxis","Please specify either 0, 1 or 2 for X, Y or Z axis respectively")}return f}const N={HPR:[[2,-1],[0,1],[2,-1]],OPK:[[0,1],[1,1],[2,1]]};function q(n,a,e=!0){if(3!==n?.length||3!==a?.length)throw new t("InvalidRotationAngles","Please specify three angles with config for rotation");const o=i();for(let t=0;t<3;t++){const[i,r]=a[t],c=I(n[t],i,r,e);s(o,c,o)}return o}function U(t,n=!0){return q(t,N.OPK,n)}function k(t,n=!0){return q(t,N.HPR,n)}function A(t,n,i){const e=Math.sin(a(i)),o=Math.cos(a(i)),r=[[t,0],[t,n],[0,n]];r.forEach(((t,n)=>{r[n]=[o*t[0]-e*t[1],e*t[0]+o*t[1]]}));const c={xmin:Math.min(0,r[0][0],r[1][0],r[2][0]),xmax:Math.max(0,r[0][0],r[1][0],r[2][0]),ymin:Math.min(0,r[0][1],r[1][1],r[2][1]),ymax:Math.max(0,r[0][1],r[1][1],r[2][1])};return{hfov:Math.abs(c.xmax-c.xmin),vfov:Math.abs(c.ymax-c.ymin)}}function K(t,n){const i=a(t[1]),e=a(t[0]),o=t[2],[r,c,s,l]=n,f=a(r),u=a(c),h=s/Math.sqrt(1-l*Math.sin(f)**2),m=e-u,p=s/Math.sqrt(1-l*Math.sin(f)**2),M=l*(h*Math.sin(f)-p*Math.sin(i));return[(p+o)*Math.cos(i)*Math.sin(m),(p+o)*(Math.sin(i)*Math.cos(f)-Math.sin(f)*Math.cos(f)*Math.cos(m))+M*Math.cos(f),(p+o)*(Math.sin(i)*Math.sin(f)+Math.cos(f)*Math.cos(i)*Math.cos(m))-h+M*Math.sin(f)]}function W(t,i){const e=Number(t[0]),o=Number(t[1]),r=Number(t[2]),[c,s,l,f]=i,u=a(c),h=a(s),m=l/Math.sqrt(1-f*Math.sin(u)**2),p=e/m,M=o/m,v=r/m,g=Math.cos(u)-Math.sin(u)*M+Math.cos(u)*v,d=Math.sin(u)+Math.cos(u)*M+Math.sin(u)*v,x=Math.sqrt(g**2+p**2),w=f*m*Math.sin(u),y=(t,n=5)=>{if(0===n)return t;const a=y(t,n-1);return Math.atan(d/x-(w-f*(l/Math.sqrt(1-f*Math.sin(a)**2))*Math.sin(a))/(m*x))},O=y(u),b=Math.atan(e/(m*g))+h,j=n(O);return[n(b),j,e/(Math.cos(O)*Math.sin(b-h))-l/Math.sqrt(1-f*Math.sin(O)**2)]}function T(t,n,a){const i=360/n,e=180/a;return{heading:(t.x-n/2)*i,pitch:90-(t.y-a/2)*e}}function X(t,n,a,i=S/2){const{heading:e,pitch:o}=Z(t,i);return Y(e,o,n,a)}function Y(t,n,a,i){const e=t%360;return{x:a/2+(e<-180?e+360:e>180?e-360:e)/(360/a),y:i-n/(180/i),heading:t,pitch:n}}function Z(t,a){const i=n(Math.acos(-t.z/a));return{heading:n(Math.atan2(t.x,t.y)),pitch:i}}function G(t,n,i=S/2){return[i*(Math.sin(a(t))*Math.sin(a(n))),i*(Math.cos(a(t))*Math.sin(a(n))),i*Math.cos(a(180-n))]}function J(t,n,a,i=S/2){const{heading:e,pitch:o}=T(t,n,a);return G(e,o,i)}async function $(t,a,i){const e=await v(a,t.spatialReference,i);let o=n(Math.atan2(e.y-t.y,e.x-t.x));return o=o>=0&&o<=90?90-o:o>90&&o<=180?360-o+90:90+Math.abs(o),o}function B(t,n,a){const i=Math.cos(a),e=Math.sin(a),o=[1,0,0,1,0,0],r=o[0]*i+o[2]*e,c=o[1]*i+o[3]*e,s=-o[0]*e+o[2]*i,l=-o[1]*e+o[3]*i;o[0]=r,o[1]=c,o[2]=s,o[3]=l;return[t*o[0]+n*o[2]+o[4],t*o[1]+n*o[3]+o[5]]}const Q=t=>t.toArray(),_=(...t)=>t.some((t=>t));function tt(t,n){if(_(0===t.length,t.some((({x:t,y:n})=>_(null==t,null==n))),!n.hasZ))throw new Error("Input pixels must have x, y and camera location must have z value")}function nt(t,n){if(t.some((t=>null==t.z))||null==n.z)throw new Error("Input points and camera location must have z value")}function at(t){if(9!==t?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix")}function it(t,n){return d(n)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/g.radius))):1}const et=t=>n=>new M(n,t),ot=t=>null!=t&&"queryExtent"in t;function rt(t,n,a,i){return[[-n,-n],[+n,-n],[+n,+n],[-n,+n]].map((([n,e])=>z(x(c(),a,[n,e,0]),i,t)))}function ct({a0:t,a1:n,a2:a,b0:i,b1:e,b2:o},r,c,s){const l=[t??r/2-.5,n,a??0,i??c/2-.5,e??0,o].map(st);return null!=s&&lt(l)?{affines:l,focalLength:s}:{affines:[r/2-.5,1,0,c/2-.5,0,-1]}}function st(t,n){if(null==t)return null;const a=parseFloat(`${t}`);return isNaN(a)?null:a}function lt(t){return null!=t[1]&&null!=t[5]}function ft(t,n,a){const{cameraHeight:i,cameraPitch:e,cameraRoll:o,elevation:r,farDistance:c,horizontalFieldOfView:s,location:l,verticalFieldOfView:f}=St(t,t.location.spatialReference),u=r??(l.z??0)-i;return{...mt(t,n,a),averageElevation:u,cameraPitch:e,cameraRoll:o??0,farDistance:c,horizontalFieldOfView:s,verticalFieldOfView:f}}function ut(t,n,a,i){return yt(i)?U([i.omega,i.phi,i.kappa]):Ot(i)?k([i.heading,i.pitch,i.roll]):k([t,n,a??0])}function ht(t,n,a){const{cameraHeading:i,cameraHeight:e,farDistance:o,horizontalFieldOfView:r,location:c,verticalFieldOfView:s}=St(t,t.location.spatialReference);return{averageElevation:(c.z??0)-e,cameraLocation:c,cameraHeading:i,farDistance:o,horizontalFieldOfView:r,imageHeight:a,imageWidth:n,verticalFieldOfView:s}}function mt(t,n,a){const{a0:i,a1:e,a2:o,b0:r,b1:c,b2:s,cameraHeading:l,cameraOrientation:f,cameraPitch:u,cameraRoll:h,focalLength:m,horizontalFieldOfView:p,location:M,matrix:v,principalX:g,principalY:d,radial:x,tangential:w,verticalFieldOfView:y}=t,{affines:O,focalLength:b}=ct({a0:i,a1:e,a2:o,b0:r,b1:c,b2:s},n,a,m),j=v??ut(l,u,h,f),E=null!=g&&null!=d?[g,d]:void 0;return{affineTransformations:f?.affineTransformations??O,cameraLocation:M.clone(),focalLength:f?.focalLength??b,horizontalFieldOfView:p,imageHeight:a,imageWidth:n,principalOffsetPoint:f?.principalOffsetPoint??E,radialDistortionCoefficients:f?.radialDistortionCoefficients??x,rotationMatrix:j,tangentialDistortionCoefficients:f?.tangentialDistortionCoefficients??w,verticalFieldOfView:y}}const pt=t=>null!=t&&"elevationSample"in t&&null!=t.elevationSample,Mt=t=>O(t?.elevationSource)&&null!=t?.extent,vt=t=>w(t?.elevationSource),gt=async(t,n,a,i,e)=>{const o=b(t),r=n-a/o;return vt(i)?(i.elevationSource=new y({constantElevation:i.elevationSource.constantElevation/o}),i):pt(i)?i:Mt(i)?{elevationSample:await j({...p(i.elevationSource)?i.elevationSource.toJSON():i.elevationSource,extent:i.extent},e),elevationSource:new y({constantElevation:r})}:{averageGroundElevation:r,spatialReference:t}},dt=t=>E(t?.heading)&&E(t?.pitch),xt=(t,n)=>[[-t,-n],[t,-n],[t,n],[-t,n]];function wt(t){const{cameraLocation:n,farDistance:e,horizontalFieldOfView:o,rotationMatrix:r,scalingFactor:s,verticalFieldOfView:f}=t,u=i();l(u,r);const p=2*Math.tan(a(f)/2)*e*s,M=2*Math.tan(a(o)/2)*e*s,v=L([0,0,-1],u),g=C([n.x,n.y,n.z],v,t.farDistance*s,s),d=L([0,1,0],u),x=L([1,0,0],u),w=D(d,p/2,s),y=D(x,M/2,s),O=h(c(),w,y),b=m(c(),w,y);return[m(c(),g,O),m(c(),g,b),h(c(),g,O),h(c(),g,b)]}const yt=t=>2===t?.type,Ot=t=>1===t?.type;function bt(t){const n=t%360;return n<-180?n+360:n}function jt(t,n,a){if("panoramic"===t){const[t,i]=a;return X({x:n.x,y:n.y,z:n.z},t,i)}return{x:n.x+.5,y:.5-n.y}}var Et;function St(t,n,a=!0){const i=b(n),e=a?t.clone():t;return e.cameraHeight/=i,e.farDistance/=i,e.nearDistance/=i,w(e.elevationSource)&&(e.elevationSource.constantElevation/=i),e}!function(t){t[t.CLOCKWISE=-1]="CLOCKWISE",t[t.COUNTERCLOCKWISE=1]="COUNTERCLOCKWISE"}(Et||(Et={}));export{wt as computeFarplaneVertices,A as computeHFOVAndVFOV,rt as computeNewReferenceCoordinates,G as convertHeadingPitchToSphereVertex,Y as convertOrientationToPixelLocation,J as convertPixelLocationToSphereVertex,T as convertPixelToHeadingPitch,Z as convertSphereVertexToOrientation,X as convertSphereVertexToPixelLocation,St as convertToSRUnits,q as createRotationMatrix,k as createRotationMatrixFromHPR,U as createRotationMatrixFromOPK,K as geographicToLTP,ct as getAffinesAndFocalLength,ht as getImageToWorldPanoramicProperties,ft as getImageToWorldProperties,$ as getInitialAngle,gt as getUpdateElevationProps,it as getWebMercatorScalingFactor,mt as getWorldToImageProperties,dt as hasAngles,Ot as hasHeadingPitchRoll,yt as hasOmegaPhiKappa,ot as isElevationSampler,pt as isUpdateElevationWithElevationSampler,Mt as isUpdateElevationWithElevationSource,vt as isUpdateUsingConstantElevation,lt as isValidAffines,V as linearEquationSolve,W as ltpToGeographic,bt as normalizeHeading,_ as or,Q as pointToArray,z as projectiveTransform,xt as reducerFn,B as rotatePixel,C as scaleAndAddWithFactor,D as scaleWithFactor,jt as transformGraphicCoordinatesToPixel,L as transformMat3,H as transformMat4,tt as validatePixelsToTransform,nt as validatePointsToTransform,at as validateRotationMatrix,et as vecToPoint};
