/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import t from"../../../core/Error.js";import r from"./CovJSONRaster.js";import e from"./ImageAuxRaster.js";import s from"./ImageServerRaster.js";import o from"./InMemoryRaster.js";import a from"./MRFRaster.js";import c from"./TIFFRaster.js";const n=new Map;n.set("MRF",{desc:"Meta Raster Format",constructor:a}),n.set("TIFF",{desc:"GeoTIFF",constructor:c}),n.set("RasterTileServer",{desc:"Raster Tile Server",constructor:s}),n.set("JPG",{desc:"JPG Raster Format",constructor:e}),n.set("PNG",{desc:"PNG Raster Format",constructor:e}),n.set("GIF",{desc:"GIF Raster Format",constructor:e}),n.set("BMP",{desc:"BMP Raster Format",constructor:e}),n.set("CovJSON",{desc:"COVJSON Raster Format",constructor:r}),n.set("MEMORY",{desc:"In Memory Raster Format",constructor:o});class u{static get supportedFormats(){const t=new Set;return n.forEach(((r,e)=>t.add(e))),t}static async open(r){const{url:e,ioConfig:s,source:o,sourceJSON:a}=r;let c=r.datasetFormat??s?.datasetFormat;null==c&&(e.includes(".")?c=e.slice(e.lastIndexOf(".")+1).toUpperCase():"coverage"===o?.type?.toLowerCase()?c="CovJSON":o?.extent&&o.pixelblocks&&(c="MEMORY")),"OVR"===c||"TIF"===c?c="TIFF":"JPG"===c||"JPEG"===c||"JFIF"===c?c="JPG":"COVJSON"===c&&(c="CovJSON"),e.toLowerCase().includes("/imageserver")&&!e.toLowerCase().includes("/wcsserver")&&(c="RasterTileServer");const u={url:e,source:o,sourceJSON:a,datasetFormat:c,ioConfig:s??{bandIds:null,sampling:null}};if(Object.keys(u).forEach((t=>{null==u[t]&&delete u[t]})),c){if(!this.supportedFormats.has(c))throw new t("rasterfactory:open","not a supported format "+c);if("CRF"===c)throw new t("rasterfactory:open",`cannot open raster: ${e}`);const s=new(0,n.get(c).constructor)(u);return await s.open({signal:r.signal}),s}const i=Array.from(n.keys()).filter((t=>"CovJSON"!==t&&"Memory"!==t));let l=0;const m=()=>{if(c=i[l++],!c)return null;if("CRF"===c)return null;const t=new(0,n.get(c).constructor)(u);return t.open({signal:r.signal}).then((()=>t)).catch((()=>m()))};return m()}static register(t,r,e){n.has(t.toUpperCase())||n.set(t.toUpperCase(),{desc:r,constructor:e})}}export{u as default};
