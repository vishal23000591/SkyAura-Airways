/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import e from"../../core/Collection.js";import t from"../../core/Error.js";import{JSONMap as n}from"../../core/jsonMap.js";import o from"../../geometry/SpatialReference.js";import r from"./Field.js";import{inferLocationInfo as i}from"./locationUtils.js";import a from"./ParquetEncodingLocation.js";import l from"./ParquetEncodingWkb.js";import{ParquetMetadata as s}from"../../libs/parquet/parquet.js";const u=new n({esriGeometryPoint:"point",esriGeometryPolygon:"polygon",esriGeometryPolyline:"polyline",esriGeometryMultipoint:"multipoint"});function m(e){return u.toJSON(e)}function c(t,n={}){return p({urls:new e(t)},n)}async function p(e,n={}){if(e.geometryType&&e.spatialReference&&e.encoding&&e.fields)return e;if(e.urls.length<1)throw new t("parquet:bad-input","At least one url must be specified",e);const i=e.metadata??await s.create(e.urls.getItemAt(0),(()=>n.customParameters)),a=i.tryReadGeoMetadata(),l={...e,metadata:i};if(null==l.fields&&(l.fields=i.fields.map((e=>r.fromJSON(e)))),null==l.encoding&&(l.encoding=d(i,a)),!l.encoding)return l;switch(l.encoding.type){case"location":null==l.spatialReference&&(l.spatialReference=o.WGS84),null==l.geometryType&&(l.geometryType="point");break;case"wkb":{if(!a)return l;const e=a.primary_column,t=a.columns[e];l.geometryType||(l.geometryType=y(t)),l.spatialReference||(l.spatialReference=g(t))}}return l}function d(e,t){if(null!=t){const n=t.primary_column,o=t.columns[n],r=e.tryReadEsriMetadata();return new l({primaryFieldName:n,orientation:o.orientation??null,multiscale:r?.multiscale})}const n=i(e.fields.map((e=>e.name)));return new a({latitudeFieldName:n.latitudeFieldName,longitudeFieldName:n.longitudeFieldName})}function f(e){switch(e){case"Point":return"point";case"Polygon":case"MultiPolygon":return"polygon";case"LineString":return"polyline";case"MultiPoint":return"multipoint";default:return null}}function y(e){const{geometry_types:n}=e,o=new Set;for(const t of n){const e=f(t);e&&o.add(e)}if(o.size>1)throw new t("unsupported","Parquet mixed geometry types are not support",{geometryTypes:o});return 1===o.size?o.values().next().value:void 0}function g(e){const t=e.crs?.id?.code;return t&&"number"==typeof t?new o({wkid:t}):void 0}export{p as completeParquetLayerInfo,c as getParquetLayerInfo,u as parquetGeometryTypeKebabDict,m as toParquetJSONGeometryType};
