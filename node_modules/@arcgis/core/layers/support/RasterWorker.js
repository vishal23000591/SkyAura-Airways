/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import r from"../../geometry/Extent.js";import e from"../../geometry/Point.js";import t from"../../geometry/operators/support/GeographicTransformation.js";import s from"./PixelBlock.js";import{decode as o}from"./rasterFormats/RasterCodec.js";import{split as i,clipTile as n,mosaic as a,approximateTransform as l,getLocalArithmeticNorthRotations as m}from"./rasterFunctions/pixelUtils.js";import{create as c}from"./rasterFunctions/rasterFunctionHelper.js";import{load as f,getProjectionOffsetGrid as p}from"./rasterFunctions/rasterProjectionHelper.js";import{computeStatisticsHistograms as u,estimateStatisticsHistograms as S}from"./rasterFunctions/stretchUtils.js";import{convertVectorFieldData as d,convertToLocalDirections as x}from"./rasterFunctions/vectorFieldUtils.js";import{readTransform as y}from"./rasterTransforms/utils.js";import h from"../../renderers/support/RasterSymbolizer.js";import{createFlowMesh as O}from"../../views/2d/engine/flow/dataUtils.js";class N{convertVectorFieldData(r){const e=s.fromJSON(r.pixelBlock),t=d(e,r.type);return Promise.resolve(null!=t?t.toJSON():null)}computeStatisticsHistograms(r){const e=s.fromJSON(r.pixelBlock),t=u(e);return Promise.resolve(t)}async decode(r){const e=await o(r.data,r.options);return e&&e.toJSON()}symbolize(e){e.pixelBlock=s.fromJSON(e.pixelBlock),e.extent=e.extent?r.fromJSON(e.extent):null;const t=this.symbolizer.symbolize(e);return Promise.resolve(null!=t?t.toJSON():null)}async updateSymbolizer(r){this.symbolizer=h.fromJSON(r.symbolizerJSON),r.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=r.histograms)}async updateRasterFunction(r){this.rasterFunction=c(r.rasterFunctionJSON)}async process(t){const o=this.rasterFunction.process({extent:r.fromJSON(t.extent),primaryPixelBlocks:t.primaryPixelBlocks.map((r=>null!=r?s.fromJSON(r):null)),primaryPixelSizes:t.primaryPixelSizes?.map((r=>null!=r?e.fromJSON(r):null)),primaryRasterIds:t.primaryRasterIds});return null!=o?o.toJSON():null}stretch(r){const e=this.symbolizer.simpleStretch(s.fromJSON(r.srcPixelBlock),r.stretchParams);return Promise.resolve(e?.toJSON())}estimateStatisticsHistograms(r){const e=S(s.fromJSON(r.srcPixelBlock));return Promise.resolve(e)}split(r){const e=i(s.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel??0,!1===r.useBilinear);return e&&e.forEach(((r,t)=>{e.set(t,r?.toJSON())})),Promise.resolve(e)}clipTile(r){const e=s.fromJSON(r.pixelBlock),t=n({...r,pixelBlock:e});return Promise.resolve(t?.toJSON())}async mosaicAndTransform(r){const e=r.srcPixelBlocks.map((r=>r?new s(r):null)),t=a(e,r.srcMosaicSize,{blockWidths:r.blockWidths,alignmentInfo:r.alignmentInfo,clipOffset:r.clipOffset,clipSize:r.clipSize});let o,i=t;return r.coefs&&(i=l(t,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation)),r.projectDirections&&r.gcsGrid&&(o=m(r.destDimension,r.gcsGrid),i=x(i,r.isUV?"vector-uv":"vector-magdir",o)),{pixelBlock:i?.toJSON(),localNorthDirections:o}}async createFlowMesh(r,e){const t={data:new Float32Array(r.flowData.buffer),mask:new Uint8Array(r.flowData.maskBuffer),width:r.flowData.width,height:r.flowData.height},{vertexData:s,indexData:o}=await O(r.meshType,r.simulationSettings,t,e.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:o.buffer},transferList:[s.buffer,o.buffer]}}async getProjectionOffsetGrid(e){const s=r.fromJSON(e.projectedExtent),o=r.fromJSON(e.srcBufferExtent);let i=null;e.datumTransformationSteps?.length&&(i=new t({steps:e.datumTransformationSteps})),await f();const n=e.rasterTransform?y(e.rasterTransform):null;return p({...e,projectedExtent:s,srcBufferExtent:o,datumTransformation:i,rasterTransform:n})}}export{N as default};
