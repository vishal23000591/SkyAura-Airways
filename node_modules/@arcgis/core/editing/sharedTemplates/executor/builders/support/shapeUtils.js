/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{equals as e}from"../../../../../core/arrayUtils.js";import{fromArray as t}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getHeightUnitCorrectionFactor as n}from"./builderUtils.js";import s from"../../../../../geometry/Point.js";import a from"../../../../../geometry/Polyline.js";function r(e){let t=0;const s=n(e);for(let n=0;n<e.paths.length;n++){const a=e.paths[n].length;for(let r=0;r<a;r++)r>0&&(t+=e.hasZ?m(e.paths[n][r-1],e.paths[n][r],s):u(e.paths[n][r-1],e.paths[n][r]))}return t}function o(e){const t=e.geometry.clone();return t.paths.map((n=>new a({spatialReference:e.geometry.spatialReference,paths:[n],hasZ:t.hasZ,hasM:t.hasM})))}function i(e){const t=[];for(const n of e.paths)for(let s=1;s<n.length;s++){const r=[[n[s-1].slice(),n[s].slice()]];t.push(new a({paths:r,spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM}))}return t}function c(e,t,n){let s=t[0]-e[0],a=t[1]-e[1];const r=Math.sqrt(s*s+a*a);return s/=r,a/=r,s*=n,a*=n,[e[0]+s,e[1]+a]}function f(e,t,n,s){const a=R([t[0]-e[0],t[1]-e[1],t[2]*s-e[2]*s]);return[e[0]+a[0]*n,e[1]+a[1]*n,e[2]+a[2]*n]}function l(e,t,n){const a=u(t[0],t[1]),r=e.x+n*((t[1][0]-t[0][0])/a),o=e.y+n*((t[1][1]-t[0][1])/a),i={};return e.hasM&&(i.m=e.m),new s({x:r,y:o,spatialReference:e.spatialReference,...i})}function h(e,t,n,a){const r=m(t[0],t[1],a),o=e.x+n*((t[1][0]-t[0][0])/r),i=e.y+n*((t[1][1]-t[0][1])/r),c=e.z+n*((t[1][2]-t[0][2])/r),f={};return e.hasM&&(f.m=e.m),new s({x:o,y:i,z:c,spatialReference:e.spatialReference,...f})}function p(e,t,n,s){if(void 0===e||void 0===t)return null;if(null===e||null===t)return null;return e+(t-e)/n*s}function u(e,t){const n=t[0]-e[0],s=t[1]-e[1];return Math.sqrt(n*n+s*s)}function m(e,t,n){return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2+(void 0!==e[2]&&void 0!==t[2]?(e[2]*n-t[2]*n)**2:0))}function R(e){const t=z(e);return[e[0]/t,e[1]/t,e[2]/t]}function M(e,t,n){const s=t[0],a=t[1],r=[a[0]-s[0],a[1]-s[1]],o=Math.sqrt(r[0]**2+r[1]**2),i=[r[0]/o,r[1]/o];return e.x+=n*i[0],e.y+=n*i[1],e}function y(e,t){let n=0,a=null;const r=e.hasM,o=e.hasZ?3:2;for(const i of e.paths){if(0===t){a=new s({x:i[0][0],y:i[0][1],...r?{m:i[0][o]}:{},spatialReference:e.spatialReference,hasM:r});break}for(let f=0;f<i.length-1;f++){const l=u(i[f],i[f+1]),h=n+l;if(h===t){a=new s({x:i[f+1][0],y:i[f+1][1],...r?{m:i[f+1][o]}:{},spatialReference:e.spatialReference,hasM:r});break}if(h>t){const h=c(i[f],i[f+1],t-n);a=new s({x:h[0],y:h[1],...r?{m:p(i[f][o],i[f+1][o],l,t-n)??void 0}:{},spatialReference:e.spatialReference,hasM:r});break}n+=l}if(null!==a)break}return a}function Z(e,n,a){let r=0;const o=e.hasM;for(const i of e.paths){if(0===n)return new s({x:i[0][0],y:i[0][1],z:i[0][2],...o?{m:i[0][3]}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference});for(let c=0;c<i.length-1;c++){const l=m(i[c],i[c+1],a),h=r+l;if(h===n)return new s({x:i[c+1][0],y:i[c+1][1],z:i[c+1][2],...o?{m:i[c+1][3]}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference});if(h>n){const h=f(t(i[c]),t(i[c+1]),n-r,a);return new s({x:h[0],y:h[1],z:h[2],...o?{m:p(i[c][3],i[c+1][3],l,n-r)??void 0}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference})}r+=l}}return null}function x(e,t,n){let a=0,r=null;if(t<=0){const s=[e.paths[0][0],e.paths[0][1]];let a=d(e,0,0);return a=l(a,s,t),M(a,s,n)}const o=e.hasM?e.hasZ?3:2:-1;for(const l of e.paths)for(let i=0;i<l.length-1;i++){const f=u(l[i],l[i+1]),h=a+f;if(h===t)return r=new s({x:l[i+1][0],y:l[i+1][1],...e.hasM?{m:l[i+1][o]}:{},spatialReference:e.spatialReference}),0===n?r:M(r,[l[i],l[i+1]],n);if(h>t){const h=c(l[i],l[i+1],t-a);return r=new s({x:h[0],y:h[1],...o>-1?{m:p(l[i][o],l[i+1][o],f,t-a)??void 0}:{},spatialReference:e.spatialReference}),0===n?r:M(r,[l[i],l[i+1]],n)}a+=f}if(0===a)return null;const i=e.paths.length-1,f=e.paths[i].length-1,h=[e.paths[i][f-1],e.paths[i][f]];let m=d(e,i,f);return m=l(m,h,t-a),M(m,h,n)}function g(e,n,a,r){let o=0;if(n<=0){const t=[e.paths[0][0],e.paths[0][1]];let s=d(e,0,0);return s=h(s,t,n,r),M(s,t,a)}const i=e.hasM?e.hasZ?3:2:-1;for(const h of e.paths)for(let c=0;c<h.length-1;c++){const l=m(h[c],h[c+1],r),u=o+l;if(u===n){const t=new s({x:h[c+1][0],y:h[c+1][1],z:h[c+1][2],...e.hasM?{m:h[c+1][i]}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===a?t:M(t,[h[c],h[c+1]],a)}if(u>n){const u=f(t(h[c]),t(h[c+1]),n-o,r),m=new s({x:u[0],y:u[1],z:u[2],...i>-1?{m:p(h[c][i],h[c+1][i],l,n-o)}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===a?m:M(m,[h[c],h[c+1]],a)}o+=l}if(0===o)return null;const c=e.paths.length-1,l=e.paths[c].length-1,u=[e.paths[c][l-1],e.paths[c][l]];let R=d(e,c,l);return R=h(R,u,n-o,r),M(R,u,a)}function w(e,t,n){const a=e.rings[t][n];return new s({spatialReference:e.spatialReference,x:a[0],y:a[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?a[2]:void 0,m:e.hasM?e.hasZ?a[3]:a[2]:void 0})}function d(e,t,n){const a=e.paths[t][n];return new s({spatialReference:e.spatialReference,x:a[0],y:a[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?a[2]:void 0,m:e.hasM?e.hasZ?a[3]:a[2]:void 0})}function v(t){return e(t.at(0),t.at(-1))}function z(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}export{r as computedTotalLength,o as convertRadialToPolylines,i as convertToTwoPoint,c as distanceAlongLineSegment,f as distanceAlongLineSegmentWithZ,u as getSegmentLength,m as getSegmentLength3d,M as offsetPointFromSegment,y as pointAlongLine,x as pointAlongLineAndOffset,Z as pointAlongLineWithZ,g as pointAlongLineWithZAndOffset,w as pointFromPolygonVertex,d as pointFromPolylineVertex,v as sameStartEndPoint};
