/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{readOffsetDistance as t,readIsProportional as e,readVertexBeforeOffset as r,readDistance as s,getHeightUnitCorrectionFactor as o,makeFeatureFromGroupPart as n}from"./support/builderUtils.js";import{offset as a}from"./support/offsetUtils.js";import{getSegmentLength3d as i,getSegmentLength as p,pointAlongLineWithZAndOffset as l,pointAlongLineAndOffset as f,offsetPointFromSegment as c}from"./support/shapeUtils.js";import{isPolyline as h,maxDigitizingDisplayEdits as u}from"../support/executorUtils.js";import m from"../../../../geometry/Multipoint.js";import{e as g}from"../../../../chunks/intersectsOperator.js";import{fromSpatialReference as y}from"../../../../geometry/operators/support/apiConverter.js";function d(t){if(b(t)&&"digitizing"!==t.mode)return j(t)}async function j({templatePart:h,parentTemplate:m,shape:d,edits:j,relationships:b,mode:M}){const{builderConfig:U}=h,Z=t(U),P=e(U),T=r(U),V=s(U,P),k=T||0===Z?d:a(d,Z);if(null===k)return;const w=m.layer.createQuery();w.geometry=k,w.spatialRelationship="intersects",w.returnM=!0,w.returnZ=!0,w.outSpatialReference=k.spatialReference,w.cacheHint=!1,w.returnGeometry=!0,w.historicMoment=m.layer.historicMoment,w.gdbVersion=m.layer.gdbVersion;const x=2*(y(k.spatialReference)?.getTolerance()??.001);w.distance=x;const{features:C}=await m.layer.queryFeatures(w);if(0===C.length)return;const S=[];for(const t of C)S.push(R(t.geometry));const q=o(k);let v=0,z=0;for(let t=0;t<k.paths.length&&!(j.length>u);t++){const e=k.paths[t].length;for(let r=0;r<e;r++){let s=k.getPoint(t,r);if(null!=s){for(const o of S)if(g(s,o)){if(r>0&&0!==V&&(v+=k.hasZ?i(k.paths[t][r-1],k.paths[t][r],q):p(k.paths[t][r-1],k.paths[t][r])),0!==V){let o=1;if(P){const s=V<0?r-1:r+1;if(s>=e||s<0)return;o=k.hasZ?i(k.paths[t][r],k.paths[t][s],q):p(k.paths[t][r],k.paths[t][s])}const n=v+o*V;s=k.hasZ?l(k,n,Z,q):f(k,n,Z)}else 0!==Z&&(s=c(s,r===e-1?[k.paths[t][r-1],k.paths[t][r]]:[k.paths[t][r],k.paths[t][r+1]],Z));s&&n({templatePart:h,shape:s,edits:j,relationships:b,mode:M},`V${z.toString()}`);break}z++}}}}function R(t){const e=[];for(const r of t.paths)for(const t of r)e.push([...t]);return new m({spatialReference:t.spatialReference,points:e})}function b(t){return null!=t.parentTemplate&&h(t.shape)}const M=!0;export{d as execute,M as isAsync};
