/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{hasScaling as r,deg2rad as t}from"../../../core/mathUtils.js";import{normalFromMat4 as o,fromMat4 as e}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{create as n}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as i}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as f}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{o as c,n as a}from"../../../chunks/vec32.js";import{create as s}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{computeTranslationToOriginAndRotation as m}from"../../projection/computeTranslationToOriginAndRotation.js";import{projectBuffer as u}from"../../projection/projectBuffer.js";import{earth as l}from"../Ellipsoid.js";import{isCGCS2000 as p,isMars as T,isMoon as y}from"../spatialReferenceUtils.js";import{y2lat as A}from"../webMercatorUtils.js";import{BufferViewVec3f as d,BufferViewVec3f64 as P}from"../buffer/BufferView.js";import{b as N,n as j}from"../../../chunks/vec3.js";import{t as M}from"../../../chunks/vec4.js";const O="Projection may be possible after calling projection.load().";function F(r,t,o,e){r.error(`Failed to project from (wkid:${t.wkid}) to (wkid:${o.wkid}).${e?" ":""}${e}`)}function E(r,t,o,e,n,i){return B(x.TO_PCPF,d.fromTypedArray(r),V.NORMAL,P.fromTypedArray(t),o,P.fromTypedArray(e),n,d.fromTypedArray(i))?i:null}function R(r,t,o,e,n,i){return B(x.FROM_PCPF,d.fromTypedArray(r),V.NORMAL,P.fromTypedArray(t),o,P.fromTypedArray(e),n,d.fromTypedArray(i))?i:null}function g(r,t,o,e){return u(r,t,0,o,e,0)?o:null}function h(r,t,o,e){return u(r,t,0,o,e,0)?o:null}function _(t,e,n){return o(q,n),N(e,t,q),r(q)&&j(e,e),e}function C(t,o,n){return e(q,n),M(o,t,q),r(q)&&j(o,o,4),o}function b(r,o,e,n){const i=o===V.NORMAL;return k(r,o,e,((r,o)=>{const e=Math.cos(t(r));o[0]=i?e:1/e,o[1]=1}),n)}function L(r,t,o,e){const n=t===V.NORMAL;return k(r,t,o,((r,t)=>{const o=Math.cosh(-r/l.radius);t[0]=1,t[1]=n?o:1/o}),e)}function k(r,t,o,e,n){const i=t===V.NORMAL?3:4,f=[0,0];for(let c=0,a=1;c<r.length;c+=i,a+=3){e(o[a],f);const t=r[c]*f[0],s=r[c+1]*f[1],m=r[c+2],u=1/Math.sqrt(t*t+s*s+m*m);n[c]=t*u,n[c+1]=s*u,n[c+2]=m*u,4===i&&(n[c+3]=r[c+3])}return n}function w(r,t,o,e,n,i){if(!B(x.TO_PCPF,d.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),V.TANGENT,P.fromTypedArray(t),o,P.fromTypedArray(e),n,d.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT)))return null;for(let f=3;f<r.length;f+=4)i[f]=r[f];return i}function G(r,t,o,e,n,i){if(!B(x.FROM_PCPF,d.fromTypedArray(r,16),V.TANGENT,P.fromTypedArray(t),o,P.fromTypedArray(e),n,d.fromTypedArray(i,16)))return null;for(let f=3;f<r.length;f+=4)i[f]=r[f];return i}var V,x;function v(r,t,n,f,c){switch(m(f,n,Y,f),r===x.FROM_PCPF&&i(Y,Y),t){case V.NORMAL:return o(c,Y);case V.TANGENT:return e(c,Y)}}function B(r,t,o,e,n,i,f,s){if(!t)return;const m=e.count;if($(n))for(let a=0;a<m;a++)i.getVec(a,S),t.getVec(a,U),c(U,U,v(r,o,S,f,q)),s.setVec(a,U);else for(let u=0;u<m;u++){i.getVec(u,S),t.getVec(u,U);const n=A(e.get(u,1));let m=Math.cos(n);o===V.TANGENT!=(r===x.TO_PCPF)&&(m=1/m),v(r,o,S,f,q),r===x.TO_PCPF?(q[0]*=m,q[1]*=m,q[2]*=m,q[3]*=m,q[4]*=m,q[5]*=m):(q[0]*=m,q[3]*=m,q[6]*=m,q[1]*=m,q[4]*=m,q[7]*=m),c(U,U,q),a(U,U),s.setVec(u,U)}return s}function $(r){return r.isWGS84||p(r)||T(r)||y(r)}!function(r){r[r.NORMAL=0]="NORMAL",r[r.TANGENT=1]="TANGENT"}(V||(V={})),function(r){r[r.TO_PCPF=0]="TO_PCPF",r[r.FROM_PCPF=1]="FROM_PCPF"}(x||(x={}));const S=s(),U=s(),Y=f(),q=n();export{V as VectorType,O as loadProjectErrorMessage,F as logProjectionError,h as projectFromPCPF,R as projectNormalFromPCPF,E as projectNormalToPCPF,G as projectTangentFromPCPF,w as projectTangentToPCPF,g as projectToPCPF,_ as transformNormal,C as transformTangent,b as transformVectorENUPlateCarree,L as transformVectorWMPlateCarree};
