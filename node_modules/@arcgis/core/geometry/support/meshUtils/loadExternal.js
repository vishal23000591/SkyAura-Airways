/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{neverReached as e}from"../../../core/compilerUtils.js";import t from"../../../core/Error.js";import{whenOrAbort as s,throwIfAborted as r,allSettledValues as n,isAborted as o,createAbortError as i}from"../../../core/promiseUtils.js";import{removeFile as l,makeRelative as a}from"../../../core/urlUtils.js";import c from"../../Point.js";async function u(t,s,r){switch(s.source.type){case"client":case"service":return f(t,s,r);case"loadable":return s.source.load(t,r);default:e(s.source)}}async function f(e,t,n){const{source:o}=t,{loadGLTFMesh:i}=await s(import("./loadGLTFMesh.js"),n),l=await p(o,n);r(n);const a=i(new c({x:0,y:0,z:0,spatialReference:e.spatialReference}),l.url,{resolveFile:m(l),signal:n?.signal,expectedType:l.type,unitConversionDisabled:t.unitConversionDisabled});a.then((()=>l.dispose()),(()=>l.dispose()));const{vertexAttributes:u,components:f}=await a;e.vertexAttributes=u,e.components=f}function m(e){const t=l(e.url);return s=>{const r=a(s,t,t),n=r?r.replace(/^ *\.\//,""):null;return(n?e.files.get(n):null)??s}}async function p(e,s){switch(e.type){case"client":return Array.isArray(e.files)?y(e.files):h(e.files);case"service":return w(e.assets,s);default:throw new t("mesh-load-external:invalid-source","Invalid source type")}}async function d(e,t){const{parts:s,assetMimeType:n,assetName:o}=e;if(1===s.length)return new M(s[0].partUrl);const i=await e.toBlob(t);return r(t),M.fromBlob(i,R(o,n))}function h(e){return M.fromBlob(e,R(e.name,e.type))}function y(e){if(!e.length)throw new t("mesh-load-external:missing-assets","There must be at least one file to load");return j(e.map((e=>({name:e.name,mimeType:e.type,source:h(e)}))))}async function w(e,s){if(!e.length)throw new t("mesh-load-external:missing-assets","There must be at least one file to load");const l=await n(e.map((async e=>{const t=await d(e);return r(s),{name:e.assetName,mimeType:e.assetMimeType,source:t}})));if(o(s))throw l.forEach((e=>e.source.dispose())),i();return j(l)}const g=/^model\/gltf\+json$/,b=/^model\/gltf-binary$/,v=/\.gltf$/i,x=/\.glb$/i;function T({mimeType:e,source:t,name:s}){return g.test(e)||v.test(s)?{url:t.url,type:"gltf"}:b.test(e)||x.test(s)?{url:t.url,type:"glb"}:null}function j(e){const s=new Map;let r=null,n=null;for(const t of e){const{source:e,name:o}=t;r??=T(t),"ESRI3DO_NORM.glb"===o&&(n=T(t)),s.set(o,e.url),e.files.forEach(((e,t)=>s.set(t,e)))}const o=n??r;if(null==o)throw new t("mesh-load-external:missing-files","Missing files to load external mesh source");return new M(o.url,(()=>e.forEach((({source:e})=>e.dispose()))),s,o.type)}class M{constructor(e,t=()=>{},s=new Map,r){this.url=e,this.dispose=t,this.files=s,this.type=r}static fromBlob(e,t){const s=URL.createObjectURL(e);return new M(s,(()=>URL.revokeObjectURL(s)),void 0,t)}}function R(e,t){return g.test(t)||v.test(e)?"gltf":b.test(t)||v.test(e)?"glb":void 0}export{u as loadExternal};
