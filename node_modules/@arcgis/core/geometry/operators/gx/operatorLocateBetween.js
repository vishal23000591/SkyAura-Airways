/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../../chunks/SimpleGeometryCursor.js";import{c as n,G as r,a as s,k as i,f as o,d as u}from"../../../chunks/Geometry.js";import{E as l,c as m}from"../../../chunks/Point2D.js";import{V as c,P as a}from"../../../chunks/Envelope.js";import{g as h,M as p,S as g,P as d,G as y}from"../../../chunks/MultiPathImpl.js";function _(t,e,n,r,s){return new f(e,n,r,s).processGeometry(t)}class f{constructor(t,e,n,r){this.m_interval=n,this.m_progressTracker=r,this.m_attribute=t,this.m_ord=e,(c.getComponentCount(this.m_attribute)<=e||e<0)&&s("LocateBetween: ordinate");2===c.getInterpolation(this.m_attribute)&&s("LocateBetween: angular interpolation")}processGeometry(t){const e=t.getGeometryType();if(e===r.enumGeometryCollection)return this.processGeometryCollection(t);if(i(e)&&s("LocateBetween does not support Polygons and Envelopes."),t.isEmpty()||!t.hasAttribute(this.m_attribute))return new a({vd:t.getDescription()});if(o(e))return this.processSegment(t);switch(e){case r.enumPoint:return this.processPoint(t);case r.enumMultiPoint:return this.processMultiPoint(t);case r.enumPolyline:return this.processPolyline(t);default:u("LocateBetween")}}processPoint(t){const e=t.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(e)?new p({point:t}):new a({vd:t.getDescription()})}processMultiPoint(t){let e=null,n=-1;const r=t.getAttributeStreamRef(this.m_attribute),s=c.getComponentCount(this.m_attribute);for(let i=0,o=0,u=t.getPointCount();i<u;++i,o+=s){const s=r.readAsDbl(o);this.m_interval.containsCoordinate(s)?-1===n&&(n=i):n>=0&&(e||(e=new p({vd:t.getDescription()})),e.addPoints(t,n,i),n=-1)}return n>=0&&(e||(e=new p({vd:t.getDescription()})),e.addPoints(t,n,-1)),e||new a({vd:t.getDescription()})}processPolyline(t){const e=t.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(e))return t;if(!this.m_interval.isIntersecting(e))return new a({vd:t.getDescription()});let n=null,s=null;const i=t.querySegmentIterator(),o=new g,u=new a,l=new a,m=new a;let c=!0,h=!1;for(;i.nextPath();)for(c=!0,h=!1;i.hasNextSegment();){const t=i.nextSegment(),e=[null],a=this.processSegmentHelper(t,o,e,u);if(a!==r.enumUnknown)if(a===r.enumPoint){if(!c&&(s.getPointByVal(s.getPointCount()-1,l),l.equals(u)))continue;if(c=!0,h&&(t.queryStart(l),u.equals(l)))continue;t.queryEnd(l),h=u.equals(l),n?n.add(u):n=new p({point:u})}else a===r.enumLine&&(h=!1,s||(s=new d),c&&(null===n||n.isEmpty()||(n.getPointByVal(n.getPointCount()-1,l),e[0].queryStart(u),l.equals(u)&&n.removePoint(n.getPointCount()-1))),s.addSegment(e[0],c),t.queryEnd(l),e[0].queryEnd(m),c=!l.equals(m));else c=!0,h=!1}if(null!==n&&n.isEmpty()&&(n=null),null!==n&&null!==s){const t=new y;return t.addGeometry(s),t.addGeometry(n),t}return null!==n?n:null!==s?s:new a({vd:t.getDescription()})}processSegment(t){const e=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),n=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),r=Number.isNaN(e)?n:e,s=Number.isNaN(n)?e:n,i=new l;i.setCoords(r,s);const o=i.clone();if(o.intersect(this.m_interval),o.isEmpty())return new a({vd:t.getDescription()});if(i.equals(o))return t;const u=s-r,c=t.calculateLength2D();if(0===o.width()){const e=new a({vd:t.getDescription()}),n=(o.vmin-r)/u,s=t.lengthToT(n*c);return t.queryCoord(s,e),e}let h=(o.vmin-r)/u,p=(o.vmax-r)/u;return h>p&&(p=m(h,h=p)),h=t.lengthToT(h*c),p=t.lengthToT(p*c),t.cut(h,p)}processGeometryCollection(t){if(t.isEmpty()||!t.hasAttribute(this.m_attribute))return new a({vd:t.getDescription()});const e=h(t),n=new y;for(let r=e.next();null!==r;r=e.next()){const t=this.processGeometry(r);t.isEmpty()||n.addGeometry(t)}return n.isEmpty()?new a({vd:t.getDescription()}):n}processSegmentHelper(t,e,n,s){const i=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),o=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),u=Number.isNaN(i)?o:i,c=Number.isNaN(o)?i:o,a=new l;a.setCoords(u,c);const h=a.clone();if(h.intersect(this.m_interval),h.isEmpty())return r.enumUnknown;if(a.equals(h))return n[0]=t,r.enumLine;const p=c-u,g=t.calculateLength2D();if(0===h.width()){const e=(h.vmin-u)/p,n=1===e?1:t.lengthToT(e*g);return t.queryCoord(n,s),r.enumPoint}let d=(h.vmin-u)/p,y=(h.vmax-u)/p;return d>y&&(y=m(d,d=y)),d=1===d?1:t.lengthToT(d*g),y=1===y?1:t.lengthToT(y*g),t.queryCut(d,y,e),n[0]=e.get(),r.enumLine}}class w{getOperatorType(){return 10801}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,n){return new v(t,e,n)}}class v extends t{constructor(t,e,n){super(),this.m_collectionCursor=null,this.m_interval=e,this.m_progressTracker=n,this.m_inputGeoms=t,this.m_index=-1}tock(){return!0}getRank(){return 1}next(){if(this.m_collectionCursor){const t=this.m_collectionCursor.next();if(t)return t;this.m_collectionCursor=null}const t=this.m_inputGeoms.next();if(null===t)return null;n(t),this.m_index=this.m_inputGeoms.getGeometryID();const e=_(t,2,0,this.m_interval,this.m_progressTracker);if(e.getGeometryType()===r.enumGeometryCollection){this.m_collectionCursor=h(e);return this.m_collectionCursor.next()}return e}getGeometryID(){return this.m_index}}const b=new w;function C(t,n){const r=b.executeMany(new e(t),n,null);return Array.from(r)}function P(){return b.supportsCurves()}export{C as executeMany,P as supportsCurves};
