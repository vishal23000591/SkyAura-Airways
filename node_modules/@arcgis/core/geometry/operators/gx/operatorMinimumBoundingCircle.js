/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import{S as e,G as t}from"../../../chunks/SimpleGeometryCursor.js";import{d as r,o as n,c as s,G as o,i,a as u}from"../../../chunks/Geometry.js";import{m as c,k as m,a,l,M as g}from"../../../chunks/MultiPathImpl.js";import{m as d,P as p}from"../../../chunks/Point2D.js";class h{getOperatorType(){return 10113}supportsCurves(){return!1}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,r){return new y(e,t,r)}execute(t,n){const s=new e([t]),o=this.executeMany(s,!1,n).next();return o||r("null output"),o}minimumBoundingCircle(e,t,r,n){return c(e,t,r)}}class y extends t{constructor(e,t,r){super(),this.m_geometryCursor=e,this.m_bMerge=t,this.m_progressTracker=r}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge)return this.mergedMinimumBoundingCircle();const e=this.m_geometryCursor.next();return e?this.minimumBoundingCircle(e):null}getGeometryID(){return this.m_geometryCursor.getGeometryID()}minimumBoundingCircle(e){if(n(e),s(e),this.m_progressTracker?.checkProgress(),e.isEmpty())return e.clone();const t=e.getGeometryType();if(t===o.enumPoint)return this.makeCircle([e.getXY()],1);if(t===o.enumLine){const t=e,r=[t.getStartXY(),t.getEndXY()];return this.makeCircle(r,2)}if(t===o.enumEnvelope){const t=e,r=d(p,2);return t.queryCorner(0,r[0]),t.queryCorner(2,r[1]),this.makeCircle(r,2)}if(i(t)){const t=e,r=[0,0,0],n=m(t,r),s=new Array(n);for(let e=0;e<n;++e)s[e]=t.getXY(r[e]);return this.makeCircle(s,n)}u("Geometry type not supported.")}makeCircle(e,t){const r=new a,n=new l;if(1===t)n.constructCircleRadius(0,e[0],!1);else if(2===t){const t=p.lerp(e[0],e[1],.5),r=p.distance(e[0],t),s=p.distance(e[1],t);n.constructCircleRadius(Math.max(r,s),t,!1)}else if(3===t){const t=p.calculateCircleCenterFromThreePoints(e[0],e[1],e[2]),r=p.distance(e[0],t),s=p.distance(e[1],t),o=p.distance(e[2],t);n.constructCircleRadius(Math.max(r,s,o),t,!1)}return r.addPathFromClosedSegment(n,!1),r}mergedMinimumBoundingCircle(){let e=null,t=this.m_geometryCursor.next();if(!t)return null;e=new g;const r=e.getImpl();do{n(t),s(t),this.m_progressTracker?.checkProgress();switch(t.getGeometryType()){case o.enumPoint:r.addPoint2D(t.getXY());break;case o.enumLine:r.addPoint2D(t.getStartXY()),r.addPoint2D(t.getEndXY());break;case o.enumEnvelope:for(let e=0;e<4;++e){const n=new p;t.queryCorner(e,n),r.addPoint2D(n)}break;case o.enumMultiPoint:case o.enumPolyline:case o.enumPolygon:{const e=t.getImpl();for(let t=0,n=e.getPointCount();t<n;t++)r.addPoint2D(e.getXY(t));break}default:u("Geometry type not supported.")}}while(t=this.m_geometryCursor.next());return this.minimumBoundingCircle(e)}}const C=new h;function f(e){return C.execute(e,null)}function k(t,r){const n=C.executeMany(new e(t),r,null);return Array.from(n)}function P(){return C.supportsCurves()}export{f as execute,k as executeMany,P as supportsCurves};
