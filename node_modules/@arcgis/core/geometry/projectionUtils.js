/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
*/
import n from"../core/Error.js";import{throwIfAborted as e,waitTick as r}from"../core/promiseUtils.js";import{trackAccess as t}from"../core/accessorSupport/tracking.js";import{SimpleObservable as l}from"../core/accessorSupport/tracking/SimpleObservable.js";import{create as o}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{assertNotMeshes as i,assertNotMesh as s}from"./asserts.js";import{isSphericalECEF as u,isSphericalPCPF as a}from"./ellipsoidUtils.js";import c from"./Extent.js";import f from"./Multipoint.js";import{l as p,p as m,i as h}from"../chunks/pe.js";import g from"./Point.js";import j from"./Polygon.js";import R from"./Polyline.js";import y from"./SpatialReference.js";import{projectBuffer as d}from"./projection/projectBuffer.js";import{getProjector as x}from"./projection/projectors.js";import{projectXYZToVector as w}from"./projection/projectXYZToVector.js";import z from"./support/GeographicTransformation.js";import{equals as M,isValid as Z,isWGS84 as v,isWebMercator as A,isCGCS2000 as S}from"./support/spatialReferenceUtils.js";import{getGeometryZScaler as G}from"./support/zscale.js";let P=null,b=null,E=null,T={};const _=new l;function k(){return!!P&&h()}function B(){return!!k()||(t(_),K(),!1)}function U(n,e){return!n||!e||(L(n,e)||B())}function W(n,e){return!L(n,e)&&!k()}function K(n){return null==E&&(E=Promise.all([p(),import("../chunks/geometryEngineBase.js").then((n=>n.g)),import("./geometryAdapters/hydrated.js")])),E.then((([,r,{hydratedAdapter:t}])=>{e(n),b=t,P=r.default,P._enableProjection(m),_.notify()}))}function O(n,e,r=null,t=null){return Array.isArray(n)?0===n.length?[]:(i(n),V(b,n,n[0].spatialReference,e,r,t)):(s(n),V(b,[n],n.spatialReference,e,r,t)[0])}function V(n,e,r,t,l=null,o=null){if(null==r||null==t)return e;if(L(r,t,l))return e.map((n=>$(n,r,t)));if(null==l&&u(r)){return e.map((n=>$(n,r,y.WGS84))).map((n=>I(n,t)))}if(null==l&&u(t)){return e.map((n=>I(n,y.WGS84))).map((n=>$(n,y.WGS84,t)))}if(null==l){const n=z.cacheKey(r,t);void 0!==T[n]?l=T[n]:(null==(l=q(r,t,void 0))&&(l=new z),T[n]=l)}if(null==P||null==n)throw new D;return null!=o?P._project(n,e,r,t,l,o):P._project(n,e,r,t,l)}function X(n,e){const r=Y([n],e);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}}function Y(n,e){if(!k())for(const r of n)if(null!=r&&!M(r.spatialReference,e)&&Z(r.spatialReference)&&Z(e)&&!L(r.spatialReference,e))return t(_),{pending:K(),geometries:null};return{pending:null,geometries:n.map((n=>null==n?null:M(n.spatialReference,e)?n:Z(n.spatialReference)&&Z(e)?I(n,e):null))}}function q(n,e,r=null){if(null==n||null==e)return null;if(null==P||null==b)throw new D;const t=P._getTransformation(b,n,e,r,r?.spatialReference);return null!==t?z.fromGE(t):null}function C(n,e,r=null){if(null==P||null==b)throw new D;const t=P._getTransformationBySuitability(b,n,e,r,r?.spatialReference);if(null!==t){const n=[];for(const e of t)n.push(z.fromGE(e));return n}return[]}class D extends n{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function F(){P=null,b=null,E=null,T={}}const H={get loadPromise(){return E}};function I(n,e){try{const r=O(n,e);if(null==r)return null;"xmin"in n&&"xmin"in r&&(r.zmin=n.zmin,r.zmax=n.zmax);const t=G(r.type,n.spatialReference,e);return null!=t&&t(r),r}catch(r){if(!(r instanceof D))throw r;return null}}async function J(n,e,r){const t=n.spatialReference;return null!=t&&null!=e&&await Q(t,e,null,r),I(n,e)}function L(n,e,r){return!r&&(!!M(n,e)||Z(n)&&Z(e)&&!!x(n,e))}function N(n,e){if(M(n,e))return!0;if(!Z(n)||!Z(e))return!1;const r=v(n)||A(n)||S(n),t=v(e)||A(e)||S(e);return r&&t}async function Q(n,e,t,l){if(k())return r(l);if(Array.isArray(n)){for(const{source:r,dest:o,geographicTransformation:i}of n)if(r&&o&&!L(r,o,i))return K(l)}else if(n&&e&&!L(n,e,t))return K(l);return r(l)}function $(n,e,r){return n?"x"in n?en(n,e,new g,r,0):"xmin"in n?cn(n,e,new c,r,0):"rings"in n?un(n,e,new j,r,0):"paths"in n?on(n,e,new R,r,0):"points"in n?tn(n,e,new f,r,0):null:null}function nn(n,e,r=e.spatialReference,t=0){return null!=r&&null!=n.spatialReference&&null!=en(n,n.spatialReference,e,r,t)}function en(n,e,r,t,l){pn[0]=n.x,pn[1]=n.y;const o=n.z;return pn[2]=void 0!==o?o:l,d(pn,e,0,pn,t,0)?(r.x=pn[0],r.y=pn[1],r.spatialReference=t,void 0!==o||a(t)?(r.z=pn[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===n.m?(r.m=void 0,r.hasM=!1):(r.m=n.m,r.hasM=!0),r):null}function rn(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=tn(n,n.spatialReference,e,r,t)}function tn(n,e,r,t,l){const{points:o,hasZ:i,hasM:s}=n,u=[],c=o.length,f=[];for(const a of o)f.push(a[0],a[1],i?a[2]:l);if(!d(f,e,0,f,t,0,c))return null;const p=i||a(t);for(let a=0;a<c;++a){const n=3*a,e=f[n],r=f[n+1];p&&s?u.push([e,r,f[n+2],o[a][3]]):p?u.push([e,r,f[n+2]]):s?u.push([e,r,o[a][2]]):u.push([e,r])}return r.points=u,r.spatialReference=t,r.hasZ=i,r.hasM=s,r}function ln(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=on(n,n.spatialReference,e,r,t)}function on(n,e,r,t,l){const{paths:o,hasZ:i,hasM:s}=n,u=[];if(!fn(o,i??!1,s??!1,e,u,t,l))return null;const c=i||a(t);return r.paths=u,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function sn(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=un(n,n.spatialReference,e,r,t)}function un(n,e,r,t,l){const{rings:o,hasZ:i,hasM:s}=n,u=[];if(!fn(o,i??!1,s??!1,e,u,t,l))return null;const c=i||a(t);return r.rings=u,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function an(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=cn(n,n.spatialReference,e,r,t)}function cn(n,e,r,t,l){const{xmin:o,ymin:i,xmax:s,ymax:u,hasZ:c,hasM:f}=n,p=c?n.zmin:l;if(!w(o,i,p,e,pn,t))return null;const m=c||a(t);r.xmin=pn[0],r.ymin=pn[1],m&&(r.zmin=pn[2]);const h=c?n.zmax:l;return w(s,u,h,e,pn,t)?(r.xmax=pn[0],r.ymax=pn[1],m&&(r.zmax=pn[2]),f&&(r.mmin=n.mmin,r.mmax=n.mmax),r.spatialReference=t,r):null}function fn(n,e,r,t,l,o,i=0){const s=new Array;for(const a of n)for(const n of a)s.push(n[0],n[1],e?n[2]:i);if(!d(s,t,0,s,o,0))return!1;let u=0;l.length=0;const c=e||a(o);for(const a of n){const n=new Array;for(const e of a)c&&r?n.push([s[u++],s[u++],s[u++],e[3]]):c?n.push([s[u++],s[u++],s[u++]]):r?(n.push([s[u++],s[u++],e[2]]),u++):(n.push([s[u++],s[u++]]),u++);l.push(n)}return!0}const pn=o();export{L as canProjectWithoutEngine,q as getTransformation,C as getTransformations,Q as initializeProjection,N as isEqualBaseGCS,k as isLoaded,B as isLoadedOrLoad,U as isLoadedOrLoadFor,K as load,O as project,an as projectExtent,V as projectMany,rn as projectMultipoint,X as projectOrLoad,Y as projectOrLoadMany,nn as projectPoint,sn as projectPolygon,ln as projectPolyline,J as projectWithZConversion,$ as projectWithoutEngine,W as requiresLoad,H as test,I as tryProjectWithZConversion,F as unload};
