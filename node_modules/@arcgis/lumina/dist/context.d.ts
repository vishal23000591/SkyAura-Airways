import { ContextConsumer, ContextProvider, Context, ContextType } from '@lit/context';
import { ReactiveControllerHost } from 'lit';
interface ContextProviderOptions<C extends Context<unknown, unknown>> {
    context: C;
    initialValue?: ContextType<C>;
}
interface ContextConsumerOptions<C extends Context<unknown, unknown>> {
    context: C;
    callback?: (value: ContextType<C>, dispose?: () => void) => void;
    subscribe?: boolean;
}
/**
 * Wrapper for Lit's ContextProvider controller to provide lazy-loading compatibility.
 *
 * @see https://lit.dev/docs/data/context/
 */
export declare const useContextProvider: <C extends Context<unknown, unknown>>(options: ContextProviderOptions<C>) => ContextProvider<C>;
/**
 * Wrapper for Lit's ContextConsumer controller to provide lazy-loading compatibility.
 *
 * @see https://lit.dev/docs/data/context/
 *
 * FEATURE: wrap this in proxyExports to improve DX, or keep it simple?
 */
export declare const useContextConsumer: <C extends Context<unknown, unknown>>(options: ContextConsumerOptions<C>) => ContextConsumer<C, LitContextHost>;
/**
 * Lit context wasn't written with lazy loading proxy in mind. For it to
 * work correctly, we must provide the DOM-attached element as the host element.
 * Events will be fired/listened on it.
 *
 * At the same time, .addController() and .requestUpdate() methods will be
 * called on it. We had to implement these on the lazy proxy to redirect the
 * calls to the actual LitElement.
 */
type LitContextHost = HTMLElement & ReactiveControllerHost;
export {};
