import { Controller } from './Controller';
import { ControllerLifecycleMethods } from './types';
/**
 * If you wish to directly expose the "exports" property of your controller,
 * rather than the entire controller class, wrap your class definition in
 * "proxyExports".
 *
 * This is especially convenient when your exports is not an object, or it is a
 * dynamically created object, and so you don't want your Controller's methods
 * interfering with the keys on the exported value.
 *
 * "proxyExports" is the default behavior for all controllers declared using
 * the makeController()/makeGenericController() function
 *
 * @remarks
 * If using readonly(), and controller updates its exports, the readonly prop
 * will still get updated
 *
 * @remarks
 * (Advanced) If you wish to use proxyExports() in a class that does not
 * extend Controller class and does not have a useControllerManager(), then your
 * class must subclass a class with the following constructor:
 * `constructor() { setAmbientController(this); }`. This
 * is necessary for proxyExports() to receive a reference to your object
 * implicitly, and before any of your default values are assigned.
 */
export declare const proxyExports: <Exports, const Parameters extends unknown[]>(Class: new (...args: Parameters) => ControllerLifecycleMethods & Pick<Controller<Exports>, "component" | "exports" | "onUpdate" | "watchExports">) => ((...args: Parameters) => Exports);
