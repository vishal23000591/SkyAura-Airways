import { IHandle } from '@arcgis/components-utils';
import { ReactiveControllerHost, ReactiveController, PropertyDeclaration, PropertyValues } from 'lit';
import { LitElement } from '../LitElement';
export type TrackKeyResolution = {
    readonly key: string;
    readonly host: BaseController | LitElement;
    /**
     * True if property is decorated with a `@state()` or `@property()` decorator
     */
    readonly isReactive: boolean;
};
/**
 * @deprecated use LitElement instead
 */
export type BaseComponent = Omit<LitElement, "componentOnReady"> & {
    autoDestroyDisabled?: boolean;
    destroy?: () => Promise<void>;
};
/**
 * Helper utility to get component type from a controller. Can be used in
 * "implements"
 * @example
 * const useHomeViewModel = makeViewModelController(newWidgetsHomeHomeViewModel);
 * export class Home extends LitElement implements Use<typeof useHomeViewModel> {
 *
 * @remarks
 * TypeScript detects errors even without Use<typeof useHomeViewModel>, but Use
 * makes errors display in a more readable format
 */
export type Use<Callback extends (component: any) => unknown> = Parameters<Callback>[0];
/**
 * Base API for a controller. Compatible with Lit's Reactive controllers
 */
export type ControllerLifecycleMethods = {
    readonly hostConnected?: ReactiveController["hostConnected"];
    readonly hostDisconnected?: ReactiveController["hostDisconnected"];
    readonly hostLoad?: () => Promise<void> | void;
    readonly hostLoaded?: () => void;
    /**
     * Called during the client-side host update, just before the host calls
     * its own update.
     *
     * Code in `update()` can depend on the DOM as it is not called in
     * server-side rendering.
     */
    hostUpdate?(changes: PropertyValues): void;
    /**
     * Called after a host update, just before the host calls firstUpdated and
     * updated. It is not called in server-side rendering.
     */
    hostUpdated?(changes: PropertyValues): void;
    /**
     * Called when the component is finally being destroyed (rather than
     * temporary disconnected from the DOM)
     */
    readonly hostDestroy?: () => void;
    /**
     * lifecycle() is a convenience higher-level callback that:
     * - calls the provided callback right away the first time if
     *   connectedCallback has already happened once
     *   - otherwise, calls it on connectedCallback
     * - calls the callback on each future connectedCallback
     * - if you returned a function, or an object like {remove:()=>void}, that
     *   function will be called on the next disconnectedCallback
     *
     * This is a bit like useEffect(callback, []) in React
     */
    readonly hostLifecycle?: () => (() => void)[] | IHandle | IHandle[] | (() => void) | undefined | void;
    /**
     * Called after component.removeComponent(controller) was called on this
     * controller
     */
    readonly controllerRemoved?: () => void;
};
/**
 * Controller host interface, compatible with both Lit's Reactive controllers
 * and Stencil's lifecycle.
 * These members are added to the component instance by ControllerManager.
 *
 * @deprecated use LitElement instead
 */
export type ControllerHost = {
    /**
     * Adds a controller to the host, which connects the controller's lifecycle
     * methods to the host's lifecycle.
     */
    addController(controller: BaseController): void;
    addController(controller: ReactiveController): void;
    /**
     * Removes a controller from the host.
     */
    removeController(controller: BaseController): void;
    removeController(controller: ReactiveController): void;
    /**
     * Requests a host update which is processed asynchronously. The update can
     * be waited on via the `updateComplete` property.
     *
     * @remarks
     * It is recommended to provide the property name describing what property
     * triggered the update - property name will be provided to the willUpdate()
     * lifecycle hook, giving it the ability to react to the change.
     *
     * @see https://lit.dev/docs/api/ReactiveElement/#ReactiveElement.requestUpdate
     */
    requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: PropertyDeclaration) => void;
    readonly updateComplete: ReactiveControllerHost["updateComplete"];
};
/**
 * A symbol is used to mark providers/controllers on a component instance.
 * This helps to distinguish them from regular properties.
 */
export declare const controllerSymbol: unique symbol;
/**
 * Adding an optional symbol to satisfy TypeScript
 * "type Controller has no properties in common with BaseController"
 */
export type BaseController = ControllerLifecycleMethods & {
    readonly [controllerSymbol]?: true;
};
/**
 * Property declaration with additional `reaDonly` option (handled by Controllers)
 */
export type LuminaPropertyDeclaration = PropertyDeclaration & {
    /**
     * Declare a property that can't be modified by the developer.
     *
     * @example
     * ```ts
     * \@property({ readOnly: true })
     * myReadonlyProp = 'initialValue';
     * ```
     *
     * @example
     * Inside the component code, you can overwrite the readOnly property like so:
     * ```ts
     * bypassReadOnly(() => {
     *  this.myReadonlyProp = 'newValue';
     * });
     * ```
     *
     * @example
     * Alternatively, you can declare a readOnly prop like so:
     *
     * ```ts
     * \@property()
     * get myReadonlyProp(): string {
     *   return 'someValue';
     * }
     * ```
     */
    readonly readOnly?: boolean;
    /**
     * Short for "changed"
     *
     * Temporary set during a setter to track whether property is considered
     * changed.
     * @private
     */
    c?: boolean;
    /**
     * Short for "descriptor"
     *
     * Stores a reference to the property getter and setter. This is overwritten
     * in useAccessor to proxy the get/set through the Accessor instance.
     * @private
     */
    d?: PropertyDescriptor;
    /**
     * The positional index of the Accessor controller to which this property is
     * bound.
     * @private
     */
    i?: number;
};
/** @private */
export type AccessorObservableLike = {
    /**
     * A callback that will be called in the setter if the value hasChanged to
     * integrate with Accessor's reactivity notification system.
     */
    notify: () => void;
};
/** @private */
export type ReactiveTrackingTarget = {
    clear: () => void;
    destroy: () => void;
};
