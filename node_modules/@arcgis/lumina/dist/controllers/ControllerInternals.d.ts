import { Controller } from './Controller';
import { BaseController } from './types';
import { LitElement } from '../LitElement';
export declare const setAmbientComponent: (component: LitElement) => void;
export declare const retrieveComponent: (name?: string) => LitElement;
export declare const setParentController: (controller: BaseController | undefined) => void;
/**
 * Get references to controllers this nested controller might have been called
 * from. The list may include extra controllers, but at least one of them or
 * the component itself is the parent for this controller.
 */
export declare const retrieveParentControllers: () => readonly BaseController[];
export declare const setAmbientChildController: (controller: BaseController | undefined) => void;
/**
 * The type definition has to be duplicated due to this TypeScript error:
 * "'use' is referenced directly or indirectly in its own type annotation."
 */
export declare const use: <Value>(value: Value, watchExports?: (value: NotNever<InferController<Value>>, unsubscribe: () => void) => void) => Promise<NotNever<InferController<Value>>>;
export declare const useRef: <Value>(value: Value) => Promise<InferController<Value>>;
export declare const useRefSync: <Value>(value: Value) => InferController<Value> | undefined;
export declare let shouldBypassReadOnly: boolean;
/**
 * Permits updating read-only properties
 *
 * @see https://qawebgis.esri.com/components/lumina/properties#read-only-properties
 */
export declare const bypassReadOnly: <T = void>(callback: () => T) => T | void;
/**
 * @deprecated see https://qawebgis.esri.com/components/lumina/properties#get-set-properties
 */
export declare const bypassSetter: <T = void>(callback: () => T) => T | void;
/**
 * If passed value is a controller, then return it. Otherwise, assume it's a
 * proxyExports() result and wrap it into a controller
 *
 * This won't type correctly if a proxyExports() controller is exporting a
 * non-proxyExports() controller
 */
type InferController<ControllerOrExports> = ControllerOrExports extends BaseController ? ControllerOrExports & {
    exports?: unknown;
    ready?: Promise<void>;
    watchExports?: Controller["watchExports"];
} : Controller<ControllerOrExports>;
/**
 * If controller never sets it's exports, then it's default exports is "this".
 * This allows usage of controller.use with controllers that don't have exports
 */
type NotNever<T extends {
    exports?: any;
}> = T extends {
    exports: never;
} ? T : T["exports"];
export {};
