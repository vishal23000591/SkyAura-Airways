import { GenericController } from '../Controller';
import { LitElement } from '../../LitElement';
type Requires<Props, Accessor extends __esri.Accessor, OmitProps extends string = never> = LitElement & Omit<Pick<Accessor, keyof Accessor & keyof Props>, AlwaysOmit | OmitProps> & {
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
type AlwaysOmit = "addHandles" | "declaredClass" | "destroyed" | "hasHandles" | "initialized" | "removeHandles" | "set" | "watch";
/**
 * Given an Accessor class, create a controller that will do two-way binding of
 * props between the component and the Accessor.
 *
 * See https://qawebgis.esri.com/components/lumina/controllers/useAccessor for
 * documentation & examples.
 */
export declare const makeAccessorController: <Props, Accessor extends __esri.Accessor, OmitProps extends string = never>(createInstance: ((props?: Props) => Accessor) | (new (props?: Props) => Accessor), _options?: {
    /**
     * By default, to ensure that you didn't accidentally forget to bind any
     * of the Accessor's properties on your component, every property that
     * is accepted by the Accessor's constructor will be required to be bound
     * on your component. If you do not wish to bind certain properties
     * (or you wish to bind them but with a different type), you can omit
     * them using this option.
     *
     * You can also bind the property to \@state rather than \@property if you
     * wish to use it internally only:
     * @example
     * ```tsx
     * \@State() timeZone = this.viewModel.timeZone;
     * ```
     *
     * @remarks
     * This option affects the TypeScript error checking only - it has
     * no runtime impact. Thus, if you wish to save a few bytes in the
     * bundle, rather than simply setting this property like
     * `makeAccessorController(..., { omitProps: ["propName"] })`, you can
     * set it like this:
     * `makeAccessorController(..., {} as { omitProps: ["propName"] })`
     */
    omitProps: OmitProps[];
}) => (component: Requires<Props, Accessor, OmitProps>) => Accessor;
export declare class AccessorController<Props, Accessor extends __esri.Accessor, ExtraRequires = Record<never, never>> extends GenericController<Accessor, ExtraRequires & Requires<Props, Accessor>> {
    #private;
    protected instance: Accessor;
    /**
     * Use getAccessorControllerBoundProperties() helper to get access to this map
     * @private
     */
    _boundAccessorProperties: Map<string & keyof Accessor, string>;
    /** @private */
    _currentlyBindingPropertyName?: string;
    /**
     * (development only) Allow these props to mismatch the name of the Accessor's
     * property to avoid collisions
     *
     * @private
     */
    static devOnly$allowedPropNameMismatches?: ReadonlySet<string>;
    get exports(): Accessor;
    set exports(value: Accessor);
    constructor(component: ExtraRequires & Requires<Props, Accessor>, createInstance: ((props?: Props) => Accessor) | (new (props?: Props) => Accessor));
    /** @private */
    _createAccessorInstance(): void;
    hostConnected(): void;
    hostDestroy(): void;
}
type MinimalAccessorController = Pick<AccessorController<never, __esri.Accessor>, "_currentlyBindingPropertyName" | "exports"> & {
    component: LitElement;
};
export declare const makeBinderProxy: (component: LitElement, accessorControllerRef: WeakRef<MinimalAccessorController & {
    constructor: MinimalAccessorController["constructor"] & {
        devOnly$allowedPropNameMismatches?: ReadonlySet<string>;
    };
}>, accessorControllerIndex: number, instance: __esri.Accessor, boundProperties: Map<string, string>) => unknown;
export declare const getAccessorControllerBoundProperties: <Accessor extends __esri.Accessor>(controller: AccessorController<unknown, Accessor>) => Map<string & keyof Accessor, string>;
export declare const reCreateAccessor: (instance: __esri.Accessor, component: LitElement) => void;
export {};
