import { isEsriInternalEnv, safeCall, Deferred, safeAsyncCall } from "@arcgis/components-utils";
import { nothing } from "lit";
const controllerSymbol = Symbol.for("controller");
const isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);
const isPromise = (arg) => typeof arg?.then === "function";
const getControllersCount = (component) => component.M.length;
let ambientComponent;
const setAmbientComponent = (component) => {
  if (ambientComponent === component) {
    return;
  }
  ambientComponent = component;
  queueMicrotask(() => ambientComponent === component ? ambientComponent = void 0 : 0);
};
const retrieveComponent = (name) => {
  if (process.env.NODE_ENV !== "production" && ambientComponent === void 0) {
    throw new Error(
      [
        `Unable to find out which component ${name || "this"} controller `,
        "belongs to. Possible causes:\n",
        "- You might have multiple versions of ",
        "@arcgis/lumina package installed\n",
        ...isEsriInternalEnv() ? [
          "- You tried to create controller outside the component. If so, ",
          "please wrap your controller definition in an arrow function (like",
          "`const myController = ()=>makeController(...);`) and call that",
          "function inside the component (`my = myController();`), or ",
          "define your controller using makeGenericController/GenericController ",
          "instead.\n",
          "- You tried to create a controller inside an async function. ",
          "This is allowed without calling controller.use(). Make sure you ",
          "use it like `await controller.use(useController())`."
        ] : []
      ].join("")
    );
  }
  return ambientComponent;
};
let ambientControllers = [];
const setParentController = (controller) => {
  if (controller === void 0) {
    ambientControllers = [];
    return;
  }
  const index = ambientControllers.indexOf(controller);
  ambientControllers = index === -1 ? [...ambientControllers, controller] : ambientControllers.slice(0, index + 1);
  queueMicrotask(() => ambientControllers = []);
};
const retrieveParentControllers = () => ambientControllers;
let ambientChildController;
const setAmbientChildController = (controller) => {
  if (ambientChildController === controller) {
    return;
  }
  ambientChildController = controller;
  queueMicrotask(() => ambientChildController === controller ? ambientChildController = void 0 : 0);
};
const retrieveAmbientChildController = () => {
  const controller = ambientChildController;
  ambientChildController = void 0;
  return controller;
};
const use = async (value, watchExports) => {
  const controller = useRefSync(value);
  if (controller === void 0) {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && typeof watchExports === "function") {
      throw new Error(
        `Unable to resolve a controller from the provided value, so can't watch it's exports. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
      );
    }
    return value;
  }
  await controller.ready;
  if (typeof watchExports === "function") {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && controller.watchExports === void 0) {
      throw new Error(`The controller must implement watchExports method to support watching exports`);
    }
    const unsubscribe = controller.watchExports(
      (exports) => watchExports(exports, unsubscribe)
    );
  }
  return controller.exports;
};
const useRef = async (value) => {
  const controller = useRefSync(value);
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && controller === void 0) {
    throw new Error(
      `Unable to resolve a controller from the provided value. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
    );
  }
  await controller.ready;
  return controller;
};
const useRefSync = (value) => {
  const component = retrieveComponent();
  const controller = component.manager.X(value);
  if (controller !== void 0) {
    return controller;
  }
  if (isController(value)) {
    return value;
  }
  const ambientChildController2 = retrieveAmbientChildController();
  if (ambientChildController2 !== void 0) {
    return ambientChildController2;
  }
  return void 0;
};
let shouldBypassReadOnly = false;
const bypassReadOnly = (callback) => {
  shouldBypassReadOnly = true;
  try {
    return callback();
  } finally {
    shouldBypassReadOnly = false;
  }
};
const bypassSetter = bypassReadOnly;
const trackPropertyKey = (object, onResolved, defaultValue) => {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0) {
    queueMicrotask(keyTrackResolve);
  }
  keyTrackMap ??= /* @__PURE__ */ new Map();
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => safeCall(onResolved, null, key2);
    const key = keys2[keyCount];
    if (key === void 0) {
      callback(void 0);
    } else if (object[key] === defaultValue) {
      callback(key);
    } else {
      callback(void 0);
    }
  });
  return defaultValue;
};
let keyTrackMap = void 0;
const keyTrackResolve = () => {
  keyTrackMap?.forEach(({ callbacks }, object) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
};
const trackPropKey = (component, onResolved, defaultValue) => {
  const manager = component.manager;
  if (manager.V !== nothing && manager.V !== defaultValue) {
    manager.S(void 0, void 0);
  }
  if (manager.T.length === 0) {
    queueMicrotask(() => manager.S(void 0, void 0));
  }
  manager.V = defaultValue;
  manager.T.push((key, value) => safeCall(onResolved, void 0, defaultValue === value ? key : void 0));
  return defaultValue;
};
const trackKey = (hostsCandidates = [
  retrieveComponent(),
  ...retrieveParentControllers()
], onResolved, defaultValue) => {
  const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
  let leftToResolve = candidateHosts.length + 1;
  const resolved = (resolution) => {
    leftToResolve -= 1;
    if (resolution !== void 0) {
      leftToResolve = Math.min(leftToResolve, 0);
    }
    if (leftToResolve === 0) {
      onResolved(resolution);
    }
  };
  candidateHosts.forEach(
    (host) => trackPropertyKey(
      host,
      (key) => resolved(key === void 0 ? void 0 : { key, host, isReactive: false }),
      defaultValue
    )
  );
  for (const host of candidateHosts) {
    if ("manager" in host && host.manager.component === host) {
      trackPropKey(
        host,
        (key) => resolved(key === void 0 ? void 0 : { key, host, isReactive: true }),
        defaultValue
      );
      break;
    }
  }
  return defaultValue;
};
const createEventFactory = (eventName = "", options = {}, component = retrieveComponent()) => {
  const emitter = {
    emit: (payload) => {
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && !component.el.isConnected) {
        console.warn(`Trying to emit an ${eventName} event on a disconnected element ${component.el.localName}`);
      }
      if (eventName === "") {
        keyTrackResolve();
        if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && eventName === "") {
          throw new Error("Unable to resolve event name from property name");
        }
      }
      const event = new CustomEvent(eventName, {
        detail: payload,
        cancelable: true,
        bubbles: true,
        composed: true,
        ...options
      });
      component.el.dispatchEvent(event);
      return event;
    }
  };
  if (eventName === "") {
    trackKey(
      void 0,
      process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? (resolution) => {
        if (resolution === void 0) {
          throw new Error(`createEvent must be called in property default value only`);
        }
        eventName = resolution.key;
      } : (resolution) => eventName = resolution.key,
      emitter
    );
  }
  return emitter;
};
const createEvent = createEventFactory.bind(null, "");
var _a;
_a = controllerSymbol;
class Controller {
  constructor(component) {
    this.#hostConnected = [];
    this.#hostDisconnected = [];
    this.#hostLoad = [];
    this.#hostLoaded = [];
    this.#hostUpdate = [];
    this.#hostUpdated = [];
    this.#hostDestroy = [];
    this.#hostLifecycle = [];
    this.#lifecycleCleanups = [];
    this.#loadCalled = false;
    this.P = new Deferred();
    this.connectedCalled = false;
    this.loadedCalled = false;
    this[_a] = true;
    this.#exportWatchers = [];
    const that = this;
    const resolvedComponent = component ?? retrieveComponent(new.target.name);
    that.#component = resolvedComponent;
    that.ready = that.P.promise;
    that.#exports = makeProvisionalValue(that);
    if (process.env.NODE_ENV !== "production") {
      Object.defineProperty(this, "component", {
        writable: false,
        enumerable: false,
        configurable: true,
        value: resolvedComponent
      });
      if ("hostDestroy" in this) {
        that.#component.manager.devOnly$ensureHasDestroy?.();
      }
    } else {
      that.component = resolvedComponent;
    }
    that.#component.addController(that);
    const manager = that.#component.manager;
    const isInControllerManager = manager === void 0;
    if (!isInControllerManager) {
      setParentController(that);
      queueMicrotask(() => that.catchUpLifecycle());
    }
  }
  #hostConnected;
  #hostDisconnected;
  #hostLoad;
  #hostLoaded;
  #hostUpdate;
  #hostUpdated;
  #hostDestroy;
  #hostLifecycle;
  #lifecycleCleanups;
  #loadCalled;
  #component;
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    const { manager } = this.#component;
    const connectedWillStillHappen = !manager.connectedCalled;
    if (!connectedWillStillHappen && !this.connectedCalled) {
      this.triggerConnected();
    }
    const loadWillStillHappen = !manager.#loadCalled;
    if (loadWillStillHappen) {
      return;
    }
    this.triggerLoad().then(
      () => (
        // Call loaded ourself, unless manager is going to do it
        manager.loadedCalled && this.triggerLoaded()
      )
    ).catch(console.error);
  }
  #exports;
  get exports() {
    return this.#exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports) {
    const oldExports = this.#exports;
    if (oldExports !== exports) {
      this.#exports = exports;
      this.#exportWatchers.forEach(safeCall);
      if (this.connectedCalled && this.O !== false) {
        this.#component.requestUpdate(this.O, oldExports);
      }
    }
    this.P.resolve(exports);
  }
  setProvisionalExports(exports, proxy = true) {
    this.#exports = proxy ? makeProvisionalValue(exports) : exports;
    this.#exportWatchers.forEach(safeCall);
  }
  #exportWatchers;
  watchExports(callback) {
    const safeCallback = () => callback(this.#exports);
    this.#exportWatchers.push(safeCallback);
    return () => void this.#exportWatchers.splice(this.#exportWatchers.indexOf(safeCallback), 1);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    setAmbientComponent(this.#component);
    return use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    setAmbientComponent(this.#component);
    return useRef;
  }
  /**
   * Like useRef, but doesn't wait for the controller to get ready
   *
   * @private
   */
  get useRefSync() {
    setAmbientComponent(this.#component);
    return useRefSync;
  }
  controllerRemoved() {
    if (this.#component.el.isConnected) {
      this.triggerDisconnected();
    }
    this.triggerDestroy();
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this.#hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this.#hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this.#hostLoad.push(callback);
  }
  onLoaded(callback) {
    this.#hostLoaded.push(callback);
  }
  onUpdate(callback) {
    this.#hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this.#hostUpdated.push(callback);
  }
  onDestroy(callback) {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      this.#component.manager.devOnly$ensureHasDestroy?.();
    }
    this.#hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this.#hostLifecycle.push(callback);
    if (this.connectedCalled && this.#component.el.isConnected) {
      this.#callLifecycle(callback);
    }
  }
  // Call each lifecycle hook
  /** @private */
  triggerConnected() {
    const that = this;
    if (that.hostConnected) {
      safeCall(that.hostConnected, that);
    }
    that.#hostConnected.forEach(safeCall);
    that.triggerLifecycle();
    that.connectedCalled = true;
  }
  /** @private */
  triggerDisconnected() {
    const that = this;
    if (that.hostDisconnected) {
      safeCall(that.hostDisconnected, that);
    }
    that.#hostDisconnected.forEach(safeCall);
    that.#lifecycleCleanups.forEach(safeCall);
    that.#lifecycleCleanups = [];
  }
  /** @private */
  async triggerLoad() {
    if (this.#loadCalled) {
      return;
    }
    this.#loadCalled = true;
    const genericController = this;
    if (genericController.hostLoad) {
      await safeAsyncCall(genericController.hostLoad, genericController);
    }
    if (this.#hostLoad.length > 0) {
      await Promise.allSettled(this.#hostLoad.map(safeAsyncCall));
    }
    this.P.resolve(this.#exports);
  }
  /** @private */
  triggerLoaded() {
    if (this.loadedCalled) {
      return;
    }
    if (this.hostLoaded) {
      safeCall(this.hostLoaded, this);
    }
    this.#hostLoaded.forEach(safeCall);
    this.loadedCalled = true;
  }
  /** @private */
  triggerUpdate(changes) {
    if (this.hostUpdate) {
      safeCall(this.hostUpdate, this, changes);
    }
    this.#hostUpdate.forEach(callUpdate, changes);
  }
  /** @private */
  triggerUpdated(changes) {
    if (this.hostUpdated) {
      safeCall(this.hostUpdated, this, changes);
    }
    this.#hostUpdated.forEach(callUpdate, changes);
  }
  /** @private */
  triggerDestroy() {
    if (this.hostDestroy) {
      safeCall(this.hostDestroy, this);
    }
    this.#hostDestroy.forEach(safeCall);
  }
  /** @private */
  triggerLifecycle() {
    if (this.hostLifecycle) {
      this.#callLifecycle(() => this.hostLifecycle());
    }
    this.#hostLifecycle.forEach(this.#callLifecycle, this);
  }
  #callLifecycle(callback) {
    setAmbientComponent(this.#component);
    const cleanupRaw = safeCall(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function") {
        this.#lifecycleCleanups.push(cleanup2);
      } else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function") {
        this.#lifecycleCleanups.push(cleanup2.remove);
      }
    });
  }
}
function callUpdate(callback) {
  safeCall(callback, void 0, this);
}
const GenericController = Controller;
const makeProvisionalValue = (base) => {
  if (typeof base !== "object" && typeof base !== "function" || base === null) {
    return base;
  }
  const proxyDefinition = {
    get(target, prop, receiver) {
      if ((prop === "exports" || prop === "_exports") && prop in target && target[prop] === proxy) {
        return void 0;
      }
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol") {
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      }
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
        if (process.env.NODE_ENV === "test" && (prop.startsWith("$$") || prop.startsWith("@@") || prop === "nodeType" || prop === "tagName" || prop === "toJSON" || prop === "hasAttribute")) {
          return;
        }
        console.error(
          `Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`
        );
      }
      return void 0;
    }
  };
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
    proxyDefinition.set = (target, prop, newValue, receiver) => {
      console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return Reflect.set(target, prop, newValue, receiver);
    };
  }
  const proxy = new Proxy(base, proxyDefinition);
  return proxy;
};
const accessBeforeLoad = process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("") : void 0;
export {
  Controller as C,
  GenericController as G,
  shouldBypassReadOnly as a,
  createEvent as b,
  controllerSymbol as c,
  setParentController as d,
  retrieveParentControllers as e,
  createEventFactory as f,
  bypassSetter as g,
  bypassReadOnly as h,
  isPromise as i,
  trackPropertyKey as j,
  keyTrackResolve as k,
  trackPropKey as l,
  isController as m,
  getControllersCount as n,
  setAmbientChildController as o,
  retrieveComponent as r,
  setAmbientComponent as s,
  trackKey as t
};
