export interface Options<I extends HTMLElement, E extends EventNames> {
    react: any;
    tagName: string;
    elementClass: Constructor<I>;
    events?: E;
    displayName?: string;
}
export type EventNames = Record<string, string>;
type Constructor<T> = new () => T;
/**
 * Wrap `createComponent` from `@lit/react` to improve lazy loading
 * compatibility.
 *
 * @private
 */
export declare const makeReactWrapperFactory: (react: unknown, createComponent: (options: Options<HTMLElement, EventNames>) => unknown) => (options: Pick<Options<HTMLElement, EventNames>, "events" | "tagName">) => unknown;
/**
 * Helper for `createComponent` to declare options in a type-safe and concise
 * manner.
 *
 * @remarks
 * Only tagName and events need to be provided to the wrapped version of the
 * `createComponent` function. However, since we inherit the typings from
 * the original `createComponent`, TypeScript would still force us to provide
 * `react` and `elementClass` properties - instead, this helper convinces
 * TypeScript that we are providing `react` and `elementClass` properties.
 *
 * @private
 */
export declare const getReactWrapperOptions: <Element extends HTMLElement, Events extends EventNames>(
/**
 * We want "Events" type argument to be inferred, but Element type
 * argument to be explicitly specified. That isn't possible until
 * https://github.com/microsoft/TypeScript/issues/26242.
 *
 * As a workaround we are making Element inferred by passing Element type as
 * a tag name:
 * ```ts
 * getReactWrapperOptions("te-st" as HTMLTeStElement, {});
 * ```
 */
tagNameAndElement: Element, events: Events) => Options<Element & {
    class?: string;
}, Events>;
export {};
