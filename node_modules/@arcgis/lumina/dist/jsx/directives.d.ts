import { Nil } from '@arcgis/components-utils';
import { Properties as CssProperties } from 'csstype';
import { ClassInfo } from 'lit-html/directives/class-map.js';
import { DirectiveResult } from 'lit/directive.js';
import { ClassMapDirective } from 'lit/directives/class-map.js';
import { StyleMapDirective } from 'lit/directives/style-map.js';
import { DirectiveClass, ElementPart, Directive } from 'lit-html/directive.js';
import { noChange } from 'lit';
/**
 * You likely won't have to import this directly. It will be added during
 * _JSX to lit-html_ conversion.
 *
 * @remarks
 * In JSX we allow both of the following:
 * ```tsx
 * const myString = "foo";
 * const myObject = { foo: true, bar: false };
 * render(<p class={myString} />);
 * render(<p class={myObject} />);
 * ```
 *
 * One of the above needs to call `classMap` directive, the other must not.
 *
 * To keep the build fast, and to guard against types being possibly incorrect,
 * we are not relying on the TypeScript type-checker to check if the provided
 * variable is a string or an object.
 * Instead, if the prop value is a object definition, variable reference,
 * ternary expression or etc, the `safeClassMap` will be called, which will
 * determine at runtime if directive should be called
 *
 * @private
 */
export declare const safeClassMap: (parameters: ClassInfo | Nil | string) => DirectiveResult<typeof ClassMapDirective> | Nil | string;
/**
 * You likely won't have to import this directly. It will be added during
 * _JSX to lit-html_ conversion.
 *
 * @remarks
 * In JSX we allow both of the following:
 * ```tsx
 * const myString = "font-size:'2px'";
 * const myObject = { fontSize: "2px" };
 * render(<p style={myString} />);
 * render(<p style={myObject} />);
 * ```
 *
 * One of the above needs to call `styleMap` directive, the other must not.
 *
 * To keep the build fast, and to guard against types being possibly incorrect,
 * we are not relying on the TypeScript type-checker to check if the provided
 * variable is a string or an object.
 * Instead, if the prop value is a object definition, variable reference,
 * ternary expression or etc, the `safeStyleMap` will be called, which will
 * determine at runtime if directive should be called
 *
 * @private
 */
export declare const safeStyleMap: (parameters: CssProperties | Nil | string) => DirectiveResult<typeof StyleMapDirective> | Nil | string;
declare class DeferLoad extends Directive {
    update(part: ElementPart): void;
    render(): typeof noChange;
}
/**
 * @private
 * Do not use this directive directly. Use the `deferLoad` JSX prop instead.
 * [Documentation](https://qawebgis.esri.com/components/lumina/jsx#deferring-web-component-load)
 */
export declare const deferLoad: DirectiveResult<typeof DeferLoad>;
/**
 * @private
 * Do not use this directly. Use the `deferLoad` JSX prop instead.
 * [Documentation](https://qawebgis.esri.com/components/lumina/jsx#deferring-web-component-load)
 */
export declare const deferredLoaders: Map<string, () => Promise<unknown>>;
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 *
 * @remarks
 * This is equivalent to Lit's native "directive()", but has return type
 * "never" to allow it be set as a value for any JSX attribute.
 */
export declare const directive: <C extends DirectiveClass>(c: C) => (...values: Parameters<InstanceType<C>["render"]>) => never;
/**
 * Checks binding values against live DOM values, instead of previously bound
 * values, when determining whether to update the value.
 *
 * @see https://lit.dev/docs/templates/directives/#live
 *
 * @remarks
 * This is equivalent to Lit's native "directive()", but has return type
 * "never" to allow it be set as a value for any JSX attribute.
 */
export declare const live: (value: unknown) => never;
export {};
