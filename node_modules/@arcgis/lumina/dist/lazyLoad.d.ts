import { Deferred } from '@arcgis/components-utils';
import { LitElement } from './LitElement';
import { Runtime } from './makeRuntime';
import { ControllerManager } from './controllers/ControllerManager';
/**
 * Defines lazy-loading proxy components for all web components in this package.
 *
 * As soon as a proxied web component is created (e.g. by adding it to the DOM),
 * it will start loading the actual web component source code.
 */
export interface DefineCustomElements {
    (_window?: Window, options?: LazyLoadOptions): void;
    (options?: LazyLoadOptions): void;
}
export type LazyLoadOptions = {
    readonly resourcesUrl?: string;
};
interface CommonInterface extends HTMLElement {
    componentOnReady: () => Promise<this>;
}
export declare const makeDefineCustomElements: (runtime: Runtime, structure: Readonly<Record<string, CompactMeta>>) => DefineCustomElements;
/**
 * Use compact meta to reduce bundle size (otherwise, it would be ~65kb for
 * map-components). Also, the meta is a string to speed-up parsing
 * (browsers parse strings much faster).
 * See https://twitter.com/mathias/status/1143551692732030979
 */
type CompactMeta = readonly [load: () => Promise<Record<string, typeof LitElement>>, compact?: string];
/**
 * If this file is run from a Node.js environment, HTMLElement won't be defined.
 * Falling back to uselessly extending parseCondensedProp in that case
 * (that particular function chosen just because it already exists, rather than
 * needlessly creating mock class/function)
 * That will error if you try to instantiate a ProxyComponent in Node.js, but
 * that is expected - if you need to instantiate ProxyComponent, HTMLElement
 * must be defined
 */
declare const HtmlElement: {
    new (): HTMLElement;
    prototype: HTMLElement;
};
/**
 * A web-component that, once connected to the page, starts loading the actual
 * component, and set's up two-way forwarding of attributes and methods.
 *
 * It also makes the actual component render it's content in this 'proxy'
 * component, so as to have identical DOM structure for lazy vs non-lazy builds
 * (otherwise, css selectors may break)
 *
 * @private
 */
export declare abstract class ProxyComponent extends HtmlElement {
    #private;
    static observedAttributes?: readonly string[];
    static _LitElementLoadPromise: Promise<Record<string, typeof LitElement>> | undefined;
    static _LitElementConstructor?: typeof LitElement;
    /**
     * A list of instances of this component. This allows hot module replacement
     * to update all proxy component to use a new LitElement instance.
     */
    static devOnly$hmrInstances: WeakRef<ProxyComponent>[] | undefined;
    static devOnly$hmrIndex: number | undefined;
    static _proxiedProperties?: readonly string[];
    static _proxiedAsyncMethods?: readonly string[];
    static _proxiedSyncMethods?: readonly string[];
    static __runtime: Runtime;
    protected static __tagName: string;
    static readonly lumina = true;
    static _initializeProxyPrototype(): void;
    /**
     * On HMR, preserve the values of all properties that at least once were set
     * by someone other than component itself.
     */
    devOnly$hmrSetProps: Set<PropertyKey>;
    devOnly$hmrSetAttributes: Set<string>;
    devOnly$InitializeComponent?: (module: Record<string, typeof LitElement>) => void;
    devOnly$hmrResetStore?: (newStore: Record<string, unknown>) => void;
    /**
     * This property is only set in development mode and exists only for usage in
     * tests or during debugging
     */
    $component: LitElement | undefined;
    /**
     * Resolved once LitElement's load() is complete.
     * Not read inside of this class, but needed for LitElement to determine if
     * it's closest ancestor finished load()
     */
    __postLoadDeferred: Deferred<void>;
    /**
     * Resolved once LitElement's loaded() is complete
     */
    _postLoadedDeferred: Deferred<void>;
    /**
     * Direct offspring that should be awaited before loaded() is emitted
     */
    __offspringComponents: (CommonInterface & {
        manager?: LitElement["manager"];
    })[];
    /**
     * Promise that resolves once parent's load() completed. False if there is no
     * parent
     */
    _ancestorLoadPromise?: Promise<void> | false;
    get manager(): ControllerManager | undefined;
    constructor();
    attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    /**
     * Create a promise that resolves once component is fully loaded
     */
    componentOnReady(): Promise<this>;
    /**
     * Implemented on the proxy for compatibility with Lit Context.
     */
    addController(): void;
    /**
     * Implemented on the proxy for compatibility with Lit Context.
     */
    requestUpdate(): void;
}
/** @private */
export type GlobalThisWithPuppeteerEnv = typeof globalThis & {
    devOnly$createdElements?: WeakRef<ProxyComponent>[];
};
export {};
